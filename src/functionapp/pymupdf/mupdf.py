# This file was automatically generated by SWIG (https://www.swig.org).
# Version 4.2.1
#
# Do not make changes to this file unless you know what you are doing - modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _mupdf
else:
    import _mupdf

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "this":
            set(self, name, value)
        elif name == "thisown":
            self.this.own(value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


import weakref


def cdata(ptr, nelements=1):
    return _mupdf.cdata(ptr, nelements)

def memmove(data, indata):
    return _mupdf.memmove(data, indata)
class SwigPyIterator(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _mupdf.delete_SwigPyIterator

    def value(self):
        return _mupdf.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _mupdf.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _mupdf.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _mupdf.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _mupdf.SwigPyIterator_equal(self, x)

    def copy(self):
        return _mupdf.SwigPyIterator_copy(self)

    def next(self):
        return _mupdf.SwigPyIterator_next(self)

    def __next__(self):
        return _mupdf.SwigPyIterator___next__(self)

    def previous(self):
        return _mupdf.SwigPyIterator_previous(self)

    def advance(self, n):
        return _mupdf.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _mupdf.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _mupdf.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _mupdf.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _mupdf.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _mupdf.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _mupdf.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self

# Register SwigPyIterator in _mupdf:
_mupdf.SwigPyIterator_swigregister(SwigPyIterator)
class uchar_array(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, nelements):
        _mupdf.uchar_array_swiginit(self, _mupdf.new_uchar_array(nelements))
    __swig_destroy__ = _mupdf.delete_uchar_array

    def __getitem__(self, index):
        return _mupdf.uchar_array___getitem__(self, index)

    def __setitem__(self, index, value):
        return _mupdf.uchar_array___setitem__(self, index, value)

    def cast(self):
        return _mupdf.uchar_array_cast(self)

    @staticmethod
    def frompointer(t):
        return _mupdf.uchar_array_frompointer(t)

# Register uchar_array in _mupdf:
_mupdf.uchar_array_swigregister(uchar_array)
class vectoruc(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _mupdf.vectoruc_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _mupdf.vectoruc___nonzero__(self)

    def __bool__(self):
        return _mupdf.vectoruc___bool__(self)

    def __len__(self):
        return _mupdf.vectoruc___len__(self)

    def __getslice__(self, i, j):
        return _mupdf.vectoruc___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _mupdf.vectoruc___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _mupdf.vectoruc___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _mupdf.vectoruc___delitem__(self, *args)

    def __getitem__(self, *args):
        return _mupdf.vectoruc___getitem__(self, *args)

    def __setitem__(self, *args):
        return _mupdf.vectoruc___setitem__(self, *args)

    def pop(self):
        return _mupdf.vectoruc_pop(self)

    def append(self, x):
        return _mupdf.vectoruc_append(self, x)

    def empty(self):
        return _mupdf.vectoruc_empty(self)

    def size(self):
        return _mupdf.vectoruc_size(self)

    def swap(self, v):
        return _mupdf.vectoruc_swap(self, v)

    def begin(self):
        return _mupdf.vectoruc_begin(self)

    def end(self):
        return _mupdf.vectoruc_end(self)

    def rbegin(self):
        return _mupdf.vectoruc_rbegin(self)

    def rend(self):
        return _mupdf.vectoruc_rend(self)

    def clear(self):
        return _mupdf.vectoruc_clear(self)

    def get_allocator(self):
        return _mupdf.vectoruc_get_allocator(self)

    def pop_back(self):
        return _mupdf.vectoruc_pop_back(self)

    def erase(self, *args):
        return _mupdf.vectoruc_erase(self, *args)

    def __init__(self, *args):
        _mupdf.vectoruc_swiginit(self, _mupdf.new_vectoruc(*args))

    def push_back(self, x):
        return _mupdf.vectoruc_push_back(self, x)

    def front(self):
        return _mupdf.vectoruc_front(self)

    def back(self):
        return _mupdf.vectoruc_back(self)

    def assign(self, n, x):
        return _mupdf.vectoruc_assign(self, n, x)

    def resize(self, *args):
        return _mupdf.vectoruc_resize(self, *args)

    def insert(self, *args):
        return _mupdf.vectoruc_insert(self, *args)

    def reserve(self, n):
        return _mupdf.vectoruc_reserve(self, n)

    def capacity(self):
        return _mupdf.vectoruc_capacity(self)
    __swig_destroy__ = _mupdf.delete_vectoruc

# Register vectoruc in _mupdf:
_mupdf.vectoruc_swigregister(vectoruc)
class vectori(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _mupdf.vectori_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _mupdf.vectori___nonzero__(self)

    def __bool__(self):
        return _mupdf.vectori___bool__(self)

    def __len__(self):
        return _mupdf.vectori___len__(self)

    def __getslice__(self, i, j):
        return _mupdf.vectori___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _mupdf.vectori___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _mupdf.vectori___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _mupdf.vectori___delitem__(self, *args)

    def __getitem__(self, *args):
        return _mupdf.vectori___getitem__(self, *args)

    def __setitem__(self, *args):
        return _mupdf.vectori___setitem__(self, *args)

    def pop(self):
        return _mupdf.vectori_pop(self)

    def append(self, x):
        return _mupdf.vectori_append(self, x)

    def empty(self):
        return _mupdf.vectori_empty(self)

    def size(self):
        return _mupdf.vectori_size(self)

    def swap(self, v):
        return _mupdf.vectori_swap(self, v)

    def begin(self):
        return _mupdf.vectori_begin(self)

    def end(self):
        return _mupdf.vectori_end(self)

    def rbegin(self):
        return _mupdf.vectori_rbegin(self)

    def rend(self):
        return _mupdf.vectori_rend(self)

    def clear(self):
        return _mupdf.vectori_clear(self)

    def get_allocator(self):
        return _mupdf.vectori_get_allocator(self)

    def pop_back(self):
        return _mupdf.vectori_pop_back(self)

    def erase(self, *args):
        return _mupdf.vectori_erase(self, *args)

    def __init__(self, *args):
        _mupdf.vectori_swiginit(self, _mupdf.new_vectori(*args))

    def push_back(self, x):
        return _mupdf.vectori_push_back(self, x)

    def front(self):
        return _mupdf.vectori_front(self)

    def back(self):
        return _mupdf.vectori_back(self)

    def assign(self, n, x):
        return _mupdf.vectori_assign(self, n, x)

    def resize(self, *args):
        return _mupdf.vectori_resize(self, *args)

    def insert(self, *args):
        return _mupdf.vectori_insert(self, *args)

    def reserve(self, n):
        return _mupdf.vectori_reserve(self, n)

    def capacity(self):
        return _mupdf.vectori_capacity(self)
    __swig_destroy__ = _mupdf.delete_vectori

# Register vectori in _mupdf:
_mupdf.vectori_swigregister(vectori)
class vectorf(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _mupdf.vectorf_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _mupdf.vectorf___nonzero__(self)

    def __bool__(self):
        return _mupdf.vectorf___bool__(self)

    def __len__(self):
        return _mupdf.vectorf___len__(self)

    def __getslice__(self, i, j):
        return _mupdf.vectorf___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _mupdf.vectorf___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _mupdf.vectorf___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _mupdf.vectorf___delitem__(self, *args)

    def __getitem__(self, *args):
        return _mupdf.vectorf___getitem__(self, *args)

    def __setitem__(self, *args):
        return _mupdf.vectorf___setitem__(self, *args)

    def pop(self):
        return _mupdf.vectorf_pop(self)

    def append(self, x):
        return _mupdf.vectorf_append(self, x)

    def empty(self):
        return _mupdf.vectorf_empty(self)

    def size(self):
        return _mupdf.vectorf_size(self)

    def swap(self, v):
        return _mupdf.vectorf_swap(self, v)

    def begin(self):
        return _mupdf.vectorf_begin(self)

    def end(self):
        return _mupdf.vectorf_end(self)

    def rbegin(self):
        return _mupdf.vectorf_rbegin(self)

    def rend(self):
        return _mupdf.vectorf_rend(self)

    def clear(self):
        return _mupdf.vectorf_clear(self)

    def get_allocator(self):
        return _mupdf.vectorf_get_allocator(self)

    def pop_back(self):
        return _mupdf.vectorf_pop_back(self)

    def erase(self, *args):
        return _mupdf.vectorf_erase(self, *args)

    def __init__(self, *args):
        _mupdf.vectorf_swiginit(self, _mupdf.new_vectorf(*args))

    def push_back(self, x):
        return _mupdf.vectorf_push_back(self, x)

    def front(self):
        return _mupdf.vectorf_front(self)

    def back(self):
        return _mupdf.vectorf_back(self)

    def assign(self, n, x):
        return _mupdf.vectorf_assign(self, n, x)

    def resize(self, *args):
        return _mupdf.vectorf_resize(self, *args)

    def insert(self, *args):
        return _mupdf.vectorf_insert(self, *args)

    def reserve(self, n):
        return _mupdf.vectorf_reserve(self, n)

    def capacity(self):
        return _mupdf.vectorf_capacity(self)
    __swig_destroy__ = _mupdf.delete_vectorf

# Register vectorf in _mupdf:
_mupdf.vectorf_swigregister(vectorf)
class vectord(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _mupdf.vectord_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _mupdf.vectord___nonzero__(self)

    def __bool__(self):
        return _mupdf.vectord___bool__(self)

    def __len__(self):
        return _mupdf.vectord___len__(self)

    def __getslice__(self, i, j):
        return _mupdf.vectord___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _mupdf.vectord___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _mupdf.vectord___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _mupdf.vectord___delitem__(self, *args)

    def __getitem__(self, *args):
        return _mupdf.vectord___getitem__(self, *args)

    def __setitem__(self, *args):
        return _mupdf.vectord___setitem__(self, *args)

    def pop(self):
        return _mupdf.vectord_pop(self)

    def append(self, x):
        return _mupdf.vectord_append(self, x)

    def empty(self):
        return _mupdf.vectord_empty(self)

    def size(self):
        return _mupdf.vectord_size(self)

    def swap(self, v):
        return _mupdf.vectord_swap(self, v)

    def begin(self):
        return _mupdf.vectord_begin(self)

    def end(self):
        return _mupdf.vectord_end(self)

    def rbegin(self):
        return _mupdf.vectord_rbegin(self)

    def rend(self):
        return _mupdf.vectord_rend(self)

    def clear(self):
        return _mupdf.vectord_clear(self)

    def get_allocator(self):
        return _mupdf.vectord_get_allocator(self)

    def pop_back(self):
        return _mupdf.vectord_pop_back(self)

    def erase(self, *args):
        return _mupdf.vectord_erase(self, *args)

    def __init__(self, *args):
        _mupdf.vectord_swiginit(self, _mupdf.new_vectord(*args))

    def push_back(self, x):
        return _mupdf.vectord_push_back(self, x)

    def front(self):
        return _mupdf.vectord_front(self)

    def back(self):
        return _mupdf.vectord_back(self)

    def assign(self, n, x):
        return _mupdf.vectord_assign(self, n, x)

    def resize(self, *args):
        return _mupdf.vectord_resize(self, *args)

    def insert(self, *args):
        return _mupdf.vectord_insert(self, *args)

    def reserve(self, n):
        return _mupdf.vectord_reserve(self, n)

    def capacity(self):
        return _mupdf.vectord_capacity(self)
    __swig_destroy__ = _mupdf.delete_vectord

# Register vectord in _mupdf:
_mupdf.vectord_swigregister(vectord)
class vectors(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _mupdf.vectors_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _mupdf.vectors___nonzero__(self)

    def __bool__(self):
        return _mupdf.vectors___bool__(self)

    def __len__(self):
        return _mupdf.vectors___len__(self)

    def __getslice__(self, i, j):
        return _mupdf.vectors___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _mupdf.vectors___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _mupdf.vectors___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _mupdf.vectors___delitem__(self, *args)

    def __getitem__(self, *args):
        return _mupdf.vectors___getitem__(self, *args)

    def __setitem__(self, *args):
        return _mupdf.vectors___setitem__(self, *args)

    def pop(self):
        return _mupdf.vectors_pop(self)

    def append(self, x):
        return _mupdf.vectors_append(self, x)

    def empty(self):
        return _mupdf.vectors_empty(self)

    def size(self):
        return _mupdf.vectors_size(self)

    def swap(self, v):
        return _mupdf.vectors_swap(self, v)

    def begin(self):
        return _mupdf.vectors_begin(self)

    def end(self):
        return _mupdf.vectors_end(self)

    def rbegin(self):
        return _mupdf.vectors_rbegin(self)

    def rend(self):
        return _mupdf.vectors_rend(self)

    def clear(self):
        return _mupdf.vectors_clear(self)

    def get_allocator(self):
        return _mupdf.vectors_get_allocator(self)

    def pop_back(self):
        return _mupdf.vectors_pop_back(self)

    def erase(self, *args):
        return _mupdf.vectors_erase(self, *args)

    def __init__(self, *args):
        _mupdf.vectors_swiginit(self, _mupdf.new_vectors(*args))

    def push_back(self, x):
        return _mupdf.vectors_push_back(self, x)

    def front(self):
        return _mupdf.vectors_front(self)

    def back(self):
        return _mupdf.vectors_back(self)

    def assign(self, n, x):
        return _mupdf.vectors_assign(self, n, x)

    def resize(self, *args):
        return _mupdf.vectors_resize(self, *args)

    def insert(self, *args):
        return _mupdf.vectors_insert(self, *args)

    def reserve(self, n):
        return _mupdf.vectors_reserve(self, n)

    def capacity(self):
        return _mupdf.vectors_capacity(self)
    __swig_destroy__ = _mupdf.delete_vectors

# Register vectors in _mupdf:
_mupdf.vectors_swigregister(vectors)
class map_string_int(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _mupdf.map_string_int_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _mupdf.map_string_int___nonzero__(self)

    def __bool__(self):
        return _mupdf.map_string_int___bool__(self)

    def __len__(self):
        return _mupdf.map_string_int___len__(self)
    def __iter__(self):
        return self.key_iterator()
    def iterkeys(self):
        return self.key_iterator()
    def itervalues(self):
        return self.value_iterator()
    def iteritems(self):
        return self.iterator()

    def __getitem__(self, key):
        return _mupdf.map_string_int___getitem__(self, key)

    def __delitem__(self, key):
        return _mupdf.map_string_int___delitem__(self, key)

    def has_key(self, key):
        return _mupdf.map_string_int_has_key(self, key)

    def keys(self):
        return _mupdf.map_string_int_keys(self)

    def values(self):
        return _mupdf.map_string_int_values(self)

    def items(self):
        return _mupdf.map_string_int_items(self)

    def __contains__(self, key):
        return _mupdf.map_string_int___contains__(self, key)

    def key_iterator(self):
        return _mupdf.map_string_int_key_iterator(self)

    def value_iterator(self):
        return _mupdf.map_string_int_value_iterator(self)

    def __setitem__(self, *args):
        return _mupdf.map_string_int___setitem__(self, *args)

    def asdict(self):
        return _mupdf.map_string_int_asdict(self)

    def __init__(self, *args):
        _mupdf.map_string_int_swiginit(self, _mupdf.new_map_string_int(*args))

    def empty(self):
        return _mupdf.map_string_int_empty(self)

    def size(self):
        return _mupdf.map_string_int_size(self)

    def swap(self, v):
        return _mupdf.map_string_int_swap(self, v)

    def begin(self):
        return _mupdf.map_string_int_begin(self)

    def end(self):
        return _mupdf.map_string_int_end(self)

    def rbegin(self):
        return _mupdf.map_string_int_rbegin(self)

    def rend(self):
        return _mupdf.map_string_int_rend(self)

    def clear(self):
        return _mupdf.map_string_int_clear(self)

    def get_allocator(self):
        return _mupdf.map_string_int_get_allocator(self)

    def count(self, x):
        return _mupdf.map_string_int_count(self, x)

    def erase(self, *args):
        return _mupdf.map_string_int_erase(self, *args)

    def find(self, x):
        return _mupdf.map_string_int_find(self, x)

    def lower_bound(self, x):
        return _mupdf.map_string_int_lower_bound(self, x)

    def upper_bound(self, x):
        return _mupdf.map_string_int_upper_bound(self, x)
    __swig_destroy__ = _mupdf.delete_map_string_int

# Register map_string_int in _mupdf:
_mupdf.map_string_int_swigregister(map_string_int)
class vectorq(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _mupdf.vectorq_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _mupdf.vectorq___nonzero__(self)

    def __bool__(self):
        return _mupdf.vectorq___bool__(self)

    def __len__(self):
        return _mupdf.vectorq___len__(self)

    def __getslice__(self, i, j):
        return _mupdf.vectorq___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _mupdf.vectorq___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _mupdf.vectorq___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _mupdf.vectorq___delitem__(self, *args)

    def __getitem__(self, *args):
        return _mupdf.vectorq___getitem__(self, *args)

    def __setitem__(self, *args):
        return _mupdf.vectorq___setitem__(self, *args)

    def pop(self):
        return _mupdf.vectorq_pop(self)

    def append(self, x):
        return _mupdf.vectorq_append(self, x)

    def empty(self):
        return _mupdf.vectorq_empty(self)

    def size(self):
        return _mupdf.vectorq_size(self)

    def swap(self, v):
        return _mupdf.vectorq_swap(self, v)

    def begin(self):
        return _mupdf.vectorq_begin(self)

    def end(self):
        return _mupdf.vectorq_end(self)

    def rbegin(self):
        return _mupdf.vectorq_rbegin(self)

    def rend(self):
        return _mupdf.vectorq_rend(self)

    def clear(self):
        return _mupdf.vectorq_clear(self)

    def get_allocator(self):
        return _mupdf.vectorq_get_allocator(self)

    def pop_back(self):
        return _mupdf.vectorq_pop_back(self)

    def erase(self, *args):
        return _mupdf.vectorq_erase(self, *args)

    def __init__(self, *args):
        _mupdf.vectorq_swiginit(self, _mupdf.new_vectorq(*args))

    def push_back(self, x):
        return _mupdf.vectorq_push_back(self, x)

    def front(self):
        return _mupdf.vectorq_front(self)

    def back(self):
        return _mupdf.vectorq_back(self)

    def assign(self, n, x):
        return _mupdf.vectorq_assign(self, n, x)

    def resize(self, *args):
        return _mupdf.vectorq_resize(self, *args)

    def insert(self, *args):
        return _mupdf.vectorq_insert(self, *args)

    def reserve(self, n):
        return _mupdf.vectorq_reserve(self, n)

    def capacity(self):
        return _mupdf.vectorq_capacity(self)
    __swig_destroy__ = _mupdf.delete_vectorq

# Register vectorq in _mupdf:
_mupdf.vectorq_swigregister(vectorq)
class vector_search_page2_hit(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _mupdf.vector_search_page2_hit_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _mupdf.vector_search_page2_hit___nonzero__(self)

    def __bool__(self):
        return _mupdf.vector_search_page2_hit___bool__(self)

    def __len__(self):
        return _mupdf.vector_search_page2_hit___len__(self)

    def __getslice__(self, i, j):
        return _mupdf.vector_search_page2_hit___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _mupdf.vector_search_page2_hit___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _mupdf.vector_search_page2_hit___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _mupdf.vector_search_page2_hit___delitem__(self, *args)

    def __getitem__(self, *args):
        return _mupdf.vector_search_page2_hit___getitem__(self, *args)

    def __setitem__(self, *args):
        return _mupdf.vector_search_page2_hit___setitem__(self, *args)

    def pop(self):
        return _mupdf.vector_search_page2_hit_pop(self)

    def append(self, x):
        return _mupdf.vector_search_page2_hit_append(self, x)

    def empty(self):
        return _mupdf.vector_search_page2_hit_empty(self)

    def size(self):
        return _mupdf.vector_search_page2_hit_size(self)

    def swap(self, v):
        return _mupdf.vector_search_page2_hit_swap(self, v)

    def begin(self):
        return _mupdf.vector_search_page2_hit_begin(self)

    def end(self):
        return _mupdf.vector_search_page2_hit_end(self)

    def rbegin(self):
        return _mupdf.vector_search_page2_hit_rbegin(self)

    def rend(self):
        return _mupdf.vector_search_page2_hit_rend(self)

    def clear(self):
        return _mupdf.vector_search_page2_hit_clear(self)

    def get_allocator(self):
        return _mupdf.vector_search_page2_hit_get_allocator(self)

    def pop_back(self):
        return _mupdf.vector_search_page2_hit_pop_back(self)

    def erase(self, *args):
        return _mupdf.vector_search_page2_hit_erase(self, *args)

    def __init__(self, *args):
        _mupdf.vector_search_page2_hit_swiginit(self, _mupdf.new_vector_search_page2_hit(*args))

    def push_back(self, x):
        return _mupdf.vector_search_page2_hit_push_back(self, x)

    def front(self):
        return _mupdf.vector_search_page2_hit_front(self)

    def back(self):
        return _mupdf.vector_search_page2_hit_back(self)

    def assign(self, n, x):
        return _mupdf.vector_search_page2_hit_assign(self, n, x)

    def resize(self, *args):
        return _mupdf.vector_search_page2_hit_resize(self, *args)

    def insert(self, *args):
        return _mupdf.vector_search_page2_hit_insert(self, *args)

    def reserve(self, n):
        return _mupdf.vector_search_page2_hit_reserve(self, n)

    def capacity(self):
        return _mupdf.vector_search_page2_hit_capacity(self)
    __swig_destroy__ = _mupdf.delete_vector_search_page2_hit

# Register vector_search_page2_hit in _mupdf:
_mupdf.vector_search_page2_hit_swigregister(vector_search_page2_hit)

def new_bytes(nelements):
    return _mupdf.new_bytes(nelements)

def delete_bytes(ary):
    return _mupdf.delete_bytes(ary)

def bytes_getitem(ary, index):
    return _mupdf.bytes_getitem(ary, index)

def bytes_setitem(ary, index, value):
    return _mupdf.bytes_setitem(ary, index, value)

def new_floats(nelements):
    return _mupdf.new_floats(nelements)

def delete_floats(ary):
    return _mupdf.delete_floats(ary)

def floats_getitem(ary, index):
    return _mupdf.floats_getitem(ary, index)

def floats_setitem(ary, index, value):
    return _mupdf.floats_setitem(ary, index, value)

def internal_set_error_classes(classes):
    return _mupdf.internal_set_error_classes(classes)
FZ_VERSION = _mupdf.FZ_VERSION
r"""This file was auto-generated by mupdfwrap.py."""
FZ_VERSION_MAJOR = _mupdf.FZ_VERSION_MAJOR
FZ_VERSION_MINOR = _mupdf.FZ_VERSION_MINOR
FZ_VERSION_PATCH = _mupdf.FZ_VERSION_PATCH
FZ_ENABLE_SPOT_RENDERING = _mupdf.FZ_ENABLE_SPOT_RENDERING
r"""
    Enable the following for spot (and hence overprint/overprint
    simulation) capable rendering. This forces FZ_PLOTTERS_N on.

    Choose which plotters we need.
    By default we build all the plotters in. To avoid building
    plotters in that aren't needed, define the unwanted
    FZ_PLOTTERS_... define to 0.

    Choose which document agents to include.
    By default all are enabled. To avoid building unwanted
    ones, define FZ_ENABLE_... to 0.

    Choose which document writers to include.
    By default all are enabled. To avoid building unwanted
    ones, define FZ_ENABLE_..._OUTPUT to 0.

    Choose whether to enable ICC color profiles.

    Choose whether to enable JPEG2000 decoding.
    By default, it is enabled, but due to frequent security
    issues with the third party libraries we support disabling
    it with this flag.

    Choose whether to enable JavaScript.
    By default JavaScript is enabled both for mutool and PDF
    interactivity.

    Choose which fonts to include.
    By default we include the base 14 PDF fonts,
    DroidSansFallback from Android for CJK, and
    Charis SIL from SIL for epub/html.
    Enable the following defines to AVOID including
    unwanted fonts.
    """
FZ_PLOTTERS_N = _mupdf.FZ_PLOTTERS_N
FZ_PLOTTERS_G = _mupdf.FZ_PLOTTERS_G
FZ_PLOTTERS_RGB = _mupdf.FZ_PLOTTERS_RGB
FZ_PLOTTERS_CMYK = _mupdf.FZ_PLOTTERS_CMYK
FZ_ENABLE_PDF = _mupdf.FZ_ENABLE_PDF
FZ_ENABLE_XPS = _mupdf.FZ_ENABLE_XPS
FZ_ENABLE_SVG = _mupdf.FZ_ENABLE_SVG
FZ_ENABLE_CBZ = _mupdf.FZ_ENABLE_CBZ
FZ_ENABLE_IMG = _mupdf.FZ_ENABLE_IMG
FZ_ENABLE_HTML = _mupdf.FZ_ENABLE_HTML
FZ_ENABLE_EPUB = _mupdf.FZ_ENABLE_EPUB
FZ_ENABLE_OCR_OUTPUT = _mupdf.FZ_ENABLE_OCR_OUTPUT
FZ_ENABLE_ODT_OUTPUT = _mupdf.FZ_ENABLE_ODT_OUTPUT
FZ_ENABLE_DOCX_OUTPUT = _mupdf.FZ_ENABLE_DOCX_OUTPUT
FZ_ENABLE_JPX = _mupdf.FZ_ENABLE_JPX
FZ_ENABLE_JS = _mupdf.FZ_ENABLE_JS
FZ_ENABLE_ICC = _mupdf.FZ_ENABLE_ICC
MEMENTO_PREFILL = _mupdf.MEMENTO_PREFILL
MEMENTO_POSTFILL = _mupdf.MEMENTO_POSTFILL
MEMENTO_ALLOCFILL = _mupdf.MEMENTO_ALLOCFILL
MEMENTO_FREEFILL = _mupdf.MEMENTO_FREEFILL

def Memento_checkBlock(arg1):
    return _mupdf.Memento_checkBlock(arg1)

def Memento_checkAllMemory():
    return _mupdf.Memento_checkAllMemory()

def Memento_check():
    return _mupdf.Memento_check()

def Memento_setParanoia(arg1):
    return _mupdf.Memento_setParanoia(arg1)

def Memento_paranoidAt(arg1):
    return _mupdf.Memento_paranoidAt(arg1)

def Memento_breakAt(arg1):
    return _mupdf.Memento_breakAt(arg1)

def Memento_breakOnFree(a):
    return _mupdf.Memento_breakOnFree(a)

def Memento_breakOnRealloc(a):
    return _mupdf.Memento_breakOnRealloc(a)

def Memento_getBlockNum(arg1):
    return _mupdf.Memento_getBlockNum(arg1)

def Memento_find(a):
    return _mupdf.Memento_find(a)

def Memento_breakpoint():
    return _mupdf.Memento_breakpoint()

def Memento_failAt(arg1):
    return _mupdf.Memento_failAt(arg1)

def Memento_failThisEvent():
    return _mupdf.Memento_failThisEvent()

def Memento_listBlocks():
    return _mupdf.Memento_listBlocks()

def Memento_listNewBlocks():
    return _mupdf.Memento_listNewBlocks()

def Memento_listPhasedBlocks():
    return _mupdf.Memento_listPhasedBlocks()

def Memento_setMax(arg1):
    return _mupdf.Memento_setMax(arg1)

def Memento_stats():
    return _mupdf.Memento_stats()

def Memento_label(arg1, arg2):
    return _mupdf.Memento_label(arg1, arg2)

def Memento_tick():
    return _mupdf.Memento_tick()

def Memento_setVerbose(arg1):
    return _mupdf.Memento_setVerbose(arg1)

def Memento_addBacktraceLimitFnname(fnname):
    return _mupdf.Memento_addBacktraceLimitFnname(fnname)

def Memento_setAtexitFin(atexitfin):
    return _mupdf.Memento_setAtexitFin(atexitfin)

def Memento_setIgnoreNewDelete(ignore):
    return _mupdf.Memento_setIgnoreNewDelete(ignore)

def Memento_malloc(s):
    return _mupdf.Memento_malloc(s)

def Memento_realloc(arg1, s):
    return _mupdf.Memento_realloc(arg1, s)

def Memento_free(arg1):
    return _mupdf.Memento_free(arg1)

def Memento_calloc(arg1, arg2):
    return _mupdf.Memento_calloc(arg1, arg2)

def Memento_strdup(arg1):
    return _mupdf.Memento_strdup(arg1)

def Memento_info(addr):
    return _mupdf.Memento_info(addr)

def Memento_listBlockInfo():
    return _mupdf.Memento_listBlockInfo()

def Memento_blockInfo(blk):
    return _mupdf.Memento_blockInfo(blk)

def Memento_takeByteRef(blk):
    return _mupdf.Memento_takeByteRef(blk)

def Memento_dropByteRef(blk):
    return _mupdf.Memento_dropByteRef(blk)

def Memento_takeShortRef(blk):
    return _mupdf.Memento_takeShortRef(blk)

def Memento_dropShortRef(blk):
    return _mupdf.Memento_dropShortRef(blk)

def Memento_takeIntRef(blk):
    return _mupdf.Memento_takeIntRef(blk)

def Memento_dropIntRef(blk):
    return _mupdf.Memento_dropIntRef(blk)

def Memento_takeRef(blk):
    return _mupdf.Memento_takeRef(blk)

def Memento_dropRef(blk):
    return _mupdf.Memento_dropRef(blk)

def Memento_adjustRef(blk, adjust):
    return _mupdf.Memento_adjustRef(blk, adjust)

def Memento_reference(blk):
    return _mupdf.Memento_reference(blk)

def Memento_checkPointerOrNull(blk):
    return _mupdf.Memento_checkPointerOrNull(blk)

def Memento_checkBytePointerOrNull(blk):
    return _mupdf.Memento_checkBytePointerOrNull(blk)

def Memento_checkShortPointerOrNull(blk):
    return _mupdf.Memento_checkShortPointerOrNull(blk)

def Memento_checkIntPointerOrNull(blk):
    return _mupdf.Memento_checkIntPointerOrNull(blk)

def Memento_startLeaking():
    return _mupdf.Memento_startLeaking()

def Memento_stopLeaking():
    return _mupdf.Memento_stopLeaking()

def Memento_sequence():
    return _mupdf.Memento_sequence()

def Memento_squeezing():
    return _mupdf.Memento_squeezing()

def Memento_fin():
    return _mupdf.Memento_fin()

def Memento_bt():
    return _mupdf.Memento_bt()
FZ_PI = _mupdf.FZ_PI
FZ_RADIAN = _mupdf.FZ_RADIAN
FZ_DEGREE = _mupdf.FZ_DEGREE
FZ_SQRT2 = _mupdf.FZ_SQRT2
FZ_LN2 = _mupdf.FZ_LN2
HAVE_SIGSETJMP = _mupdf.HAVE_SIGSETJMP
r"""
    Spot architectures where we have optimisations.

    Some differences in libc can be smoothed over
    """
EOF = _mupdf.EOF
SEEK_SET = _mupdf.SEEK_SET
SEEK_CUR = _mupdf.SEEK_CUR
SEEK_END = _mupdf.SEEK_END
class fz_point(object):
    r"""	fz_point is a point in a two-dimensional space."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    x = property(_mupdf.fz_point_x_get, _mupdf.fz_point_x_set)
    y = property(_mupdf.fz_point_y_get, _mupdf.fz_point_y_set)

    def __init__(self):
        _mupdf.fz_point_swiginit(self, _mupdf.new_fz_point())
    __swig_destroy__ = _mupdf.delete_fz_point

# Register fz_point in _mupdf:
_mupdf.fz_point_swigregister(fz_point)
class fz_rect(object):
    r"""
    fz_rect is a rectangle represented by two diagonally opposite
    corners at arbitrary coordinates.

    Rectangles are always axis-aligned with the X- and Y- axes. We
    wish to distinguish rectangles in 3 categories; infinite, finite,
    and invalid. Zero area rectangles are a sub-category of finite
    ones.

    For all valid rectangles, x0 <= x1 and y0 <= y1 in all cases.
    Infinite rectangles have x0 = y0 = FZ_MIN_INF_RECT,
    x1 = y1 = FZ_MAX_INF_RECT. For any non infinite valid rectangle,
    the area is defined as (x1 - x0) * (y1 - y0).

    To check for empty or infinite rectangles use fz_is_empty_rect
    and fz_is_infinite_rect. To check for valid rectangles use
    fz_is_valid_rect.

    We choose this representation, so that we can easily distinguish
    the difference between intersecting 2 valid rectangles and
    getting an invalid one, as opposed to getting a zero area one
    (which nonetheless has valid bounds within the plane).

    x0, y0: The top left corner.

    x1, y1: The bottom right corner.

    We choose FZ_{MIN,MAX}_INF_RECT to be the largest 32bit signed
    integer values that survive roundtripping to floats.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    x0 = property(_mupdf.fz_rect_x0_get, _mupdf.fz_rect_x0_set)
    y0 = property(_mupdf.fz_rect_y0_get, _mupdf.fz_rect_y0_set)
    x1 = property(_mupdf.fz_rect_x1_get, _mupdf.fz_rect_x1_set)
    y1 = property(_mupdf.fz_rect_y1_get, _mupdf.fz_rect_y1_set)

    def __init__(self):
        _mupdf.fz_rect_swiginit(self, _mupdf.new_fz_rect())
    __swig_destroy__ = _mupdf.delete_fz_rect

# Register fz_rect in _mupdf:
_mupdf.fz_rect_swigregister(fz_rect)
class fz_irect(object):
    r"""
    fz_irect is a rectangle using integers instead of floats.

    It's used in the draw device and for pixmap dimensions.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    x0 = property(_mupdf.fz_irect_x0_get, _mupdf.fz_irect_x0_set)
    y0 = property(_mupdf.fz_irect_y0_get, _mupdf.fz_irect_y0_set)
    x1 = property(_mupdf.fz_irect_x1_get, _mupdf.fz_irect_x1_set)
    y1 = property(_mupdf.fz_irect_y1_get, _mupdf.fz_irect_y1_set)

    def __init__(self):
        _mupdf.fz_irect_swiginit(self, _mupdf.new_fz_irect())
    __swig_destroy__ = _mupdf.delete_fz_irect

# Register fz_irect in _mupdf:
_mupdf.fz_irect_swigregister(fz_irect)
class fz_matrix(object):
    r"""
    	fz_matrix is a row-major 3x3 matrix used for representing
    	transformations of coordinates throughout MuPDF.

    	Since all points reside in a two-dimensional space, one vector
    	is always a constant unit vector; hence only some elements may
    	vary in a matrix. Below is how the elements map between
    	different representations.

    a b 0
    	| c d 0 | normally represented as [ a b c d e f ].
    	\ e f 1 /
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    a = property(_mupdf.fz_matrix_a_get, _mupdf.fz_matrix_a_set)
    b = property(_mupdf.fz_matrix_b_get, _mupdf.fz_matrix_b_set)
    c = property(_mupdf.fz_matrix_c_get, _mupdf.fz_matrix_c_set)
    d = property(_mupdf.fz_matrix_d_get, _mupdf.fz_matrix_d_set)
    e = property(_mupdf.fz_matrix_e_get, _mupdf.fz_matrix_e_set)
    f = property(_mupdf.fz_matrix_f_get, _mupdf.fz_matrix_f_set)

    def __init__(self):
        _mupdf.fz_matrix_swiginit(self, _mupdf.new_fz_matrix())
    __swig_destroy__ = _mupdf.delete_fz_matrix

# Register fz_matrix in _mupdf:
_mupdf.fz_matrix_swigregister(fz_matrix)
cvar = _mupdf.cvar
fz_unit_rect = cvar.fz_unit_rect
fz_empty_rect = cvar.fz_empty_rect
fz_empty_irect = cvar.fz_empty_irect
fz_infinite_rect = cvar.fz_infinite_rect
fz_infinite_irect = cvar.fz_infinite_irect

class fz_quad(object):
    r"""
    A representation for a region defined by 4 points.

    The significant difference between quads and rects is that
    the edges of quads are not axis aligned.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    ul = property(_mupdf.fz_quad_ul_get, _mupdf.fz_quad_ul_set)
    ur = property(_mupdf.fz_quad_ur_get, _mupdf.fz_quad_ur_set)
    ll = property(_mupdf.fz_quad_ll_get, _mupdf.fz_quad_ll_set)
    lr = property(_mupdf.fz_quad_lr_get, _mupdf.fz_quad_lr_set)

    def __init__(self):
        _mupdf.fz_quad_swiginit(self, _mupdf.new_fz_quad())
    __swig_destroy__ = _mupdf.delete_fz_quad

# Register fz_quad in _mupdf:
_mupdf.fz_quad_swigregister(fz_quad)
fz_identity = cvar.fz_identity

FZ_VERBOSE_EXCEPTIONS = _mupdf.FZ_VERBOSE_EXCEPTIONS
class fz_alloc_context(object):
    r"""	Allocator structure; holds callbacks and private data pointer."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    user = property(_mupdf.fz_alloc_context_user_get, _mupdf.fz_alloc_context_user_set)
    malloc = property(_mupdf.fz_alloc_context_malloc_get, _mupdf.fz_alloc_context_malloc_set)
    realloc = property(_mupdf.fz_alloc_context_realloc_get, _mupdf.fz_alloc_context_realloc_set)
    free = property(_mupdf.fz_alloc_context_free_get, _mupdf.fz_alloc_context_free_set)

    def __init__(self):
        _mupdf.fz_alloc_context_swiginit(self, _mupdf.new_fz_alloc_context())
    __swig_destroy__ = _mupdf.delete_fz_alloc_context

# Register fz_alloc_context in _mupdf:
_mupdf.fz_alloc_context_swigregister(fz_alloc_context)
FZ_ERROR_NONE = _mupdf.FZ_ERROR_NONE
FZ_ERROR_GENERIC = _mupdf.FZ_ERROR_GENERIC
FZ_ERROR_SYSTEM = _mupdf.FZ_ERROR_SYSTEM
FZ_ERROR_LIBRARY = _mupdf.FZ_ERROR_LIBRARY
FZ_ERROR_ARGUMENT = _mupdf.FZ_ERROR_ARGUMENT
FZ_ERROR_LIMIT = _mupdf.FZ_ERROR_LIMIT
FZ_ERROR_UNSUPPORTED = _mupdf.FZ_ERROR_UNSUPPORTED
FZ_ERROR_FORMAT = _mupdf.FZ_ERROR_FORMAT
FZ_ERROR_SYNTAX = _mupdf.FZ_ERROR_SYNTAX
FZ_ERROR_TRYLATER = _mupdf.FZ_ERROR_TRYLATER
FZ_ERROR_ABORT = _mupdf.FZ_ERROR_ABORT
FZ_ERROR_REPAIRED = _mupdf.FZ_ERROR_REPAIRED
class fz_locks_context(object):
    r"""
    Locking functions

    MuPDF is kept deliberately free of any knowledge of particular
    threading systems. As such, in order for safe multi-threaded
    operation, we rely on callbacks to client provided functions.

    A client is expected to provide FZ_LOCK_MAX number of mutexes,
    and a function to lock/unlock each of them. These may be
    recursive mutexes, but do not have to be.

    If a client does not intend to use multiple threads, then it
    may pass NULL instead of a lock structure.

    In order to avoid deadlocks, we have one simple rule
    internally as to how we use locks: We can never take lock n
    when we already hold any lock i, where 0 <= i <= n. In order
    to verify this, we have some debugging code, that can be
    enabled by defining FITZ_DEBUG_LOCKING.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    user = property(_mupdf.fz_locks_context_user_get, _mupdf.fz_locks_context_user_set)
    lock = property(_mupdf.fz_locks_context_lock_get, _mupdf.fz_locks_context_lock_set)
    unlock = property(_mupdf.fz_locks_context_unlock_get, _mupdf.fz_locks_context_unlock_set)

    def __init__(self):
        _mupdf.fz_locks_context_swiginit(self, _mupdf.new_fz_locks_context())
    __swig_destroy__ = _mupdf.delete_fz_locks_context

# Register fz_locks_context in _mupdf:
_mupdf.fz_locks_context_swigregister(fz_locks_context)
FZ_LOCK_ALLOC = _mupdf.FZ_LOCK_ALLOC
FZ_LOCK_FREETYPE = _mupdf.FZ_LOCK_FREETYPE
FZ_LOCK_GLYPHCACHE = _mupdf.FZ_LOCK_GLYPHCACHE
FZ_LOCK_MAX = _mupdf.FZ_LOCK_MAX
FZ_STORE_UNLIMITED = _mupdf.FZ_STORE_UNLIMITED
FZ_STORE_DEFAULT = _mupdf.FZ_STORE_DEFAULT
class fz_string(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    refs = property(_mupdf.fz_string_refs_get, _mupdf.fz_string_refs_set)
    str = property(_mupdf.fz_string_str_get, _mupdf.fz_string_str_set)

    def __init__(self):
        _mupdf.fz_string_swiginit(self, _mupdf.new_fz_string())
    __swig_destroy__ = _mupdf.delete_fz_string

# Register fz_string in _mupdf:
_mupdf.fz_string_swigregister(fz_string)
FZ_JMPBUF_ALIGN = _mupdf.FZ_JMPBUF_ALIGN
class fz_error_context(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    top = property(_mupdf.fz_error_context_top_get, _mupdf.fz_error_context_top_set)
    stack = property(_mupdf.fz_error_context_stack_get, _mupdf.fz_error_context_stack_set)
    padding = property(_mupdf.fz_error_context_padding_get, _mupdf.fz_error_context_padding_set)
    stack_base = property(_mupdf.fz_error_context_stack_base_get, _mupdf.fz_error_context_stack_base_set)
    errcode = property(_mupdf.fz_error_context_errcode_get, _mupdf.fz_error_context_errcode_set)
    errnum = property(_mupdf.fz_error_context_errnum_get, _mupdf.fz_error_context_errnum_set)
    print_user = property(_mupdf.fz_error_context_print_user_get, _mupdf.fz_error_context_print_user_set)
    _print = property(_mupdf.fz_error_context__print_get, _mupdf.fz_error_context__print_set)
    message = property(_mupdf.fz_error_context_message_get, _mupdf.fz_error_context_message_set)

    def __init__(self):
        _mupdf.fz_error_context_swiginit(self, _mupdf.new_fz_error_context())
    __swig_destroy__ = _mupdf.delete_fz_error_context

# Register fz_error_context in _mupdf:
_mupdf.fz_error_context_swigregister(fz_error_context)
class fz_warn_context(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    print_user = property(_mupdf.fz_warn_context_print_user_get, _mupdf.fz_warn_context_print_user_set)
    _print = property(_mupdf.fz_warn_context__print_get, _mupdf.fz_warn_context__print_set)
    count = property(_mupdf.fz_warn_context_count_get, _mupdf.fz_warn_context_count_set)
    message = property(_mupdf.fz_warn_context_message_get, _mupdf.fz_warn_context_message_set)

    def __init__(self):
        _mupdf.fz_warn_context_swiginit(self, _mupdf.new_fz_warn_context())
    __swig_destroy__ = _mupdf.delete_fz_warn_context

# Register fz_warn_context in _mupdf:
_mupdf.fz_warn_context_swigregister(fz_warn_context)
class fz_aa_context(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    hscale = property(_mupdf.fz_aa_context_hscale_get, _mupdf.fz_aa_context_hscale_set)
    vscale = property(_mupdf.fz_aa_context_vscale_get, _mupdf.fz_aa_context_vscale_set)
    scale = property(_mupdf.fz_aa_context_scale_get, _mupdf.fz_aa_context_scale_set)
    bits = property(_mupdf.fz_aa_context_bits_get, _mupdf.fz_aa_context_bits_set)
    text_bits = property(_mupdf.fz_aa_context_text_bits_get, _mupdf.fz_aa_context_text_bits_set)
    min_line_width = property(_mupdf.fz_aa_context_min_line_width_get, _mupdf.fz_aa_context_min_line_width_set)

    def __init__(self):
        _mupdf.fz_aa_context_swiginit(self, _mupdf.new_fz_aa_context())
    __swig_destroy__ = _mupdf.delete_fz_aa_context

# Register fz_aa_context in _mupdf:
_mupdf.fz_aa_context_swigregister(fz_aa_context)
class fz_context(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    user = property(_mupdf.fz_context_user_get, _mupdf.fz_context_user_set)
    alloc = property(_mupdf.fz_context_alloc_get, _mupdf.fz_context_alloc_set)
    locks = property(_mupdf.fz_context_locks_get, _mupdf.fz_context_locks_set)
    error = property(_mupdf.fz_context_error_get, _mupdf.fz_context_error_set)
    warn = property(_mupdf.fz_context_warn_get, _mupdf.fz_context_warn_set)
    aa = property(_mupdf.fz_context_aa_get, _mupdf.fz_context_aa_set)
    seed48 = property(_mupdf.fz_context_seed48_get, _mupdf.fz_context_seed48_set)
    icc_enabled = property(_mupdf.fz_context_icc_enabled_get, _mupdf.fz_context_icc_enabled_set)
    throw_on_repair = property(_mupdf.fz_context_throw_on_repair_get, _mupdf.fz_context_throw_on_repair_set)
    handler = property(_mupdf.fz_context_handler_get, _mupdf.fz_context_handler_set)
    archive = property(_mupdf.fz_context_archive_get, _mupdf.fz_context_archive_set)
    style = property(_mupdf.fz_context_style_get, _mupdf.fz_context_style_set)
    tuning = property(_mupdf.fz_context_tuning_get, _mupdf.fz_context_tuning_set)
    stddbg = property(_mupdf.fz_context_stddbg_get, _mupdf.fz_context_stddbg_set)
    font = property(_mupdf.fz_context_font_get, _mupdf.fz_context_font_set)
    colorspace = property(_mupdf.fz_context_colorspace_get, _mupdf.fz_context_colorspace_set)
    store = property(_mupdf.fz_context_store_get, _mupdf.fz_context_store_set)
    glyph_cache = property(_mupdf.fz_context_glyph_cache_get, _mupdf.fz_context_glyph_cache_set)

    def __init__(self):
        _mupdf.fz_context_swiginit(self, _mupdf.new_fz_context())
    __swig_destroy__ = _mupdf.delete_fz_context

# Register fz_context in _mupdf:
_mupdf.fz_context_swigregister(fz_context)
class fz_buffer(object):
    r"""
    fz_buffer is a wrapper around a dynamically allocated array of
    bytes.

    Buffers have a capacity (the number of bytes storage immediately
    available) and a current size.

    The contents of the structure are considered implementation
    details and are subject to change. Users should use the accessor
    functions in preference.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    refs = property(_mupdf.fz_buffer_refs_get, _mupdf.fz_buffer_refs_set)
    data = property(_mupdf.fz_buffer_data_get, _mupdf.fz_buffer_data_set)
    cap = property(_mupdf.fz_buffer_cap_get, _mupdf.fz_buffer_cap_set)
    len = property(_mupdf.fz_buffer_len_get, _mupdf.fz_buffer_len_set)
    unused_bits = property(_mupdf.fz_buffer_unused_bits_get, _mupdf.fz_buffer_unused_bits_set)
    shared = property(_mupdf.fz_buffer_shared_get, _mupdf.fz_buffer_shared_set)

    def __init__(self):
        _mupdf.fz_buffer_swiginit(self, _mupdf.new_fz_buffer())
    __swig_destroy__ = _mupdf.delete_fz_buffer

# Register fz_buffer in _mupdf:
_mupdf.fz_buffer_swigregister(fz_buffer)
FZ_REPLACEMENT_CHARACTER = _mupdf.FZ_REPLACEMENT_CHARACTER
FZ_UTFMAX = _mupdf.FZ_UTFMAX
class fz_stream(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    refs = property(_mupdf.fz_stream_refs_get, _mupdf.fz_stream_refs_set)
    error = property(_mupdf.fz_stream_error_get, _mupdf.fz_stream_error_set)
    eof = property(_mupdf.fz_stream_eof_get, _mupdf.fz_stream_eof_set)
    progressive = property(_mupdf.fz_stream_progressive_get, _mupdf.fz_stream_progressive_set)
    pos = property(_mupdf.fz_stream_pos_get, _mupdf.fz_stream_pos_set)
    avail = property(_mupdf.fz_stream_avail_get, _mupdf.fz_stream_avail_set)
    bits = property(_mupdf.fz_stream_bits_get, _mupdf.fz_stream_bits_set)
    rp = property(_mupdf.fz_stream_rp_get, _mupdf.fz_stream_rp_set)
    wp = property(_mupdf.fz_stream_wp_get, _mupdf.fz_stream_wp_set)
    state = property(_mupdf.fz_stream_state_get, _mupdf.fz_stream_state_set)
    next = property(_mupdf.fz_stream_next_get, _mupdf.fz_stream_next_set)
    drop = property(_mupdf.fz_stream_drop_get, _mupdf.fz_stream_drop_set)
    seek = property(_mupdf.fz_stream_seek_get, _mupdf.fz_stream_seek_set)

    def __init__(self):
        _mupdf.fz_stream_swiginit(self, _mupdf.new_fz_stream())
    __swig_destroy__ = _mupdf.delete_fz_stream

# Register fz_stream in _mupdf:
_mupdf.fz_stream_swigregister(fz_stream)
class fz_output(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    state = property(_mupdf.fz_output_state_get, _mupdf.fz_output_state_set)
    write = property(_mupdf.fz_output_write_get, _mupdf.fz_output_write_set)
    seek = property(_mupdf.fz_output_seek_get, _mupdf.fz_output_seek_set)
    tell = property(_mupdf.fz_output_tell_get, _mupdf.fz_output_tell_set)
    close = property(_mupdf.fz_output_close_get, _mupdf.fz_output_close_set)
    drop = property(_mupdf.fz_output_drop_get, _mupdf.fz_output_drop_set)
    reset = property(_mupdf.fz_output_reset_get, _mupdf.fz_output_reset_set)
    as_stream = property(_mupdf.fz_output_as_stream_get, _mupdf.fz_output_as_stream_set)
    truncate = property(_mupdf.fz_output_truncate_get, _mupdf.fz_output_truncate_set)
    closed = property(_mupdf.fz_output_closed_get, _mupdf.fz_output_closed_set)
    bp = property(_mupdf.fz_output_bp_get, _mupdf.fz_output_bp_set)
    wp = property(_mupdf.fz_output_wp_get, _mupdf.fz_output_wp_set)
    ep = property(_mupdf.fz_output_ep_get, _mupdf.fz_output_ep_set)
    buffered = property(_mupdf.fz_output_buffered_get, _mupdf.fz_output_buffered_set)
    bits = property(_mupdf.fz_output_bits_get, _mupdf.fz_output_bits_set)

    def __init__(self):
        _mupdf.fz_output_swiginit(self, _mupdf.new_fz_output())
    __swig_destroy__ = _mupdf.delete_fz_output

# Register fz_output in _mupdf:
_mupdf.fz_output_swigregister(fz_output)
class fz_md5(object):
    r"""
    Structure definition is public to enable stack
    based allocation. Do not access the members directly.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    lo = property(_mupdf.fz_md5_lo_get, _mupdf.fz_md5_lo_set)
    hi = property(_mupdf.fz_md5_hi_get, _mupdf.fz_md5_hi_set)
    a = property(_mupdf.fz_md5_a_get, _mupdf.fz_md5_a_set)
    b = property(_mupdf.fz_md5_b_get, _mupdf.fz_md5_b_set)
    c = property(_mupdf.fz_md5_c_get, _mupdf.fz_md5_c_set)
    d = property(_mupdf.fz_md5_d_get, _mupdf.fz_md5_d_set)
    buffer = property(_mupdf.fz_md5_buffer_get, _mupdf.fz_md5_buffer_set)

    def __init__(self):
        _mupdf.fz_md5_swiginit(self, _mupdf.new_fz_md5())
    __swig_destroy__ = _mupdf.delete_fz_md5

# Register fz_md5 in _mupdf:
_mupdf.fz_md5_swigregister(fz_md5)
class fz_sha256(object):
    r"""
    Structure definition is public to enable stack
    based allocation. Do not access the members directly.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    state = property(_mupdf.fz_sha256_state_get, _mupdf.fz_sha256_state_set)
    count = property(_mupdf.fz_sha256_count_get, _mupdf.fz_sha256_count_set)

    def __init__(self):
        _mupdf.fz_sha256_swiginit(self, _mupdf.new_fz_sha256())
    __swig_destroy__ = _mupdf.delete_fz_sha256

# Register fz_sha256 in _mupdf:
_mupdf.fz_sha256_swigregister(fz_sha256)
class fz_sha512(object):
    r"""
    Structure definition is public to enable stack
    based allocation. Do not access the members directly.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    state = property(_mupdf.fz_sha512_state_get, _mupdf.fz_sha512_state_set)
    count = property(_mupdf.fz_sha512_count_get, _mupdf.fz_sha512_count_set)

    def __init__(self):
        _mupdf.fz_sha512_swiginit(self, _mupdf.new_fz_sha512())
    __swig_destroy__ = _mupdf.delete_fz_sha512

# Register fz_sha512 in _mupdf:
_mupdf.fz_sha512_swigregister(fz_sha512)
class fz_arc4(object):
    r"""
    Structure definition is public to enable stack
    based allocation. Do not access the members directly.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    x = property(_mupdf.fz_arc4_x_get, _mupdf.fz_arc4_x_set)
    y = property(_mupdf.fz_arc4_y_get, _mupdf.fz_arc4_y_set)
    state = property(_mupdf.fz_arc4_state_get, _mupdf.fz_arc4_state_set)

    def __init__(self):
        _mupdf.fz_arc4_swiginit(self, _mupdf.new_fz_arc4())
    __swig_destroy__ = _mupdf.delete_fz_arc4

# Register fz_arc4 in _mupdf:
_mupdf.fz_arc4_swigregister(fz_arc4)
class fz_aes(object):
    r"""
    Structure definitions are public to enable stack
    based allocation. Do not access the members directly.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    nr = property(_mupdf.fz_aes_nr_get, _mupdf.fz_aes_nr_set)
    rk = property(_mupdf.fz_aes_rk_get, _mupdf.fz_aes_rk_set)
    buf = property(_mupdf.fz_aes_buf_get, _mupdf.fz_aes_buf_set)

    def __init__(self):
        _mupdf.fz_aes_swiginit(self, _mupdf.new_fz_aes())
    __swig_destroy__ = _mupdf.delete_fz_aes

# Register fz_aes in _mupdf:
_mupdf.fz_aes_swigregister(fz_aes)
FZ_AES_DECRYPT = _mupdf.FZ_AES_DECRYPT
FZ_AES_ENCRYPT = _mupdf.FZ_AES_ENCRYPT
class fz_getopt_long_options(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    option = property(_mupdf.fz_getopt_long_options_option_get, _mupdf.fz_getopt_long_options_option_set)
    flag = property(_mupdf.fz_getopt_long_options_flag_get, _mupdf.fz_getopt_long_options_flag_set)
    opaque = property(_mupdf.fz_getopt_long_options_opaque_get, _mupdf.fz_getopt_long_options_opaque_set)

    def __init__(self):
        _mupdf.fz_getopt_long_options_swiginit(self, _mupdf.new_fz_getopt_long_options())
    __swig_destroy__ = _mupdf.delete_fz_getopt_long_options

# Register fz_getopt_long_options in _mupdf:
_mupdf.fz_getopt_long_options_swigregister(fz_getopt_long_options)
FZ_HASH_TABLE_KEY_LENGTH = _mupdf.FZ_HASH_TABLE_KEY_LENGTH
FZ_BIDI_LTR = _mupdf.FZ_BIDI_LTR
FZ_BIDI_RTL = _mupdf.FZ_BIDI_RTL
FZ_BIDI_NEUTRAL = _mupdf.FZ_BIDI_NEUTRAL
FZ_BIDI_CLASSIFY_WHITE_SPACE = _mupdf.FZ_BIDI_CLASSIFY_WHITE_SPACE
FZ_BIDI_REPLACE_TAB = _mupdf.FZ_BIDI_REPLACE_TAB
class fz_archive_handler(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    recognize = property(_mupdf.fz_archive_handler_recognize_get, _mupdf.fz_archive_handler_recognize_set)
    open = property(_mupdf.fz_archive_handler_open_get, _mupdf.fz_archive_handler_open_set)

    def __init__(self):
        _mupdf.fz_archive_handler_swiginit(self, _mupdf.new_fz_archive_handler())
    __swig_destroy__ = _mupdf.delete_fz_archive_handler

# Register fz_archive_handler in _mupdf:
_mupdf.fz_archive_handler_swigregister(fz_archive_handler)
class fz_archive(object):
    r"""	Implementation details: Subject to change."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    refs = property(_mupdf.fz_archive_refs_get, _mupdf.fz_archive_refs_set)
    file = property(_mupdf.fz_archive_file_get, _mupdf.fz_archive_file_set)
    format = property(_mupdf.fz_archive_format_get, _mupdf.fz_archive_format_set)
    drop_archive = property(_mupdf.fz_archive_drop_archive_get, _mupdf.fz_archive_drop_archive_set)
    count_entries = property(_mupdf.fz_archive_count_entries_get, _mupdf.fz_archive_count_entries_set)
    list_entry = property(_mupdf.fz_archive_list_entry_get, _mupdf.fz_archive_list_entry_set)
    has_entry = property(_mupdf.fz_archive_has_entry_get, _mupdf.fz_archive_has_entry_set)
    read_entry = property(_mupdf.fz_archive_read_entry_get, _mupdf.fz_archive_read_entry_set)
    open_entry = property(_mupdf.fz_archive_open_entry_get, _mupdf.fz_archive_open_entry_set)

    def __init__(self):
        _mupdf.fz_archive_swiginit(self, _mupdf.new_fz_archive())
    __swig_destroy__ = _mupdf.delete_fz_archive

# Register fz_archive in _mupdf:
_mupdf.fz_archive_swigregister(fz_archive)
fz_libarchive_archive_handler = cvar.fz_libarchive_archive_handler

class fz_storable(object):
    r"""
    Any storable object should include an fz_storable structure
    at the start (by convention at least) of their structure.
    (Unless it starts with an fz_key_storable, see below).
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    refs = property(_mupdf.fz_storable_refs_get, _mupdf.fz_storable_refs_set)
    drop = property(_mupdf.fz_storable_drop_get, _mupdf.fz_storable_drop_set)
    droppable = property(_mupdf.fz_storable_droppable_get, _mupdf.fz_storable_droppable_set)

    def __init__(self):
        _mupdf.fz_storable_swiginit(self, _mupdf.new_fz_storable())
    __swig_destroy__ = _mupdf.delete_fz_storable

# Register fz_storable in _mupdf:
_mupdf.fz_storable_swigregister(fz_storable)
class fz_key_storable(object):
    r"""
    Any storable object that can appear in the key of another
    storable object should include an fz_key_storable structure
    at the start (by convention at least) of their structure.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    storable = property(_mupdf.fz_key_storable_storable_get, _mupdf.fz_key_storable_storable_set)
    store_key_refs = property(_mupdf.fz_key_storable_store_key_refs_get, _mupdf.fz_key_storable_store_key_refs_set)

    def __init__(self):
        _mupdf.fz_key_storable_swiginit(self, _mupdf.new_fz_key_storable())
    __swig_destroy__ = _mupdf.delete_fz_key_storable

# Register fz_key_storable in _mupdf:
_mupdf.fz_key_storable_swigregister(fz_key_storable)
class fz_store_hash(object):
    r"""
    The store can be seen as a dictionary that maps keys to
    fz_storable values. In order to allow keys of different types to
    be stored, we have a structure full of functions for each key
    'type'; this fz_store_type pointer is stored with each key, and
    tells the store how to perform certain operations (like taking/
    dropping a reference, comparing two keys, outputting details for
    debugging etc).

    The store uses a hash table internally for speed where possible.
    In order for this to work, we need a mechanism for turning a
    generic 'key' into 'a hashable string'. For this purpose the
    type structure contains a make_hash_key function pointer that
    maps from a void * to a fz_store_hash structure. If
    make_hash_key function returns 0, then the key is determined not
    to be hashable, and the value is not stored in the hash table.

    Some objects can be used both as values within the store, and as
    a component of keys within the store. We refer to these objects
    as "key storable" objects. In this case, we need to take
    additional care to ensure that we do not end up keeping an item
    within the store, purely because its value is referred to by
    another key in the store.

    An example of this are fz_images in PDF files. Each fz_image is
    placed into the	store to enable it to be easily reused. When the
    image is rendered, a pixmap is generated from the image, and the
    pixmap is placed into the store so it can be reused on
    subsequent renders. The image forms part of the key for the
    pixmap.

    When we close the pdf document (and any associated pages/display
    lists etc), we drop the images from the store. This may leave us
    in the position of the images having non-zero reference counts
    purely because they are used as part of the keys for the
    pixmaps.

    We therefore use special reference counting functions to keep
    track of these "key storable" items, and hence store the number
    of references to these items that are used in keys.

    When the number of references to an object == the number of
    references to an object from keys in the store, we know that we
    can remove all the items which have that object as part of the
    key. This is done by running a pass over the store, 'reaping'
    those items.

    Reap passes are slower than we would like as they touch every
    item in the store. We therefore provide a way to 'batch' such
    reap passes together, using fz_defer_reap_start/
    fz_defer_reap_end to bracket a region in which many may be
    triggered.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    drop = property(_mupdf.fz_store_hash_drop_get, _mupdf.fz_store_hash_drop_set)

    def __init__(self):
        _mupdf.fz_store_hash_swiginit(self, _mupdf.new_fz_store_hash())
    __swig_destroy__ = _mupdf.delete_fz_store_hash

# Register fz_store_hash in _mupdf:
_mupdf.fz_store_hash_swigregister(fz_store_hash)
class fz_store_type(object):
    r"""
    Every type of object to be placed into the store defines an
    fz_store_type. This contains the pointers to functions to
    make hashes, manipulate keys, and check for needing reaping.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    name = property(_mupdf.fz_store_type_name_get, _mupdf.fz_store_type_name_set)
    make_hash_key = property(_mupdf.fz_store_type_make_hash_key_get, _mupdf.fz_store_type_make_hash_key_set)
    keep_key = property(_mupdf.fz_store_type_keep_key_get, _mupdf.fz_store_type_keep_key_set)
    drop_key = property(_mupdf.fz_store_type_drop_key_get, _mupdf.fz_store_type_drop_key_set)
    cmp_key = property(_mupdf.fz_store_type_cmp_key_get, _mupdf.fz_store_type_cmp_key_set)
    format_key = property(_mupdf.fz_store_type_format_key_get, _mupdf.fz_store_type_format_key_set)
    needs_reap = property(_mupdf.fz_store_type_needs_reap_get, _mupdf.fz_store_type_needs_reap_set)

    def __init__(self):
        _mupdf.fz_store_type_swiginit(self, _mupdf.new_fz_store_type())
    __swig_destroy__ = _mupdf.delete_fz_store_type

# Register fz_store_type in _mupdf:
_mupdf.fz_store_type_swigregister(fz_store_type)
FZ_RI_PERCEPTUAL = _mupdf.FZ_RI_PERCEPTUAL
FZ_RI_RELATIVE_COLORIMETRIC = _mupdf.FZ_RI_RELATIVE_COLORIMETRIC
FZ_RI_SATURATION = _mupdf.FZ_RI_SATURATION
FZ_RI_ABSOLUTE_COLORIMETRIC = _mupdf.FZ_RI_ABSOLUTE_COLORIMETRIC
class fz_color_params(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    ri = property(_mupdf.fz_color_params_ri_get, _mupdf.fz_color_params_ri_set)
    bp = property(_mupdf.fz_color_params_bp_get, _mupdf.fz_color_params_bp_set)
    op = property(_mupdf.fz_color_params_op_get, _mupdf.fz_color_params_op_set)
    opm = property(_mupdf.fz_color_params_opm_get, _mupdf.fz_color_params_opm_set)

    def __init__(self):
        _mupdf.fz_color_params_swiginit(self, _mupdf.new_fz_color_params())
    __swig_destroy__ = _mupdf.delete_fz_color_params

# Register fz_color_params in _mupdf:
_mupdf.fz_color_params_swigregister(fz_color_params)
FZ_MAX_COLORS = _mupdf.FZ_MAX_COLORS
FZ_COLORSPACE_IS_DEVICE = _mupdf.FZ_COLORSPACE_IS_DEVICE
FZ_COLORSPACE_IS_ICC = _mupdf.FZ_COLORSPACE_IS_ICC
FZ_COLORSPACE_HAS_CMYK = _mupdf.FZ_COLORSPACE_HAS_CMYK
FZ_COLORSPACE_HAS_SPOTS = _mupdf.FZ_COLORSPACE_HAS_SPOTS
FZ_COLORSPACE_HAS_CMYK_AND_SPOTS = _mupdf.FZ_COLORSPACE_HAS_CMYK_AND_SPOTS
class fz_default_colorspaces(object):
    r"""	Structure to hold default colorspaces."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    refs = property(_mupdf.fz_default_colorspaces_refs_get, _mupdf.fz_default_colorspaces_refs_set)
    gray = property(_mupdf.fz_default_colorspaces_gray_get, _mupdf.fz_default_colorspaces_gray_set)
    rgb = property(_mupdf.fz_default_colorspaces_rgb_get, _mupdf.fz_default_colorspaces_rgb_set)
    cmyk = property(_mupdf.fz_default_colorspaces_cmyk_get, _mupdf.fz_default_colorspaces_cmyk_set)
    oi = property(_mupdf.fz_default_colorspaces_oi_get, _mupdf.fz_default_colorspaces_oi_set)

    def __init__(self):
        _mupdf.fz_default_colorspaces_swiginit(self, _mupdf.new_fz_default_colorspaces())
    __swig_destroy__ = _mupdf.delete_fz_default_colorspaces

# Register fz_default_colorspaces in _mupdf:
_mupdf.fz_default_colorspaces_swigregister(fz_default_colorspaces)
fz_default_color_params = cvar.fz_default_color_params

class fz_colorspace(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    key_storable = property(_mupdf.fz_colorspace_key_storable_get, _mupdf.fz_colorspace_key_storable_set)
    type = property(_mupdf.fz_colorspace_type_get, _mupdf.fz_colorspace_type_set)
    flags = property(_mupdf.fz_colorspace_flags_get, _mupdf.fz_colorspace_flags_set)
    n = property(_mupdf.fz_colorspace_n_get, _mupdf.fz_colorspace_n_set)
    name = property(_mupdf.fz_colorspace_name_get, _mupdf.fz_colorspace_name_set)

    def __init__(self):
        _mupdf.fz_colorspace_swiginit(self, _mupdf.new_fz_colorspace())
    __swig_destroy__ = _mupdf.delete_fz_colorspace

# Register fz_colorspace in _mupdf:
_mupdf.fz_colorspace_swigregister(fz_colorspace)
FZ_MAX_SEPARATIONS = _mupdf.FZ_MAX_SEPARATIONS
FZ_SEPARATION_COMPOSITE = _mupdf.FZ_SEPARATION_COMPOSITE
FZ_SEPARATION_SPOT = _mupdf.FZ_SEPARATION_SPOT
FZ_SEPARATION_DISABLED = _mupdf.FZ_SEPARATION_DISABLED
class fz_pixmap(object):
    r"""
    Pixmaps represent a set of pixels for a 2 dimensional region of
    a plane. Each pixel has n components per pixel. The components
    are in the order process-components, spot-colors, alpha, where
    there can be 0 of any of those types. The data is in
    premultiplied alpha when rendering, but non-premultiplied for
    colorspace conversions and rescaling.

    x, y: The minimum x and y coord of the region in pixels.

    w, h: The width and height of the region in pixels.

    n: The number of color components in the image.
    	n = num composite colors + num spots + num alphas

    s: The number of spot channels in the image.

    alpha: 0 for no alpha, 1 for alpha present.

    flags: flag bits.
    	Bit 0: If set, draw the image with linear interpolation.
    	Bit 1: If set, free the samples buffer when the pixmap
    	is destroyed.

    stride: The byte offset from the data for any given pixel
    to the data for the same pixel on the row below.

    seps: NULL, or a pointer to a separations structure. If NULL,
    s should be 0.

    xres, yres: Image resolution in dpi. Default is 96 dpi.

    colorspace: Pointer to a colorspace object describing the
    colorspace the pixmap is in. If NULL, the image is a mask.

    samples: Pointer to the first byte of the pixmap sample data.
    This is typically a simple block of memory w * h * n bytes of
    memory in which the components are stored linearly, but with the
    use of appropriate stride values, scanlines can be stored in
    different orders, and have different amounts of padding. The
    first n bytes are components 0 to n-1 for the pixel at (x,y).
    Each successive n bytes gives another pixel in scanline order
    as we move across the line. The start of each scanline is offset
    the start of the previous one by stride bytes.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    storable = property(_mupdf.fz_pixmap_storable_get, _mupdf.fz_pixmap_storable_set)
    x = property(_mupdf.fz_pixmap_x_get, _mupdf.fz_pixmap_x_set)
    y = property(_mupdf.fz_pixmap_y_get, _mupdf.fz_pixmap_y_set)
    w = property(_mupdf.fz_pixmap_w_get, _mupdf.fz_pixmap_w_set)
    h = property(_mupdf.fz_pixmap_h_get, _mupdf.fz_pixmap_h_set)
    n = property(_mupdf.fz_pixmap_n_get, _mupdf.fz_pixmap_n_set)
    s = property(_mupdf.fz_pixmap_s_get, _mupdf.fz_pixmap_s_set)
    alpha = property(_mupdf.fz_pixmap_alpha_get, _mupdf.fz_pixmap_alpha_set)
    flags = property(_mupdf.fz_pixmap_flags_get, _mupdf.fz_pixmap_flags_set)
    stride = property(_mupdf.fz_pixmap_stride_get, _mupdf.fz_pixmap_stride_set)
    seps = property(_mupdf.fz_pixmap_seps_get, _mupdf.fz_pixmap_seps_set)
    xres = property(_mupdf.fz_pixmap_xres_get, _mupdf.fz_pixmap_xres_set)
    yres = property(_mupdf.fz_pixmap_yres_get, _mupdf.fz_pixmap_yres_set)
    colorspace = property(_mupdf.fz_pixmap_colorspace_get, _mupdf.fz_pixmap_colorspace_set)
    samples = property(_mupdf.fz_pixmap_samples_get, _mupdf.fz_pixmap_samples_set)
    underlying = property(_mupdf.fz_pixmap_underlying_get, _mupdf.fz_pixmap_underlying_set)

    def __init__(self):
        _mupdf.fz_pixmap_swiginit(self, _mupdf.new_fz_pixmap())
    __swig_destroy__ = _mupdf.delete_fz_pixmap

# Register fz_pixmap in _mupdf:
_mupdf.fz_pixmap_swigregister(fz_pixmap)
FZ_PIXMAP_FLAG_INTERPOLATE = _mupdf.FZ_PIXMAP_FLAG_INTERPOLATE
FZ_PIXMAP_FLAG_FREE_SAMPLES = _mupdf.FZ_PIXMAP_FLAG_FREE_SAMPLES
FZ_DEFLATE_NONE = _mupdf.FZ_DEFLATE_NONE
FZ_DEFLATE_BEST_SPEED = _mupdf.FZ_DEFLATE_BEST_SPEED
FZ_DEFLATE_BEST = _mupdf.FZ_DEFLATE_BEST
FZ_DEFLATE_DEFAULT = _mupdf.FZ_DEFLATE_DEFAULT
class fz_range(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    offset = property(_mupdf.fz_range_offset_get, _mupdf.fz_range_offset_set)
    length = property(_mupdf.fz_range_length_get, _mupdf.fz_range_length_set)

    def __init__(self):
        _mupdf.fz_range_swiginit(self, _mupdf.new_fz_range())
    __swig_destroy__ = _mupdf.delete_fz_range

# Register fz_range in _mupdf:
_mupdf.fz_range_swigregister(fz_range)
class fz_compression_params(object):
    r"""
    Compression parameters used for buffers of compressed data;
    typically for the source data for images.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    type = property(_mupdf.fz_compression_params_type_get, _mupdf.fz_compression_params_type_set)

    def __init__(self):
        _mupdf.fz_compression_params_swiginit(self, _mupdf.new_fz_compression_params())
    __swig_destroy__ = _mupdf.delete_fz_compression_params

# Register fz_compression_params in _mupdf:
_mupdf.fz_compression_params_swigregister(fz_compression_params)
class fz_compressed_buffer(object):
    r"""
    Buffers of compressed data; typically for the source data
    for images.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    refs = property(_mupdf.fz_compressed_buffer_refs_get, _mupdf.fz_compressed_buffer_refs_set)
    params = property(_mupdf.fz_compressed_buffer_params_get, _mupdf.fz_compressed_buffer_params_set)
    buffer = property(_mupdf.fz_compressed_buffer_buffer_get, _mupdf.fz_compressed_buffer_buffer_set)

    def __init__(self):
        _mupdf.fz_compressed_buffer_swiginit(self, _mupdf.new_fz_compressed_buffer())
    __swig_destroy__ = _mupdf.delete_fz_compressed_buffer

# Register fz_compressed_buffer in _mupdf:
_mupdf.fz_compressed_buffer_swigregister(fz_compressed_buffer)
FZ_IMAGE_UNKNOWN = _mupdf.FZ_IMAGE_UNKNOWN
FZ_IMAGE_RAW = _mupdf.FZ_IMAGE_RAW
FZ_IMAGE_FAX = _mupdf.FZ_IMAGE_FAX
FZ_IMAGE_FLATE = _mupdf.FZ_IMAGE_FLATE
FZ_IMAGE_LZW = _mupdf.FZ_IMAGE_LZW
FZ_IMAGE_RLD = _mupdf.FZ_IMAGE_RLD
FZ_IMAGE_BMP = _mupdf.FZ_IMAGE_BMP
FZ_IMAGE_GIF = _mupdf.FZ_IMAGE_GIF
FZ_IMAGE_JBIG2 = _mupdf.FZ_IMAGE_JBIG2
FZ_IMAGE_JPEG = _mupdf.FZ_IMAGE_JPEG
FZ_IMAGE_JPX = _mupdf.FZ_IMAGE_JPX
FZ_IMAGE_JXR = _mupdf.FZ_IMAGE_JXR
FZ_IMAGE_PNG = _mupdf.FZ_IMAGE_PNG
FZ_IMAGE_PNM = _mupdf.FZ_IMAGE_PNM
FZ_IMAGE_TIFF = _mupdf.FZ_IMAGE_TIFF
FZ_IMAGE_PSD = _mupdf.FZ_IMAGE_PSD
class fz_bitmap(object):
    r"""
    Bitmaps have 1 bit per component. Only used for creating
    halftoned versions of contone buffers, and saving out. Samples
    are stored msb first, akin to pbms.

    The internals of this struct are considered implementation
    details and subject to change. Where possible, accessor
    functions should be used in preference.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    refs = property(_mupdf.fz_bitmap_refs_get, _mupdf.fz_bitmap_refs_set)
    w = property(_mupdf.fz_bitmap_w_get, _mupdf.fz_bitmap_w_set)
    h = property(_mupdf.fz_bitmap_h_get, _mupdf.fz_bitmap_h_set)
    stride = property(_mupdf.fz_bitmap_stride_get, _mupdf.fz_bitmap_stride_set)
    n = property(_mupdf.fz_bitmap_n_get, _mupdf.fz_bitmap_n_set)
    xres = property(_mupdf.fz_bitmap_xres_get, _mupdf.fz_bitmap_xres_set)
    yres = property(_mupdf.fz_bitmap_yres_get, _mupdf.fz_bitmap_yres_set)
    samples = property(_mupdf.fz_bitmap_samples_get, _mupdf.fz_bitmap_samples_set)

    def __init__(self):
        _mupdf.fz_bitmap_swiginit(self, _mupdf.new_fz_bitmap())
    __swig_destroy__ = _mupdf.delete_fz_bitmap

# Register fz_bitmap in _mupdf:
_mupdf.fz_bitmap_swigregister(fz_bitmap)
class fz_image(object):
    r"""
    Structure is public to allow other structures to
    be derived from it. Do not access members directly.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    key_storable = property(_mupdf.fz_image_key_storable_get, _mupdf.fz_image_key_storable_set)
    w = property(_mupdf.fz_image_w_get, _mupdf.fz_image_w_set)
    h = property(_mupdf.fz_image_h_get, _mupdf.fz_image_h_set)
    n = property(_mupdf.fz_image_n_get, _mupdf.fz_image_n_set)
    bpc = property(_mupdf.fz_image_bpc_get, _mupdf.fz_image_bpc_set)
    imagemask = property(_mupdf.fz_image_imagemask_get, _mupdf.fz_image_imagemask_set)
    interpolate = property(_mupdf.fz_image_interpolate_get, _mupdf.fz_image_interpolate_set)
    use_colorkey = property(_mupdf.fz_image_use_colorkey_get, _mupdf.fz_image_use_colorkey_set)
    use_decode = property(_mupdf.fz_image_use_decode_get, _mupdf.fz_image_use_decode_set)
    decoded = property(_mupdf.fz_image_decoded_get, _mupdf.fz_image_decoded_set)
    scalable = property(_mupdf.fz_image_scalable_get, _mupdf.fz_image_scalable_set)
    orientation = property(_mupdf.fz_image_orientation_get, _mupdf.fz_image_orientation_set)
    mask = property(_mupdf.fz_image_mask_get, _mupdf.fz_image_mask_set)
    xres = property(_mupdf.fz_image_xres_get, _mupdf.fz_image_xres_set)
    yres = property(_mupdf.fz_image_yres_get, _mupdf.fz_image_yres_set)
    colorspace = property(_mupdf.fz_image_colorspace_get, _mupdf.fz_image_colorspace_set)
    drop_image = property(_mupdf.fz_image_drop_image_get, _mupdf.fz_image_drop_image_set)
    get_pixmap = property(_mupdf.fz_image_get_pixmap_get, _mupdf.fz_image_get_pixmap_set)
    get_size = property(_mupdf.fz_image_get_size_get, _mupdf.fz_image_get_size_set)
    colorkey = property(_mupdf.fz_image_colorkey_get, _mupdf.fz_image_colorkey_set)
    decode = property(_mupdf.fz_image_decode_get, _mupdf.fz_image_decode_set)

    def __init__(self):
        _mupdf.fz_image_swiginit(self, _mupdf.new_fz_image())
    __swig_destroy__ = _mupdf.delete_fz_image

# Register fz_image in _mupdf:
_mupdf.fz_image_swigregister(fz_image)
FZ_FUNCTION_BASED = _mupdf.FZ_FUNCTION_BASED
FZ_LINEAR = _mupdf.FZ_LINEAR
FZ_RADIAL = _mupdf.FZ_RADIAL
FZ_MESH_TYPE4 = _mupdf.FZ_MESH_TYPE4
FZ_MESH_TYPE5 = _mupdf.FZ_MESH_TYPE5
FZ_MESH_TYPE6 = _mupdf.FZ_MESH_TYPE6
FZ_MESH_TYPE7 = _mupdf.FZ_MESH_TYPE7
class fz_shade(object):
    r"""
    Structure is public to allow derived classes. Do not
    access the members directly.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    storable = property(_mupdf.fz_shade_storable_get, _mupdf.fz_shade_storable_set)
    bbox = property(_mupdf.fz_shade_bbox_get, _mupdf.fz_shade_bbox_set)
    colorspace = property(_mupdf.fz_shade_colorspace_get, _mupdf.fz_shade_colorspace_set)
    matrix = property(_mupdf.fz_shade_matrix_get, _mupdf.fz_shade_matrix_set)
    use_background = property(_mupdf.fz_shade_use_background_get, _mupdf.fz_shade_use_background_set)
    background = property(_mupdf.fz_shade_background_get, _mupdf.fz_shade_background_set)
    use_function = property(_mupdf.fz_shade_use_function_get, _mupdf.fz_shade_use_function_set)
    function = property(_mupdf.fz_shade_function_get, _mupdf.fz_shade_function_set)
    type = property(_mupdf.fz_shade_type_get, _mupdf.fz_shade_type_set)
    buffer = property(_mupdf.fz_shade_buffer_get, _mupdf.fz_shade_buffer_set)

    def __init__(self):
        _mupdf.fz_shade_swiginit(self, _mupdf.new_fz_shade())
    __swig_destroy__ = _mupdf.delete_fz_shade

# Register fz_shade in _mupdf:
_mupdf.fz_shade_swigregister(fz_shade)
class fz_vertex(object):
    r"""	Handy routine for processing mesh based shades"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    p = property(_mupdf.fz_vertex_p_get, _mupdf.fz_vertex_p_set)
    c = property(_mupdf.fz_vertex_c_get, _mupdf.fz_vertex_c_set)

    def __init__(self):
        _mupdf.fz_vertex_swiginit(self, _mupdf.new_fz_vertex())
    __swig_destroy__ = _mupdf.delete_fz_vertex

# Register fz_vertex in _mupdf:
_mupdf.fz_vertex_swigregister(fz_vertex)
class fz_text_decoder(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    decode_bound = property(_mupdf.fz_text_decoder_decode_bound_get, _mupdf.fz_text_decoder_decode_bound_set)
    decode_size = property(_mupdf.fz_text_decoder_decode_size_get, _mupdf.fz_text_decoder_decode_size_set)
    decode = property(_mupdf.fz_text_decoder_decode_get, _mupdf.fz_text_decoder_decode_set)
    table1 = property(_mupdf.fz_text_decoder_table1_get, _mupdf.fz_text_decoder_table1_set)
    table2 = property(_mupdf.fz_text_decoder_table2_get, _mupdf.fz_text_decoder_table2_set)

    def __init__(self):
        _mupdf.fz_text_decoder_swiginit(self, _mupdf.new_fz_text_decoder())
    __swig_destroy__ = _mupdf.delete_fz_text_decoder

# Register fz_text_decoder in _mupdf:
_mupdf.fz_text_decoder_swigregister(fz_text_decoder)
fz_unicode_from_iso8859_1 = cvar.fz_unicode_from_iso8859_1
fz_unicode_from_iso8859_7 = cvar.fz_unicode_from_iso8859_7
fz_unicode_from_koi8u = cvar.fz_unicode_from_koi8u
fz_unicode_from_pdf_doc_encoding = cvar.fz_unicode_from_pdf_doc_encoding
fz_unicode_from_windows_1250 = cvar.fz_unicode_from_windows_1250
fz_unicode_from_windows_1251 = cvar.fz_unicode_from_windows_1251
fz_unicode_from_windows_1252 = cvar.fz_unicode_from_windows_1252

FZ_ADOBE_CNS = _mupdf.FZ_ADOBE_CNS
FZ_ADOBE_GB = _mupdf.FZ_ADOBE_GB
FZ_ADOBE_JAPAN = _mupdf.FZ_ADOBE_JAPAN
FZ_ADOBE_KOREA = _mupdf.FZ_ADOBE_KOREA
class fz_font_flags_t(object):
    r"""
    Every fz_font carries a set of flags
    within it, in a fz_font_flags_t structure.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    is_mono = property(_mupdf.fz_font_flags_t_is_mono_get, _mupdf.fz_font_flags_t_is_mono_set)
    is_serif = property(_mupdf.fz_font_flags_t_is_serif_get, _mupdf.fz_font_flags_t_is_serif_set)
    is_bold = property(_mupdf.fz_font_flags_t_is_bold_get, _mupdf.fz_font_flags_t_is_bold_set)
    is_italic = property(_mupdf.fz_font_flags_t_is_italic_get, _mupdf.fz_font_flags_t_is_italic_set)
    ft_substitute = property(_mupdf.fz_font_flags_t_ft_substitute_get, _mupdf.fz_font_flags_t_ft_substitute_set)
    ft_stretch = property(_mupdf.fz_font_flags_t_ft_stretch_get, _mupdf.fz_font_flags_t_ft_stretch_set)
    fake_bold = property(_mupdf.fz_font_flags_t_fake_bold_get, _mupdf.fz_font_flags_t_fake_bold_set)
    fake_italic = property(_mupdf.fz_font_flags_t_fake_italic_get, _mupdf.fz_font_flags_t_fake_italic_set)
    has_opentype = property(_mupdf.fz_font_flags_t_has_opentype_get, _mupdf.fz_font_flags_t_has_opentype_set)
    invalid_bbox = property(_mupdf.fz_font_flags_t_invalid_bbox_get, _mupdf.fz_font_flags_t_invalid_bbox_set)
    cjk = property(_mupdf.fz_font_flags_t_cjk_get, _mupdf.fz_font_flags_t_cjk_set)
    cjk_lang = property(_mupdf.fz_font_flags_t_cjk_lang_get, _mupdf.fz_font_flags_t_cjk_lang_set)
    embed = property(_mupdf.fz_font_flags_t_embed_get, _mupdf.fz_font_flags_t_embed_set)
    never_embed = property(_mupdf.fz_font_flags_t_never_embed_get, _mupdf.fz_font_flags_t_never_embed_set)

    def __init__(self):
        _mupdf.fz_font_flags_t_swiginit(self, _mupdf.new_fz_font_flags_t())
    __swig_destroy__ = _mupdf.delete_fz_font_flags_t

# Register fz_font_flags_t in _mupdf:
_mupdf.fz_font_flags_t_swigregister(fz_font_flags_t)
class fz_shaper_data_t(object):
    r"""
    In order to shape a given font, we need to
    declare it to a shaper library (harfbuzz, by default, but others
    are possible). To avoid redeclaring it every time we need to
    shape, we hold a shaper handle and the destructor for it within
    the font itself. The handle is initialised by the caller when
    first required and the destructor is called when the fz_font is
    destroyed.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    shaper_handle = property(_mupdf.fz_shaper_data_t_shaper_handle_get, _mupdf.fz_shaper_data_t_shaper_handle_set)
    destroy = property(_mupdf.fz_shaper_data_t_destroy_get, _mupdf.fz_shaper_data_t_destroy_set)

    def __init__(self):
        _mupdf.fz_shaper_data_t_swiginit(self, _mupdf.new_fz_shaper_data_t())
    __swig_destroy__ = _mupdf.delete_fz_shaper_data_t

# Register fz_shaper_data_t in _mupdf:
_mupdf.fz_shaper_data_t_swigregister(fz_shaper_data_t)
class fz_font(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    refs = property(_mupdf.fz_font_refs_get, _mupdf.fz_font_refs_set)
    name = property(_mupdf.fz_font_name_get, _mupdf.fz_font_name_set)
    buffer = property(_mupdf.fz_font_buffer_get, _mupdf.fz_font_buffer_set)
    flags = property(_mupdf.fz_font_flags_get, _mupdf.fz_font_flags_set)
    ft_face = property(_mupdf.fz_font_ft_face_get, _mupdf.fz_font_ft_face_set)
    shaper_data = property(_mupdf.fz_font_shaper_data_get, _mupdf.fz_font_shaper_data_set)
    t3matrix = property(_mupdf.fz_font_t3matrix_get, _mupdf.fz_font_t3matrix_set)
    t3resources = property(_mupdf.fz_font_t3resources_get, _mupdf.fz_font_t3resources_set)
    t3procs = property(_mupdf.fz_font_t3procs_get, _mupdf.fz_font_t3procs_set)
    t3lists = property(_mupdf.fz_font_t3lists_get, _mupdf.fz_font_t3lists_set)
    t3widths = property(_mupdf.fz_font_t3widths_get, _mupdf.fz_font_t3widths_set)
    t3flags = property(_mupdf.fz_font_t3flags_get, _mupdf.fz_font_t3flags_set)
    t3doc = property(_mupdf.fz_font_t3doc_get, _mupdf.fz_font_t3doc_set)
    t3run = property(_mupdf.fz_font_t3run_get, _mupdf.fz_font_t3run_set)
    t3freeres = property(_mupdf.fz_font_t3freeres_get, _mupdf.fz_font_t3freeres_set)
    bbox = property(_mupdf.fz_font_bbox_get, _mupdf.fz_font_bbox_set)
    glyph_count = property(_mupdf.fz_font_glyph_count_get, _mupdf.fz_font_glyph_count_set)
    bbox_table = property(_mupdf.fz_font_bbox_table_get, _mupdf.fz_font_bbox_table_set)
    use_glyph_bbox = property(_mupdf.fz_font_use_glyph_bbox_get, _mupdf.fz_font_use_glyph_bbox_set)
    width_count = property(_mupdf.fz_font_width_count_get, _mupdf.fz_font_width_count_set)
    width_default = property(_mupdf.fz_font_width_default_get, _mupdf.fz_font_width_default_set)
    width_table = property(_mupdf.fz_font_width_table_get, _mupdf.fz_font_width_table_set)
    advance_cache = property(_mupdf.fz_font_advance_cache_get, _mupdf.fz_font_advance_cache_set)
    encoding_cache = property(_mupdf.fz_font_encoding_cache_get, _mupdf.fz_font_encoding_cache_set)
    has_digest = property(_mupdf.fz_font_has_digest_get, _mupdf.fz_font_has_digest_set)
    digest = property(_mupdf.fz_font_digest_get, _mupdf.fz_font_digest_set)
    subfont = property(_mupdf.fz_font_subfont_get, _mupdf.fz_font_subfont_set)

    def __init__(self):
        _mupdf.fz_font_swiginit(self, _mupdf.new_fz_font())
    __swig_destroy__ = _mupdf.delete_fz_font

# Register fz_font in _mupdf:
_mupdf.fz_font_swigregister(fz_font)
FZ_LINECAP_BUTT = _mupdf.FZ_LINECAP_BUTT
FZ_LINECAP_ROUND = _mupdf.FZ_LINECAP_ROUND
FZ_LINECAP_SQUARE = _mupdf.FZ_LINECAP_SQUARE
FZ_LINECAP_TRIANGLE = _mupdf.FZ_LINECAP_TRIANGLE
FZ_LINEJOIN_MITER = _mupdf.FZ_LINEJOIN_MITER
FZ_LINEJOIN_ROUND = _mupdf.FZ_LINEJOIN_ROUND
FZ_LINEJOIN_BEVEL = _mupdf.FZ_LINEJOIN_BEVEL
FZ_LINEJOIN_MITER_XPS = _mupdf.FZ_LINEJOIN_MITER_XPS
class fz_stroke_state(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    refs = property(_mupdf.fz_stroke_state_refs_get, _mupdf.fz_stroke_state_refs_set)
    start_cap = property(_mupdf.fz_stroke_state_start_cap_get, _mupdf.fz_stroke_state_start_cap_set)
    dash_cap = property(_mupdf.fz_stroke_state_dash_cap_get, _mupdf.fz_stroke_state_dash_cap_set)
    end_cap = property(_mupdf.fz_stroke_state_end_cap_get, _mupdf.fz_stroke_state_end_cap_set)
    linejoin = property(_mupdf.fz_stroke_state_linejoin_get, _mupdf.fz_stroke_state_linejoin_set)
    linewidth = property(_mupdf.fz_stroke_state_linewidth_get, _mupdf.fz_stroke_state_linewidth_set)
    miterlimit = property(_mupdf.fz_stroke_state_miterlimit_get, _mupdf.fz_stroke_state_miterlimit_set)
    dash_phase = property(_mupdf.fz_stroke_state_dash_phase_get, _mupdf.fz_stroke_state_dash_phase_set)
    dash_len = property(_mupdf.fz_stroke_state_dash_len_get, _mupdf.fz_stroke_state_dash_len_set)
    dash_list = property(_mupdf.fz_stroke_state_dash_list_get, _mupdf.fz_stroke_state_dash_list_set)

    def __init__(self):
        _mupdf.fz_stroke_state_swiginit(self, _mupdf.new_fz_stroke_state())
    __swig_destroy__ = _mupdf.delete_fz_stroke_state

# Register fz_stroke_state in _mupdf:
_mupdf.fz_stroke_state_swigregister(fz_stroke_state)
class fz_path_walker(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    moveto = property(_mupdf.fz_path_walker_moveto_get, _mupdf.fz_path_walker_moveto_set)
    lineto = property(_mupdf.fz_path_walker_lineto_get, _mupdf.fz_path_walker_lineto_set)
    curveto = property(_mupdf.fz_path_walker_curveto_get, _mupdf.fz_path_walker_curveto_set)
    closepath = property(_mupdf.fz_path_walker_closepath_get, _mupdf.fz_path_walker_closepath_set)
    quadto = property(_mupdf.fz_path_walker_quadto_get, _mupdf.fz_path_walker_quadto_set)
    curvetov = property(_mupdf.fz_path_walker_curvetov_get, _mupdf.fz_path_walker_curvetov_set)
    curvetoy = property(_mupdf.fz_path_walker_curvetoy_get, _mupdf.fz_path_walker_curvetoy_set)
    rectto = property(_mupdf.fz_path_walker_rectto_get, _mupdf.fz_path_walker_rectto_set)

    def __init__(self):
        _mupdf.fz_path_walker_swiginit(self, _mupdf.new_fz_path_walker())
    __swig_destroy__ = _mupdf.delete_fz_path_walker

# Register fz_path_walker in _mupdf:
_mupdf.fz_path_walker_swigregister(fz_path_walker)
class fz_text_item(object):
    r"""
    Text buffer.

    The trm field contains the a, b, c and d coefficients.
    The e and f coefficients come from the individual elements,
    together they form the transform matrix for the glyph.

    Glyphs are referenced by glyph ID.
    The Unicode text equivalent is kept in a separate array
    with indexes into the glyph array.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    x = property(_mupdf.fz_text_item_x_get, _mupdf.fz_text_item_x_set)
    y = property(_mupdf.fz_text_item_y_get, _mupdf.fz_text_item_y_set)
    gid = property(_mupdf.fz_text_item_gid_get, _mupdf.fz_text_item_gid_set)
    ucs = property(_mupdf.fz_text_item_ucs_get, _mupdf.fz_text_item_ucs_set)
    cid = property(_mupdf.fz_text_item_cid_get, _mupdf.fz_text_item_cid_set)

    def __init__(self):
        _mupdf.fz_text_item_swiginit(self, _mupdf.new_fz_text_item())
    __swig_destroy__ = _mupdf.delete_fz_text_item

# Register fz_text_item in _mupdf:
_mupdf.fz_text_item_swigregister(fz_text_item)
fz_default_stroke_state = cvar.fz_default_stroke_state

FZ_LANG_UNSET = _mupdf.FZ_LANG_UNSET
FZ_LANG_ur = _mupdf.FZ_LANG_ur
FZ_LANG_urd = _mupdf.FZ_LANG_urd
FZ_LANG_ko = _mupdf.FZ_LANG_ko
FZ_LANG_ja = _mupdf.FZ_LANG_ja
FZ_LANG_zh = _mupdf.FZ_LANG_zh
FZ_LANG_zh_Hans = _mupdf.FZ_LANG_zh_Hans
FZ_LANG_zh_Hant = _mupdf.FZ_LANG_zh_Hant
class fz_text_span(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    font = property(_mupdf.fz_text_span_font_get, _mupdf.fz_text_span_font_set)
    trm = property(_mupdf.fz_text_span_trm_get, _mupdf.fz_text_span_trm_set)
    wmode = property(_mupdf.fz_text_span_wmode_get, _mupdf.fz_text_span_wmode_set)
    bidi_level = property(_mupdf.fz_text_span_bidi_level_get, _mupdf.fz_text_span_bidi_level_set)
    markup_dir = property(_mupdf.fz_text_span_markup_dir_get, _mupdf.fz_text_span_markup_dir_set)
    language = property(_mupdf.fz_text_span_language_get, _mupdf.fz_text_span_language_set)
    len = property(_mupdf.fz_text_span_len_get, _mupdf.fz_text_span_len_set)
    cap = property(_mupdf.fz_text_span_cap_get, _mupdf.fz_text_span_cap_set)
    items = property(_mupdf.fz_text_span_items_get, _mupdf.fz_text_span_items_set)
    next = property(_mupdf.fz_text_span_next_get, _mupdf.fz_text_span_next_set)

    def __init__(self):
        _mupdf.fz_text_span_swiginit(self, _mupdf.new_fz_text_span())
    __swig_destroy__ = _mupdf.delete_fz_text_span

# Register fz_text_span in _mupdf:
_mupdf.fz_text_span_swigregister(fz_text_span)
class fz_text(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    refs = property(_mupdf.fz_text_refs_get, _mupdf.fz_text_refs_set)
    head = property(_mupdf.fz_text_head_get, _mupdf.fz_text_head_set)
    tail = property(_mupdf.fz_text_tail_get, _mupdf.fz_text_tail_set)

    def __init__(self):
        _mupdf.fz_text_swiginit(self, _mupdf.new_fz_text())
    __swig_destroy__ = _mupdf.delete_fz_text

# Register fz_text in _mupdf:
_mupdf.fz_text_swigregister(fz_text)
FZ_DEVFLAG_MASK = _mupdf.FZ_DEVFLAG_MASK
FZ_DEVFLAG_COLOR = _mupdf.FZ_DEVFLAG_COLOR
FZ_DEVFLAG_UNCACHEABLE = _mupdf.FZ_DEVFLAG_UNCACHEABLE
FZ_DEVFLAG_FILLCOLOR_UNDEFINED = _mupdf.FZ_DEVFLAG_FILLCOLOR_UNDEFINED
FZ_DEVFLAG_STROKECOLOR_UNDEFINED = _mupdf.FZ_DEVFLAG_STROKECOLOR_UNDEFINED
FZ_DEVFLAG_STARTCAP_UNDEFINED = _mupdf.FZ_DEVFLAG_STARTCAP_UNDEFINED
FZ_DEVFLAG_DASHCAP_UNDEFINED = _mupdf.FZ_DEVFLAG_DASHCAP_UNDEFINED
FZ_DEVFLAG_ENDCAP_UNDEFINED = _mupdf.FZ_DEVFLAG_ENDCAP_UNDEFINED
FZ_DEVFLAG_LINEJOIN_UNDEFINED = _mupdf.FZ_DEVFLAG_LINEJOIN_UNDEFINED
FZ_DEVFLAG_MITERLIMIT_UNDEFINED = _mupdf.FZ_DEVFLAG_MITERLIMIT_UNDEFINED
FZ_DEVFLAG_LINEWIDTH_UNDEFINED = _mupdf.FZ_DEVFLAG_LINEWIDTH_UNDEFINED
FZ_DEVFLAG_BBOX_DEFINED = _mupdf.FZ_DEVFLAG_BBOX_DEFINED
FZ_DEVFLAG_GRIDFIT_AS_TILED = _mupdf.FZ_DEVFLAG_GRIDFIT_AS_TILED
FZ_BLEND_NORMAL = _mupdf.FZ_BLEND_NORMAL
FZ_BLEND_MULTIPLY = _mupdf.FZ_BLEND_MULTIPLY
FZ_BLEND_SCREEN = _mupdf.FZ_BLEND_SCREEN
FZ_BLEND_OVERLAY = _mupdf.FZ_BLEND_OVERLAY
FZ_BLEND_DARKEN = _mupdf.FZ_BLEND_DARKEN
FZ_BLEND_LIGHTEN = _mupdf.FZ_BLEND_LIGHTEN
FZ_BLEND_COLOR_DODGE = _mupdf.FZ_BLEND_COLOR_DODGE
FZ_BLEND_COLOR_BURN = _mupdf.FZ_BLEND_COLOR_BURN
FZ_BLEND_HARD_LIGHT = _mupdf.FZ_BLEND_HARD_LIGHT
FZ_BLEND_SOFT_LIGHT = _mupdf.FZ_BLEND_SOFT_LIGHT
FZ_BLEND_DIFFERENCE = _mupdf.FZ_BLEND_DIFFERENCE
FZ_BLEND_EXCLUSION = _mupdf.FZ_BLEND_EXCLUSION
FZ_BLEND_HUE = _mupdf.FZ_BLEND_HUE
FZ_BLEND_SATURATION = _mupdf.FZ_BLEND_SATURATION
FZ_BLEND_COLOR = _mupdf.FZ_BLEND_COLOR
FZ_BLEND_LUMINOSITY = _mupdf.FZ_BLEND_LUMINOSITY
FZ_BLEND_MODEMASK = _mupdf.FZ_BLEND_MODEMASK
FZ_BLEND_ISOLATED = _mupdf.FZ_BLEND_ISOLATED
FZ_BLEND_KNOCKOUT = _mupdf.FZ_BLEND_KNOCKOUT
FZ_FUNCTION_MAX_N = _mupdf.FZ_FUNCTION_MAX_N
FZ_FUNCTION_MAX_M = _mupdf.FZ_FUNCTION_MAX_M
class fz_function(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    storable = property(_mupdf.fz_function_storable_get, _mupdf.fz_function_storable_set)
    size = property(_mupdf.fz_function_size_get, _mupdf.fz_function_size_set)
    m = property(_mupdf.fz_function_m_get, _mupdf.fz_function_m_set)
    n = property(_mupdf.fz_function_n_get, _mupdf.fz_function_n_set)
    eval = property(_mupdf.fz_function_eval_get, _mupdf.fz_function_eval_set)

    def __init__(self):
        _mupdf.fz_function_swiginit(self, _mupdf.new_fz_function())
    __swig_destroy__ = _mupdf.delete_fz_function

# Register fz_function in _mupdf:
_mupdf.fz_function_swigregister(fz_function)
class fz_device_container_stack(object):
    r"""
    The device structure is public to allow devices to be
    implemented outside of fitz.

    Device methods should always be called using e.g.
    fz_fill_path(ctx, dev, ...) rather than
    dev->fill_path(ctx, dev, ...)

    Devices can keep track of containers (clips/masks/groups/tiles)
    as they go to save callers having to do it.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    scissor = property(_mupdf.fz_device_container_stack_scissor_get, _mupdf.fz_device_container_stack_scissor_set)
    type = property(_mupdf.fz_device_container_stack_type_get, _mupdf.fz_device_container_stack_type_set)
    user = property(_mupdf.fz_device_container_stack_user_get, _mupdf.fz_device_container_stack_user_set)

    def __init__(self):
        _mupdf.fz_device_container_stack_swiginit(self, _mupdf.new_fz_device_container_stack())
    __swig_destroy__ = _mupdf.delete_fz_device_container_stack

# Register fz_device_container_stack in _mupdf:
_mupdf.fz_device_container_stack_swigregister(fz_device_container_stack)
fz_device_container_stack_is_clip = _mupdf.fz_device_container_stack_is_clip
fz_device_container_stack_is_mask = _mupdf.fz_device_container_stack_is_mask
fz_device_container_stack_is_group = _mupdf.fz_device_container_stack_is_group
fz_device_container_stack_is_tile = _mupdf.fz_device_container_stack_is_tile
FZ_STRUCTURE_INVALID = _mupdf.FZ_STRUCTURE_INVALID
FZ_STRUCTURE_DOCUMENT = _mupdf.FZ_STRUCTURE_DOCUMENT
FZ_STRUCTURE_PART = _mupdf.FZ_STRUCTURE_PART
FZ_STRUCTURE_ART = _mupdf.FZ_STRUCTURE_ART
FZ_STRUCTURE_SECT = _mupdf.FZ_STRUCTURE_SECT
FZ_STRUCTURE_DIV = _mupdf.FZ_STRUCTURE_DIV
FZ_STRUCTURE_BLOCKQUOTE = _mupdf.FZ_STRUCTURE_BLOCKQUOTE
FZ_STRUCTURE_CAPTION = _mupdf.FZ_STRUCTURE_CAPTION
FZ_STRUCTURE_TOC = _mupdf.FZ_STRUCTURE_TOC
FZ_STRUCTURE_TOCI = _mupdf.FZ_STRUCTURE_TOCI
FZ_STRUCTURE_INDEX = _mupdf.FZ_STRUCTURE_INDEX
FZ_STRUCTURE_NONSTRUCT = _mupdf.FZ_STRUCTURE_NONSTRUCT
FZ_STRUCTURE_PRIVATE = _mupdf.FZ_STRUCTURE_PRIVATE
FZ_STRUCTURE_DOCUMENTFRAGMENT = _mupdf.FZ_STRUCTURE_DOCUMENTFRAGMENT
FZ_STRUCTURE_ASIDE = _mupdf.FZ_STRUCTURE_ASIDE
FZ_STRUCTURE_TITLE = _mupdf.FZ_STRUCTURE_TITLE
FZ_STRUCTURE_FENOTE = _mupdf.FZ_STRUCTURE_FENOTE
FZ_STRUCTURE_SUB = _mupdf.FZ_STRUCTURE_SUB
FZ_STRUCTURE_P = _mupdf.FZ_STRUCTURE_P
FZ_STRUCTURE_H = _mupdf.FZ_STRUCTURE_H
FZ_STRUCTURE_H1 = _mupdf.FZ_STRUCTURE_H1
FZ_STRUCTURE_H2 = _mupdf.FZ_STRUCTURE_H2
FZ_STRUCTURE_H3 = _mupdf.FZ_STRUCTURE_H3
FZ_STRUCTURE_H4 = _mupdf.FZ_STRUCTURE_H4
FZ_STRUCTURE_H5 = _mupdf.FZ_STRUCTURE_H5
FZ_STRUCTURE_H6 = _mupdf.FZ_STRUCTURE_H6
FZ_STRUCTURE_LIST = _mupdf.FZ_STRUCTURE_LIST
FZ_STRUCTURE_LISTITEM = _mupdf.FZ_STRUCTURE_LISTITEM
FZ_STRUCTURE_LABEL = _mupdf.FZ_STRUCTURE_LABEL
FZ_STRUCTURE_LISTBODY = _mupdf.FZ_STRUCTURE_LISTBODY
FZ_STRUCTURE_TABLE = _mupdf.FZ_STRUCTURE_TABLE
FZ_STRUCTURE_TR = _mupdf.FZ_STRUCTURE_TR
FZ_STRUCTURE_TH = _mupdf.FZ_STRUCTURE_TH
FZ_STRUCTURE_TD = _mupdf.FZ_STRUCTURE_TD
FZ_STRUCTURE_THEAD = _mupdf.FZ_STRUCTURE_THEAD
FZ_STRUCTURE_TBODY = _mupdf.FZ_STRUCTURE_TBODY
FZ_STRUCTURE_TFOOT = _mupdf.FZ_STRUCTURE_TFOOT
FZ_STRUCTURE_SPAN = _mupdf.FZ_STRUCTURE_SPAN
FZ_STRUCTURE_QUOTE = _mupdf.FZ_STRUCTURE_QUOTE
FZ_STRUCTURE_NOTE = _mupdf.FZ_STRUCTURE_NOTE
FZ_STRUCTURE_REFERENCE = _mupdf.FZ_STRUCTURE_REFERENCE
FZ_STRUCTURE_BIBENTRY = _mupdf.FZ_STRUCTURE_BIBENTRY
FZ_STRUCTURE_CODE = _mupdf.FZ_STRUCTURE_CODE
FZ_STRUCTURE_LINK = _mupdf.FZ_STRUCTURE_LINK
FZ_STRUCTURE_ANNOT = _mupdf.FZ_STRUCTURE_ANNOT
FZ_STRUCTURE_EM = _mupdf.FZ_STRUCTURE_EM
FZ_STRUCTURE_STRONG = _mupdf.FZ_STRUCTURE_STRONG
FZ_STRUCTURE_RUBY = _mupdf.FZ_STRUCTURE_RUBY
FZ_STRUCTURE_RB = _mupdf.FZ_STRUCTURE_RB
FZ_STRUCTURE_RT = _mupdf.FZ_STRUCTURE_RT
FZ_STRUCTURE_RP = _mupdf.FZ_STRUCTURE_RP
FZ_STRUCTURE_WARICHU = _mupdf.FZ_STRUCTURE_WARICHU
FZ_STRUCTURE_WT = _mupdf.FZ_STRUCTURE_WT
FZ_STRUCTURE_WP = _mupdf.FZ_STRUCTURE_WP
FZ_STRUCTURE_FIGURE = _mupdf.FZ_STRUCTURE_FIGURE
FZ_STRUCTURE_FORMULA = _mupdf.FZ_STRUCTURE_FORMULA
FZ_STRUCTURE_FORM = _mupdf.FZ_STRUCTURE_FORM
FZ_STRUCTURE_ARTIFACT = _mupdf.FZ_STRUCTURE_ARTIFACT
FZ_METATEXT_ACTUALTEXT = _mupdf.FZ_METATEXT_ACTUALTEXT
FZ_METATEXT_ALT = _mupdf.FZ_METATEXT_ALT
FZ_METATEXT_ABBREVIATION = _mupdf.FZ_METATEXT_ABBREVIATION
FZ_METATEXT_TITLE = _mupdf.FZ_METATEXT_TITLE
class fz_device(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    refs = property(_mupdf.fz_device_refs_get, _mupdf.fz_device_refs_set)
    hints = property(_mupdf.fz_device_hints_get, _mupdf.fz_device_hints_set)
    flags = property(_mupdf.fz_device_flags_get, _mupdf.fz_device_flags_set)
    close_device = property(_mupdf.fz_device_close_device_get, _mupdf.fz_device_close_device_set)
    drop_device = property(_mupdf.fz_device_drop_device_get, _mupdf.fz_device_drop_device_set)
    fill_path = property(_mupdf.fz_device_fill_path_get, _mupdf.fz_device_fill_path_set)
    stroke_path = property(_mupdf.fz_device_stroke_path_get, _mupdf.fz_device_stroke_path_set)
    clip_path = property(_mupdf.fz_device_clip_path_get, _mupdf.fz_device_clip_path_set)
    clip_stroke_path = property(_mupdf.fz_device_clip_stroke_path_get, _mupdf.fz_device_clip_stroke_path_set)
    fill_text = property(_mupdf.fz_device_fill_text_get, _mupdf.fz_device_fill_text_set)
    stroke_text = property(_mupdf.fz_device_stroke_text_get, _mupdf.fz_device_stroke_text_set)
    clip_text = property(_mupdf.fz_device_clip_text_get, _mupdf.fz_device_clip_text_set)
    clip_stroke_text = property(_mupdf.fz_device_clip_stroke_text_get, _mupdf.fz_device_clip_stroke_text_set)
    ignore_text = property(_mupdf.fz_device_ignore_text_get, _mupdf.fz_device_ignore_text_set)
    fill_shade = property(_mupdf.fz_device_fill_shade_get, _mupdf.fz_device_fill_shade_set)
    fill_image = property(_mupdf.fz_device_fill_image_get, _mupdf.fz_device_fill_image_set)
    fill_image_mask = property(_mupdf.fz_device_fill_image_mask_get, _mupdf.fz_device_fill_image_mask_set)
    clip_image_mask = property(_mupdf.fz_device_clip_image_mask_get, _mupdf.fz_device_clip_image_mask_set)
    pop_clip = property(_mupdf.fz_device_pop_clip_get, _mupdf.fz_device_pop_clip_set)
    begin_mask = property(_mupdf.fz_device_begin_mask_get, _mupdf.fz_device_begin_mask_set)
    end_mask = property(_mupdf.fz_device_end_mask_get, _mupdf.fz_device_end_mask_set)
    begin_group = property(_mupdf.fz_device_begin_group_get, _mupdf.fz_device_begin_group_set)
    end_group = property(_mupdf.fz_device_end_group_get, _mupdf.fz_device_end_group_set)
    begin_tile = property(_mupdf.fz_device_begin_tile_get, _mupdf.fz_device_begin_tile_set)
    end_tile = property(_mupdf.fz_device_end_tile_get, _mupdf.fz_device_end_tile_set)
    render_flags = property(_mupdf.fz_device_render_flags_get, _mupdf.fz_device_render_flags_set)
    set_default_colorspaces = property(_mupdf.fz_device_set_default_colorspaces_get, _mupdf.fz_device_set_default_colorspaces_set)
    begin_layer = property(_mupdf.fz_device_begin_layer_get, _mupdf.fz_device_begin_layer_set)
    end_layer = property(_mupdf.fz_device_end_layer_get, _mupdf.fz_device_end_layer_set)
    begin_structure = property(_mupdf.fz_device_begin_structure_get, _mupdf.fz_device_begin_structure_set)
    end_structure = property(_mupdf.fz_device_end_structure_get, _mupdf.fz_device_end_structure_set)
    begin_metatext = property(_mupdf.fz_device_begin_metatext_get, _mupdf.fz_device_begin_metatext_set)
    end_metatext = property(_mupdf.fz_device_end_metatext_get, _mupdf.fz_device_end_metatext_set)
    d1_rect = property(_mupdf.fz_device_d1_rect_get, _mupdf.fz_device_d1_rect_set)
    container_len = property(_mupdf.fz_device_container_len_get, _mupdf.fz_device_container_len_set)
    container_cap = property(_mupdf.fz_device_container_cap_get, _mupdf.fz_device_container_cap_set)
    container = property(_mupdf.fz_device_container_get, _mupdf.fz_device_container_set)

    def __init__(self):
        _mupdf.fz_device_swiginit(self, _mupdf.new_fz_device())
    __swig_destroy__ = _mupdf.delete_fz_device

# Register fz_device in _mupdf:
_mupdf.fz_device_swigregister(fz_device)
FZ_DONT_INTERPOLATE_IMAGES = _mupdf.FZ_DONT_INTERPOLATE_IMAGES
FZ_NO_CACHE = _mupdf.FZ_NO_CACHE
FZ_DONT_DECODE_IMAGES = _mupdf.FZ_DONT_DECODE_IMAGES
class fz_cookie(object):
    r"""
    Cookie support - simple communication channel between app/library.

    Provide two-way communication between application and library.
    Intended for multi-threaded applications where one thread is
    rendering pages and another thread wants to read progress
    feedback or abort a job that takes a long time to finish. The
    communication is unsynchronized without locking.

    abort: The application should set this field to 0 before
    calling fz_run_page to render a page. At any point when the
    page is being rendered the application my set this field to 1
    which will cause the rendering to finish soon. This field is
    checked periodically when the page is rendered, but exactly
    when is not known, therefore there is no upper bound on
    exactly when the rendering will abort. If the application
    did not provide a set of locks to fz_new_context, it must also
    await the completion of fz_run_page before issuing another
    call to fz_run_page. Note that once the application has set
    this field to 1 after it called fz_run_page it may not change
    the value again.

    progress: Communicates rendering progress back to the
    application and is read only. Increments as a page is being
    rendered. The value starts out at 0 and is limited to less
    than or equal to progress_max, unless progress_max is -1.

    progress_max: Communicates the known upper bound of rendering
    back to the application and is read only. The maximum value
    that the progress field may take. If there is no known upper
    bound on how long the rendering may take this value is -1 and
    progress is not limited. Note that the value of progress_max
    may change from -1 to a positive value once an upper bound is
    known, so take this into consideration when comparing the
    value of progress to that of progress_max.

    errors: count of errors during current rendering.

    incomplete: Initially should be set to 0. Will be set to
    non-zero if a TRYLATER error is thrown during rendering.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    abort = property(_mupdf.fz_cookie_abort_get, _mupdf.fz_cookie_abort_set)
    progress = property(_mupdf.fz_cookie_progress_get, _mupdf.fz_cookie_progress_set)
    progress_max = property(_mupdf.fz_cookie_progress_max_get, _mupdf.fz_cookie_progress_max_set)
    errors = property(_mupdf.fz_cookie_errors_get, _mupdf.fz_cookie_errors_set)
    incomplete = property(_mupdf.fz_cookie_incomplete_get, _mupdf.fz_cookie_incomplete_set)

    def __init__(self):
        _mupdf.fz_cookie_swiginit(self, _mupdf.new_fz_cookie())
    __swig_destroy__ = _mupdf.delete_fz_cookie

# Register fz_cookie in _mupdf:
_mupdf.fz_cookie_swigregister(fz_cookie)
FZ_TEST_OPT_IMAGES = _mupdf.FZ_TEST_OPT_IMAGES
FZ_TEST_OPT_SHADINGS = _mupdf.FZ_TEST_OPT_SHADINGS
class fz_draw_options(object):
    r"""
    struct fz_draw_options: Options for creating a pixmap and draw
    device.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    rotate = property(_mupdf.fz_draw_options_rotate_get, _mupdf.fz_draw_options_rotate_set)
    x_resolution = property(_mupdf.fz_draw_options_x_resolution_get, _mupdf.fz_draw_options_x_resolution_set)
    y_resolution = property(_mupdf.fz_draw_options_y_resolution_get, _mupdf.fz_draw_options_y_resolution_set)
    width = property(_mupdf.fz_draw_options_width_get, _mupdf.fz_draw_options_width_set)
    height = property(_mupdf.fz_draw_options_height_get, _mupdf.fz_draw_options_height_set)
    colorspace = property(_mupdf.fz_draw_options_colorspace_get, _mupdf.fz_draw_options_colorspace_set)
    alpha = property(_mupdf.fz_draw_options_alpha_get, _mupdf.fz_draw_options_alpha_set)
    graphics = property(_mupdf.fz_draw_options_graphics_get, _mupdf.fz_draw_options_graphics_set)
    text = property(_mupdf.fz_draw_options_text_get, _mupdf.fz_draw_options_text_set)

    def __init__(self):
        _mupdf.fz_draw_options_swiginit(self, _mupdf.new_fz_draw_options())
    __swig_destroy__ = _mupdf.delete_fz_draw_options

# Register fz_draw_options in _mupdf:
_mupdf.fz_draw_options_swigregister(fz_draw_options)
class fz_location(object):
    r"""
    Locations within the document are referred to in terms of
    chapter and page, rather than just a page number. For some
    documents (such as epub documents with large numbers of pages
    broken into many chapters) this can make navigation much faster
    as only the required chapter needs to be decoded at a time.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    chapter = property(_mupdf.fz_location_chapter_get, _mupdf.fz_location_chapter_set)
    page = property(_mupdf.fz_location_page_get, _mupdf.fz_location_page_set)

    def __init__(self):
        _mupdf.fz_location_swiginit(self, _mupdf.new_fz_location())
    __swig_destroy__ = _mupdf.delete_fz_location

# Register fz_location in _mupdf:
_mupdf.fz_location_swigregister(fz_location)
class fz_layout_char(object):
    r"""	Simple text layout (for use with annotation editing primarily)."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    x = property(_mupdf.fz_layout_char_x_get, _mupdf.fz_layout_char_x_set)
    advance = property(_mupdf.fz_layout_char_advance_get, _mupdf.fz_layout_char_advance_set)
    p = property(_mupdf.fz_layout_char_p_get, _mupdf.fz_layout_char_p_set)
    next = property(_mupdf.fz_layout_char_next_get, _mupdf.fz_layout_char_next_set)

    def __init__(self):
        _mupdf.fz_layout_char_swiginit(self, _mupdf.new_fz_layout_char())
    __swig_destroy__ = _mupdf.delete_fz_layout_char

# Register fz_layout_char in _mupdf:
_mupdf.fz_layout_char_swigregister(fz_layout_char)
class fz_layout_line(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    x = property(_mupdf.fz_layout_line_x_get, _mupdf.fz_layout_line_x_set)
    y = property(_mupdf.fz_layout_line_y_get, _mupdf.fz_layout_line_y_set)
    font_size = property(_mupdf.fz_layout_line_font_size_get, _mupdf.fz_layout_line_font_size_set)
    p = property(_mupdf.fz_layout_line_p_get, _mupdf.fz_layout_line_p_set)
    text = property(_mupdf.fz_layout_line_text_get, _mupdf.fz_layout_line_text_set)
    next = property(_mupdf.fz_layout_line_next_get, _mupdf.fz_layout_line_next_set)

    def __init__(self):
        _mupdf.fz_layout_line_swiginit(self, _mupdf.new_fz_layout_line())
    __swig_destroy__ = _mupdf.delete_fz_layout_line

# Register fz_layout_line in _mupdf:
_mupdf.fz_layout_line_swigregister(fz_layout_line)
class fz_layout_block(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    pool = property(_mupdf.fz_layout_block_pool_get, _mupdf.fz_layout_block_pool_set)
    matrix = property(_mupdf.fz_layout_block_matrix_get, _mupdf.fz_layout_block_matrix_set)
    inv_matrix = property(_mupdf.fz_layout_block_inv_matrix_get, _mupdf.fz_layout_block_inv_matrix_set)
    head = property(_mupdf.fz_layout_block_head_get, _mupdf.fz_layout_block_head_set)
    tailp = property(_mupdf.fz_layout_block_tailp_get, _mupdf.fz_layout_block_tailp_set)
    text_tailp = property(_mupdf.fz_layout_block_text_tailp_get, _mupdf.fz_layout_block_text_tailp_set)

    def __init__(self):
        _mupdf.fz_layout_block_swiginit(self, _mupdf.new_fz_layout_block())
    __swig_destroy__ = _mupdf.delete_fz_layout_block

# Register fz_layout_block in _mupdf:
_mupdf.fz_layout_block_swigregister(fz_layout_block)
FZ_STEXT_PRESERVE_LIGATURES = _mupdf.FZ_STEXT_PRESERVE_LIGATURES
FZ_STEXT_PRESERVE_WHITESPACE = _mupdf.FZ_STEXT_PRESERVE_WHITESPACE
FZ_STEXT_PRESERVE_IMAGES = _mupdf.FZ_STEXT_PRESERVE_IMAGES
FZ_STEXT_INHIBIT_SPACES = _mupdf.FZ_STEXT_INHIBIT_SPACES
FZ_STEXT_DEHYPHENATE = _mupdf.FZ_STEXT_DEHYPHENATE
FZ_STEXT_PRESERVE_SPANS = _mupdf.FZ_STEXT_PRESERVE_SPANS
FZ_STEXT_MEDIABOX_CLIP = _mupdf.FZ_STEXT_MEDIABOX_CLIP
FZ_STEXT_USE_CID_FOR_UNKNOWN_UNICODE = _mupdf.FZ_STEXT_USE_CID_FOR_UNKNOWN_UNICODE
class fz_stext_page(object):
    r"""
    A text page is a list of blocks, together with an overall
    bounding box.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    pool = property(_mupdf.fz_stext_page_pool_get, _mupdf.fz_stext_page_pool_set)
    mediabox = property(_mupdf.fz_stext_page_mediabox_get, _mupdf.fz_stext_page_mediabox_set)
    first_block = property(_mupdf.fz_stext_page_first_block_get, _mupdf.fz_stext_page_first_block_set)
    last_block = property(_mupdf.fz_stext_page_last_block_get, _mupdf.fz_stext_page_last_block_set)

    def __init__(self):
        _mupdf.fz_stext_page_swiginit(self, _mupdf.new_fz_stext_page())
    __swig_destroy__ = _mupdf.delete_fz_stext_page

# Register fz_stext_page in _mupdf:
_mupdf.fz_stext_page_swigregister(fz_stext_page)
FZ_STEXT_BLOCK_TEXT = _mupdf.FZ_STEXT_BLOCK_TEXT
FZ_STEXT_BLOCK_IMAGE = _mupdf.FZ_STEXT_BLOCK_IMAGE
class fz_stext_block(object):
    r"""
    A text block is a list of lines of text (typically a paragraph),
    or an image.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    type = property(_mupdf.fz_stext_block_type_get, _mupdf.fz_stext_block_type_set)
    bbox = property(_mupdf.fz_stext_block_bbox_get, _mupdf.fz_stext_block_bbox_set)
    prev = property(_mupdf.fz_stext_block_prev_get, _mupdf.fz_stext_block_prev_set)
    next = property(_mupdf.fz_stext_block_next_get, _mupdf.fz_stext_block_next_set)

    def __init__(self):
        _mupdf.fz_stext_block_swiginit(self, _mupdf.new_fz_stext_block())
    __swig_destroy__ = _mupdf.delete_fz_stext_block

# Register fz_stext_block in _mupdf:
_mupdf.fz_stext_block_swigregister(fz_stext_block)
class fz_stext_line(object):
    r"""	A text line is a list of characters that share a common baseline."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    wmode = property(_mupdf.fz_stext_line_wmode_get, _mupdf.fz_stext_line_wmode_set)
    dir = property(_mupdf.fz_stext_line_dir_get, _mupdf.fz_stext_line_dir_set)
    bbox = property(_mupdf.fz_stext_line_bbox_get, _mupdf.fz_stext_line_bbox_set)
    first_char = property(_mupdf.fz_stext_line_first_char_get, _mupdf.fz_stext_line_first_char_set)
    last_char = property(_mupdf.fz_stext_line_last_char_get, _mupdf.fz_stext_line_last_char_set)
    prev = property(_mupdf.fz_stext_line_prev_get, _mupdf.fz_stext_line_prev_set)
    next = property(_mupdf.fz_stext_line_next_get, _mupdf.fz_stext_line_next_set)

    def __init__(self):
        _mupdf.fz_stext_line_swiginit(self, _mupdf.new_fz_stext_line())
    __swig_destroy__ = _mupdf.delete_fz_stext_line

# Register fz_stext_line in _mupdf:
_mupdf.fz_stext_line_swigregister(fz_stext_line)
class fz_stext_char(object):
    r"""
    A text char is a unicode character, the style in which is
    appears, and the point at which it is positioned.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    c = property(_mupdf.fz_stext_char_c_get, _mupdf.fz_stext_char_c_set)
    bidi = property(_mupdf.fz_stext_char_bidi_get, _mupdf.fz_stext_char_bidi_set)
    color = property(_mupdf.fz_stext_char_color_get, _mupdf.fz_stext_char_color_set)
    origin = property(_mupdf.fz_stext_char_origin_get, _mupdf.fz_stext_char_origin_set)
    quad = property(_mupdf.fz_stext_char_quad_get, _mupdf.fz_stext_char_quad_set)
    size = property(_mupdf.fz_stext_char_size_get, _mupdf.fz_stext_char_size_set)
    font = property(_mupdf.fz_stext_char_font_get, _mupdf.fz_stext_char_font_set)
    next = property(_mupdf.fz_stext_char_next_get, _mupdf.fz_stext_char_next_set)

    def __init__(self):
        _mupdf.fz_stext_char_swiginit(self, _mupdf.new_fz_stext_char())
    __swig_destroy__ = _mupdf.delete_fz_stext_char

# Register fz_stext_char in _mupdf:
_mupdf.fz_stext_char_swigregister(fz_stext_char)
FZ_SELECT_CHARS = _mupdf.FZ_SELECT_CHARS
FZ_SELECT_WORDS = _mupdf.FZ_SELECT_WORDS
FZ_SELECT_LINES = _mupdf.FZ_SELECT_LINES
class fz_stext_options(object):
    r"""	Options for creating structured text."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    flags = property(_mupdf.fz_stext_options_flags_get, _mupdf.fz_stext_options_flags_set)
    scale = property(_mupdf.fz_stext_options_scale_get, _mupdf.fz_stext_options_scale_set)

    def __init__(self):
        _mupdf.fz_stext_options_swiginit(self, _mupdf.new_fz_stext_options())
    __swig_destroy__ = _mupdf.delete_fz_stext_options

# Register fz_stext_options in _mupdf:
_mupdf.fz_stext_options_swigregister(fz_stext_options)
FZ_TRANSITION_NONE = _mupdf.FZ_TRANSITION_NONE
FZ_TRANSITION_SPLIT = _mupdf.FZ_TRANSITION_SPLIT
FZ_TRANSITION_BLINDS = _mupdf.FZ_TRANSITION_BLINDS
FZ_TRANSITION_BOX = _mupdf.FZ_TRANSITION_BOX
FZ_TRANSITION_WIPE = _mupdf.FZ_TRANSITION_WIPE
FZ_TRANSITION_DISSOLVE = _mupdf.FZ_TRANSITION_DISSOLVE
FZ_TRANSITION_GLITTER = _mupdf.FZ_TRANSITION_GLITTER
FZ_TRANSITION_FLY = _mupdf.FZ_TRANSITION_FLY
FZ_TRANSITION_PUSH = _mupdf.FZ_TRANSITION_PUSH
FZ_TRANSITION_COVER = _mupdf.FZ_TRANSITION_COVER
FZ_TRANSITION_UNCOVER = _mupdf.FZ_TRANSITION_UNCOVER
FZ_TRANSITION_FADE = _mupdf.FZ_TRANSITION_FADE
class fz_transition(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    type = property(_mupdf.fz_transition_type_get, _mupdf.fz_transition_type_set)
    duration = property(_mupdf.fz_transition_duration_get, _mupdf.fz_transition_duration_set)
    vertical = property(_mupdf.fz_transition_vertical_get, _mupdf.fz_transition_vertical_set)
    outwards = property(_mupdf.fz_transition_outwards_get, _mupdf.fz_transition_outwards_set)
    direction = property(_mupdf.fz_transition_direction_get, _mupdf.fz_transition_direction_set)
    state0 = property(_mupdf.fz_transition_state0_get, _mupdf.fz_transition_state0_set)
    state1 = property(_mupdf.fz_transition_state1_get, _mupdf.fz_transition_state1_set)

    def __init__(self):
        _mupdf.fz_transition_swiginit(self, _mupdf.new_fz_transition())
    __swig_destroy__ = _mupdf.delete_fz_transition

# Register fz_transition in _mupdf:
_mupdf.fz_transition_swigregister(fz_transition)
class fz_link(object):
    r"""
    fz_link is a list of interactive links on a page.

    There is no relation between the order of the links in the
    list and the order they appear on the page. The list of links
    for a given page can be obtained from fz_load_links.

    A link is reference counted. Dropping a reference to a link is
    done by calling fz_drop_link.

    rect: The hot zone. The area that can be clicked in
    untransformed coordinates.

    uri: Link destinations come in two forms: internal and external.
    Internal links refer to other pages in the same document.
    External links are URLs to other documents.

    next: A pointer to the next link on the same page.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    refs = property(_mupdf.fz_link_refs_get, _mupdf.fz_link_refs_set)
    next = property(_mupdf.fz_link_next_get, _mupdf.fz_link_next_set)
    rect = property(_mupdf.fz_link_rect_get, _mupdf.fz_link_rect_set)
    uri = property(_mupdf.fz_link_uri_get, _mupdf.fz_link_uri_set)
    set_rect_fn = property(_mupdf.fz_link_set_rect_fn_get, _mupdf.fz_link_set_rect_fn_set)
    set_uri_fn = property(_mupdf.fz_link_set_uri_fn_get, _mupdf.fz_link_set_uri_fn_set)
    drop = property(_mupdf.fz_link_drop_get, _mupdf.fz_link_drop_set)

    def __init__(self):
        _mupdf.fz_link_swiginit(self, _mupdf.new_fz_link())
    __swig_destroy__ = _mupdf.delete_fz_link

# Register fz_link in _mupdf:
_mupdf.fz_link_swigregister(fz_link)
FZ_LINK_DEST_FIT = _mupdf.FZ_LINK_DEST_FIT
FZ_LINK_DEST_FIT_B = _mupdf.FZ_LINK_DEST_FIT_B
FZ_LINK_DEST_FIT_H = _mupdf.FZ_LINK_DEST_FIT_H
FZ_LINK_DEST_FIT_BH = _mupdf.FZ_LINK_DEST_FIT_BH
FZ_LINK_DEST_FIT_V = _mupdf.FZ_LINK_DEST_FIT_V
FZ_LINK_DEST_FIT_BV = _mupdf.FZ_LINK_DEST_FIT_BV
FZ_LINK_DEST_FIT_R = _mupdf.FZ_LINK_DEST_FIT_R
FZ_LINK_DEST_XYZ = _mupdf.FZ_LINK_DEST_XYZ
class fz_link_dest(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    loc = property(_mupdf.fz_link_dest_loc_get, _mupdf.fz_link_dest_loc_set)
    type = property(_mupdf.fz_link_dest_type_get, _mupdf.fz_link_dest_type_set)
    x = property(_mupdf.fz_link_dest_x_get, _mupdf.fz_link_dest_x_set)
    y = property(_mupdf.fz_link_dest_y_get, _mupdf.fz_link_dest_y_set)
    w = property(_mupdf.fz_link_dest_w_get, _mupdf.fz_link_dest_w_set)
    h = property(_mupdf.fz_link_dest_h_get, _mupdf.fz_link_dest_h_set)
    zoom = property(_mupdf.fz_link_dest_zoom_get, _mupdf.fz_link_dest_zoom_set)

    def __init__(self):
        _mupdf.fz_link_dest_swiginit(self, _mupdf.new_fz_link_dest())
    __swig_destroy__ = _mupdf.delete_fz_link_dest

# Register fz_link_dest in _mupdf:
_mupdf.fz_link_dest_swigregister(fz_link_dest)
class fz_outline_item(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    title = property(_mupdf.fz_outline_item_title_get, _mupdf.fz_outline_item_title_set)
    uri = property(_mupdf.fz_outline_item_uri_get, _mupdf.fz_outline_item_uri_set)
    is_open = property(_mupdf.fz_outline_item_is_open_get, _mupdf.fz_outline_item_is_open_set)

    def __init__(self):
        _mupdf.fz_outline_item_swiginit(self, _mupdf.new_fz_outline_item())
    __swig_destroy__ = _mupdf.delete_fz_outline_item

# Register fz_outline_item in _mupdf:
_mupdf.fz_outline_item_swigregister(fz_outline_item)
class fz_outline(object):
    r"""
    Structure based API
    fz_outline is a tree of the outline of a document (also known
    as table of contents).

    title: Title of outline item using UTF-8 encoding. May be NULL
    if the outline item has no text string.

    uri: Destination in the document to be displayed when this
    outline item is activated. May be an internal or external
    link, or NULL if the outline item does not have a destination.

    page: The page number of an internal link, or -1 for external
    links or links with no destination.

    next: The next outline item at the same level as this outline
    item. May be NULL if no more outline items exist at this level.

    down: The outline items immediate children in the hierarchy.
    May be NULL if no children exist.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    refs = property(_mupdf.fz_outline_refs_get, _mupdf.fz_outline_refs_set)
    title = property(_mupdf.fz_outline_title_get, _mupdf.fz_outline_title_set)
    uri = property(_mupdf.fz_outline_uri_get, _mupdf.fz_outline_uri_set)
    page = property(_mupdf.fz_outline_page_get, _mupdf.fz_outline_page_set)
    x = property(_mupdf.fz_outline_x_get, _mupdf.fz_outline_x_set)
    y = property(_mupdf.fz_outline_y_get, _mupdf.fz_outline_y_set)
    next = property(_mupdf.fz_outline_next_get, _mupdf.fz_outline_next_set)
    down = property(_mupdf.fz_outline_down_get, _mupdf.fz_outline_down_set)
    is_open = property(_mupdf.fz_outline_is_open_get, _mupdf.fz_outline_is_open_set)

    def __init__(self):
        _mupdf.fz_outline_swiginit(self, _mupdf.new_fz_outline())
    __swig_destroy__ = _mupdf.delete_fz_outline

# Register fz_outline in _mupdf:
_mupdf.fz_outline_swigregister(fz_outline)
class fz_outline_iterator(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    drop = property(_mupdf.fz_outline_iterator_drop_get, _mupdf.fz_outline_iterator_drop_set)
    item = property(_mupdf.fz_outline_iterator_item_get, _mupdf.fz_outline_iterator_item_set)
    next = property(_mupdf.fz_outline_iterator_next_get, _mupdf.fz_outline_iterator_next_set)
    prev = property(_mupdf.fz_outline_iterator_prev_get, _mupdf.fz_outline_iterator_prev_set)
    up = property(_mupdf.fz_outline_iterator_up_get, _mupdf.fz_outline_iterator_up_set)
    down = property(_mupdf.fz_outline_iterator_down_get, _mupdf.fz_outline_iterator_down_set)
    insert = property(_mupdf.fz_outline_iterator_insert_get, _mupdf.fz_outline_iterator_insert_set)
    update = property(_mupdf.fz_outline_iterator_update_get, _mupdf.fz_outline_iterator_update_set)
    _del = property(_mupdf.fz_outline_iterator__del_get, _mupdf.fz_outline_iterator__del_set)
    doc = property(_mupdf.fz_outline_iterator_doc_get, _mupdf.fz_outline_iterator_doc_set)

    def __init__(self):
        _mupdf.fz_outline_iterator_swiginit(self, _mupdf.new_fz_outline_iterator())
    __swig_destroy__ = _mupdf.delete_fz_outline_iterator

# Register fz_outline_iterator in _mupdf:
_mupdf.fz_outline_iterator_swigregister(fz_outline_iterator)
FZ_MEDIA_BOX = _mupdf.FZ_MEDIA_BOX
FZ_CROP_BOX = _mupdf.FZ_CROP_BOX
FZ_BLEED_BOX = _mupdf.FZ_BLEED_BOX
FZ_TRIM_BOX = _mupdf.FZ_TRIM_BOX
FZ_ART_BOX = _mupdf.FZ_ART_BOX
FZ_UNKNOWN_BOX = _mupdf.FZ_UNKNOWN_BOX
FZ_LAYOUT_KINDLE_W = _mupdf.FZ_LAYOUT_KINDLE_W
FZ_LAYOUT_KINDLE_H = _mupdf.FZ_LAYOUT_KINDLE_H
FZ_LAYOUT_KINDLE_EM = _mupdf.FZ_LAYOUT_KINDLE_EM
FZ_LAYOUT_US_POCKET_W = _mupdf.FZ_LAYOUT_US_POCKET_W
FZ_LAYOUT_US_POCKET_H = _mupdf.FZ_LAYOUT_US_POCKET_H
FZ_LAYOUT_US_POCKET_EM = _mupdf.FZ_LAYOUT_US_POCKET_EM
FZ_LAYOUT_US_TRADE_W = _mupdf.FZ_LAYOUT_US_TRADE_W
FZ_LAYOUT_US_TRADE_H = _mupdf.FZ_LAYOUT_US_TRADE_H
FZ_LAYOUT_US_TRADE_EM = _mupdf.FZ_LAYOUT_US_TRADE_EM
FZ_LAYOUT_UK_A_FORMAT_W = _mupdf.FZ_LAYOUT_UK_A_FORMAT_W
FZ_LAYOUT_UK_A_FORMAT_H = _mupdf.FZ_LAYOUT_UK_A_FORMAT_H
FZ_LAYOUT_UK_A_FORMAT_EM = _mupdf.FZ_LAYOUT_UK_A_FORMAT_EM
FZ_LAYOUT_UK_B_FORMAT_W = _mupdf.FZ_LAYOUT_UK_B_FORMAT_W
FZ_LAYOUT_UK_B_FORMAT_H = _mupdf.FZ_LAYOUT_UK_B_FORMAT_H
FZ_LAYOUT_UK_B_FORMAT_EM = _mupdf.FZ_LAYOUT_UK_B_FORMAT_EM
FZ_LAYOUT_UK_C_FORMAT_W = _mupdf.FZ_LAYOUT_UK_C_FORMAT_W
FZ_LAYOUT_UK_C_FORMAT_H = _mupdf.FZ_LAYOUT_UK_C_FORMAT_H
FZ_LAYOUT_UK_C_FORMAT_EM = _mupdf.FZ_LAYOUT_UK_C_FORMAT_EM
FZ_LAYOUT_A5_W = _mupdf.FZ_LAYOUT_A5_W
FZ_LAYOUT_A5_H = _mupdf.FZ_LAYOUT_A5_H
FZ_LAYOUT_A5_EM = _mupdf.FZ_LAYOUT_A5_EM
FZ_DEFAULT_LAYOUT_W = _mupdf.FZ_DEFAULT_LAYOUT_W
FZ_DEFAULT_LAYOUT_H = _mupdf.FZ_DEFAULT_LAYOUT_H
FZ_DEFAULT_LAYOUT_EM = _mupdf.FZ_DEFAULT_LAYOUT_EM
FZ_PERMISSION_PRINT = _mupdf.FZ_PERMISSION_PRINT
FZ_PERMISSION_COPY = _mupdf.FZ_PERMISSION_COPY
FZ_PERMISSION_EDIT = _mupdf.FZ_PERMISSION_EDIT
FZ_PERMISSION_ANNOTATE = _mupdf.FZ_PERMISSION_ANNOTATE
FZ_PERMISSION_FORM = _mupdf.FZ_PERMISSION_FORM
FZ_PERMISSION_ACCESSIBILITY = _mupdf.FZ_PERMISSION_ACCESSIBILITY
FZ_PERMISSION_ASSEMBLE = _mupdf.FZ_PERMISSION_ASSEMBLE
FZ_PERMISSION_PRINT_HQ = _mupdf.FZ_PERMISSION_PRINT_HQ
FZ_META_FORMAT = _mupdf.FZ_META_FORMAT
FZ_META_ENCRYPTION = _mupdf.FZ_META_ENCRYPTION
FZ_META_INFO = _mupdf.FZ_META_INFO
FZ_META_INFO_TITLE = _mupdf.FZ_META_INFO_TITLE
FZ_META_INFO_AUTHOR = _mupdf.FZ_META_INFO_AUTHOR
FZ_META_INFO_SUBJECT = _mupdf.FZ_META_INFO_SUBJECT
FZ_META_INFO_KEYWORDS = _mupdf.FZ_META_INFO_KEYWORDS
FZ_META_INFO_CREATOR = _mupdf.FZ_META_INFO_CREATOR
FZ_META_INFO_PRODUCER = _mupdf.FZ_META_INFO_PRODUCER
FZ_META_INFO_CREATIONDATE = _mupdf.FZ_META_INFO_CREATIONDATE
FZ_META_INFO_MODIFICATIONDATE = _mupdf.FZ_META_INFO_MODIFICATIONDATE
class fz_page(object):
    r"""
    Structure definition is public so other classes can
    derive from it. Do not access the members directly.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    refs = property(_mupdf.fz_page_refs_get, _mupdf.fz_page_refs_set)
    doc = property(_mupdf.fz_page_doc_get, _mupdf.fz_page_doc_set)
    chapter = property(_mupdf.fz_page_chapter_get, _mupdf.fz_page_chapter_set)
    number = property(_mupdf.fz_page_number_get, _mupdf.fz_page_number_set)
    incomplete = property(_mupdf.fz_page_incomplete_get, _mupdf.fz_page_incomplete_set)
    drop_page = property(_mupdf.fz_page_drop_page_get, _mupdf.fz_page_drop_page_set)
    bound_page = property(_mupdf.fz_page_bound_page_get, _mupdf.fz_page_bound_page_set)
    run_page_contents = property(_mupdf.fz_page_run_page_contents_get, _mupdf.fz_page_run_page_contents_set)
    run_page_annots = property(_mupdf.fz_page_run_page_annots_get, _mupdf.fz_page_run_page_annots_set)
    run_page_widgets = property(_mupdf.fz_page_run_page_widgets_get, _mupdf.fz_page_run_page_widgets_set)
    load_links = property(_mupdf.fz_page_load_links_get, _mupdf.fz_page_load_links_set)
    page_presentation = property(_mupdf.fz_page_page_presentation_get, _mupdf.fz_page_page_presentation_set)
    control_separation = property(_mupdf.fz_page_control_separation_get, _mupdf.fz_page_control_separation_set)
    separation_disabled = property(_mupdf.fz_page_separation_disabled_get, _mupdf.fz_page_separation_disabled_set)
    separations = property(_mupdf.fz_page_separations_get, _mupdf.fz_page_separations_set)
    overprint = property(_mupdf.fz_page_overprint_get, _mupdf.fz_page_overprint_set)
    create_link = property(_mupdf.fz_page_create_link_get, _mupdf.fz_page_create_link_set)
    delete_link = property(_mupdf.fz_page_delete_link_get, _mupdf.fz_page_delete_link_set)
    prev = property(_mupdf.fz_page_prev_get, _mupdf.fz_page_prev_set)
    next = property(_mupdf.fz_page_next_get, _mupdf.fz_page_next_set)

    def __init__(self):
        _mupdf.fz_page_swiginit(self, _mupdf.new_fz_page())
    __swig_destroy__ = _mupdf.delete_fz_page

# Register fz_page in _mupdf:
_mupdf.fz_page_swigregister(fz_page)
class fz_document(object):
    r"""
    Structure definition is public so other classes can
    derive from it. Callers should not access the members
    directly, though implementations will need initialize
    functions directly.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    refs = property(_mupdf.fz_document_refs_get, _mupdf.fz_document_refs_set)
    drop_document = property(_mupdf.fz_document_drop_document_get, _mupdf.fz_document_drop_document_set)
    needs_password = property(_mupdf.fz_document_needs_password_get, _mupdf.fz_document_needs_password_set)
    authenticate_password = property(_mupdf.fz_document_authenticate_password_get, _mupdf.fz_document_authenticate_password_set)
    has_permission = property(_mupdf.fz_document_has_permission_get, _mupdf.fz_document_has_permission_set)
    load_outline = property(_mupdf.fz_document_load_outline_get, _mupdf.fz_document_load_outline_set)
    outline_iterator = property(_mupdf.fz_document_outline_iterator_get, _mupdf.fz_document_outline_iterator_set)
    layout = property(_mupdf.fz_document_layout_get, _mupdf.fz_document_layout_set)
    make_bookmark = property(_mupdf.fz_document_make_bookmark_get, _mupdf.fz_document_make_bookmark_set)
    lookup_bookmark = property(_mupdf.fz_document_lookup_bookmark_get, _mupdf.fz_document_lookup_bookmark_set)
    resolve_link_dest = property(_mupdf.fz_document_resolve_link_dest_get, _mupdf.fz_document_resolve_link_dest_set)
    format_link_uri = property(_mupdf.fz_document_format_link_uri_get, _mupdf.fz_document_format_link_uri_set)
    count_chapters = property(_mupdf.fz_document_count_chapters_get, _mupdf.fz_document_count_chapters_set)
    count_pages = property(_mupdf.fz_document_count_pages_get, _mupdf.fz_document_count_pages_set)
    load_page = property(_mupdf.fz_document_load_page_get, _mupdf.fz_document_load_page_set)
    page_label = property(_mupdf.fz_document_page_label_get, _mupdf.fz_document_page_label_set)
    lookup_metadata = property(_mupdf.fz_document_lookup_metadata_get, _mupdf.fz_document_lookup_metadata_set)
    set_metadata = property(_mupdf.fz_document_set_metadata_get, _mupdf.fz_document_set_metadata_set)
    get_output_intent = property(_mupdf.fz_document_get_output_intent_get, _mupdf.fz_document_get_output_intent_set)
    output_accelerator = property(_mupdf.fz_document_output_accelerator_get, _mupdf.fz_document_output_accelerator_set)
    run_structure = property(_mupdf.fz_document_run_structure_get, _mupdf.fz_document_run_structure_set)
    did_layout = property(_mupdf.fz_document_did_layout_get, _mupdf.fz_document_did_layout_set)
    is_reflowable = property(_mupdf.fz_document_is_reflowable_get, _mupdf.fz_document_is_reflowable_set)
    open = property(_mupdf.fz_document_open_get, _mupdf.fz_document_open_set)

    def __init__(self):
        _mupdf.fz_document_swiginit(self, _mupdf.new_fz_document())
    __swig_destroy__ = _mupdf.delete_fz_document

# Register fz_document in _mupdf:
_mupdf.fz_document_swigregister(fz_document)
class fz_document_handler(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    recognize = property(_mupdf.fz_document_handler_recognize_get, _mupdf.fz_document_handler_recognize_set)
    open = property(_mupdf.fz_document_handler_open_get, _mupdf.fz_document_handler_open_set)
    extensions = property(_mupdf.fz_document_handler_extensions_get, _mupdf.fz_document_handler_extensions_set)
    mimetypes = property(_mupdf.fz_document_handler_mimetypes_get, _mupdf.fz_document_handler_mimetypes_set)
    recognize_content = property(_mupdf.fz_document_handler_recognize_content_get, _mupdf.fz_document_handler_recognize_content_set)

    def __init__(self):
        _mupdf.fz_document_handler_swiginit(self, _mupdf.new_fz_document_handler())
    __swig_destroy__ = _mupdf.delete_fz_document_handler

# Register fz_document_handler in _mupdf:
_mupdf.fz_document_handler_swigregister(fz_document_handler)
class fz_document_writer(object):
    r"""
    Structure is public to allow other structures to
    be derived from it. Do not access members directly.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    begin_page = property(_mupdf.fz_document_writer_begin_page_get, _mupdf.fz_document_writer_begin_page_set)
    end_page = property(_mupdf.fz_document_writer_end_page_get, _mupdf.fz_document_writer_end_page_set)
    close_writer = property(_mupdf.fz_document_writer_close_writer_get, _mupdf.fz_document_writer_close_writer_set)
    drop_writer = property(_mupdf.fz_document_writer_drop_writer_get, _mupdf.fz_document_writer_drop_writer_set)
    dev = property(_mupdf.fz_document_writer_dev_get, _mupdf.fz_document_writer_dev_set)

    def __init__(self):
        _mupdf.fz_document_writer_swiginit(self, _mupdf.new_fz_document_writer())
    __swig_destroy__ = _mupdf.delete_fz_document_writer

# Register fz_document_writer in _mupdf:
_mupdf.fz_document_writer_swigregister(fz_document_writer)
class fz_band_writer(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    drop = property(_mupdf.fz_band_writer_drop_get, _mupdf.fz_band_writer_drop_set)
    close = property(_mupdf.fz_band_writer_close_get, _mupdf.fz_band_writer_close_set)
    header = property(_mupdf.fz_band_writer_header_get, _mupdf.fz_band_writer_header_set)
    band = property(_mupdf.fz_band_writer_band_get, _mupdf.fz_band_writer_band_set)
    trailer = property(_mupdf.fz_band_writer_trailer_get, _mupdf.fz_band_writer_trailer_set)
    out = property(_mupdf.fz_band_writer_out_get, _mupdf.fz_band_writer_out_set)
    w = property(_mupdf.fz_band_writer_w_get, _mupdf.fz_band_writer_w_set)
    h = property(_mupdf.fz_band_writer_h_get, _mupdf.fz_band_writer_h_set)
    n = property(_mupdf.fz_band_writer_n_get, _mupdf.fz_band_writer_n_set)
    s = property(_mupdf.fz_band_writer_s_get, _mupdf.fz_band_writer_s_set)
    alpha = property(_mupdf.fz_band_writer_alpha_get, _mupdf.fz_band_writer_alpha_set)
    xres = property(_mupdf.fz_band_writer_xres_get, _mupdf.fz_band_writer_xres_set)
    yres = property(_mupdf.fz_band_writer_yres_get, _mupdf.fz_band_writer_yres_set)
    pagenum = property(_mupdf.fz_band_writer_pagenum_get, _mupdf.fz_band_writer_pagenum_set)
    line = property(_mupdf.fz_band_writer_line_get, _mupdf.fz_band_writer_line_set)
    seps = property(_mupdf.fz_band_writer_seps_get, _mupdf.fz_band_writer_seps_set)

    def __init__(self):
        _mupdf.fz_band_writer_swiginit(self, _mupdf.new_fz_band_writer())
    __swig_destroy__ = _mupdf.delete_fz_band_writer

# Register fz_band_writer in _mupdf:
_mupdf.fz_band_writer_swigregister(fz_band_writer)
class fz_pcl_options(object):
    r"""	PCL output"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    features = property(_mupdf.fz_pcl_options_features_get, _mupdf.fz_pcl_options_features_set)
    odd_page_init = property(_mupdf.fz_pcl_options_odd_page_init_get, _mupdf.fz_pcl_options_odd_page_init_set)
    even_page_init = property(_mupdf.fz_pcl_options_even_page_init_get, _mupdf.fz_pcl_options_even_page_init_set)
    tumble = property(_mupdf.fz_pcl_options_tumble_get, _mupdf.fz_pcl_options_tumble_set)
    duplex_set = property(_mupdf.fz_pcl_options_duplex_set_get, _mupdf.fz_pcl_options_duplex_set_set)
    duplex = property(_mupdf.fz_pcl_options_duplex_get, _mupdf.fz_pcl_options_duplex_set)
    paper_size = property(_mupdf.fz_pcl_options_paper_size_get, _mupdf.fz_pcl_options_paper_size_set)
    manual_feed_set = property(_mupdf.fz_pcl_options_manual_feed_set_get, _mupdf.fz_pcl_options_manual_feed_set_set)
    manual_feed = property(_mupdf.fz_pcl_options_manual_feed_get, _mupdf.fz_pcl_options_manual_feed_set)
    media_position_set = property(_mupdf.fz_pcl_options_media_position_set_get, _mupdf.fz_pcl_options_media_position_set_set)
    media_position = property(_mupdf.fz_pcl_options_media_position_get, _mupdf.fz_pcl_options_media_position_set)
    orientation = property(_mupdf.fz_pcl_options_orientation_get, _mupdf.fz_pcl_options_orientation_set)
    page_count = property(_mupdf.fz_pcl_options_page_count_get, _mupdf.fz_pcl_options_page_count_set)

    def __init__(self):
        _mupdf.fz_pcl_options_swiginit(self, _mupdf.new_fz_pcl_options())
    __swig_destroy__ = _mupdf.delete_fz_pcl_options

# Register fz_pcl_options in _mupdf:
_mupdf.fz_pcl_options_swigregister(fz_pcl_options)
class fz_pclm_options(object):
    r"""	PCLm output"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    compress = property(_mupdf.fz_pclm_options_compress_get, _mupdf.fz_pclm_options_compress_set)
    strip_height = property(_mupdf.fz_pclm_options_strip_height_get, _mupdf.fz_pclm_options_strip_height_set)
    page_count = property(_mupdf.fz_pclm_options_page_count_get, _mupdf.fz_pclm_options_page_count_set)

    def __init__(self):
        _mupdf.fz_pclm_options_swiginit(self, _mupdf.new_fz_pclm_options())
    __swig_destroy__ = _mupdf.delete_fz_pclm_options

# Register fz_pclm_options in _mupdf:
_mupdf.fz_pclm_options_swigregister(fz_pclm_options)
class fz_pdfocr_options(object):
    r"""	PDFOCR output"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    compress = property(_mupdf.fz_pdfocr_options_compress_get, _mupdf.fz_pdfocr_options_compress_set)
    strip_height = property(_mupdf.fz_pdfocr_options_strip_height_get, _mupdf.fz_pdfocr_options_strip_height_set)
    language = property(_mupdf.fz_pdfocr_options_language_get, _mupdf.fz_pdfocr_options_language_set)
    datadir = property(_mupdf.fz_pdfocr_options_datadir_get, _mupdf.fz_pdfocr_options_datadir_set)
    page_count = property(_mupdf.fz_pdfocr_options_page_count_get, _mupdf.fz_pdfocr_options_page_count_set)

    def __init__(self):
        _mupdf.fz_pdfocr_options_swiginit(self, _mupdf.new_fz_pdfocr_options())
    __swig_destroy__ = _mupdf.delete_fz_pdfocr_options

# Register fz_pdfocr_options in _mupdf:
_mupdf.fz_pdfocr_options_swigregister(fz_pdfocr_options)
class fz_pwg_options(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    media_class = property(_mupdf.fz_pwg_options_media_class_get, _mupdf.fz_pwg_options_media_class_set)
    media_color = property(_mupdf.fz_pwg_options_media_color_get, _mupdf.fz_pwg_options_media_color_set)
    media_type = property(_mupdf.fz_pwg_options_media_type_get, _mupdf.fz_pwg_options_media_type_set)
    output_type = property(_mupdf.fz_pwg_options_output_type_get, _mupdf.fz_pwg_options_output_type_set)
    advance_distance = property(_mupdf.fz_pwg_options_advance_distance_get, _mupdf.fz_pwg_options_advance_distance_set)
    advance_media = property(_mupdf.fz_pwg_options_advance_media_get, _mupdf.fz_pwg_options_advance_media_set)
    collate = property(_mupdf.fz_pwg_options_collate_get, _mupdf.fz_pwg_options_collate_set)
    cut_media = property(_mupdf.fz_pwg_options_cut_media_get, _mupdf.fz_pwg_options_cut_media_set)
    duplex = property(_mupdf.fz_pwg_options_duplex_get, _mupdf.fz_pwg_options_duplex_set)
    insert_sheet = property(_mupdf.fz_pwg_options_insert_sheet_get, _mupdf.fz_pwg_options_insert_sheet_set)
    jog = property(_mupdf.fz_pwg_options_jog_get, _mupdf.fz_pwg_options_jog_set)
    leading_edge = property(_mupdf.fz_pwg_options_leading_edge_get, _mupdf.fz_pwg_options_leading_edge_set)
    manual_feed = property(_mupdf.fz_pwg_options_manual_feed_get, _mupdf.fz_pwg_options_manual_feed_set)
    media_position = property(_mupdf.fz_pwg_options_media_position_get, _mupdf.fz_pwg_options_media_position_set)
    media_weight = property(_mupdf.fz_pwg_options_media_weight_get, _mupdf.fz_pwg_options_media_weight_set)
    mirror_print = property(_mupdf.fz_pwg_options_mirror_print_get, _mupdf.fz_pwg_options_mirror_print_set)
    negative_print = property(_mupdf.fz_pwg_options_negative_print_get, _mupdf.fz_pwg_options_negative_print_set)
    num_copies = property(_mupdf.fz_pwg_options_num_copies_get, _mupdf.fz_pwg_options_num_copies_set)
    orientation = property(_mupdf.fz_pwg_options_orientation_get, _mupdf.fz_pwg_options_orientation_set)
    output_face_up = property(_mupdf.fz_pwg_options_output_face_up_get, _mupdf.fz_pwg_options_output_face_up_set)
    PageSize = property(_mupdf.fz_pwg_options_PageSize_get, _mupdf.fz_pwg_options_PageSize_set)
    separations = property(_mupdf.fz_pwg_options_separations_get, _mupdf.fz_pwg_options_separations_set)
    tray_switch = property(_mupdf.fz_pwg_options_tray_switch_get, _mupdf.fz_pwg_options_tray_switch_set)
    tumble = property(_mupdf.fz_pwg_options_tumble_get, _mupdf.fz_pwg_options_tumble_set)
    media_type_num = property(_mupdf.fz_pwg_options_media_type_num_get, _mupdf.fz_pwg_options_media_type_num_set)
    compression = property(_mupdf.fz_pwg_options_compression_get, _mupdf.fz_pwg_options_compression_set)
    row_count = property(_mupdf.fz_pwg_options_row_count_get, _mupdf.fz_pwg_options_row_count_set)
    row_feed = property(_mupdf.fz_pwg_options_row_feed_get, _mupdf.fz_pwg_options_row_feed_set)
    row_step = property(_mupdf.fz_pwg_options_row_step_get, _mupdf.fz_pwg_options_row_step_set)
    rendering_intent = property(_mupdf.fz_pwg_options_rendering_intent_get, _mupdf.fz_pwg_options_rendering_intent_set)
    page_size_name = property(_mupdf.fz_pwg_options_page_size_name_get, _mupdf.fz_pwg_options_page_size_name_set)

    def __init__(self):
        _mupdf.fz_pwg_options_swiginit(self, _mupdf.new_fz_pwg_options())
    __swig_destroy__ = _mupdf.delete_fz_pwg_options

# Register fz_pwg_options in _mupdf:
_mupdf.fz_pwg_options_swigregister(fz_pwg_options)
FZ_SVG_TEXT_AS_PATH = _mupdf.FZ_SVG_TEXT_AS_PATH
FZ_SVG_TEXT_AS_TEXT = _mupdf.FZ_SVG_TEXT_AS_TEXT
FZ_PLACE_STORY_FLAG_NO_OVERFLOW = _mupdf.FZ_PLACE_STORY_FLAG_NO_OVERFLOW
FZ_PLACE_STORY_RETURN_ALL_FITTED = _mupdf.FZ_PLACE_STORY_RETURN_ALL_FITTED
FZ_PLACE_STORY_RETURN_OVERFLOW_WIDTH = _mupdf.FZ_PLACE_STORY_RETURN_OVERFLOW_WIDTH
class fz_story_element_position(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    depth = property(_mupdf.fz_story_element_position_depth_get, _mupdf.fz_story_element_position_depth_set)
    heading = property(_mupdf.fz_story_element_position_heading_get, _mupdf.fz_story_element_position_heading_set)
    id = property(_mupdf.fz_story_element_position_id_get, _mupdf.fz_story_element_position_id_set)
    href = property(_mupdf.fz_story_element_position_href_get, _mupdf.fz_story_element_position_href_set)
    rect = property(_mupdf.fz_story_element_position_rect_get, _mupdf.fz_story_element_position_rect_set)
    text = property(_mupdf.fz_story_element_position_text_get, _mupdf.fz_story_element_position_text_set)
    open_close = property(_mupdf.fz_story_element_position_open_close_get, _mupdf.fz_story_element_position_open_close_set)
    rectangle_num = property(_mupdf.fz_story_element_position_rectangle_num_get, _mupdf.fz_story_element_position_rectangle_num_set)

    def __init__(self):
        _mupdf.fz_story_element_position_swiginit(self, _mupdf.new_fz_story_element_position())
    __swig_destroy__ = _mupdf.delete_fz_story_element_position

# Register fz_story_element_position in _mupdf:
_mupdf.fz_story_element_position_swigregister(fz_story_element_position)
class fz_write_story_position(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    element = property(_mupdf.fz_write_story_position_element_get, _mupdf.fz_write_story_position_element_set)
    page_num = property(_mupdf.fz_write_story_position_page_num_get, _mupdf.fz_write_story_position_page_num_set)

    def __init__(self):
        _mupdf.fz_write_story_position_swiginit(self, _mupdf.new_fz_write_story_position())
    __swig_destroy__ = _mupdf.delete_fz_write_story_position

# Register fz_write_story_position in _mupdf:
_mupdf.fz_write_story_position_swigregister(fz_write_story_position)
class fz_write_story_positions(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    positions = property(_mupdf.fz_write_story_positions_positions_get, _mupdf.fz_write_story_positions_positions_set)
    num = property(_mupdf.fz_write_story_positions_num_get, _mupdf.fz_write_story_positions_num_set)

    def __init__(self):
        _mupdf.fz_write_story_positions_swiginit(self, _mupdf.new_fz_write_story_positions())
    __swig_destroy__ = _mupdf.delete_fz_write_story_positions

# Register fz_write_story_positions in _mupdf:
_mupdf.fz_write_story_positions_swigregister(fz_write_story_positions)
PDF_MAX_OBJECT_NUMBER = _mupdf.PDF_MAX_OBJECT_NUMBER
PDF_MAX_GEN_NUMBER = _mupdf.PDF_MAX_GEN_NUMBER
class pdf_cycle_list(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    up = property(_mupdf.pdf_cycle_list_up_get, _mupdf.pdf_cycle_list_up_set)
    num = property(_mupdf.pdf_cycle_list_num_get, _mupdf.pdf_cycle_list_num_set)

    def __init__(self):
        _mupdf.pdf_cycle_list_swiginit(self, _mupdf.new_pdf_cycle_list())
    __swig_destroy__ = _mupdf.delete_pdf_cycle_list

# Register pdf_cycle_list in _mupdf:
_mupdf.pdf_cycle_list_swigregister(pdf_cycle_list)
class pdf_mark_bits(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    len = property(_mupdf.pdf_mark_bits_len_get, _mupdf.pdf_mark_bits_len_set)
    bits = property(_mupdf.pdf_mark_bits_bits_get, _mupdf.pdf_mark_bits_bits_set)

    def __init__(self):
        _mupdf.pdf_mark_bits_swiginit(self, _mupdf.new_pdf_mark_bits())
    __swig_destroy__ = _mupdf.delete_pdf_mark_bits

# Register pdf_mark_bits in _mupdf:
_mupdf.pdf_mark_bits_swigregister(pdf_mark_bits)
class pdf_mark_list(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    len = property(_mupdf.pdf_mark_list_len_get, _mupdf.pdf_mark_list_len_set)
    max = property(_mupdf.pdf_mark_list_max_get, _mupdf.pdf_mark_list_max_set)
    list = property(_mupdf.pdf_mark_list_list_get, _mupdf.pdf_mark_list_list_set)
    local_list = property(_mupdf.pdf_mark_list_local_list_get, _mupdf.pdf_mark_list_local_list_set)

    def __init__(self):
        _mupdf.pdf_mark_list_swiginit(self, _mupdf.new_pdf_mark_list())
    __swig_destroy__ = _mupdf.delete_pdf_mark_list

# Register pdf_mark_list in _mupdf:
_mupdf.pdf_mark_list_swigregister(pdf_mark_list)
PDF_ENUM_NULL = _mupdf.PDF_ENUM_NULL
PDF_ENUM_TRUE = _mupdf.PDF_ENUM_TRUE
PDF_ENUM_FALSE = _mupdf.PDF_ENUM_FALSE
PDF_ENUM_NAME_1_2 = _mupdf.PDF_ENUM_NAME_1_2
PDF_ENUM_NAME_1_5 = _mupdf.PDF_ENUM_NAME_1_5
PDF_ENUM_NAME_3D = _mupdf.PDF_ENUM_NAME_3D
PDF_ENUM_NAME_A = _mupdf.PDF_ENUM_NAME_A
PDF_ENUM_NAME_A85 = _mupdf.PDF_ENUM_NAME_A85
PDF_ENUM_NAME_AA = _mupdf.PDF_ENUM_NAME_AA
PDF_ENUM_NAME_AC = _mupdf.PDF_ENUM_NAME_AC
PDF_ENUM_NAME_AESV2 = _mupdf.PDF_ENUM_NAME_AESV2
PDF_ENUM_NAME_AESV3 = _mupdf.PDF_ENUM_NAME_AESV3
PDF_ENUM_NAME_AHx = _mupdf.PDF_ENUM_NAME_AHx
PDF_ENUM_NAME_AP = _mupdf.PDF_ENUM_NAME_AP
PDF_ENUM_NAME_AS = _mupdf.PDF_ENUM_NAME_AS
PDF_ENUM_NAME_ASCII85Decode = _mupdf.PDF_ENUM_NAME_ASCII85Decode
PDF_ENUM_NAME_ASCIIHexDecode = _mupdf.PDF_ENUM_NAME_ASCIIHexDecode
PDF_ENUM_NAME_AcroForm = _mupdf.PDF_ENUM_NAME_AcroForm
PDF_ENUM_NAME_Action = _mupdf.PDF_ENUM_NAME_Action
PDF_ENUM_NAME_ActualText = _mupdf.PDF_ENUM_NAME_ActualText
PDF_ENUM_NAME_Adobe_PPKLite = _mupdf.PDF_ENUM_NAME_Adobe_PPKLite
PDF_ENUM_NAME_All = _mupdf.PDF_ENUM_NAME_All
PDF_ENUM_NAME_AllOff = _mupdf.PDF_ENUM_NAME_AllOff
PDF_ENUM_NAME_AllOn = _mupdf.PDF_ENUM_NAME_AllOn
PDF_ENUM_NAME_Alpha = _mupdf.PDF_ENUM_NAME_Alpha
PDF_ENUM_NAME_Alt = _mupdf.PDF_ENUM_NAME_Alt
PDF_ENUM_NAME_Alternate = _mupdf.PDF_ENUM_NAME_Alternate
PDF_ENUM_NAME_Annot = _mupdf.PDF_ENUM_NAME_Annot
PDF_ENUM_NAME_Annots = _mupdf.PDF_ENUM_NAME_Annots
PDF_ENUM_NAME_AnyOff = _mupdf.PDF_ENUM_NAME_AnyOff
PDF_ENUM_NAME_App = _mupdf.PDF_ENUM_NAME_App
PDF_ENUM_NAME_Approved = _mupdf.PDF_ENUM_NAME_Approved
PDF_ENUM_NAME_Art = _mupdf.PDF_ENUM_NAME_Art
PDF_ENUM_NAME_ArtBox = _mupdf.PDF_ENUM_NAME_ArtBox
PDF_ENUM_NAME_Artifact = _mupdf.PDF_ENUM_NAME_Artifact
PDF_ENUM_NAME_AsIs = _mupdf.PDF_ENUM_NAME_AsIs
PDF_ENUM_NAME_Ascent = _mupdf.PDF_ENUM_NAME_Ascent
PDF_ENUM_NAME_Aside = _mupdf.PDF_ENUM_NAME_Aside
PDF_ENUM_NAME_AuthEvent = _mupdf.PDF_ENUM_NAME_AuthEvent
PDF_ENUM_NAME_Author = _mupdf.PDF_ENUM_NAME_Author
PDF_ENUM_NAME_B = _mupdf.PDF_ENUM_NAME_B
PDF_ENUM_NAME_BBox = _mupdf.PDF_ENUM_NAME_BBox
PDF_ENUM_NAME_BC = _mupdf.PDF_ENUM_NAME_BC
PDF_ENUM_NAME_BE = _mupdf.PDF_ENUM_NAME_BE
PDF_ENUM_NAME_BG = _mupdf.PDF_ENUM_NAME_BG
PDF_ENUM_NAME_BM = _mupdf.PDF_ENUM_NAME_BM
PDF_ENUM_NAME_BPC = _mupdf.PDF_ENUM_NAME_BPC
PDF_ENUM_NAME_BS = _mupdf.PDF_ENUM_NAME_BS
PDF_ENUM_NAME_Background = _mupdf.PDF_ENUM_NAME_Background
PDF_ENUM_NAME_BaseEncoding = _mupdf.PDF_ENUM_NAME_BaseEncoding
PDF_ENUM_NAME_BaseFont = _mupdf.PDF_ENUM_NAME_BaseFont
PDF_ENUM_NAME_BaseState = _mupdf.PDF_ENUM_NAME_BaseState
PDF_ENUM_NAME_BibEntry = _mupdf.PDF_ENUM_NAME_BibEntry
PDF_ENUM_NAME_BitsPerComponent = _mupdf.PDF_ENUM_NAME_BitsPerComponent
PDF_ENUM_NAME_BitsPerCoordinate = _mupdf.PDF_ENUM_NAME_BitsPerCoordinate
PDF_ENUM_NAME_BitsPerFlag = _mupdf.PDF_ENUM_NAME_BitsPerFlag
PDF_ENUM_NAME_BitsPerSample = _mupdf.PDF_ENUM_NAME_BitsPerSample
PDF_ENUM_NAME_BlackIs1 = _mupdf.PDF_ENUM_NAME_BlackIs1
PDF_ENUM_NAME_BlackPoint = _mupdf.PDF_ENUM_NAME_BlackPoint
PDF_ENUM_NAME_BleedBox = _mupdf.PDF_ENUM_NAME_BleedBox
PDF_ENUM_NAME_Blinds = _mupdf.PDF_ENUM_NAME_Blinds
PDF_ENUM_NAME_BlockQuote = _mupdf.PDF_ENUM_NAME_BlockQuote
PDF_ENUM_NAME_Border = _mupdf.PDF_ENUM_NAME_Border
PDF_ENUM_NAME_Bounds = _mupdf.PDF_ENUM_NAME_Bounds
PDF_ENUM_NAME_Box = _mupdf.PDF_ENUM_NAME_Box
PDF_ENUM_NAME_Bt = _mupdf.PDF_ENUM_NAME_Bt
PDF_ENUM_NAME_Btn = _mupdf.PDF_ENUM_NAME_Btn
PDF_ENUM_NAME_Butt = _mupdf.PDF_ENUM_NAME_Butt
PDF_ENUM_NAME_ByteRange = _mupdf.PDF_ENUM_NAME_ByteRange
PDF_ENUM_NAME_C = _mupdf.PDF_ENUM_NAME_C
PDF_ENUM_NAME_C0 = _mupdf.PDF_ENUM_NAME_C0
PDF_ENUM_NAME_C1 = _mupdf.PDF_ENUM_NAME_C1
PDF_ENUM_NAME_CA = _mupdf.PDF_ENUM_NAME_CA
PDF_ENUM_NAME_CCF = _mupdf.PDF_ENUM_NAME_CCF
PDF_ENUM_NAME_CCITTFaxDecode = _mupdf.PDF_ENUM_NAME_CCITTFaxDecode
PDF_ENUM_NAME_CF = _mupdf.PDF_ENUM_NAME_CF
PDF_ENUM_NAME_CFM = _mupdf.PDF_ENUM_NAME_CFM
PDF_ENUM_NAME_CI = _mupdf.PDF_ENUM_NAME_CI
PDF_ENUM_NAME_CIDFontType0 = _mupdf.PDF_ENUM_NAME_CIDFontType0
PDF_ENUM_NAME_CIDFontType0C = _mupdf.PDF_ENUM_NAME_CIDFontType0C
PDF_ENUM_NAME_CIDFontType2 = _mupdf.PDF_ENUM_NAME_CIDFontType2
PDF_ENUM_NAME_CIDSystemInfo = _mupdf.PDF_ENUM_NAME_CIDSystemInfo
PDF_ENUM_NAME_CIDToGIDMap = _mupdf.PDF_ENUM_NAME_CIDToGIDMap
PDF_ENUM_NAME_CMYK = _mupdf.PDF_ENUM_NAME_CMYK
PDF_ENUM_NAME_CS = _mupdf.PDF_ENUM_NAME_CS
PDF_ENUM_NAME_CalCMYK = _mupdf.PDF_ENUM_NAME_CalCMYK
PDF_ENUM_NAME_CalGray = _mupdf.PDF_ENUM_NAME_CalGray
PDF_ENUM_NAME_CalRGB = _mupdf.PDF_ENUM_NAME_CalRGB
PDF_ENUM_NAME_CapHeight = _mupdf.PDF_ENUM_NAME_CapHeight
PDF_ENUM_NAME_Caption = _mupdf.PDF_ENUM_NAME_Caption
PDF_ENUM_NAME_Caret = _mupdf.PDF_ENUM_NAME_Caret
PDF_ENUM_NAME_Catalog = _mupdf.PDF_ENUM_NAME_Catalog
PDF_ENUM_NAME_Cert = _mupdf.PDF_ENUM_NAME_Cert
PDF_ENUM_NAME_Ch = _mupdf.PDF_ENUM_NAME_Ch
PDF_ENUM_NAME_Changes = _mupdf.PDF_ENUM_NAME_Changes
PDF_ENUM_NAME_CharProcs = _mupdf.PDF_ENUM_NAME_CharProcs
PDF_ENUM_NAME_CheckSum = _mupdf.PDF_ENUM_NAME_CheckSum
PDF_ENUM_NAME_Circle = _mupdf.PDF_ENUM_NAME_Circle
PDF_ENUM_NAME_ClosedArrow = _mupdf.PDF_ENUM_NAME_ClosedArrow
PDF_ENUM_NAME_Code = _mupdf.PDF_ENUM_NAME_Code
PDF_ENUM_NAME_Collection = _mupdf.PDF_ENUM_NAME_Collection
PDF_ENUM_NAME_ColorSpace = _mupdf.PDF_ENUM_NAME_ColorSpace
PDF_ENUM_NAME_ColorTransform = _mupdf.PDF_ENUM_NAME_ColorTransform
PDF_ENUM_NAME_Colorants = _mupdf.PDF_ENUM_NAME_Colorants
PDF_ENUM_NAME_Colors = _mupdf.PDF_ENUM_NAME_Colors
PDF_ENUM_NAME_Columns = _mupdf.PDF_ENUM_NAME_Columns
PDF_ENUM_NAME_Confidential = _mupdf.PDF_ENUM_NAME_Confidential
PDF_ENUM_NAME_Configs = _mupdf.PDF_ENUM_NAME_Configs
PDF_ENUM_NAME_ContactInfo = _mupdf.PDF_ENUM_NAME_ContactInfo
PDF_ENUM_NAME_Contents = _mupdf.PDF_ENUM_NAME_Contents
PDF_ENUM_NAME_Coords = _mupdf.PDF_ENUM_NAME_Coords
PDF_ENUM_NAME_Count = _mupdf.PDF_ENUM_NAME_Count
PDF_ENUM_NAME_Cover = _mupdf.PDF_ENUM_NAME_Cover
PDF_ENUM_NAME_CreationDate = _mupdf.PDF_ENUM_NAME_CreationDate
PDF_ENUM_NAME_Creator = _mupdf.PDF_ENUM_NAME_Creator
PDF_ENUM_NAME_CropBox = _mupdf.PDF_ENUM_NAME_CropBox
PDF_ENUM_NAME_Crypt = _mupdf.PDF_ENUM_NAME_Crypt
PDF_ENUM_NAME_D = _mupdf.PDF_ENUM_NAME_D
PDF_ENUM_NAME_DA = _mupdf.PDF_ENUM_NAME_DA
PDF_ENUM_NAME_DC = _mupdf.PDF_ENUM_NAME_DC
PDF_ENUM_NAME_DCT = _mupdf.PDF_ENUM_NAME_DCT
PDF_ENUM_NAME_DCTDecode = _mupdf.PDF_ENUM_NAME_DCTDecode
PDF_ENUM_NAME_DL = _mupdf.PDF_ENUM_NAME_DL
PDF_ENUM_NAME_DOS = _mupdf.PDF_ENUM_NAME_DOS
PDF_ENUM_NAME_DP = _mupdf.PDF_ENUM_NAME_DP
PDF_ENUM_NAME_DR = _mupdf.PDF_ENUM_NAME_DR
PDF_ENUM_NAME_DS = _mupdf.PDF_ENUM_NAME_DS
PDF_ENUM_NAME_DV = _mupdf.PDF_ENUM_NAME_DV
PDF_ENUM_NAME_DW = _mupdf.PDF_ENUM_NAME_DW
PDF_ENUM_NAME_DW2 = _mupdf.PDF_ENUM_NAME_DW2
PDF_ENUM_NAME_DamagedRowsBeforeError = _mupdf.PDF_ENUM_NAME_DamagedRowsBeforeError
PDF_ENUM_NAME_Data = _mupdf.PDF_ENUM_NAME_Data
PDF_ENUM_NAME_Date = _mupdf.PDF_ENUM_NAME_Date
PDF_ENUM_NAME_Decode = _mupdf.PDF_ENUM_NAME_Decode
PDF_ENUM_NAME_DecodeParms = _mupdf.PDF_ENUM_NAME_DecodeParms
PDF_ENUM_NAME_Default = _mupdf.PDF_ENUM_NAME_Default
PDF_ENUM_NAME_DefaultCMYK = _mupdf.PDF_ENUM_NAME_DefaultCMYK
PDF_ENUM_NAME_DefaultGray = _mupdf.PDF_ENUM_NAME_DefaultGray
PDF_ENUM_NAME_DefaultRGB = _mupdf.PDF_ENUM_NAME_DefaultRGB
PDF_ENUM_NAME_Departmental = _mupdf.PDF_ENUM_NAME_Departmental
PDF_ENUM_NAME_Desc = _mupdf.PDF_ENUM_NAME_Desc
PDF_ENUM_NAME_DescendantFonts = _mupdf.PDF_ENUM_NAME_DescendantFonts
PDF_ENUM_NAME_Descent = _mupdf.PDF_ENUM_NAME_Descent
PDF_ENUM_NAME_Design = _mupdf.PDF_ENUM_NAME_Design
PDF_ENUM_NAME_Dest = _mupdf.PDF_ENUM_NAME_Dest
PDF_ENUM_NAME_DestOutputProfile = _mupdf.PDF_ENUM_NAME_DestOutputProfile
PDF_ENUM_NAME_Dests = _mupdf.PDF_ENUM_NAME_Dests
PDF_ENUM_NAME_DeviceCMYK = _mupdf.PDF_ENUM_NAME_DeviceCMYK
PDF_ENUM_NAME_DeviceGray = _mupdf.PDF_ENUM_NAME_DeviceGray
PDF_ENUM_NAME_DeviceN = _mupdf.PDF_ENUM_NAME_DeviceN
PDF_ENUM_NAME_DeviceRGB = _mupdf.PDF_ENUM_NAME_DeviceRGB
PDF_ENUM_NAME_Di = _mupdf.PDF_ENUM_NAME_Di
PDF_ENUM_NAME_Diamond = _mupdf.PDF_ENUM_NAME_Diamond
PDF_ENUM_NAME_Differences = _mupdf.PDF_ENUM_NAME_Differences
PDF_ENUM_NAME_DigestLocation = _mupdf.PDF_ENUM_NAME_DigestLocation
PDF_ENUM_NAME_DigestMethod = _mupdf.PDF_ENUM_NAME_DigestMethod
PDF_ENUM_NAME_DigestValue = _mupdf.PDF_ENUM_NAME_DigestValue
PDF_ENUM_NAME_Dissolve = _mupdf.PDF_ENUM_NAME_Dissolve
PDF_ENUM_NAME_Div = _mupdf.PDF_ENUM_NAME_Div
PDF_ENUM_NAME_Dm = _mupdf.PDF_ENUM_NAME_Dm
PDF_ENUM_NAME_DocMDP = _mupdf.PDF_ENUM_NAME_DocMDP
PDF_ENUM_NAME_Document = _mupdf.PDF_ENUM_NAME_Document
PDF_ENUM_NAME_DocumentFragment = _mupdf.PDF_ENUM_NAME_DocumentFragment
PDF_ENUM_NAME_Domain = _mupdf.PDF_ENUM_NAME_Domain
PDF_ENUM_NAME_Draft = _mupdf.PDF_ENUM_NAME_Draft
PDF_ENUM_NAME_Dur = _mupdf.PDF_ENUM_NAME_Dur
PDF_ENUM_NAME_E = _mupdf.PDF_ENUM_NAME_E
PDF_ENUM_NAME_EF = _mupdf.PDF_ENUM_NAME_EF
PDF_ENUM_NAME_EarlyChange = _mupdf.PDF_ENUM_NAME_EarlyChange
PDF_ENUM_NAME_Em = _mupdf.PDF_ENUM_NAME_Em
PDF_ENUM_NAME_EmbeddedFile = _mupdf.PDF_ENUM_NAME_EmbeddedFile
PDF_ENUM_NAME_EmbeddedFiles = _mupdf.PDF_ENUM_NAME_EmbeddedFiles
PDF_ENUM_NAME_Encode = _mupdf.PDF_ENUM_NAME_Encode
PDF_ENUM_NAME_EncodedByteAlign = _mupdf.PDF_ENUM_NAME_EncodedByteAlign
PDF_ENUM_NAME_Encoding = _mupdf.PDF_ENUM_NAME_Encoding
PDF_ENUM_NAME_Encrypt = _mupdf.PDF_ENUM_NAME_Encrypt
PDF_ENUM_NAME_EncryptMetadata = _mupdf.PDF_ENUM_NAME_EncryptMetadata
PDF_ENUM_NAME_EndOfBlock = _mupdf.PDF_ENUM_NAME_EndOfBlock
PDF_ENUM_NAME_EndOfLine = _mupdf.PDF_ENUM_NAME_EndOfLine
PDF_ENUM_NAME_Exclude = _mupdf.PDF_ENUM_NAME_Exclude
PDF_ENUM_NAME_Experimental = _mupdf.PDF_ENUM_NAME_Experimental
PDF_ENUM_NAME_Expired = _mupdf.PDF_ENUM_NAME_Expired
PDF_ENUM_NAME_ExtGState = _mupdf.PDF_ENUM_NAME_ExtGState
PDF_ENUM_NAME_Extend = _mupdf.PDF_ENUM_NAME_Extend
PDF_ENUM_NAME_F = _mupdf.PDF_ENUM_NAME_F
PDF_ENUM_NAME_FENote = _mupdf.PDF_ENUM_NAME_FENote
PDF_ENUM_NAME_FL = _mupdf.PDF_ENUM_NAME_FL
PDF_ENUM_NAME_FRM = _mupdf.PDF_ENUM_NAME_FRM
PDF_ENUM_NAME_FS = _mupdf.PDF_ENUM_NAME_FS
PDF_ENUM_NAME_FT = _mupdf.PDF_ENUM_NAME_FT
PDF_ENUM_NAME_Fade = _mupdf.PDF_ENUM_NAME_Fade
PDF_ENUM_NAME_Ff = _mupdf.PDF_ENUM_NAME_Ff
PDF_ENUM_NAME_FieldMDP = _mupdf.PDF_ENUM_NAME_FieldMDP
PDF_ENUM_NAME_Fields = _mupdf.PDF_ENUM_NAME_Fields
PDF_ENUM_NAME_Figure = _mupdf.PDF_ENUM_NAME_Figure
PDF_ENUM_NAME_FileAttachment = _mupdf.PDF_ENUM_NAME_FileAttachment
PDF_ENUM_NAME_FileSize = _mupdf.PDF_ENUM_NAME_FileSize
PDF_ENUM_NAME_Filespec = _mupdf.PDF_ENUM_NAME_Filespec
PDF_ENUM_NAME_Filter = _mupdf.PDF_ENUM_NAME_Filter
PDF_ENUM_NAME_Final = _mupdf.PDF_ENUM_NAME_Final
PDF_ENUM_NAME_Fingerprint = _mupdf.PDF_ENUM_NAME_Fingerprint
PDF_ENUM_NAME_First = _mupdf.PDF_ENUM_NAME_First
PDF_ENUM_NAME_FirstChar = _mupdf.PDF_ENUM_NAME_FirstChar
PDF_ENUM_NAME_FirstPage = _mupdf.PDF_ENUM_NAME_FirstPage
PDF_ENUM_NAME_Fit = _mupdf.PDF_ENUM_NAME_Fit
PDF_ENUM_NAME_FitB = _mupdf.PDF_ENUM_NAME_FitB
PDF_ENUM_NAME_FitBH = _mupdf.PDF_ENUM_NAME_FitBH
PDF_ENUM_NAME_FitBV = _mupdf.PDF_ENUM_NAME_FitBV
PDF_ENUM_NAME_FitH = _mupdf.PDF_ENUM_NAME_FitH
PDF_ENUM_NAME_FitR = _mupdf.PDF_ENUM_NAME_FitR
PDF_ENUM_NAME_FitV = _mupdf.PDF_ENUM_NAME_FitV
PDF_ENUM_NAME_Fl = _mupdf.PDF_ENUM_NAME_Fl
PDF_ENUM_NAME_Flags = _mupdf.PDF_ENUM_NAME_Flags
PDF_ENUM_NAME_FlateDecode = _mupdf.PDF_ENUM_NAME_FlateDecode
PDF_ENUM_NAME_Fly = _mupdf.PDF_ENUM_NAME_Fly
PDF_ENUM_NAME_Font = _mupdf.PDF_ENUM_NAME_Font
PDF_ENUM_NAME_FontBBox = _mupdf.PDF_ENUM_NAME_FontBBox
PDF_ENUM_NAME_FontDescriptor = _mupdf.PDF_ENUM_NAME_FontDescriptor
PDF_ENUM_NAME_FontFile = _mupdf.PDF_ENUM_NAME_FontFile
PDF_ENUM_NAME_FontFile2 = _mupdf.PDF_ENUM_NAME_FontFile2
PDF_ENUM_NAME_FontFile3 = _mupdf.PDF_ENUM_NAME_FontFile3
PDF_ENUM_NAME_FontMatrix = _mupdf.PDF_ENUM_NAME_FontMatrix
PDF_ENUM_NAME_FontName = _mupdf.PDF_ENUM_NAME_FontName
PDF_ENUM_NAME_ForComment = _mupdf.PDF_ENUM_NAME_ForComment
PDF_ENUM_NAME_ForPublicRelease = _mupdf.PDF_ENUM_NAME_ForPublicRelease
PDF_ENUM_NAME_Form = _mupdf.PDF_ENUM_NAME_Form
PDF_ENUM_NAME_FormEx = _mupdf.PDF_ENUM_NAME_FormEx
PDF_ENUM_NAME_FormType = _mupdf.PDF_ENUM_NAME_FormType
PDF_ENUM_NAME_Formula = _mupdf.PDF_ENUM_NAME_Formula
PDF_ENUM_NAME_FreeText = _mupdf.PDF_ENUM_NAME_FreeText
PDF_ENUM_NAME_Function = _mupdf.PDF_ENUM_NAME_Function
PDF_ENUM_NAME_FunctionType = _mupdf.PDF_ENUM_NAME_FunctionType
PDF_ENUM_NAME_Functions = _mupdf.PDF_ENUM_NAME_Functions
PDF_ENUM_NAME_G = _mupdf.PDF_ENUM_NAME_G
PDF_ENUM_NAME_GTS_PDFX = _mupdf.PDF_ENUM_NAME_GTS_PDFX
PDF_ENUM_NAME_Gamma = _mupdf.PDF_ENUM_NAME_Gamma
PDF_ENUM_NAME_Glitter = _mupdf.PDF_ENUM_NAME_Glitter
PDF_ENUM_NAME_GoTo = _mupdf.PDF_ENUM_NAME_GoTo
PDF_ENUM_NAME_GoToR = _mupdf.PDF_ENUM_NAME_GoToR
PDF_ENUM_NAME_Group = _mupdf.PDF_ENUM_NAME_Group
PDF_ENUM_NAME_H = _mupdf.PDF_ENUM_NAME_H
PDF_ENUM_NAME_H1 = _mupdf.PDF_ENUM_NAME_H1
PDF_ENUM_NAME_H2 = _mupdf.PDF_ENUM_NAME_H2
PDF_ENUM_NAME_H3 = _mupdf.PDF_ENUM_NAME_H3
PDF_ENUM_NAME_H4 = _mupdf.PDF_ENUM_NAME_H4
PDF_ENUM_NAME_H5 = _mupdf.PDF_ENUM_NAME_H5
PDF_ENUM_NAME_H6 = _mupdf.PDF_ENUM_NAME_H6
PDF_ENUM_NAME_Height = _mupdf.PDF_ENUM_NAME_Height
PDF_ENUM_NAME_Helv = _mupdf.PDF_ENUM_NAME_Helv
PDF_ENUM_NAME_Highlight = _mupdf.PDF_ENUM_NAME_Highlight
PDF_ENUM_NAME_HistoryPos = _mupdf.PDF_ENUM_NAME_HistoryPos
PDF_ENUM_NAME_I = _mupdf.PDF_ENUM_NAME_I
PDF_ENUM_NAME_IC = _mupdf.PDF_ENUM_NAME_IC
PDF_ENUM_NAME_ICCBased = _mupdf.PDF_ENUM_NAME_ICCBased
PDF_ENUM_NAME_ID = _mupdf.PDF_ENUM_NAME_ID
PDF_ENUM_NAME_IM = _mupdf.PDF_ENUM_NAME_IM
PDF_ENUM_NAME_IRT = _mupdf.PDF_ENUM_NAME_IRT
PDF_ENUM_NAME_Identity = _mupdf.PDF_ENUM_NAME_Identity
PDF_ENUM_NAME_Identity_H = _mupdf.PDF_ENUM_NAME_Identity_H
PDF_ENUM_NAME_Identity_V = _mupdf.PDF_ENUM_NAME_Identity_V
PDF_ENUM_NAME_Image = _mupdf.PDF_ENUM_NAME_Image
PDF_ENUM_NAME_ImageB = _mupdf.PDF_ENUM_NAME_ImageB
PDF_ENUM_NAME_ImageC = _mupdf.PDF_ENUM_NAME_ImageC
PDF_ENUM_NAME_ImageI = _mupdf.PDF_ENUM_NAME_ImageI
PDF_ENUM_NAME_ImageMask = _mupdf.PDF_ENUM_NAME_ImageMask
PDF_ENUM_NAME_Include = _mupdf.PDF_ENUM_NAME_Include
PDF_ENUM_NAME_Index = _mupdf.PDF_ENUM_NAME_Index
PDF_ENUM_NAME_Indexed = _mupdf.PDF_ENUM_NAME_Indexed
PDF_ENUM_NAME_Info = _mupdf.PDF_ENUM_NAME_Info
PDF_ENUM_NAME_Ink = _mupdf.PDF_ENUM_NAME_Ink
PDF_ENUM_NAME_InkList = _mupdf.PDF_ENUM_NAME_InkList
PDF_ENUM_NAME_Intent = _mupdf.PDF_ENUM_NAME_Intent
PDF_ENUM_NAME_Interpolate = _mupdf.PDF_ENUM_NAME_Interpolate
PDF_ENUM_NAME_IsMap = _mupdf.PDF_ENUM_NAME_IsMap
PDF_ENUM_NAME_ItalicAngle = _mupdf.PDF_ENUM_NAME_ItalicAngle
PDF_ENUM_NAME_JBIG2Decode = _mupdf.PDF_ENUM_NAME_JBIG2Decode
PDF_ENUM_NAME_JBIG2Globals = _mupdf.PDF_ENUM_NAME_JBIG2Globals
PDF_ENUM_NAME_JPXDecode = _mupdf.PDF_ENUM_NAME_JPXDecode
PDF_ENUM_NAME_JS = _mupdf.PDF_ENUM_NAME_JS
PDF_ENUM_NAME_JavaScript = _mupdf.PDF_ENUM_NAME_JavaScript
PDF_ENUM_NAME_K = _mupdf.PDF_ENUM_NAME_K
PDF_ENUM_NAME_Keywords = _mupdf.PDF_ENUM_NAME_Keywords
PDF_ENUM_NAME_Kids = _mupdf.PDF_ENUM_NAME_Kids
PDF_ENUM_NAME_L = _mupdf.PDF_ENUM_NAME_L
PDF_ENUM_NAME_LBody = _mupdf.PDF_ENUM_NAME_LBody
PDF_ENUM_NAME_LC = _mupdf.PDF_ENUM_NAME_LC
PDF_ENUM_NAME_LE = _mupdf.PDF_ENUM_NAME_LE
PDF_ENUM_NAME_LI = _mupdf.PDF_ENUM_NAME_LI
PDF_ENUM_NAME_LJ = _mupdf.PDF_ENUM_NAME_LJ
PDF_ENUM_NAME_LW = _mupdf.PDF_ENUM_NAME_LW
PDF_ENUM_NAME_LZ = _mupdf.PDF_ENUM_NAME_LZ
PDF_ENUM_NAME_LZW = _mupdf.PDF_ENUM_NAME_LZW
PDF_ENUM_NAME_LZWDecode = _mupdf.PDF_ENUM_NAME_LZWDecode
PDF_ENUM_NAME_Lab = _mupdf.PDF_ENUM_NAME_Lab
PDF_ENUM_NAME_Label = _mupdf.PDF_ENUM_NAME_Label
PDF_ENUM_NAME_Lang = _mupdf.PDF_ENUM_NAME_Lang
PDF_ENUM_NAME_Last = _mupdf.PDF_ENUM_NAME_Last
PDF_ENUM_NAME_LastChar = _mupdf.PDF_ENUM_NAME_LastChar
PDF_ENUM_NAME_LastPage = _mupdf.PDF_ENUM_NAME_LastPage
PDF_ENUM_NAME_Launch = _mupdf.PDF_ENUM_NAME_Launch
PDF_ENUM_NAME_Layer = _mupdf.PDF_ENUM_NAME_Layer
PDF_ENUM_NAME_Lbl = _mupdf.PDF_ENUM_NAME_Lbl
PDF_ENUM_NAME_Length = _mupdf.PDF_ENUM_NAME_Length
PDF_ENUM_NAME_Length1 = _mupdf.PDF_ENUM_NAME_Length1
PDF_ENUM_NAME_Length2 = _mupdf.PDF_ENUM_NAME_Length2
PDF_ENUM_NAME_Length3 = _mupdf.PDF_ENUM_NAME_Length3
PDF_ENUM_NAME_Limits = _mupdf.PDF_ENUM_NAME_Limits
PDF_ENUM_NAME_Line = _mupdf.PDF_ENUM_NAME_Line
PDF_ENUM_NAME_Linearized = _mupdf.PDF_ENUM_NAME_Linearized
PDF_ENUM_NAME_Link = _mupdf.PDF_ENUM_NAME_Link
PDF_ENUM_NAME_List = _mupdf.PDF_ENUM_NAME_List
PDF_ENUM_NAME_Location = _mupdf.PDF_ENUM_NAME_Location
PDF_ENUM_NAME_Lock = _mupdf.PDF_ENUM_NAME_Lock
PDF_ENUM_NAME_Locked = _mupdf.PDF_ENUM_NAME_Locked
PDF_ENUM_NAME_Luminosity = _mupdf.PDF_ENUM_NAME_Luminosity
PDF_ENUM_NAME_M = _mupdf.PDF_ENUM_NAME_M
PDF_ENUM_NAME_MCID = _mupdf.PDF_ENUM_NAME_MCID
PDF_ENUM_NAME_MK = _mupdf.PDF_ENUM_NAME_MK
PDF_ENUM_NAME_ML = _mupdf.PDF_ENUM_NAME_ML
PDF_ENUM_NAME_MMType1 = _mupdf.PDF_ENUM_NAME_MMType1
PDF_ENUM_NAME_Mac = _mupdf.PDF_ENUM_NAME_Mac
PDF_ENUM_NAME_Mask = _mupdf.PDF_ENUM_NAME_Mask
PDF_ENUM_NAME_Matrix = _mupdf.PDF_ENUM_NAME_Matrix
PDF_ENUM_NAME_Matte = _mupdf.PDF_ENUM_NAME_Matte
PDF_ENUM_NAME_MaxLen = _mupdf.PDF_ENUM_NAME_MaxLen
PDF_ENUM_NAME_MediaBox = _mupdf.PDF_ENUM_NAME_MediaBox
PDF_ENUM_NAME_Metadata = _mupdf.PDF_ENUM_NAME_Metadata
PDF_ENUM_NAME_MissingWidth = _mupdf.PDF_ENUM_NAME_MissingWidth
PDF_ENUM_NAME_ModDate = _mupdf.PDF_ENUM_NAME_ModDate
PDF_ENUM_NAME_Movie = _mupdf.PDF_ENUM_NAME_Movie
PDF_ENUM_NAME_Msg = _mupdf.PDF_ENUM_NAME_Msg
PDF_ENUM_NAME_Multiply = _mupdf.PDF_ENUM_NAME_Multiply
PDF_ENUM_NAME_N = _mupdf.PDF_ENUM_NAME_N
PDF_ENUM_NAME_Name = _mupdf.PDF_ENUM_NAME_Name
PDF_ENUM_NAME_Named = _mupdf.PDF_ENUM_NAME_Named
PDF_ENUM_NAME_Names = _mupdf.PDF_ENUM_NAME_Names
PDF_ENUM_NAME_NewWindow = _mupdf.PDF_ENUM_NAME_NewWindow
PDF_ENUM_NAME_Next = _mupdf.PDF_ENUM_NAME_Next
PDF_ENUM_NAME_NextPage = _mupdf.PDF_ENUM_NAME_NextPage
PDF_ENUM_NAME_NonEFontNoWarn = _mupdf.PDF_ENUM_NAME_NonEFontNoWarn
PDF_ENUM_NAME_NonStruct = _mupdf.PDF_ENUM_NAME_NonStruct
PDF_ENUM_NAME_None = _mupdf.PDF_ENUM_NAME_None
PDF_ENUM_NAME_Normal = _mupdf.PDF_ENUM_NAME_Normal
PDF_ENUM_NAME_NotApproved = _mupdf.PDF_ENUM_NAME_NotApproved
PDF_ENUM_NAME_NotForPublicRelease = _mupdf.PDF_ENUM_NAME_NotForPublicRelease
PDF_ENUM_NAME_Note = _mupdf.PDF_ENUM_NAME_Note
PDF_ENUM_NAME_NumSections = _mupdf.PDF_ENUM_NAME_NumSections
PDF_ENUM_NAME_Nums = _mupdf.PDF_ENUM_NAME_Nums
PDF_ENUM_NAME_O = _mupdf.PDF_ENUM_NAME_O
PDF_ENUM_NAME_OC = _mupdf.PDF_ENUM_NAME_OC
PDF_ENUM_NAME_OCG = _mupdf.PDF_ENUM_NAME_OCG
PDF_ENUM_NAME_OCGs = _mupdf.PDF_ENUM_NAME_OCGs
PDF_ENUM_NAME_OCMD = _mupdf.PDF_ENUM_NAME_OCMD
PDF_ENUM_NAME_OCProperties = _mupdf.PDF_ENUM_NAME_OCProperties
PDF_ENUM_NAME_OE = _mupdf.PDF_ENUM_NAME_OE
PDF_ENUM_NAME_OFF = _mupdf.PDF_ENUM_NAME_OFF
PDF_ENUM_NAME_ON = _mupdf.PDF_ENUM_NAME_ON
PDF_ENUM_NAME_OP = _mupdf.PDF_ENUM_NAME_OP
PDF_ENUM_NAME_OPM = _mupdf.PDF_ENUM_NAME_OPM
PDF_ENUM_NAME_OS = _mupdf.PDF_ENUM_NAME_OS
PDF_ENUM_NAME_ObjStm = _mupdf.PDF_ENUM_NAME_ObjStm
PDF_ENUM_NAME_Of = _mupdf.PDF_ENUM_NAME_Of
PDF_ENUM_NAME_Off = _mupdf.PDF_ENUM_NAME_Off
PDF_ENUM_NAME_Open = _mupdf.PDF_ENUM_NAME_Open
PDF_ENUM_NAME_OpenArrow = _mupdf.PDF_ENUM_NAME_OpenArrow
PDF_ENUM_NAME_OpenType = _mupdf.PDF_ENUM_NAME_OpenType
PDF_ENUM_NAME_Opt = _mupdf.PDF_ENUM_NAME_Opt
PDF_ENUM_NAME_Order = _mupdf.PDF_ENUM_NAME_Order
PDF_ENUM_NAME_Ordering = _mupdf.PDF_ENUM_NAME_Ordering
PDF_ENUM_NAME_Outlines = _mupdf.PDF_ENUM_NAME_Outlines
PDF_ENUM_NAME_OutputCondition = _mupdf.PDF_ENUM_NAME_OutputCondition
PDF_ENUM_NAME_OutputConditionIdentifier = _mupdf.PDF_ENUM_NAME_OutputConditionIdentifier
PDF_ENUM_NAME_OutputIntent = _mupdf.PDF_ENUM_NAME_OutputIntent
PDF_ENUM_NAME_OutputIntents = _mupdf.PDF_ENUM_NAME_OutputIntents
PDF_ENUM_NAME_P = _mupdf.PDF_ENUM_NAME_P
PDF_ENUM_NAME_PDF = _mupdf.PDF_ENUM_NAME_PDF
PDF_ENUM_NAME_PS = _mupdf.PDF_ENUM_NAME_PS
PDF_ENUM_NAME_Page = _mupdf.PDF_ENUM_NAME_Page
PDF_ENUM_NAME_PageLabels = _mupdf.PDF_ENUM_NAME_PageLabels
PDF_ENUM_NAME_PageMode = _mupdf.PDF_ENUM_NAME_PageMode
PDF_ENUM_NAME_Pages = _mupdf.PDF_ENUM_NAME_Pages
PDF_ENUM_NAME_PaintType = _mupdf.PDF_ENUM_NAME_PaintType
PDF_ENUM_NAME_Params = _mupdf.PDF_ENUM_NAME_Params
PDF_ENUM_NAME_Parent = _mupdf.PDF_ENUM_NAME_Parent
PDF_ENUM_NAME_ParentTree = _mupdf.PDF_ENUM_NAME_ParentTree
PDF_ENUM_NAME_Part = _mupdf.PDF_ENUM_NAME_Part
PDF_ENUM_NAME_Pattern = _mupdf.PDF_ENUM_NAME_Pattern
PDF_ENUM_NAME_PatternType = _mupdf.PDF_ENUM_NAME_PatternType
PDF_ENUM_NAME_Perms = _mupdf.PDF_ENUM_NAME_Perms
PDF_ENUM_NAME_PolyLine = _mupdf.PDF_ENUM_NAME_PolyLine
PDF_ENUM_NAME_Polygon = _mupdf.PDF_ENUM_NAME_Polygon
PDF_ENUM_NAME_Popup = _mupdf.PDF_ENUM_NAME_Popup
PDF_ENUM_NAME_PreRelease = _mupdf.PDF_ENUM_NAME_PreRelease
PDF_ENUM_NAME_Predictor = _mupdf.PDF_ENUM_NAME_Predictor
PDF_ENUM_NAME_Prev = _mupdf.PDF_ENUM_NAME_Prev
PDF_ENUM_NAME_PrevPage = _mupdf.PDF_ENUM_NAME_PrevPage
PDF_ENUM_NAME_Preview = _mupdf.PDF_ENUM_NAME_Preview
PDF_ENUM_NAME_Print = _mupdf.PDF_ENUM_NAME_Print
PDF_ENUM_NAME_PrinterMark = _mupdf.PDF_ENUM_NAME_PrinterMark
PDF_ENUM_NAME_Private = _mupdf.PDF_ENUM_NAME_Private
PDF_ENUM_NAME_ProcSet = _mupdf.PDF_ENUM_NAME_ProcSet
PDF_ENUM_NAME_Producer = _mupdf.PDF_ENUM_NAME_Producer
PDF_ENUM_NAME_Prop_AuthTime = _mupdf.PDF_ENUM_NAME_Prop_AuthTime
PDF_ENUM_NAME_Prop_AuthType = _mupdf.PDF_ENUM_NAME_Prop_AuthType
PDF_ENUM_NAME_Prop_Build = _mupdf.PDF_ENUM_NAME_Prop_Build
PDF_ENUM_NAME_Properties = _mupdf.PDF_ENUM_NAME_Properties
PDF_ENUM_NAME_PubSec = _mupdf.PDF_ENUM_NAME_PubSec
PDF_ENUM_NAME_Push = _mupdf.PDF_ENUM_NAME_Push
PDF_ENUM_NAME_Q = _mupdf.PDF_ENUM_NAME_Q
PDF_ENUM_NAME_QuadPoints = _mupdf.PDF_ENUM_NAME_QuadPoints
PDF_ENUM_NAME_Quote = _mupdf.PDF_ENUM_NAME_Quote
PDF_ENUM_NAME_R = _mupdf.PDF_ENUM_NAME_R
PDF_ENUM_NAME_RB = _mupdf.PDF_ENUM_NAME_RB
PDF_ENUM_NAME_RBGroups = _mupdf.PDF_ENUM_NAME_RBGroups
PDF_ENUM_NAME_RC = _mupdf.PDF_ENUM_NAME_RC
PDF_ENUM_NAME_RClosedArrow = _mupdf.PDF_ENUM_NAME_RClosedArrow
PDF_ENUM_NAME_RD = _mupdf.PDF_ENUM_NAME_RD
PDF_ENUM_NAME_REx = _mupdf.PDF_ENUM_NAME_REx
PDF_ENUM_NAME_RGB = _mupdf.PDF_ENUM_NAME_RGB
PDF_ENUM_NAME_RI = _mupdf.PDF_ENUM_NAME_RI
PDF_ENUM_NAME_RL = _mupdf.PDF_ENUM_NAME_RL
PDF_ENUM_NAME_ROpenArrow = _mupdf.PDF_ENUM_NAME_ROpenArrow
PDF_ENUM_NAME_RP = _mupdf.PDF_ENUM_NAME_RP
PDF_ENUM_NAME_RT = _mupdf.PDF_ENUM_NAME_RT
PDF_ENUM_NAME_Range = _mupdf.PDF_ENUM_NAME_Range
PDF_ENUM_NAME_Reason = _mupdf.PDF_ENUM_NAME_Reason
PDF_ENUM_NAME_Rect = _mupdf.PDF_ENUM_NAME_Rect
PDF_ENUM_NAME_Redact = _mupdf.PDF_ENUM_NAME_Redact
PDF_ENUM_NAME_Ref = _mupdf.PDF_ENUM_NAME_Ref
PDF_ENUM_NAME_Reference = _mupdf.PDF_ENUM_NAME_Reference
PDF_ENUM_NAME_Registry = _mupdf.PDF_ENUM_NAME_Registry
PDF_ENUM_NAME_ResetForm = _mupdf.PDF_ENUM_NAME_ResetForm
PDF_ENUM_NAME_Resources = _mupdf.PDF_ENUM_NAME_Resources
PDF_ENUM_NAME_RoleMap = _mupdf.PDF_ENUM_NAME_RoleMap
PDF_ENUM_NAME_Root = _mupdf.PDF_ENUM_NAME_Root
PDF_ENUM_NAME_Rotate = _mupdf.PDF_ENUM_NAME_Rotate
PDF_ENUM_NAME_Rows = _mupdf.PDF_ENUM_NAME_Rows
PDF_ENUM_NAME_Ruby = _mupdf.PDF_ENUM_NAME_Ruby
PDF_ENUM_NAME_RunLengthDecode = _mupdf.PDF_ENUM_NAME_RunLengthDecode
PDF_ENUM_NAME_S = _mupdf.PDF_ENUM_NAME_S
PDF_ENUM_NAME_SMask = _mupdf.PDF_ENUM_NAME_SMask
PDF_ENUM_NAME_SMaskInData = _mupdf.PDF_ENUM_NAME_SMaskInData
PDF_ENUM_NAME_Schema = _mupdf.PDF_ENUM_NAME_Schema
PDF_ENUM_NAME_Screen = _mupdf.PDF_ENUM_NAME_Screen
PDF_ENUM_NAME_Sect = _mupdf.PDF_ENUM_NAME_Sect
PDF_ENUM_NAME_Separation = _mupdf.PDF_ENUM_NAME_Separation
PDF_ENUM_NAME_Shading = _mupdf.PDF_ENUM_NAME_Shading
PDF_ENUM_NAME_ShadingType = _mupdf.PDF_ENUM_NAME_ShadingType
PDF_ENUM_NAME_Si = _mupdf.PDF_ENUM_NAME_Si
PDF_ENUM_NAME_Sig = _mupdf.PDF_ENUM_NAME_Sig
PDF_ENUM_NAME_SigFlags = _mupdf.PDF_ENUM_NAME_SigFlags
PDF_ENUM_NAME_SigQ = _mupdf.PDF_ENUM_NAME_SigQ
PDF_ENUM_NAME_SigRef = _mupdf.PDF_ENUM_NAME_SigRef
PDF_ENUM_NAME_Size = _mupdf.PDF_ENUM_NAME_Size
PDF_ENUM_NAME_Slash = _mupdf.PDF_ENUM_NAME_Slash
PDF_ENUM_NAME_Sold = _mupdf.PDF_ENUM_NAME_Sold
PDF_ENUM_NAME_Sound = _mupdf.PDF_ENUM_NAME_Sound
PDF_ENUM_NAME_Span = _mupdf.PDF_ENUM_NAME_Span
PDF_ENUM_NAME_Split = _mupdf.PDF_ENUM_NAME_Split
PDF_ENUM_NAME_Square = _mupdf.PDF_ENUM_NAME_Square
PDF_ENUM_NAME_Squiggly = _mupdf.PDF_ENUM_NAME_Squiggly
PDF_ENUM_NAME_St = _mupdf.PDF_ENUM_NAME_St
PDF_ENUM_NAME_Stamp = _mupdf.PDF_ENUM_NAME_Stamp
PDF_ENUM_NAME_Standard = _mupdf.PDF_ENUM_NAME_Standard
PDF_ENUM_NAME_StdCF = _mupdf.PDF_ENUM_NAME_StdCF
PDF_ENUM_NAME_StemV = _mupdf.PDF_ENUM_NAME_StemV
PDF_ENUM_NAME_StmF = _mupdf.PDF_ENUM_NAME_StmF
PDF_ENUM_NAME_StrF = _mupdf.PDF_ENUM_NAME_StrF
PDF_ENUM_NAME_StrikeOut = _mupdf.PDF_ENUM_NAME_StrikeOut
PDF_ENUM_NAME_Strong = _mupdf.PDF_ENUM_NAME_Strong
PDF_ENUM_NAME_StructParent = _mupdf.PDF_ENUM_NAME_StructParent
PDF_ENUM_NAME_StructParents = _mupdf.PDF_ENUM_NAME_StructParents
PDF_ENUM_NAME_StructTreeRoot = _mupdf.PDF_ENUM_NAME_StructTreeRoot
PDF_ENUM_NAME_Sub = _mupdf.PDF_ENUM_NAME_Sub
PDF_ENUM_NAME_SubFilter = _mupdf.PDF_ENUM_NAME_SubFilter
PDF_ENUM_NAME_Subject = _mupdf.PDF_ENUM_NAME_Subject
PDF_ENUM_NAME_Subtype = _mupdf.PDF_ENUM_NAME_Subtype
PDF_ENUM_NAME_Subtype2 = _mupdf.PDF_ENUM_NAME_Subtype2
PDF_ENUM_NAME_Supplement = _mupdf.PDF_ENUM_NAME_Supplement
PDF_ENUM_NAME_Symb = _mupdf.PDF_ENUM_NAME_Symb
PDF_ENUM_NAME_T = _mupdf.PDF_ENUM_NAME_T
PDF_ENUM_NAME_TBody = _mupdf.PDF_ENUM_NAME_TBody
PDF_ENUM_NAME_TD = _mupdf.PDF_ENUM_NAME_TD
PDF_ENUM_NAME_TFoot = _mupdf.PDF_ENUM_NAME_TFoot
PDF_ENUM_NAME_TH = _mupdf.PDF_ENUM_NAME_TH
PDF_ENUM_NAME_THead = _mupdf.PDF_ENUM_NAME_THead
PDF_ENUM_NAME_TI = _mupdf.PDF_ENUM_NAME_TI
PDF_ENUM_NAME_TOC = _mupdf.PDF_ENUM_NAME_TOC
PDF_ENUM_NAME_TOCI = _mupdf.PDF_ENUM_NAME_TOCI
PDF_ENUM_NAME_TR = _mupdf.PDF_ENUM_NAME_TR
PDF_ENUM_NAME_TR2 = _mupdf.PDF_ENUM_NAME_TR2
PDF_ENUM_NAME_TU = _mupdf.PDF_ENUM_NAME_TU
PDF_ENUM_NAME_Table = _mupdf.PDF_ENUM_NAME_Table
PDF_ENUM_NAME_Text = _mupdf.PDF_ENUM_NAME_Text
PDF_ENUM_NAME_TilingType = _mupdf.PDF_ENUM_NAME_TilingType
PDF_ENUM_NAME_Times = _mupdf.PDF_ENUM_NAME_Times
PDF_ENUM_NAME_Title = _mupdf.PDF_ENUM_NAME_Title
PDF_ENUM_NAME_ToUnicode = _mupdf.PDF_ENUM_NAME_ToUnicode
PDF_ENUM_NAME_TopSecret = _mupdf.PDF_ENUM_NAME_TopSecret
PDF_ENUM_NAME_Trans = _mupdf.PDF_ENUM_NAME_Trans
PDF_ENUM_NAME_TransformMethod = _mupdf.PDF_ENUM_NAME_TransformMethod
PDF_ENUM_NAME_TransformParams = _mupdf.PDF_ENUM_NAME_TransformParams
PDF_ENUM_NAME_Transparency = _mupdf.PDF_ENUM_NAME_Transparency
PDF_ENUM_NAME_TrapNet = _mupdf.PDF_ENUM_NAME_TrapNet
PDF_ENUM_NAME_TrimBox = _mupdf.PDF_ENUM_NAME_TrimBox
PDF_ENUM_NAME_TrueType = _mupdf.PDF_ENUM_NAME_TrueType
PDF_ENUM_NAME_TrustedMode = _mupdf.PDF_ENUM_NAME_TrustedMode
PDF_ENUM_NAME_Tx = _mupdf.PDF_ENUM_NAME_Tx
PDF_ENUM_NAME_Type = _mupdf.PDF_ENUM_NAME_Type
PDF_ENUM_NAME_Type0 = _mupdf.PDF_ENUM_NAME_Type0
PDF_ENUM_NAME_Type1 = _mupdf.PDF_ENUM_NAME_Type1
PDF_ENUM_NAME_Type1C = _mupdf.PDF_ENUM_NAME_Type1C
PDF_ENUM_NAME_Type3 = _mupdf.PDF_ENUM_NAME_Type3
PDF_ENUM_NAME_U = _mupdf.PDF_ENUM_NAME_U
PDF_ENUM_NAME_UE = _mupdf.PDF_ENUM_NAME_UE
PDF_ENUM_NAME_UF = _mupdf.PDF_ENUM_NAME_UF
PDF_ENUM_NAME_URI = _mupdf.PDF_ENUM_NAME_URI
PDF_ENUM_NAME_URL = _mupdf.PDF_ENUM_NAME_URL
PDF_ENUM_NAME_Unchanged = _mupdf.PDF_ENUM_NAME_Unchanged
PDF_ENUM_NAME_Uncover = _mupdf.PDF_ENUM_NAME_Uncover
PDF_ENUM_NAME_Underline = _mupdf.PDF_ENUM_NAME_Underline
PDF_ENUM_NAME_Unix = _mupdf.PDF_ENUM_NAME_Unix
PDF_ENUM_NAME_Usage = _mupdf.PDF_ENUM_NAME_Usage
PDF_ENUM_NAME_UseBlackPtComp = _mupdf.PDF_ENUM_NAME_UseBlackPtComp
PDF_ENUM_NAME_UseCMap = _mupdf.PDF_ENUM_NAME_UseCMap
PDF_ENUM_NAME_UseOutlines = _mupdf.PDF_ENUM_NAME_UseOutlines
PDF_ENUM_NAME_UserUnit = _mupdf.PDF_ENUM_NAME_UserUnit
PDF_ENUM_NAME_V = _mupdf.PDF_ENUM_NAME_V
PDF_ENUM_NAME_V2 = _mupdf.PDF_ENUM_NAME_V2
PDF_ENUM_NAME_VE = _mupdf.PDF_ENUM_NAME_VE
PDF_ENUM_NAME_Version = _mupdf.PDF_ENUM_NAME_Version
PDF_ENUM_NAME_Vertices = _mupdf.PDF_ENUM_NAME_Vertices
PDF_ENUM_NAME_VerticesPerRow = _mupdf.PDF_ENUM_NAME_VerticesPerRow
PDF_ENUM_NAME_View = _mupdf.PDF_ENUM_NAME_View
PDF_ENUM_NAME_W = _mupdf.PDF_ENUM_NAME_W
PDF_ENUM_NAME_W2 = _mupdf.PDF_ENUM_NAME_W2
PDF_ENUM_NAME_WMode = _mupdf.PDF_ENUM_NAME_WMode
PDF_ENUM_NAME_WP = _mupdf.PDF_ENUM_NAME_WP
PDF_ENUM_NAME_WT = _mupdf.PDF_ENUM_NAME_WT
PDF_ENUM_NAME_Warichu = _mupdf.PDF_ENUM_NAME_Warichu
PDF_ENUM_NAME_Watermark = _mupdf.PDF_ENUM_NAME_Watermark
PDF_ENUM_NAME_WhitePoint = _mupdf.PDF_ENUM_NAME_WhitePoint
PDF_ENUM_NAME_Widget = _mupdf.PDF_ENUM_NAME_Widget
PDF_ENUM_NAME_Width = _mupdf.PDF_ENUM_NAME_Width
PDF_ENUM_NAME_Widths = _mupdf.PDF_ENUM_NAME_Widths
PDF_ENUM_NAME_WinAnsiEncoding = _mupdf.PDF_ENUM_NAME_WinAnsiEncoding
PDF_ENUM_NAME_Wipe = _mupdf.PDF_ENUM_NAME_Wipe
PDF_ENUM_NAME_XFA = _mupdf.PDF_ENUM_NAME_XFA
PDF_ENUM_NAME_XHeight = _mupdf.PDF_ENUM_NAME_XHeight
PDF_ENUM_NAME_XML = _mupdf.PDF_ENUM_NAME_XML
PDF_ENUM_NAME_XObject = _mupdf.PDF_ENUM_NAME_XObject
PDF_ENUM_NAME_XRef = _mupdf.PDF_ENUM_NAME_XRef
PDF_ENUM_NAME_XRefStm = _mupdf.PDF_ENUM_NAME_XRefStm
PDF_ENUM_NAME_XStep = _mupdf.PDF_ENUM_NAME_XStep
PDF_ENUM_NAME_XYZ = _mupdf.PDF_ENUM_NAME_XYZ
PDF_ENUM_NAME_YStep = _mupdf.PDF_ENUM_NAME_YStep
PDF_ENUM_NAME_Yes = _mupdf.PDF_ENUM_NAME_Yes
PDF_ENUM_NAME_ZaDb = _mupdf.PDF_ENUM_NAME_ZaDb
PDF_ENUM_NAME_a = _mupdf.PDF_ENUM_NAME_a
PDF_ENUM_NAME_adbe_pkcs7_detached = _mupdf.PDF_ENUM_NAME_adbe_pkcs7_detached
PDF_ENUM_NAME_ca = _mupdf.PDF_ENUM_NAME_ca
PDF_ENUM_NAME_n0 = _mupdf.PDF_ENUM_NAME_n0
PDF_ENUM_NAME_n1 = _mupdf.PDF_ENUM_NAME_n1
PDF_ENUM_NAME_n2 = _mupdf.PDF_ENUM_NAME_n2
PDF_ENUM_NAME_op = _mupdf.PDF_ENUM_NAME_op
PDF_ENUM_NAME_r = _mupdf.PDF_ENUM_NAME_r
PDF_ENUM_LIMIT = _mupdf.PDF_ENUM_LIMIT
PDF_LEXBUF_SMALL = _mupdf.PDF_LEXBUF_SMALL
PDF_LEXBUF_LARGE = _mupdf.PDF_LEXBUF_LARGE
class pdf_lexbuf(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    size = property(_mupdf.pdf_lexbuf_size_get, _mupdf.pdf_lexbuf_size_set)
    base_size = property(_mupdf.pdf_lexbuf_base_size_get, _mupdf.pdf_lexbuf_base_size_set)
    len = property(_mupdf.pdf_lexbuf_len_get, _mupdf.pdf_lexbuf_len_set)
    i = property(_mupdf.pdf_lexbuf_i_get, _mupdf.pdf_lexbuf_i_set)
    f = property(_mupdf.pdf_lexbuf_f_get, _mupdf.pdf_lexbuf_f_set)
    scratch = property(_mupdf.pdf_lexbuf_scratch_get, _mupdf.pdf_lexbuf_scratch_set)
    buffer = property(_mupdf.pdf_lexbuf_buffer_get, _mupdf.pdf_lexbuf_buffer_set)

    def __init__(self):
        _mupdf.pdf_lexbuf_swiginit(self, _mupdf.new_pdf_lexbuf())
    __swig_destroy__ = _mupdf.delete_pdf_lexbuf

# Register pdf_lexbuf in _mupdf:
_mupdf.pdf_lexbuf_swigregister(pdf_lexbuf)
class pdf_lexbuf_large(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    base = property(_mupdf.pdf_lexbuf_large_base_get, _mupdf.pdf_lexbuf_large_base_set)
    buffer = property(_mupdf.pdf_lexbuf_large_buffer_get, _mupdf.pdf_lexbuf_large_buffer_set)

    def __init__(self):
        _mupdf.pdf_lexbuf_large_swiginit(self, _mupdf.new_pdf_lexbuf_large())
    __swig_destroy__ = _mupdf.delete_pdf_lexbuf_large

# Register pdf_lexbuf_large in _mupdf:
_mupdf.pdf_lexbuf_large_swigregister(pdf_lexbuf_large)
class pdf_js_console(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    drop = property(_mupdf.pdf_js_console_drop_get, _mupdf.pdf_js_console_drop_set)
    show = property(_mupdf.pdf_js_console_show_get, _mupdf.pdf_js_console_show_set)
    hide = property(_mupdf.pdf_js_console_hide_get, _mupdf.pdf_js_console_hide_set)
    clear = property(_mupdf.pdf_js_console_clear_get, _mupdf.pdf_js_console_clear_set)
    write = property(_mupdf.pdf_js_console_write_get, _mupdf.pdf_js_console_write_set)

    def __init__(self):
        _mupdf.pdf_js_console_swiginit(self, _mupdf.new_pdf_js_console())
    __swig_destroy__ = _mupdf.delete_pdf_js_console

# Register pdf_js_console in _mupdf:
_mupdf.pdf_js_console_swigregister(pdf_js_console)
class pdf_layer_config(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    name = property(_mupdf.pdf_layer_config_name_get, _mupdf.pdf_layer_config_name_set)
    creator = property(_mupdf.pdf_layer_config_creator_get, _mupdf.pdf_layer_config_creator_set)

    def __init__(self):
        _mupdf.pdf_layer_config_swiginit(self, _mupdf.new_pdf_layer_config())
    __swig_destroy__ = _mupdf.delete_pdf_layer_config

# Register pdf_layer_config in _mupdf:
_mupdf.pdf_layer_config_swigregister(pdf_layer_config)
PDF_LAYER_UI_LABEL = _mupdf.PDF_LAYER_UI_LABEL
PDF_LAYER_UI_CHECKBOX = _mupdf.PDF_LAYER_UI_CHECKBOX
PDF_LAYER_UI_RADIOBOX = _mupdf.PDF_LAYER_UI_RADIOBOX
class pdf_layer_config_ui(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    text = property(_mupdf.pdf_layer_config_ui_text_get, _mupdf.pdf_layer_config_ui_text_set)
    depth = property(_mupdf.pdf_layer_config_ui_depth_get, _mupdf.pdf_layer_config_ui_depth_set)
    type = property(_mupdf.pdf_layer_config_ui_type_get, _mupdf.pdf_layer_config_ui_type_set)
    selected = property(_mupdf.pdf_layer_config_ui_selected_get, _mupdf.pdf_layer_config_ui_selected_set)
    locked = property(_mupdf.pdf_layer_config_ui_locked_get, _mupdf.pdf_layer_config_ui_locked_set)

    def __init__(self):
        _mupdf.pdf_layer_config_ui_swiginit(self, _mupdf.new_pdf_layer_config_ui())
    __swig_destroy__ = _mupdf.delete_pdf_layer_config_ui

# Register pdf_layer_config_ui in _mupdf:
_mupdf.pdf_layer_config_ui_swigregister(pdf_layer_config_ui)
class pdf_unsaved_sig(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    field = property(_mupdf.pdf_unsaved_sig_field_get, _mupdf.pdf_unsaved_sig_field_set)
    byte_range_start = property(_mupdf.pdf_unsaved_sig_byte_range_start_get, _mupdf.pdf_unsaved_sig_byte_range_start_set)
    byte_range_end = property(_mupdf.pdf_unsaved_sig_byte_range_end_get, _mupdf.pdf_unsaved_sig_byte_range_end_set)
    contents_start = property(_mupdf.pdf_unsaved_sig_contents_start_get, _mupdf.pdf_unsaved_sig_contents_start_set)
    contents_end = property(_mupdf.pdf_unsaved_sig_contents_end_get, _mupdf.pdf_unsaved_sig_contents_end_set)
    signer = property(_mupdf.pdf_unsaved_sig_signer_get, _mupdf.pdf_unsaved_sig_signer_set)
    next = property(_mupdf.pdf_unsaved_sig_next_get, _mupdf.pdf_unsaved_sig_next_set)

    def __init__(self):
        _mupdf.pdf_unsaved_sig_swiginit(self, _mupdf.new_pdf_unsaved_sig())
    __swig_destroy__ = _mupdf.delete_pdf_unsaved_sig

# Register pdf_unsaved_sig in _mupdf:
_mupdf.pdf_unsaved_sig_swigregister(pdf_unsaved_sig)
class pdf_rev_page_map(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    page = property(_mupdf.pdf_rev_page_map_page_get, _mupdf.pdf_rev_page_map_page_set)
    object = property(_mupdf.pdf_rev_page_map_object_get, _mupdf.pdf_rev_page_map_object_set)

    def __init__(self):
        _mupdf.pdf_rev_page_map_swiginit(self, _mupdf.new_pdf_rev_page_map())
    __swig_destroy__ = _mupdf.delete_pdf_rev_page_map

# Register pdf_rev_page_map in _mupdf:
_mupdf.pdf_rev_page_map_swigregister(pdf_rev_page_map)
class pdf_hint_page(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    number = property(_mupdf.pdf_hint_page_number_get, _mupdf.pdf_hint_page_number_set)
    offset = property(_mupdf.pdf_hint_page_offset_get, _mupdf.pdf_hint_page_offset_set)
    index = property(_mupdf.pdf_hint_page_index_get, _mupdf.pdf_hint_page_index_set)

    def __init__(self):
        _mupdf.pdf_hint_page_swiginit(self, _mupdf.new_pdf_hint_page())
    __swig_destroy__ = _mupdf.delete_pdf_hint_page

# Register pdf_hint_page in _mupdf:
_mupdf.pdf_hint_page_swigregister(pdf_hint_page)
class pdf_hint_shared(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    number = property(_mupdf.pdf_hint_shared_number_get, _mupdf.pdf_hint_shared_number_set)
    offset = property(_mupdf.pdf_hint_shared_offset_get, _mupdf.pdf_hint_shared_offset_set)

    def __init__(self):
        _mupdf.pdf_hint_shared_swiginit(self, _mupdf.new_pdf_hint_shared())
    __swig_destroy__ = _mupdf.delete_pdf_hint_shared

# Register pdf_hint_shared in _mupdf:
_mupdf.pdf_hint_shared_swigregister(pdf_hint_shared)
class pdf_document(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    super = property(_mupdf.pdf_document_super_get, _mupdf.pdf_document_super_set)
    file = property(_mupdf.pdf_document_file_get, _mupdf.pdf_document_file_set)
    version = property(_mupdf.pdf_document_version_get, _mupdf.pdf_document_version_set)
    is_fdf = property(_mupdf.pdf_document_is_fdf_get, _mupdf.pdf_document_is_fdf_set)
    startxref = property(_mupdf.pdf_document_startxref_get, _mupdf.pdf_document_startxref_set)
    file_size = property(_mupdf.pdf_document_file_size_get, _mupdf.pdf_document_file_size_set)
    crypt = property(_mupdf.pdf_document_crypt_get, _mupdf.pdf_document_crypt_set)
    ocg = property(_mupdf.pdf_document_ocg_get, _mupdf.pdf_document_ocg_set)
    oi = property(_mupdf.pdf_document_oi_get, _mupdf.pdf_document_oi_set)
    max_xref_len = property(_mupdf.pdf_document_max_xref_len_get, _mupdf.pdf_document_max_xref_len_set)
    num_xref_sections = property(_mupdf.pdf_document_num_xref_sections_get, _mupdf.pdf_document_num_xref_sections_set)
    saved_num_xref_sections = property(_mupdf.pdf_document_saved_num_xref_sections_get, _mupdf.pdf_document_saved_num_xref_sections_set)
    num_incremental_sections = property(_mupdf.pdf_document_num_incremental_sections_get, _mupdf.pdf_document_num_incremental_sections_set)
    xref_base = property(_mupdf.pdf_document_xref_base_get, _mupdf.pdf_document_xref_base_set)
    disallow_new_increments = property(_mupdf.pdf_document_disallow_new_increments_get, _mupdf.pdf_document_disallow_new_increments_set)
    local_xref = property(_mupdf.pdf_document_local_xref_get, _mupdf.pdf_document_local_xref_set)
    local_xref_nesting = property(_mupdf.pdf_document_local_xref_nesting_get, _mupdf.pdf_document_local_xref_nesting_set)
    xref_sections = property(_mupdf.pdf_document_xref_sections_get, _mupdf.pdf_document_xref_sections_set)
    saved_xref_sections = property(_mupdf.pdf_document_saved_xref_sections_get, _mupdf.pdf_document_saved_xref_sections_set)
    xref_index = property(_mupdf.pdf_document_xref_index_get, _mupdf.pdf_document_xref_index_set)
    save_in_progress = property(_mupdf.pdf_document_save_in_progress_get, _mupdf.pdf_document_save_in_progress_set)
    last_xref_was_old_style = property(_mupdf.pdf_document_last_xref_was_old_style_get, _mupdf.pdf_document_last_xref_was_old_style_set)
    has_linearization_object = property(_mupdf.pdf_document_has_linearization_object_get, _mupdf.pdf_document_has_linearization_object_set)
    map_page_count = property(_mupdf.pdf_document_map_page_count_get, _mupdf.pdf_document_map_page_count_set)
    rev_page_map = property(_mupdf.pdf_document_rev_page_map_get, _mupdf.pdf_document_rev_page_map_set)
    fwd_page_map = property(_mupdf.pdf_document_fwd_page_map_get, _mupdf.pdf_document_fwd_page_map_set)
    page_tree_broken = property(_mupdf.pdf_document_page_tree_broken_get, _mupdf.pdf_document_page_tree_broken_set)
    repair_attempted = property(_mupdf.pdf_document_repair_attempted_get, _mupdf.pdf_document_repair_attempted_set)
    repair_in_progress = property(_mupdf.pdf_document_repair_in_progress_get, _mupdf.pdf_document_repair_in_progress_set)
    non_structural_change = property(_mupdf.pdf_document_non_structural_change_get, _mupdf.pdf_document_non_structural_change_set)
    file_reading_linearly = property(_mupdf.pdf_document_file_reading_linearly_get, _mupdf.pdf_document_file_reading_linearly_set)
    file_length = property(_mupdf.pdf_document_file_length_get, _mupdf.pdf_document_file_length_set)
    linear_page_count = property(_mupdf.pdf_document_linear_page_count_get, _mupdf.pdf_document_linear_page_count_set)
    linear_obj = property(_mupdf.pdf_document_linear_obj_get, _mupdf.pdf_document_linear_obj_set)
    linear_page_refs = property(_mupdf.pdf_document_linear_page_refs_get, _mupdf.pdf_document_linear_page_refs_set)
    linear_page1_obj_num = property(_mupdf.pdf_document_linear_page1_obj_num_get, _mupdf.pdf_document_linear_page1_obj_num_set)
    linear_pos = property(_mupdf.pdf_document_linear_pos_get, _mupdf.pdf_document_linear_pos_set)
    linear_page_num = property(_mupdf.pdf_document_linear_page_num_get, _mupdf.pdf_document_linear_page_num_set)
    hint_object_offset = property(_mupdf.pdf_document_hint_object_offset_get, _mupdf.pdf_document_hint_object_offset_set)
    hint_object_length = property(_mupdf.pdf_document_hint_object_length_get, _mupdf.pdf_document_hint_object_length_set)
    hints_loaded = property(_mupdf.pdf_document_hints_loaded_get, _mupdf.pdf_document_hints_loaded_set)
    hint_page = property(_mupdf.pdf_document_hint_page_get, _mupdf.pdf_document_hint_page_set)
    hint_shared_ref = property(_mupdf.pdf_document_hint_shared_ref_get, _mupdf.pdf_document_hint_shared_ref_set)
    hint_shared = property(_mupdf.pdf_document_hint_shared_get, _mupdf.pdf_document_hint_shared_set)
    hint_obj_offsets_max = property(_mupdf.pdf_document_hint_obj_offsets_max_get, _mupdf.pdf_document_hint_obj_offsets_max_set)
    hint_obj_offsets = property(_mupdf.pdf_document_hint_obj_offsets_get, _mupdf.pdf_document_hint_obj_offsets_set)
    resources_localised = property(_mupdf.pdf_document_resources_localised_get, _mupdf.pdf_document_resources_localised_set)
    lexbuf = property(_mupdf.pdf_document_lexbuf_get, _mupdf.pdf_document_lexbuf_set)
    js = property(_mupdf.pdf_document_js_get, _mupdf.pdf_document_js_set)
    recalculate = property(_mupdf.pdf_document_recalculate_get, _mupdf.pdf_document_recalculate_set)
    redacted = property(_mupdf.pdf_document_redacted_get, _mupdf.pdf_document_redacted_set)
    resynth_required = property(_mupdf.pdf_document_resynth_required_get, _mupdf.pdf_document_resynth_required_set)
    event_cb = property(_mupdf.pdf_document_event_cb_get, _mupdf.pdf_document_event_cb_set)
    free_event_data_cb = property(_mupdf.pdf_document_free_event_data_cb_get, _mupdf.pdf_document_free_event_data_cb_set)
    event_cb_data = property(_mupdf.pdf_document_event_cb_data_get, _mupdf.pdf_document_event_cb_data_set)
    num_type3_fonts = property(_mupdf.pdf_document_num_type3_fonts_get, _mupdf.pdf_document_num_type3_fonts_set)
    max_type3_fonts = property(_mupdf.pdf_document_max_type3_fonts_get, _mupdf.pdf_document_max_type3_fonts_set)
    type3_fonts = property(_mupdf.pdf_document_type3_fonts_get, _mupdf.pdf_document_type3_fonts_set)
    orphans_max = property(_mupdf.pdf_document_orphans_max_get, _mupdf.pdf_document_orphans_max_set)
    orphans_count = property(_mupdf.pdf_document_orphans_count_get, _mupdf.pdf_document_orphans_count_set)
    orphans = property(_mupdf.pdf_document_orphans_get, _mupdf.pdf_document_orphans_set)
    xfa = property(_mupdf.pdf_document_xfa_get, _mupdf.pdf_document_xfa_set)
    journal = property(_mupdf.pdf_document_journal_get, _mupdf.pdf_document_journal_set)

    def __init__(self):
        _mupdf.pdf_document_swiginit(self, _mupdf.new_pdf_document())
    __swig_destroy__ = _mupdf.delete_pdf_document

# Register pdf_document in _mupdf:
_mupdf.pdf_document_swigregister(pdf_document)
PDF_PAGE_LABEL_NONE = _mupdf.PDF_PAGE_LABEL_NONE
PDF_PAGE_LABEL_DECIMAL = _mupdf.PDF_PAGE_LABEL_DECIMAL
PDF_PAGE_LABEL_ROMAN_UC = _mupdf.PDF_PAGE_LABEL_ROMAN_UC
PDF_PAGE_LABEL_ROMAN_LC = _mupdf.PDF_PAGE_LABEL_ROMAN_LC
PDF_PAGE_LABEL_ALPHA_UC = _mupdf.PDF_PAGE_LABEL_ALPHA_UC
PDF_PAGE_LABEL_ALPHA_LC = _mupdf.PDF_PAGE_LABEL_ALPHA_LC
class pdf_write_options(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    do_incremental = property(_mupdf.pdf_write_options_do_incremental_get, _mupdf.pdf_write_options_do_incremental_set)
    do_pretty = property(_mupdf.pdf_write_options_do_pretty_get, _mupdf.pdf_write_options_do_pretty_set)
    do_ascii = property(_mupdf.pdf_write_options_do_ascii_get, _mupdf.pdf_write_options_do_ascii_set)
    do_compress = property(_mupdf.pdf_write_options_do_compress_get, _mupdf.pdf_write_options_do_compress_set)
    do_compress_images = property(_mupdf.pdf_write_options_do_compress_images_get, _mupdf.pdf_write_options_do_compress_images_set)
    do_compress_fonts = property(_mupdf.pdf_write_options_do_compress_fonts_get, _mupdf.pdf_write_options_do_compress_fonts_set)
    do_decompress = property(_mupdf.pdf_write_options_do_decompress_get, _mupdf.pdf_write_options_do_decompress_set)
    do_garbage = property(_mupdf.pdf_write_options_do_garbage_get, _mupdf.pdf_write_options_do_garbage_set)
    do_linear = property(_mupdf.pdf_write_options_do_linear_get, _mupdf.pdf_write_options_do_linear_set)
    do_clean = property(_mupdf.pdf_write_options_do_clean_get, _mupdf.pdf_write_options_do_clean_set)
    do_sanitize = property(_mupdf.pdf_write_options_do_sanitize_get, _mupdf.pdf_write_options_do_sanitize_set)
    do_appearance = property(_mupdf.pdf_write_options_do_appearance_get, _mupdf.pdf_write_options_do_appearance_set)
    do_encrypt = property(_mupdf.pdf_write_options_do_encrypt_get, _mupdf.pdf_write_options_do_encrypt_set)
    dont_regenerate_id = property(_mupdf.pdf_write_options_dont_regenerate_id_get, _mupdf.pdf_write_options_dont_regenerate_id_set)
    permissions = property(_mupdf.pdf_write_options_permissions_get, _mupdf.pdf_write_options_permissions_set)
    opwd_utf8 = property(_mupdf.pdf_write_options_opwd_utf8_get, _mupdf.pdf_write_options_opwd_utf8_set)
    upwd_utf8 = property(_mupdf.pdf_write_options_upwd_utf8_get, _mupdf.pdf_write_options_upwd_utf8_set)
    do_snapshot = property(_mupdf.pdf_write_options_do_snapshot_get, _mupdf.pdf_write_options_do_snapshot_set)
    do_preserve_metadata = property(_mupdf.pdf_write_options_do_preserve_metadata_get, _mupdf.pdf_write_options_do_preserve_metadata_set)
    do_use_objstms = property(_mupdf.pdf_write_options_do_use_objstms_get, _mupdf.pdf_write_options_do_use_objstms_set)
    compression_effort = property(_mupdf.pdf_write_options_compression_effort_get, _mupdf.pdf_write_options_compression_effort_set)

    def __init__(self):
        _mupdf.pdf_write_options_swiginit(self, _mupdf.new_pdf_write_options())
    __swig_destroy__ = _mupdf.delete_pdf_write_options

# Register pdf_write_options in _mupdf:
_mupdf.pdf_write_options_swigregister(pdf_write_options)
PDF_TOK_ERROR = _mupdf.PDF_TOK_ERROR
PDF_TOK_EOF = _mupdf.PDF_TOK_EOF
PDF_TOK_OPEN_ARRAY = _mupdf.PDF_TOK_OPEN_ARRAY
PDF_TOK_CLOSE_ARRAY = _mupdf.PDF_TOK_CLOSE_ARRAY
PDF_TOK_OPEN_DICT = _mupdf.PDF_TOK_OPEN_DICT
PDF_TOK_CLOSE_DICT = _mupdf.PDF_TOK_CLOSE_DICT
PDF_TOK_OPEN_BRACE = _mupdf.PDF_TOK_OPEN_BRACE
PDF_TOK_CLOSE_BRACE = _mupdf.PDF_TOK_CLOSE_BRACE
PDF_TOK_NAME = _mupdf.PDF_TOK_NAME
PDF_TOK_INT = _mupdf.PDF_TOK_INT
PDF_TOK_REAL = _mupdf.PDF_TOK_REAL
PDF_TOK_STRING = _mupdf.PDF_TOK_STRING
PDF_TOK_KEYWORD = _mupdf.PDF_TOK_KEYWORD
PDF_TOK_R = _mupdf.PDF_TOK_R
PDF_TOK_TRUE = _mupdf.PDF_TOK_TRUE
PDF_TOK_FALSE = _mupdf.PDF_TOK_FALSE
PDF_TOK_NULL = _mupdf.PDF_TOK_NULL
PDF_TOK_OBJ = _mupdf.PDF_TOK_OBJ
PDF_TOK_ENDOBJ = _mupdf.PDF_TOK_ENDOBJ
PDF_TOK_STREAM = _mupdf.PDF_TOK_STREAM
PDF_TOK_ENDSTREAM = _mupdf.PDF_TOK_ENDSTREAM
PDF_TOK_XREF = _mupdf.PDF_TOK_XREF
PDF_TOK_TRAILER = _mupdf.PDF_TOK_TRAILER
PDF_TOK_STARTXREF = _mupdf.PDF_TOK_STARTXREF
PDF_TOK_NEWOBJ = _mupdf.PDF_TOK_NEWOBJ
PDF_NUM_TOKENS = _mupdf.PDF_NUM_TOKENS
class pdf_xref_entry(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    type = property(_mupdf.pdf_xref_entry_type_get, _mupdf.pdf_xref_entry_type_set)
    marked = property(_mupdf.pdf_xref_entry_marked_get, _mupdf.pdf_xref_entry_marked_set)
    gen = property(_mupdf.pdf_xref_entry_gen_get, _mupdf.pdf_xref_entry_gen_set)
    num = property(_mupdf.pdf_xref_entry_num_get, _mupdf.pdf_xref_entry_num_set)
    ofs = property(_mupdf.pdf_xref_entry_ofs_get, _mupdf.pdf_xref_entry_ofs_set)
    stm_ofs = property(_mupdf.pdf_xref_entry_stm_ofs_get, _mupdf.pdf_xref_entry_stm_ofs_set)
    stm_buf = property(_mupdf.pdf_xref_entry_stm_buf_get, _mupdf.pdf_xref_entry_stm_buf_set)
    obj = property(_mupdf.pdf_xref_entry_obj_get, _mupdf.pdf_xref_entry_obj_set)

    def __init__(self):
        _mupdf.pdf_xref_entry_swiginit(self, _mupdf.new_pdf_xref_entry())
    __swig_destroy__ = _mupdf.delete_pdf_xref_entry

# Register pdf_xref_entry in _mupdf:
_mupdf.pdf_xref_entry_swigregister(pdf_xref_entry)
pdf_default_write_options = cvar.pdf_default_write_options

class pdf_xref_subsec(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    next = property(_mupdf.pdf_xref_subsec_next_get, _mupdf.pdf_xref_subsec_next_set)
    len = property(_mupdf.pdf_xref_subsec_len_get, _mupdf.pdf_xref_subsec_len_set)
    start = property(_mupdf.pdf_xref_subsec_start_get, _mupdf.pdf_xref_subsec_start_set)
    table = property(_mupdf.pdf_xref_subsec_table_get, _mupdf.pdf_xref_subsec_table_set)

    def __init__(self):
        _mupdf.pdf_xref_subsec_swiginit(self, _mupdf.new_pdf_xref_subsec())
    __swig_destroy__ = _mupdf.delete_pdf_xref_subsec

# Register pdf_xref_subsec in _mupdf:
_mupdf.pdf_xref_subsec_swigregister(pdf_xref_subsec)
class pdf_xref(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    num_objects = property(_mupdf.pdf_xref_num_objects_get, _mupdf.pdf_xref_num_objects_set)
    subsec = property(_mupdf.pdf_xref_subsec_get, _mupdf.pdf_xref_subsec_set)
    trailer = property(_mupdf.pdf_xref_trailer_get, _mupdf.pdf_xref_trailer_set)
    pre_repair_trailer = property(_mupdf.pdf_xref_pre_repair_trailer_get, _mupdf.pdf_xref_pre_repair_trailer_set)
    unsaved_sigs = property(_mupdf.pdf_xref_unsaved_sigs_get, _mupdf.pdf_xref_unsaved_sigs_set)
    unsaved_sigs_end = property(_mupdf.pdf_xref_unsaved_sigs_end_get, _mupdf.pdf_xref_unsaved_sigs_end_set)
    end_ofs = property(_mupdf.pdf_xref_end_ofs_get, _mupdf.pdf_xref_end_ofs_set)

    def __init__(self):
        _mupdf.pdf_xref_swiginit(self, _mupdf.new_pdf_xref())
    __swig_destroy__ = _mupdf.delete_pdf_xref

# Register pdf_xref in _mupdf:
_mupdf.pdf_xref_swigregister(pdf_xref)
PDF_ENCRYPT_KEEP = _mupdf.PDF_ENCRYPT_KEEP
PDF_ENCRYPT_NONE = _mupdf.PDF_ENCRYPT_NONE
PDF_ENCRYPT_RC4_40 = _mupdf.PDF_ENCRYPT_RC4_40
PDF_ENCRYPT_RC4_128 = _mupdf.PDF_ENCRYPT_RC4_128
PDF_ENCRYPT_AES_128 = _mupdf.PDF_ENCRYPT_AES_128
PDF_ENCRYPT_AES_256 = _mupdf.PDF_ENCRYPT_AES_256
PDF_ENCRYPT_UNKNOWN = _mupdf.PDF_ENCRYPT_UNKNOWN
PDF_PERM_PRINT = _mupdf.PDF_PERM_PRINT
PDF_PERM_MODIFY = _mupdf.PDF_PERM_MODIFY
PDF_PERM_COPY = _mupdf.PDF_PERM_COPY
PDF_PERM_ANNOTATE = _mupdf.PDF_PERM_ANNOTATE
PDF_PERM_FORM = _mupdf.PDF_PERM_FORM
PDF_PERM_ACCESSIBILITY = _mupdf.PDF_PERM_ACCESSIBILITY
PDF_PERM_ASSEMBLE = _mupdf.PDF_PERM_ASSEMBLE
PDF_PERM_PRINT_HQ = _mupdf.PDF_PERM_PRINT_HQ
PDF_MRANGE_CAP = _mupdf.PDF_MRANGE_CAP
class pdf_range(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    low = property(_mupdf.pdf_range_low_get, _mupdf.pdf_range_low_set)
    high = property(_mupdf.pdf_range_high_get, _mupdf.pdf_range_high_set)
    out = property(_mupdf.pdf_range_out_get, _mupdf.pdf_range_out_set)

    def __init__(self):
        _mupdf.pdf_range_swiginit(self, _mupdf.new_pdf_range())
    __swig_destroy__ = _mupdf.delete_pdf_range

# Register pdf_range in _mupdf:
_mupdf.pdf_range_swigregister(pdf_range)
class pdf_xrange(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    low = property(_mupdf.pdf_xrange_low_get, _mupdf.pdf_xrange_low_set)
    high = property(_mupdf.pdf_xrange_high_get, _mupdf.pdf_xrange_high_set)
    out = property(_mupdf.pdf_xrange_out_get, _mupdf.pdf_xrange_out_set)

    def __init__(self):
        _mupdf.pdf_xrange_swiginit(self, _mupdf.new_pdf_xrange())
    __swig_destroy__ = _mupdf.delete_pdf_xrange

# Register pdf_xrange in _mupdf:
_mupdf.pdf_xrange_swigregister(pdf_xrange)
class pdf_mrange(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    low = property(_mupdf.pdf_mrange_low_get, _mupdf.pdf_mrange_low_set)
    out = property(_mupdf.pdf_mrange_out_get, _mupdf.pdf_mrange_out_set)

    def __init__(self):
        _mupdf.pdf_mrange_swiginit(self, _mupdf.new_pdf_mrange())
    __swig_destroy__ = _mupdf.delete_pdf_mrange

# Register pdf_mrange in _mupdf:
_mupdf.pdf_mrange_swigregister(pdf_mrange)
class pdf_cmap(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    storable = property(_mupdf.pdf_cmap_storable_get, _mupdf.pdf_cmap_storable_set)
    cmap_name = property(_mupdf.pdf_cmap_cmap_name_get, _mupdf.pdf_cmap_cmap_name_set)
    usecmap_name = property(_mupdf.pdf_cmap_usecmap_name_get, _mupdf.pdf_cmap_usecmap_name_set)
    usecmap = property(_mupdf.pdf_cmap_usecmap_get, _mupdf.pdf_cmap_usecmap_set)
    wmode = property(_mupdf.pdf_cmap_wmode_get, _mupdf.pdf_cmap_wmode_set)
    codespace_len = property(_mupdf.pdf_cmap_codespace_len_get, _mupdf.pdf_cmap_codespace_len_set)
    rlen = property(_mupdf.pdf_cmap_rlen_get, _mupdf.pdf_cmap_rlen_set)
    rcap = property(_mupdf.pdf_cmap_rcap_get, _mupdf.pdf_cmap_rcap_set)
    ranges = property(_mupdf.pdf_cmap_ranges_get, _mupdf.pdf_cmap_ranges_set)
    xlen = property(_mupdf.pdf_cmap_xlen_get, _mupdf.pdf_cmap_xlen_set)
    xcap = property(_mupdf.pdf_cmap_xcap_get, _mupdf.pdf_cmap_xcap_set)
    xranges = property(_mupdf.pdf_cmap_xranges_get, _mupdf.pdf_cmap_xranges_set)
    mlen = property(_mupdf.pdf_cmap_mlen_get, _mupdf.pdf_cmap_mlen_set)
    mcap = property(_mupdf.pdf_cmap_mcap_get, _mupdf.pdf_cmap_mcap_set)
    mranges = property(_mupdf.pdf_cmap_mranges_get, _mupdf.pdf_cmap_mranges_set)
    dlen = property(_mupdf.pdf_cmap_dlen_get, _mupdf.pdf_cmap_dlen_set)
    dcap = property(_mupdf.pdf_cmap_dcap_get, _mupdf.pdf_cmap_dcap_set)
    dict = property(_mupdf.pdf_cmap_dict_get, _mupdf.pdf_cmap_dict_set)
    tlen = property(_mupdf.pdf_cmap_tlen_get, _mupdf.pdf_cmap_tlen_set)
    tcap = property(_mupdf.pdf_cmap_tcap_get, _mupdf.pdf_cmap_tcap_set)
    ttop = property(_mupdf.pdf_cmap_ttop_get, _mupdf.pdf_cmap_ttop_set)
    tree = property(_mupdf.pdf_cmap_tree_get, _mupdf.pdf_cmap_tree_set)

    def __init__(self):
        _mupdf.pdf_cmap_swiginit(self, _mupdf.new_pdf_cmap())
    __swig_destroy__ = _mupdf.delete_pdf_cmap

# Register pdf_cmap in _mupdf:
_mupdf.pdf_cmap_swigregister(pdf_cmap)
PDF_FD_FIXED_PITCH = _mupdf.PDF_FD_FIXED_PITCH
PDF_FD_SERIF = _mupdf.PDF_FD_SERIF
PDF_FD_SYMBOLIC = _mupdf.PDF_FD_SYMBOLIC
PDF_FD_SCRIPT = _mupdf.PDF_FD_SCRIPT
PDF_FD_NONSYMBOLIC = _mupdf.PDF_FD_NONSYMBOLIC
PDF_FD_ITALIC = _mupdf.PDF_FD_ITALIC
PDF_FD_ALL_CAP = _mupdf.PDF_FD_ALL_CAP
PDF_FD_SMALL_CAP = _mupdf.PDF_FD_SMALL_CAP
PDF_FD_FORCE_BOLD = _mupdf.PDF_FD_FORCE_BOLD
class pdf_hmtx(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    lo = property(_mupdf.pdf_hmtx_lo_get, _mupdf.pdf_hmtx_lo_set)
    hi = property(_mupdf.pdf_hmtx_hi_get, _mupdf.pdf_hmtx_hi_set)
    w = property(_mupdf.pdf_hmtx_w_get, _mupdf.pdf_hmtx_w_set)

    def __init__(self):
        _mupdf.pdf_hmtx_swiginit(self, _mupdf.new_pdf_hmtx())
    __swig_destroy__ = _mupdf.delete_pdf_hmtx

# Register pdf_hmtx in _mupdf:
_mupdf.pdf_hmtx_swigregister(pdf_hmtx)
class pdf_vmtx(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    lo = property(_mupdf.pdf_vmtx_lo_get, _mupdf.pdf_vmtx_lo_set)
    hi = property(_mupdf.pdf_vmtx_hi_get, _mupdf.pdf_vmtx_hi_set)
    x = property(_mupdf.pdf_vmtx_x_get, _mupdf.pdf_vmtx_x_set)
    y = property(_mupdf.pdf_vmtx_y_get, _mupdf.pdf_vmtx_y_set)
    w = property(_mupdf.pdf_vmtx_w_get, _mupdf.pdf_vmtx_w_set)

    def __init__(self):
        _mupdf.pdf_vmtx_swiginit(self, _mupdf.new_pdf_vmtx())
    __swig_destroy__ = _mupdf.delete_pdf_vmtx

# Register pdf_vmtx in _mupdf:
_mupdf.pdf_vmtx_swigregister(pdf_vmtx)
class pdf_font_desc(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    storable = property(_mupdf.pdf_font_desc_storable_get, _mupdf.pdf_font_desc_storable_set)
    size = property(_mupdf.pdf_font_desc_size_get, _mupdf.pdf_font_desc_size_set)
    font = property(_mupdf.pdf_font_desc_font_get, _mupdf.pdf_font_desc_font_set)
    flags = property(_mupdf.pdf_font_desc_flags_get, _mupdf.pdf_font_desc_flags_set)
    italic_angle = property(_mupdf.pdf_font_desc_italic_angle_get, _mupdf.pdf_font_desc_italic_angle_set)
    ascent = property(_mupdf.pdf_font_desc_ascent_get, _mupdf.pdf_font_desc_ascent_set)
    descent = property(_mupdf.pdf_font_desc_descent_get, _mupdf.pdf_font_desc_descent_set)
    cap_height = property(_mupdf.pdf_font_desc_cap_height_get, _mupdf.pdf_font_desc_cap_height_set)
    x_height = property(_mupdf.pdf_font_desc_x_height_get, _mupdf.pdf_font_desc_x_height_set)
    missing_width = property(_mupdf.pdf_font_desc_missing_width_get, _mupdf.pdf_font_desc_missing_width_set)
    encoding = property(_mupdf.pdf_font_desc_encoding_get, _mupdf.pdf_font_desc_encoding_set)
    to_ttf_cmap = property(_mupdf.pdf_font_desc_to_ttf_cmap_get, _mupdf.pdf_font_desc_to_ttf_cmap_set)
    cid_to_gid_len = property(_mupdf.pdf_font_desc_cid_to_gid_len_get, _mupdf.pdf_font_desc_cid_to_gid_len_set)
    cid_to_gid = property(_mupdf.pdf_font_desc_cid_to_gid_get, _mupdf.pdf_font_desc_cid_to_gid_set)
    to_unicode = property(_mupdf.pdf_font_desc_to_unicode_get, _mupdf.pdf_font_desc_to_unicode_set)
    cid_to_ucs_len = property(_mupdf.pdf_font_desc_cid_to_ucs_len_get, _mupdf.pdf_font_desc_cid_to_ucs_len_set)
    cid_to_ucs = property(_mupdf.pdf_font_desc_cid_to_ucs_get, _mupdf.pdf_font_desc_cid_to_ucs_set)
    wmode = property(_mupdf.pdf_font_desc_wmode_get, _mupdf.pdf_font_desc_wmode_set)
    hmtx_len = property(_mupdf.pdf_font_desc_hmtx_len_get, _mupdf.pdf_font_desc_hmtx_len_set)
    hmtx_cap = property(_mupdf.pdf_font_desc_hmtx_cap_get, _mupdf.pdf_font_desc_hmtx_cap_set)
    dhmtx = property(_mupdf.pdf_font_desc_dhmtx_get, _mupdf.pdf_font_desc_dhmtx_set)
    hmtx = property(_mupdf.pdf_font_desc_hmtx_get, _mupdf.pdf_font_desc_hmtx_set)
    vmtx_len = property(_mupdf.pdf_font_desc_vmtx_len_get, _mupdf.pdf_font_desc_vmtx_len_set)
    vmtx_cap = property(_mupdf.pdf_font_desc_vmtx_cap_get, _mupdf.pdf_font_desc_vmtx_cap_set)
    dvmtx = property(_mupdf.pdf_font_desc_dvmtx_get, _mupdf.pdf_font_desc_dvmtx_set)
    vmtx = property(_mupdf.pdf_font_desc_vmtx_get, _mupdf.pdf_font_desc_vmtx_set)
    is_embedded = property(_mupdf.pdf_font_desc_is_embedded_get, _mupdf.pdf_font_desc_is_embedded_set)
    t3loading = property(_mupdf.pdf_font_desc_t3loading_get, _mupdf.pdf_font_desc_t3loading_set)

    def __init__(self):
        _mupdf.pdf_font_desc_swiginit(self, _mupdf.new_pdf_font_desc())
    __swig_destroy__ = _mupdf.delete_pdf_font_desc

# Register pdf_font_desc in _mupdf:
_mupdf.pdf_font_desc_swigregister(pdf_font_desc)
PDF_SIMPLE_FONT_RESOURCE = _mupdf.PDF_SIMPLE_FONT_RESOURCE
PDF_CID_FONT_RESOURCE = _mupdf.PDF_CID_FONT_RESOURCE
PDF_CJK_FONT_RESOURCE = _mupdf.PDF_CJK_FONT_RESOURCE
PDF_SIMPLE_ENCODING_LATIN = _mupdf.PDF_SIMPLE_ENCODING_LATIN
PDF_SIMPLE_ENCODING_GREEK = _mupdf.PDF_SIMPLE_ENCODING_GREEK
PDF_SIMPLE_ENCODING_CYRILLIC = _mupdf.PDF_SIMPLE_ENCODING_CYRILLIC
class pdf_font_resource_key(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    digest = property(_mupdf.pdf_font_resource_key_digest_get, _mupdf.pdf_font_resource_key_digest_set)
    type = property(_mupdf.pdf_font_resource_key_type_get, _mupdf.pdf_font_resource_key_type_set)
    encoding = property(_mupdf.pdf_font_resource_key_encoding_get, _mupdf.pdf_font_resource_key_encoding_set)
    local_xref = property(_mupdf.pdf_font_resource_key_local_xref_get, _mupdf.pdf_font_resource_key_local_xref_set)

    def __init__(self):
        _mupdf.pdf_font_resource_key_swiginit(self, _mupdf.new_pdf_font_resource_key())
    __swig_destroy__ = _mupdf.delete_pdf_font_resource_key

# Register pdf_font_resource_key in _mupdf:
_mupdf.pdf_font_resource_key_swigregister(pdf_font_resource_key)
class pdf_pattern(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    storable = property(_mupdf.pdf_pattern_storable_get, _mupdf.pdf_pattern_storable_set)
    ismask = property(_mupdf.pdf_pattern_ismask_get, _mupdf.pdf_pattern_ismask_set)
    xstep = property(_mupdf.pdf_pattern_xstep_get, _mupdf.pdf_pattern_xstep_set)
    ystep = property(_mupdf.pdf_pattern_ystep_get, _mupdf.pdf_pattern_ystep_set)
    matrix = property(_mupdf.pdf_pattern_matrix_get, _mupdf.pdf_pattern_matrix_set)
    bbox = property(_mupdf.pdf_pattern_bbox_get, _mupdf.pdf_pattern_bbox_set)
    document = property(_mupdf.pdf_pattern_document_get, _mupdf.pdf_pattern_document_set)
    resources = property(_mupdf.pdf_pattern_resources_get, _mupdf.pdf_pattern_resources_set)
    contents = property(_mupdf.pdf_pattern_contents_get, _mupdf.pdf_pattern_contents_set)
    id = property(_mupdf.pdf_pattern_id_get, _mupdf.pdf_pattern_id_set)

    def __init__(self):
        _mupdf.pdf_pattern_swiginit(self, _mupdf.new_pdf_pattern())
    __swig_destroy__ = _mupdf.delete_pdf_pattern

# Register pdf_pattern in _mupdf:
_mupdf.pdf_pattern_swigregister(pdf_pattern)
PDF_PROCESSOR_REQUIRES_DECODED_IMAGES = _mupdf.PDF_PROCESSOR_REQUIRES_DECODED_IMAGES
class pdf_processor(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    refs = property(_mupdf.pdf_processor_refs_get, _mupdf.pdf_processor_refs_set)
    closed = property(_mupdf.pdf_processor_closed_get, _mupdf.pdf_processor_closed_set)
    close_processor = property(_mupdf.pdf_processor_close_processor_get, _mupdf.pdf_processor_close_processor_set)
    drop_processor = property(_mupdf.pdf_processor_drop_processor_get, _mupdf.pdf_processor_drop_processor_set)
    reset_processor = property(_mupdf.pdf_processor_reset_processor_get, _mupdf.pdf_processor_reset_processor_set)
    push_resources = property(_mupdf.pdf_processor_push_resources_get, _mupdf.pdf_processor_push_resources_set)
    pop_resources = property(_mupdf.pdf_processor_pop_resources_get, _mupdf.pdf_processor_pop_resources_set)
    op_w = property(_mupdf.pdf_processor_op_w_get, _mupdf.pdf_processor_op_w_set)
    op_j = property(_mupdf.pdf_processor_op_j_get, _mupdf.pdf_processor_op_j_set)
    op_J = property(_mupdf.pdf_processor_op_J_get, _mupdf.pdf_processor_op_J_set)
    op_M = property(_mupdf.pdf_processor_op_M_get, _mupdf.pdf_processor_op_M_set)
    op_d = property(_mupdf.pdf_processor_op_d_get, _mupdf.pdf_processor_op_d_set)
    op_ri = property(_mupdf.pdf_processor_op_ri_get, _mupdf.pdf_processor_op_ri_set)
    op_i = property(_mupdf.pdf_processor_op_i_get, _mupdf.pdf_processor_op_i_set)
    op_gs_begin = property(_mupdf.pdf_processor_op_gs_begin_get, _mupdf.pdf_processor_op_gs_begin_set)
    op_gs_BM = property(_mupdf.pdf_processor_op_gs_BM_get, _mupdf.pdf_processor_op_gs_BM_set)
    op_gs_ca = property(_mupdf.pdf_processor_op_gs_ca_get, _mupdf.pdf_processor_op_gs_ca_set)
    op_gs_CA = property(_mupdf.pdf_processor_op_gs_CA_get, _mupdf.pdf_processor_op_gs_CA_set)
    op_gs_SMask = property(_mupdf.pdf_processor_op_gs_SMask_get, _mupdf.pdf_processor_op_gs_SMask_set)
    op_gs_end = property(_mupdf.pdf_processor_op_gs_end_get, _mupdf.pdf_processor_op_gs_end_set)
    op_q = property(_mupdf.pdf_processor_op_q_get, _mupdf.pdf_processor_op_q_set)
    op_Q = property(_mupdf.pdf_processor_op_Q_get, _mupdf.pdf_processor_op_Q_set)
    op_cm = property(_mupdf.pdf_processor_op_cm_get, _mupdf.pdf_processor_op_cm_set)
    op_m = property(_mupdf.pdf_processor_op_m_get, _mupdf.pdf_processor_op_m_set)
    op_l = property(_mupdf.pdf_processor_op_l_get, _mupdf.pdf_processor_op_l_set)
    op_c = property(_mupdf.pdf_processor_op_c_get, _mupdf.pdf_processor_op_c_set)
    op_v = property(_mupdf.pdf_processor_op_v_get, _mupdf.pdf_processor_op_v_set)
    op_y = property(_mupdf.pdf_processor_op_y_get, _mupdf.pdf_processor_op_y_set)
    op_h = property(_mupdf.pdf_processor_op_h_get, _mupdf.pdf_processor_op_h_set)
    op_re = property(_mupdf.pdf_processor_op_re_get, _mupdf.pdf_processor_op_re_set)
    op_S = property(_mupdf.pdf_processor_op_S_get, _mupdf.pdf_processor_op_S_set)
    op_s = property(_mupdf.pdf_processor_op_s_get, _mupdf.pdf_processor_op_s_set)
    op_F = property(_mupdf.pdf_processor_op_F_get, _mupdf.pdf_processor_op_F_set)
    op_f = property(_mupdf.pdf_processor_op_f_get, _mupdf.pdf_processor_op_f_set)
    op_fstar = property(_mupdf.pdf_processor_op_fstar_get, _mupdf.pdf_processor_op_fstar_set)
    op_B = property(_mupdf.pdf_processor_op_B_get, _mupdf.pdf_processor_op_B_set)
    op_Bstar = property(_mupdf.pdf_processor_op_Bstar_get, _mupdf.pdf_processor_op_Bstar_set)
    op_b = property(_mupdf.pdf_processor_op_b_get, _mupdf.pdf_processor_op_b_set)
    op_bstar = property(_mupdf.pdf_processor_op_bstar_get, _mupdf.pdf_processor_op_bstar_set)
    op_n = property(_mupdf.pdf_processor_op_n_get, _mupdf.pdf_processor_op_n_set)
    op_W = property(_mupdf.pdf_processor_op_W_get, _mupdf.pdf_processor_op_W_set)
    op_Wstar = property(_mupdf.pdf_processor_op_Wstar_get, _mupdf.pdf_processor_op_Wstar_set)
    op_BT = property(_mupdf.pdf_processor_op_BT_get, _mupdf.pdf_processor_op_BT_set)
    op_ET = property(_mupdf.pdf_processor_op_ET_get, _mupdf.pdf_processor_op_ET_set)
    op_Tc = property(_mupdf.pdf_processor_op_Tc_get, _mupdf.pdf_processor_op_Tc_set)
    op_Tw = property(_mupdf.pdf_processor_op_Tw_get, _mupdf.pdf_processor_op_Tw_set)
    op_Tz = property(_mupdf.pdf_processor_op_Tz_get, _mupdf.pdf_processor_op_Tz_set)
    op_TL = property(_mupdf.pdf_processor_op_TL_get, _mupdf.pdf_processor_op_TL_set)
    op_Tf = property(_mupdf.pdf_processor_op_Tf_get, _mupdf.pdf_processor_op_Tf_set)
    op_Tr = property(_mupdf.pdf_processor_op_Tr_get, _mupdf.pdf_processor_op_Tr_set)
    op_Ts = property(_mupdf.pdf_processor_op_Ts_get, _mupdf.pdf_processor_op_Ts_set)
    op_Td = property(_mupdf.pdf_processor_op_Td_get, _mupdf.pdf_processor_op_Td_set)
    op_TD = property(_mupdf.pdf_processor_op_TD_get, _mupdf.pdf_processor_op_TD_set)
    op_Tm = property(_mupdf.pdf_processor_op_Tm_get, _mupdf.pdf_processor_op_Tm_set)
    op_Tstar = property(_mupdf.pdf_processor_op_Tstar_get, _mupdf.pdf_processor_op_Tstar_set)
    op_TJ = property(_mupdf.pdf_processor_op_TJ_get, _mupdf.pdf_processor_op_TJ_set)
    op_Tj = property(_mupdf.pdf_processor_op_Tj_get, _mupdf.pdf_processor_op_Tj_set)
    op_squote = property(_mupdf.pdf_processor_op_squote_get, _mupdf.pdf_processor_op_squote_set)
    op_dquote = property(_mupdf.pdf_processor_op_dquote_get, _mupdf.pdf_processor_op_dquote_set)
    op_d0 = property(_mupdf.pdf_processor_op_d0_get, _mupdf.pdf_processor_op_d0_set)
    op_d1 = property(_mupdf.pdf_processor_op_d1_get, _mupdf.pdf_processor_op_d1_set)
    op_CS = property(_mupdf.pdf_processor_op_CS_get, _mupdf.pdf_processor_op_CS_set)
    op_cs = property(_mupdf.pdf_processor_op_cs_get, _mupdf.pdf_processor_op_cs_set)
    op_SC_pattern = property(_mupdf.pdf_processor_op_SC_pattern_get, _mupdf.pdf_processor_op_SC_pattern_set)
    op_sc_pattern = property(_mupdf.pdf_processor_op_sc_pattern_get, _mupdf.pdf_processor_op_sc_pattern_set)
    op_SC_shade = property(_mupdf.pdf_processor_op_SC_shade_get, _mupdf.pdf_processor_op_SC_shade_set)
    op_sc_shade = property(_mupdf.pdf_processor_op_sc_shade_get, _mupdf.pdf_processor_op_sc_shade_set)
    op_SC_color = property(_mupdf.pdf_processor_op_SC_color_get, _mupdf.pdf_processor_op_SC_color_set)
    op_sc_color = property(_mupdf.pdf_processor_op_sc_color_get, _mupdf.pdf_processor_op_sc_color_set)
    op_G = property(_mupdf.pdf_processor_op_G_get, _mupdf.pdf_processor_op_G_set)
    op_g = property(_mupdf.pdf_processor_op_g_get, _mupdf.pdf_processor_op_g_set)
    op_RG = property(_mupdf.pdf_processor_op_RG_get, _mupdf.pdf_processor_op_RG_set)
    op_rg = property(_mupdf.pdf_processor_op_rg_get, _mupdf.pdf_processor_op_rg_set)
    op_K = property(_mupdf.pdf_processor_op_K_get, _mupdf.pdf_processor_op_K_set)
    op_k = property(_mupdf.pdf_processor_op_k_get, _mupdf.pdf_processor_op_k_set)
    op_BI = property(_mupdf.pdf_processor_op_BI_get, _mupdf.pdf_processor_op_BI_set)
    op_sh = property(_mupdf.pdf_processor_op_sh_get, _mupdf.pdf_processor_op_sh_set)
    op_Do_image = property(_mupdf.pdf_processor_op_Do_image_get, _mupdf.pdf_processor_op_Do_image_set)
    op_Do_form = property(_mupdf.pdf_processor_op_Do_form_get, _mupdf.pdf_processor_op_Do_form_set)
    op_MP = property(_mupdf.pdf_processor_op_MP_get, _mupdf.pdf_processor_op_MP_set)
    op_DP = property(_mupdf.pdf_processor_op_DP_get, _mupdf.pdf_processor_op_DP_set)
    op_BMC = property(_mupdf.pdf_processor_op_BMC_get, _mupdf.pdf_processor_op_BMC_set)
    op_BDC = property(_mupdf.pdf_processor_op_BDC_get, _mupdf.pdf_processor_op_BDC_set)
    op_EMC = property(_mupdf.pdf_processor_op_EMC_get, _mupdf.pdf_processor_op_EMC_set)
    op_BX = property(_mupdf.pdf_processor_op_BX_get, _mupdf.pdf_processor_op_BX_set)
    op_EX = property(_mupdf.pdf_processor_op_EX_get, _mupdf.pdf_processor_op_EX_set)
    op_gs_OP = property(_mupdf.pdf_processor_op_gs_OP_get, _mupdf.pdf_processor_op_gs_OP_set)
    op_gs_op = property(_mupdf.pdf_processor_op_gs_op_get, _mupdf.pdf_processor_op_gs_op_set)
    op_gs_OPM = property(_mupdf.pdf_processor_op_gs_OPM_get, _mupdf.pdf_processor_op_gs_OPM_set)
    op_gs_UseBlackPtComp = property(_mupdf.pdf_processor_op_gs_UseBlackPtComp_get, _mupdf.pdf_processor_op_gs_UseBlackPtComp_set)
    op_END = property(_mupdf.pdf_processor_op_END_get, _mupdf.pdf_processor_op_END_set)
    usage = property(_mupdf.pdf_processor_usage_get, _mupdf.pdf_processor_usage_set)
    hidden = property(_mupdf.pdf_processor_hidden_get, _mupdf.pdf_processor_hidden_set)
    requirements = property(_mupdf.pdf_processor_requirements_get, _mupdf.pdf_processor_requirements_set)

    def __init__(self):
        _mupdf.pdf_processor_swiginit(self, _mupdf.new_pdf_processor())
    __swig_destroy__ = _mupdf.delete_pdf_processor

# Register pdf_processor in _mupdf:
_mupdf.pdf_processor_swigregister(pdf_processor)
class pdf_csi(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    doc = property(_mupdf.pdf_csi_doc_get, _mupdf.pdf_csi_doc_set)
    rdb = property(_mupdf.pdf_csi_rdb_get, _mupdf.pdf_csi_rdb_set)
    buf = property(_mupdf.pdf_csi_buf_get, _mupdf.pdf_csi_buf_set)
    cookie = property(_mupdf.pdf_csi_cookie_get, _mupdf.pdf_csi_cookie_set)
    gstate = property(_mupdf.pdf_csi_gstate_get, _mupdf.pdf_csi_gstate_set)
    xbalance = property(_mupdf.pdf_csi_xbalance_get, _mupdf.pdf_csi_xbalance_set)
    in_text = property(_mupdf.pdf_csi_in_text_get, _mupdf.pdf_csi_in_text_set)
    d1_rect = property(_mupdf.pdf_csi_d1_rect_get, _mupdf.pdf_csi_d1_rect_set)
    obj = property(_mupdf.pdf_csi_obj_get, _mupdf.pdf_csi_obj_set)
    name = property(_mupdf.pdf_csi_name_get, _mupdf.pdf_csi_name_set)
    string = property(_mupdf.pdf_csi_string_get, _mupdf.pdf_csi_string_set)
    string_len = property(_mupdf.pdf_csi_string_len_get, _mupdf.pdf_csi_string_len_set)
    top = property(_mupdf.pdf_csi_top_get, _mupdf.pdf_csi_top_set)
    stack = property(_mupdf.pdf_csi_stack_get, _mupdf.pdf_csi_stack_set)

    def __init__(self):
        _mupdf.pdf_csi_swiginit(self, _mupdf.new_pdf_csi())
    __swig_destroy__ = _mupdf.delete_pdf_csi

# Register pdf_csi in _mupdf:
_mupdf.pdf_csi_swigregister(pdf_csi)
class pdf_filter_factory(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    filter = property(_mupdf.pdf_filter_factory_filter_get, _mupdf.pdf_filter_factory_filter_set)
    options = property(_mupdf.pdf_filter_factory_options_get, _mupdf.pdf_filter_factory_options_set)

    def __init__(self):
        _mupdf.pdf_filter_factory_swiginit(self, _mupdf.new_pdf_filter_factory())
    __swig_destroy__ = _mupdf.delete_pdf_filter_factory

# Register pdf_filter_factory in _mupdf:
_mupdf.pdf_filter_factory_swigregister(pdf_filter_factory)
class pdf_filter_options(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    recurse = property(_mupdf.pdf_filter_options_recurse_get, _mupdf.pdf_filter_options_recurse_set)
    instance_forms = property(_mupdf.pdf_filter_options_instance_forms_get, _mupdf.pdf_filter_options_instance_forms_set)
    ascii = property(_mupdf.pdf_filter_options_ascii_get, _mupdf.pdf_filter_options_ascii_set)
    no_update = property(_mupdf.pdf_filter_options_no_update_get, _mupdf.pdf_filter_options_no_update_set)
    opaque = property(_mupdf.pdf_filter_options_opaque_get, _mupdf.pdf_filter_options_opaque_set)
    complete = property(_mupdf.pdf_filter_options_complete_get, _mupdf.pdf_filter_options_complete_set)
    filters = property(_mupdf.pdf_filter_options_filters_get, _mupdf.pdf_filter_options_filters_set)
    newlines = property(_mupdf.pdf_filter_options_newlines_get, _mupdf.pdf_filter_options_newlines_set)

    def __init__(self):
        _mupdf.pdf_filter_options_swiginit(self, _mupdf.new_pdf_filter_options())
    __swig_destroy__ = _mupdf.delete_pdf_filter_options

# Register pdf_filter_options in _mupdf:
_mupdf.pdf_filter_options_swigregister(pdf_filter_options)
FZ_CULL_PATH_FILL = _mupdf.FZ_CULL_PATH_FILL
FZ_CULL_PATH_STROKE = _mupdf.FZ_CULL_PATH_STROKE
FZ_CULL_PATH_FILL_STROKE = _mupdf.FZ_CULL_PATH_FILL_STROKE
FZ_CULL_CLIP_PATH = _mupdf.FZ_CULL_CLIP_PATH
FZ_CULL_GLYPH = _mupdf.FZ_CULL_GLYPH
FZ_CULL_IMAGE = _mupdf.FZ_CULL_IMAGE
FZ_CULL_SHADING = _mupdf.FZ_CULL_SHADING
class pdf_sanitize_filter_options(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    opaque = property(_mupdf.pdf_sanitize_filter_options_opaque_get, _mupdf.pdf_sanitize_filter_options_opaque_set)
    image_filter = property(_mupdf.pdf_sanitize_filter_options_image_filter_get, _mupdf.pdf_sanitize_filter_options_image_filter_set)
    text_filter = property(_mupdf.pdf_sanitize_filter_options_text_filter_get, _mupdf.pdf_sanitize_filter_options_text_filter_set)
    after_text_object = property(_mupdf.pdf_sanitize_filter_options_after_text_object_get, _mupdf.pdf_sanitize_filter_options_after_text_object_set)
    culler = property(_mupdf.pdf_sanitize_filter_options_culler_get, _mupdf.pdf_sanitize_filter_options_culler_set)

    def __init__(self):
        _mupdf.pdf_sanitize_filter_options_swiginit(self, _mupdf.new_pdf_sanitize_filter_options())
    __swig_destroy__ = _mupdf.delete_pdf_sanitize_filter_options

# Register pdf_sanitize_filter_options in _mupdf:
_mupdf.pdf_sanitize_filter_options_swigregister(pdf_sanitize_filter_options)
class pdf_color_filter_options(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    opaque = property(_mupdf.pdf_color_filter_options_opaque_get, _mupdf.pdf_color_filter_options_opaque_set)
    color_rewrite = property(_mupdf.pdf_color_filter_options_color_rewrite_get, _mupdf.pdf_color_filter_options_color_rewrite_set)
    image_rewrite = property(_mupdf.pdf_color_filter_options_image_rewrite_get, _mupdf.pdf_color_filter_options_image_rewrite_set)
    shade_rewrite = property(_mupdf.pdf_color_filter_options_shade_rewrite_get, _mupdf.pdf_color_filter_options_shade_rewrite_set)
    repeated_image_rewrite = property(_mupdf.pdf_color_filter_options_repeated_image_rewrite_get, _mupdf.pdf_color_filter_options_repeated_image_rewrite_set)

    def __init__(self):
        _mupdf.pdf_color_filter_options_swiginit(self, _mupdf.new_pdf_color_filter_options())
    __swig_destroy__ = _mupdf.delete_pdf_color_filter_options

# Register pdf_color_filter_options in _mupdf:
_mupdf.pdf_color_filter_options_swigregister(pdf_color_filter_options)
class pdf_text_state(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    char_space = property(_mupdf.pdf_text_state_char_space_get, _mupdf.pdf_text_state_char_space_set)
    word_space = property(_mupdf.pdf_text_state_word_space_get, _mupdf.pdf_text_state_word_space_set)
    scale = property(_mupdf.pdf_text_state_scale_get, _mupdf.pdf_text_state_scale_set)
    leading = property(_mupdf.pdf_text_state_leading_get, _mupdf.pdf_text_state_leading_set)
    font = property(_mupdf.pdf_text_state_font_get, _mupdf.pdf_text_state_font_set)
    fontname = property(_mupdf.pdf_text_state_fontname_get, _mupdf.pdf_text_state_fontname_set)
    size = property(_mupdf.pdf_text_state_size_get, _mupdf.pdf_text_state_size_set)
    render = property(_mupdf.pdf_text_state_render_get, _mupdf.pdf_text_state_render_set)
    rise = property(_mupdf.pdf_text_state_rise_get, _mupdf.pdf_text_state_rise_set)

    def __init__(self):
        _mupdf.pdf_text_state_swiginit(self, _mupdf.new_pdf_text_state())
    __swig_destroy__ = _mupdf.delete_pdf_text_state

# Register pdf_text_state in _mupdf:
_mupdf.pdf_text_state_swigregister(pdf_text_state)
class pdf_text_object_state(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    text = property(_mupdf.pdf_text_object_state_text_get, _mupdf.pdf_text_object_state_text_set)
    text_bbox = property(_mupdf.pdf_text_object_state_text_bbox_get, _mupdf.pdf_text_object_state_text_bbox_set)
    tlm = property(_mupdf.pdf_text_object_state_tlm_get, _mupdf.pdf_text_object_state_tlm_set)
    tm = property(_mupdf.pdf_text_object_state_tm_get, _mupdf.pdf_text_object_state_tm_set)
    text_mode = property(_mupdf.pdf_text_object_state_text_mode_get, _mupdf.pdf_text_object_state_text_mode_set)
    cid = property(_mupdf.pdf_text_object_state_cid_get, _mupdf.pdf_text_object_state_cid_set)
    gid = property(_mupdf.pdf_text_object_state_gid_get, _mupdf.pdf_text_object_state_gid_set)
    char_bbox = property(_mupdf.pdf_text_object_state_char_bbox_get, _mupdf.pdf_text_object_state_char_bbox_set)
    fontdesc = property(_mupdf.pdf_text_object_state_fontdesc_get, _mupdf.pdf_text_object_state_fontdesc_set)
    char_tx = property(_mupdf.pdf_text_object_state_char_tx_get, _mupdf.pdf_text_object_state_char_tx_set)
    char_ty = property(_mupdf.pdf_text_object_state_char_ty_get, _mupdf.pdf_text_object_state_char_ty_set)

    def __init__(self):
        _mupdf.pdf_text_object_state_swiginit(self, _mupdf.new_pdf_text_object_state())
    __swig_destroy__ = _mupdf.delete_pdf_text_object_state

# Register pdf_text_object_state in _mupdf:
_mupdf.pdf_text_object_state_swigregister(pdf_text_object_state)
PDF_REDACT_IMAGE_NONE = _mupdf.PDF_REDACT_IMAGE_NONE
PDF_REDACT_IMAGE_REMOVE = _mupdf.PDF_REDACT_IMAGE_REMOVE
PDF_REDACT_IMAGE_PIXELS = _mupdf.PDF_REDACT_IMAGE_PIXELS
PDF_REDACT_IMAGE_REMOVE_UNLESS_INVISIBLE = _mupdf.PDF_REDACT_IMAGE_REMOVE_UNLESS_INVISIBLE
PDF_REDACT_LINE_ART_NONE = _mupdf.PDF_REDACT_LINE_ART_NONE
PDF_REDACT_LINE_ART_REMOVE_IF_COVERED = _mupdf.PDF_REDACT_LINE_ART_REMOVE_IF_COVERED
PDF_REDACT_LINE_ART_REMOVE_IF_TOUCHED = _mupdf.PDF_REDACT_LINE_ART_REMOVE_IF_TOUCHED
PDF_REDACT_TEXT_REMOVE = _mupdf.PDF_REDACT_TEXT_REMOVE
PDF_REDACT_TEXT_NONE = _mupdf.PDF_REDACT_TEXT_NONE
class pdf_redact_options(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    black_boxes = property(_mupdf.pdf_redact_options_black_boxes_get, _mupdf.pdf_redact_options_black_boxes_set)
    image_method = property(_mupdf.pdf_redact_options_image_method_get, _mupdf.pdf_redact_options_image_method_set)
    line_art = property(_mupdf.pdf_redact_options_line_art_get, _mupdf.pdf_redact_options_line_art_set)
    text = property(_mupdf.pdf_redact_options_text_get, _mupdf.pdf_redact_options_text_set)

    def __init__(self):
        _mupdf.pdf_redact_options_swiginit(self, _mupdf.new_pdf_redact_options())
    __swig_destroy__ = _mupdf.delete_pdf_redact_options

# Register pdf_redact_options in _mupdf:
_mupdf.pdf_redact_options_swigregister(pdf_redact_options)
class pdf_page(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    super = property(_mupdf.pdf_page_super_get, _mupdf.pdf_page_super_set)
    doc = property(_mupdf.pdf_page_doc_get, _mupdf.pdf_page_doc_set)
    obj = property(_mupdf.pdf_page_obj_get, _mupdf.pdf_page_obj_set)
    transparency = property(_mupdf.pdf_page_transparency_get, _mupdf.pdf_page_transparency_set)
    overprint = property(_mupdf.pdf_page_overprint_get, _mupdf.pdf_page_overprint_set)
    links = property(_mupdf.pdf_page_links_get, _mupdf.pdf_page_links_set)
    annots = property(_mupdf.pdf_page_annots_get, _mupdf.pdf_page_annots_set)
    annot_tailp = property(_mupdf.pdf_page_annot_tailp_get, _mupdf.pdf_page_annot_tailp_set)
    widgets = property(_mupdf.pdf_page_widgets_get, _mupdf.pdf_page_widgets_set)
    widget_tailp = property(_mupdf.pdf_page_widget_tailp_get, _mupdf.pdf_page_widget_tailp_set)

    def __init__(self):
        _mupdf.pdf_page_swiginit(self, _mupdf.new_pdf_page())
    __swig_destroy__ = _mupdf.delete_pdf_page

# Register pdf_page in _mupdf:
_mupdf.pdf_page_swigregister(pdf_page)
PDF_ANNOT_TEXT = _mupdf.PDF_ANNOT_TEXT
PDF_ANNOT_LINK = _mupdf.PDF_ANNOT_LINK
PDF_ANNOT_FREE_TEXT = _mupdf.PDF_ANNOT_FREE_TEXT
PDF_ANNOT_LINE = _mupdf.PDF_ANNOT_LINE
PDF_ANNOT_SQUARE = _mupdf.PDF_ANNOT_SQUARE
PDF_ANNOT_CIRCLE = _mupdf.PDF_ANNOT_CIRCLE
PDF_ANNOT_POLYGON = _mupdf.PDF_ANNOT_POLYGON
PDF_ANNOT_POLY_LINE = _mupdf.PDF_ANNOT_POLY_LINE
PDF_ANNOT_HIGHLIGHT = _mupdf.PDF_ANNOT_HIGHLIGHT
PDF_ANNOT_UNDERLINE = _mupdf.PDF_ANNOT_UNDERLINE
PDF_ANNOT_SQUIGGLY = _mupdf.PDF_ANNOT_SQUIGGLY
PDF_ANNOT_STRIKE_OUT = _mupdf.PDF_ANNOT_STRIKE_OUT
PDF_ANNOT_REDACT = _mupdf.PDF_ANNOT_REDACT
PDF_ANNOT_STAMP = _mupdf.PDF_ANNOT_STAMP
PDF_ANNOT_CARET = _mupdf.PDF_ANNOT_CARET
PDF_ANNOT_INK = _mupdf.PDF_ANNOT_INK
PDF_ANNOT_POPUP = _mupdf.PDF_ANNOT_POPUP
PDF_ANNOT_FILE_ATTACHMENT = _mupdf.PDF_ANNOT_FILE_ATTACHMENT
PDF_ANNOT_SOUND = _mupdf.PDF_ANNOT_SOUND
PDF_ANNOT_MOVIE = _mupdf.PDF_ANNOT_MOVIE
PDF_ANNOT_RICH_MEDIA = _mupdf.PDF_ANNOT_RICH_MEDIA
PDF_ANNOT_WIDGET = _mupdf.PDF_ANNOT_WIDGET
PDF_ANNOT_SCREEN = _mupdf.PDF_ANNOT_SCREEN
PDF_ANNOT_PRINTER_MARK = _mupdf.PDF_ANNOT_PRINTER_MARK
PDF_ANNOT_TRAP_NET = _mupdf.PDF_ANNOT_TRAP_NET
PDF_ANNOT_WATERMARK = _mupdf.PDF_ANNOT_WATERMARK
PDF_ANNOT_3D = _mupdf.PDF_ANNOT_3D
PDF_ANNOT_PROJECTION = _mupdf.PDF_ANNOT_PROJECTION
PDF_ANNOT_UNKNOWN = _mupdf.PDF_ANNOT_UNKNOWN
PDF_ANNOT_IS_INVISIBLE = _mupdf.PDF_ANNOT_IS_INVISIBLE
PDF_ANNOT_IS_HIDDEN = _mupdf.PDF_ANNOT_IS_HIDDEN
PDF_ANNOT_IS_PRINT = _mupdf.PDF_ANNOT_IS_PRINT
PDF_ANNOT_IS_NO_ZOOM = _mupdf.PDF_ANNOT_IS_NO_ZOOM
PDF_ANNOT_IS_NO_ROTATE = _mupdf.PDF_ANNOT_IS_NO_ROTATE
PDF_ANNOT_IS_NO_VIEW = _mupdf.PDF_ANNOT_IS_NO_VIEW
PDF_ANNOT_IS_READ_ONLY = _mupdf.PDF_ANNOT_IS_READ_ONLY
PDF_ANNOT_IS_LOCKED = _mupdf.PDF_ANNOT_IS_LOCKED
PDF_ANNOT_IS_TOGGLE_NO_VIEW = _mupdf.PDF_ANNOT_IS_TOGGLE_NO_VIEW
PDF_ANNOT_IS_LOCKED_CONTENTS = _mupdf.PDF_ANNOT_IS_LOCKED_CONTENTS
PDF_ANNOT_LE_NONE = _mupdf.PDF_ANNOT_LE_NONE
PDF_ANNOT_LE_SQUARE = _mupdf.PDF_ANNOT_LE_SQUARE
PDF_ANNOT_LE_CIRCLE = _mupdf.PDF_ANNOT_LE_CIRCLE
PDF_ANNOT_LE_DIAMOND = _mupdf.PDF_ANNOT_LE_DIAMOND
PDF_ANNOT_LE_OPEN_ARROW = _mupdf.PDF_ANNOT_LE_OPEN_ARROW
PDF_ANNOT_LE_CLOSED_ARROW = _mupdf.PDF_ANNOT_LE_CLOSED_ARROW
PDF_ANNOT_LE_BUTT = _mupdf.PDF_ANNOT_LE_BUTT
PDF_ANNOT_LE_R_OPEN_ARROW = _mupdf.PDF_ANNOT_LE_R_OPEN_ARROW
PDF_ANNOT_LE_R_CLOSED_ARROW = _mupdf.PDF_ANNOT_LE_R_CLOSED_ARROW
PDF_ANNOT_LE_SLASH = _mupdf.PDF_ANNOT_LE_SLASH
PDF_ANNOT_Q_LEFT = _mupdf.PDF_ANNOT_Q_LEFT
PDF_ANNOT_Q_CENTER = _mupdf.PDF_ANNOT_Q_CENTER
PDF_ANNOT_Q_RIGHT = _mupdf.PDF_ANNOT_Q_RIGHT
PDF_BORDER_STYLE_SOLID = _mupdf.PDF_BORDER_STYLE_SOLID
PDF_BORDER_STYLE_DASHED = _mupdf.PDF_BORDER_STYLE_DASHED
PDF_BORDER_STYLE_BEVELED = _mupdf.PDF_BORDER_STYLE_BEVELED
PDF_BORDER_STYLE_INSET = _mupdf.PDF_BORDER_STYLE_INSET
PDF_BORDER_STYLE_UNDERLINE = _mupdf.PDF_BORDER_STYLE_UNDERLINE
PDF_BORDER_EFFECT_NONE = _mupdf.PDF_BORDER_EFFECT_NONE
PDF_BORDER_EFFECT_CLOUDY = _mupdf.PDF_BORDER_EFFECT_CLOUDY
class pdf_embedded_file_params(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    filename = property(_mupdf.pdf_embedded_file_params_filename_get, _mupdf.pdf_embedded_file_params_filename_set)
    mimetype = property(_mupdf.pdf_embedded_file_params_mimetype_get, _mupdf.pdf_embedded_file_params_mimetype_set)
    size = property(_mupdf.pdf_embedded_file_params_size_get, _mupdf.pdf_embedded_file_params_size_set)
    created = property(_mupdf.pdf_embedded_file_params_created_get, _mupdf.pdf_embedded_file_params_created_set)
    modified = property(_mupdf.pdf_embedded_file_params_modified_get, _mupdf.pdf_embedded_file_params_modified_set)

    def __init__(self):
        _mupdf.pdf_embedded_file_params_swiginit(self, _mupdf.new_pdf_embedded_file_params())
    __swig_destroy__ = _mupdf.delete_pdf_embedded_file_params

# Register pdf_embedded_file_params in _mupdf:
_mupdf.pdf_embedded_file_params_swigregister(pdf_embedded_file_params)
PDF_WIDGET_TYPE_UNKNOWN = _mupdf.PDF_WIDGET_TYPE_UNKNOWN
PDF_WIDGET_TYPE_BUTTON = _mupdf.PDF_WIDGET_TYPE_BUTTON
PDF_WIDGET_TYPE_CHECKBOX = _mupdf.PDF_WIDGET_TYPE_CHECKBOX
PDF_WIDGET_TYPE_COMBOBOX = _mupdf.PDF_WIDGET_TYPE_COMBOBOX
PDF_WIDGET_TYPE_LISTBOX = _mupdf.PDF_WIDGET_TYPE_LISTBOX
PDF_WIDGET_TYPE_RADIOBUTTON = _mupdf.PDF_WIDGET_TYPE_RADIOBUTTON
PDF_WIDGET_TYPE_SIGNATURE = _mupdf.PDF_WIDGET_TYPE_SIGNATURE
PDF_WIDGET_TYPE_TEXT = _mupdf.PDF_WIDGET_TYPE_TEXT
PDF_WIDGET_TX_FORMAT_NONE = _mupdf.PDF_WIDGET_TX_FORMAT_NONE
PDF_WIDGET_TX_FORMAT_NUMBER = _mupdf.PDF_WIDGET_TX_FORMAT_NUMBER
PDF_WIDGET_TX_FORMAT_SPECIAL = _mupdf.PDF_WIDGET_TX_FORMAT_SPECIAL
PDF_WIDGET_TX_FORMAT_DATE = _mupdf.PDF_WIDGET_TX_FORMAT_DATE
PDF_WIDGET_TX_FORMAT_TIME = _mupdf.PDF_WIDGET_TX_FORMAT_TIME
PDF_FIELD_IS_READ_ONLY = _mupdf.PDF_FIELD_IS_READ_ONLY
PDF_FIELD_IS_REQUIRED = _mupdf.PDF_FIELD_IS_REQUIRED
PDF_FIELD_IS_NO_EXPORT = _mupdf.PDF_FIELD_IS_NO_EXPORT
PDF_TX_FIELD_IS_MULTILINE = _mupdf.PDF_TX_FIELD_IS_MULTILINE
PDF_TX_FIELD_IS_PASSWORD = _mupdf.PDF_TX_FIELD_IS_PASSWORD
PDF_TX_FIELD_IS_FILE_SELECT = _mupdf.PDF_TX_FIELD_IS_FILE_SELECT
PDF_TX_FIELD_IS_DO_NOT_SPELL_CHECK = _mupdf.PDF_TX_FIELD_IS_DO_NOT_SPELL_CHECK
PDF_TX_FIELD_IS_DO_NOT_SCROLL = _mupdf.PDF_TX_FIELD_IS_DO_NOT_SCROLL
PDF_TX_FIELD_IS_COMB = _mupdf.PDF_TX_FIELD_IS_COMB
PDF_TX_FIELD_IS_RICH_TEXT = _mupdf.PDF_TX_FIELD_IS_RICH_TEXT
PDF_BTN_FIELD_IS_NO_TOGGLE_TO_OFF = _mupdf.PDF_BTN_FIELD_IS_NO_TOGGLE_TO_OFF
PDF_BTN_FIELD_IS_RADIO = _mupdf.PDF_BTN_FIELD_IS_RADIO
PDF_BTN_FIELD_IS_PUSHBUTTON = _mupdf.PDF_BTN_FIELD_IS_PUSHBUTTON
PDF_BTN_FIELD_IS_RADIOS_IN_UNISON = _mupdf.PDF_BTN_FIELD_IS_RADIOS_IN_UNISON
PDF_CH_FIELD_IS_COMBO = _mupdf.PDF_CH_FIELD_IS_COMBO
PDF_CH_FIELD_IS_EDIT = _mupdf.PDF_CH_FIELD_IS_EDIT
PDF_CH_FIELD_IS_SORT = _mupdf.PDF_CH_FIELD_IS_SORT
PDF_CH_FIELD_IS_MULTI_SELECT = _mupdf.PDF_CH_FIELD_IS_MULTI_SELECT
PDF_CH_FIELD_IS_DO_NOT_SPELL_CHECK = _mupdf.PDF_CH_FIELD_IS_DO_NOT_SPELL_CHECK
PDF_CH_FIELD_IS_COMMIT_ON_SEL_CHANGE = _mupdf.PDF_CH_FIELD_IS_COMMIT_ON_SEL_CHANGE
class pdf_pkcs7_distinguished_name(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    cn = property(_mupdf.pdf_pkcs7_distinguished_name_cn_get, _mupdf.pdf_pkcs7_distinguished_name_cn_set)
    o = property(_mupdf.pdf_pkcs7_distinguished_name_o_get, _mupdf.pdf_pkcs7_distinguished_name_o_set)
    ou = property(_mupdf.pdf_pkcs7_distinguished_name_ou_get, _mupdf.pdf_pkcs7_distinguished_name_ou_set)
    email = property(_mupdf.pdf_pkcs7_distinguished_name_email_get, _mupdf.pdf_pkcs7_distinguished_name_email_set)
    c = property(_mupdf.pdf_pkcs7_distinguished_name_c_get, _mupdf.pdf_pkcs7_distinguished_name_c_set)

    def __init__(self):
        _mupdf.pdf_pkcs7_distinguished_name_swiginit(self, _mupdf.new_pdf_pkcs7_distinguished_name())
    __swig_destroy__ = _mupdf.delete_pdf_pkcs7_distinguished_name

# Register pdf_pkcs7_distinguished_name in _mupdf:
_mupdf.pdf_pkcs7_distinguished_name_swigregister(pdf_pkcs7_distinguished_name)
PDF_SIGNATURE_ERROR_OKAY = _mupdf.PDF_SIGNATURE_ERROR_OKAY
PDF_SIGNATURE_ERROR_NO_SIGNATURES = _mupdf.PDF_SIGNATURE_ERROR_NO_SIGNATURES
PDF_SIGNATURE_ERROR_NO_CERTIFICATE = _mupdf.PDF_SIGNATURE_ERROR_NO_CERTIFICATE
PDF_SIGNATURE_ERROR_DIGEST_FAILURE = _mupdf.PDF_SIGNATURE_ERROR_DIGEST_FAILURE
PDF_SIGNATURE_ERROR_SELF_SIGNED = _mupdf.PDF_SIGNATURE_ERROR_SELF_SIGNED
PDF_SIGNATURE_ERROR_SELF_SIGNED_IN_CHAIN = _mupdf.PDF_SIGNATURE_ERROR_SELF_SIGNED_IN_CHAIN
PDF_SIGNATURE_ERROR_NOT_TRUSTED = _mupdf.PDF_SIGNATURE_ERROR_NOT_TRUSTED
PDF_SIGNATURE_ERROR_UNKNOWN = _mupdf.PDF_SIGNATURE_ERROR_UNKNOWN
class pdf_pkcs7_signer(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    keep = property(_mupdf.pdf_pkcs7_signer_keep_get, _mupdf.pdf_pkcs7_signer_keep_set)
    drop = property(_mupdf.pdf_pkcs7_signer_drop_get, _mupdf.pdf_pkcs7_signer_drop_set)
    get_signing_name = property(_mupdf.pdf_pkcs7_signer_get_signing_name_get, _mupdf.pdf_pkcs7_signer_get_signing_name_set)
    max_digest_size = property(_mupdf.pdf_pkcs7_signer_max_digest_size_get, _mupdf.pdf_pkcs7_signer_max_digest_size_set)
    create_digest = property(_mupdf.pdf_pkcs7_signer_create_digest_get, _mupdf.pdf_pkcs7_signer_create_digest_set)

    def __init__(self):
        _mupdf.pdf_pkcs7_signer_swiginit(self, _mupdf.new_pdf_pkcs7_signer())
    __swig_destroy__ = _mupdf.delete_pdf_pkcs7_signer

# Register pdf_pkcs7_signer in _mupdf:
_mupdf.pdf_pkcs7_signer_swigregister(pdf_pkcs7_signer)
class pdf_pkcs7_verifier(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    drop = property(_mupdf.pdf_pkcs7_verifier_drop_get, _mupdf.pdf_pkcs7_verifier_drop_set)
    check_certificate = property(_mupdf.pdf_pkcs7_verifier_check_certificate_get, _mupdf.pdf_pkcs7_verifier_check_certificate_set)
    check_digest = property(_mupdf.pdf_pkcs7_verifier_check_digest_get, _mupdf.pdf_pkcs7_verifier_check_digest_set)
    get_signatory = property(_mupdf.pdf_pkcs7_verifier_get_signatory_get, _mupdf.pdf_pkcs7_verifier_get_signatory_set)

    def __init__(self):
        _mupdf.pdf_pkcs7_verifier_swiginit(self, _mupdf.new_pdf_pkcs7_verifier())
    __swig_destroy__ = _mupdf.delete_pdf_pkcs7_verifier

# Register pdf_pkcs7_verifier in _mupdf:
_mupdf.pdf_pkcs7_verifier_swigregister(pdf_pkcs7_verifier)
PDF_SIGNATURE_SHOW_LABELS = _mupdf.PDF_SIGNATURE_SHOW_LABELS
PDF_SIGNATURE_SHOW_DN = _mupdf.PDF_SIGNATURE_SHOW_DN
PDF_SIGNATURE_SHOW_DATE = _mupdf.PDF_SIGNATURE_SHOW_DATE
PDF_SIGNATURE_SHOW_TEXT_NAME = _mupdf.PDF_SIGNATURE_SHOW_TEXT_NAME
PDF_SIGNATURE_SHOW_GRAPHIC_NAME = _mupdf.PDF_SIGNATURE_SHOW_GRAPHIC_NAME
PDF_SIGNATURE_SHOW_LOGO = _mupdf.PDF_SIGNATURE_SHOW_LOGO
class pdf_keystroke_event(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    value = property(_mupdf.pdf_keystroke_event_value_get, _mupdf.pdf_keystroke_event_value_set)
    change = property(_mupdf.pdf_keystroke_event_change_get, _mupdf.pdf_keystroke_event_change_set)
    selStart = property(_mupdf.pdf_keystroke_event_selStart_get, _mupdf.pdf_keystroke_event_selStart_set)
    selEnd = property(_mupdf.pdf_keystroke_event_selEnd_get, _mupdf.pdf_keystroke_event_selEnd_set)
    willCommit = property(_mupdf.pdf_keystroke_event_willCommit_get, _mupdf.pdf_keystroke_event_willCommit_set)
    newChange = property(_mupdf.pdf_keystroke_event_newChange_get, _mupdf.pdf_keystroke_event_newChange_set)
    newValue = property(_mupdf.pdf_keystroke_event_newValue_get, _mupdf.pdf_keystroke_event_newValue_set)

    def __init__(self):
        _mupdf.pdf_keystroke_event_swiginit(self, _mupdf.new_pdf_keystroke_event())
    __swig_destroy__ = _mupdf.delete_pdf_keystroke_event

# Register pdf_keystroke_event in _mupdf:
_mupdf.pdf_keystroke_event_swigregister(pdf_keystroke_event)
class pdf_doc_event(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    type = property(_mupdf.pdf_doc_event_type_get, _mupdf.pdf_doc_event_type_set)

    def __init__(self):
        _mupdf.pdf_doc_event_swiginit(self, _mupdf.new_pdf_doc_event())
    __swig_destroy__ = _mupdf.delete_pdf_doc_event

# Register pdf_doc_event in _mupdf:
_mupdf.pdf_doc_event_swigregister(pdf_doc_event)
PDF_DOCUMENT_EVENT_ALERT = _mupdf.PDF_DOCUMENT_EVENT_ALERT
PDF_DOCUMENT_EVENT_PRINT = _mupdf.PDF_DOCUMENT_EVENT_PRINT
PDF_DOCUMENT_EVENT_LAUNCH_URL = _mupdf.PDF_DOCUMENT_EVENT_LAUNCH_URL
PDF_DOCUMENT_EVENT_MAIL_DOC = _mupdf.PDF_DOCUMENT_EVENT_MAIL_DOC
PDF_DOCUMENT_EVENT_SUBMIT = _mupdf.PDF_DOCUMENT_EVENT_SUBMIT
PDF_DOCUMENT_EVENT_EXEC_MENU_ITEM = _mupdf.PDF_DOCUMENT_EVENT_EXEC_MENU_ITEM
class pdf_alert_event(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    doc = property(_mupdf.pdf_alert_event_doc_get, _mupdf.pdf_alert_event_doc_set)
    message = property(_mupdf.pdf_alert_event_message_get, _mupdf.pdf_alert_event_message_set)
    icon_type = property(_mupdf.pdf_alert_event_icon_type_get, _mupdf.pdf_alert_event_icon_type_set)
    button_group_type = property(_mupdf.pdf_alert_event_button_group_type_get, _mupdf.pdf_alert_event_button_group_type_set)
    title = property(_mupdf.pdf_alert_event_title_get, _mupdf.pdf_alert_event_title_set)
    has_check_box = property(_mupdf.pdf_alert_event_has_check_box_get, _mupdf.pdf_alert_event_has_check_box_set)
    check_box_message = property(_mupdf.pdf_alert_event_check_box_message_get, _mupdf.pdf_alert_event_check_box_message_set)
    initially_checked = property(_mupdf.pdf_alert_event_initially_checked_get, _mupdf.pdf_alert_event_initially_checked_set)
    finally_checked = property(_mupdf.pdf_alert_event_finally_checked_get, _mupdf.pdf_alert_event_finally_checked_set)
    button_pressed = property(_mupdf.pdf_alert_event_button_pressed_get, _mupdf.pdf_alert_event_button_pressed_set)

    def __init__(self):
        _mupdf.pdf_alert_event_swiginit(self, _mupdf.new_pdf_alert_event())
    __swig_destroy__ = _mupdf.delete_pdf_alert_event

# Register pdf_alert_event in _mupdf:
_mupdf.pdf_alert_event_swigregister(pdf_alert_event)
PDF_ALERT_ICON_ERROR = _mupdf.PDF_ALERT_ICON_ERROR
PDF_ALERT_ICON_WARNING = _mupdf.PDF_ALERT_ICON_WARNING
PDF_ALERT_ICON_QUESTION = _mupdf.PDF_ALERT_ICON_QUESTION
PDF_ALERT_ICON_STATUS = _mupdf.PDF_ALERT_ICON_STATUS
PDF_ALERT_BUTTON_GROUP_OK = _mupdf.PDF_ALERT_BUTTON_GROUP_OK
PDF_ALERT_BUTTON_GROUP_OK_CANCEL = _mupdf.PDF_ALERT_BUTTON_GROUP_OK_CANCEL
PDF_ALERT_BUTTON_GROUP_YES_NO = _mupdf.PDF_ALERT_BUTTON_GROUP_YES_NO
PDF_ALERT_BUTTON_GROUP_YES_NO_CANCEL = _mupdf.PDF_ALERT_BUTTON_GROUP_YES_NO_CANCEL
PDF_ALERT_BUTTON_NONE = _mupdf.PDF_ALERT_BUTTON_NONE
PDF_ALERT_BUTTON_OK = _mupdf.PDF_ALERT_BUTTON_OK
PDF_ALERT_BUTTON_CANCEL = _mupdf.PDF_ALERT_BUTTON_CANCEL
PDF_ALERT_BUTTON_NO = _mupdf.PDF_ALERT_BUTTON_NO
PDF_ALERT_BUTTON_YES = _mupdf.PDF_ALERT_BUTTON_YES
class pdf_launch_url_event(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    url = property(_mupdf.pdf_launch_url_event_url_get, _mupdf.pdf_launch_url_event_url_set)
    new_frame = property(_mupdf.pdf_launch_url_event_new_frame_get, _mupdf.pdf_launch_url_event_new_frame_set)

    def __init__(self):
        _mupdf.pdf_launch_url_event_swiginit(self, _mupdf.new_pdf_launch_url_event())
    __swig_destroy__ = _mupdf.delete_pdf_launch_url_event

# Register pdf_launch_url_event in _mupdf:
_mupdf.pdf_launch_url_event_swigregister(pdf_launch_url_event)
class pdf_mail_doc_event(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    ask_user = property(_mupdf.pdf_mail_doc_event_ask_user_get, _mupdf.pdf_mail_doc_event_ask_user_set)
    to = property(_mupdf.pdf_mail_doc_event_to_get, _mupdf.pdf_mail_doc_event_to_set)
    cc = property(_mupdf.pdf_mail_doc_event_cc_get, _mupdf.pdf_mail_doc_event_cc_set)
    bcc = property(_mupdf.pdf_mail_doc_event_bcc_get, _mupdf.pdf_mail_doc_event_bcc_set)
    subject = property(_mupdf.pdf_mail_doc_event_subject_get, _mupdf.pdf_mail_doc_event_subject_set)
    message = property(_mupdf.pdf_mail_doc_event_message_get, _mupdf.pdf_mail_doc_event_message_set)

    def __init__(self):
        _mupdf.pdf_mail_doc_event_swiginit(self, _mupdf.new_pdf_mail_doc_event())
    __swig_destroy__ = _mupdf.delete_pdf_mail_doc_event

# Register pdf_mail_doc_event in _mupdf:
_mupdf.pdf_mail_doc_event_swigregister(pdf_mail_doc_event)
FZ_SUBSAMPLE_AVERAGE = _mupdf.FZ_SUBSAMPLE_AVERAGE
FZ_SUBSAMPLE_BICUBIC = _mupdf.FZ_SUBSAMPLE_BICUBIC
FZ_RECOMPRESS_NEVER = _mupdf.FZ_RECOMPRESS_NEVER
FZ_RECOMPRESS_SAME = _mupdf.FZ_RECOMPRESS_SAME
FZ_RECOMPRESS_LOSSLESS = _mupdf.FZ_RECOMPRESS_LOSSLESS
FZ_RECOMPRESS_JPEG = _mupdf.FZ_RECOMPRESS_JPEG
FZ_RECOMPRESS_J2K = _mupdf.FZ_RECOMPRESS_J2K
FZ_RECOMPRESS_FAX = _mupdf.FZ_RECOMPRESS_FAX
class pdf_image_rewriter_options(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    color_lossless_image_subsample_method = property(_mupdf.pdf_image_rewriter_options_color_lossless_image_subsample_method_get, _mupdf.pdf_image_rewriter_options_color_lossless_image_subsample_method_set)
    color_lossy_image_subsample_method = property(_mupdf.pdf_image_rewriter_options_color_lossy_image_subsample_method_get, _mupdf.pdf_image_rewriter_options_color_lossy_image_subsample_method_set)
    color_lossless_image_subsample_threshold = property(_mupdf.pdf_image_rewriter_options_color_lossless_image_subsample_threshold_get, _mupdf.pdf_image_rewriter_options_color_lossless_image_subsample_threshold_set)
    color_lossless_image_subsample_to = property(_mupdf.pdf_image_rewriter_options_color_lossless_image_subsample_to_get, _mupdf.pdf_image_rewriter_options_color_lossless_image_subsample_to_set)
    color_lossy_image_subsample_threshold = property(_mupdf.pdf_image_rewriter_options_color_lossy_image_subsample_threshold_get, _mupdf.pdf_image_rewriter_options_color_lossy_image_subsample_threshold_set)
    color_lossy_image_subsample_to = property(_mupdf.pdf_image_rewriter_options_color_lossy_image_subsample_to_get, _mupdf.pdf_image_rewriter_options_color_lossy_image_subsample_to_set)
    color_lossless_image_recompress_method = property(_mupdf.pdf_image_rewriter_options_color_lossless_image_recompress_method_get, _mupdf.pdf_image_rewriter_options_color_lossless_image_recompress_method_set)
    color_lossy_image_recompress_method = property(_mupdf.pdf_image_rewriter_options_color_lossy_image_recompress_method_get, _mupdf.pdf_image_rewriter_options_color_lossy_image_recompress_method_set)
    color_lossy_image_recompress_quality = property(_mupdf.pdf_image_rewriter_options_color_lossy_image_recompress_quality_get, _mupdf.pdf_image_rewriter_options_color_lossy_image_recompress_quality_set)
    color_lossless_image_recompress_quality = property(_mupdf.pdf_image_rewriter_options_color_lossless_image_recompress_quality_get, _mupdf.pdf_image_rewriter_options_color_lossless_image_recompress_quality_set)
    gray_lossless_image_subsample_method = property(_mupdf.pdf_image_rewriter_options_gray_lossless_image_subsample_method_get, _mupdf.pdf_image_rewriter_options_gray_lossless_image_subsample_method_set)
    gray_lossy_image_subsample_method = property(_mupdf.pdf_image_rewriter_options_gray_lossy_image_subsample_method_get, _mupdf.pdf_image_rewriter_options_gray_lossy_image_subsample_method_set)
    gray_lossless_image_subsample_threshold = property(_mupdf.pdf_image_rewriter_options_gray_lossless_image_subsample_threshold_get, _mupdf.pdf_image_rewriter_options_gray_lossless_image_subsample_threshold_set)
    gray_lossless_image_subsample_to = property(_mupdf.pdf_image_rewriter_options_gray_lossless_image_subsample_to_get, _mupdf.pdf_image_rewriter_options_gray_lossless_image_subsample_to_set)
    gray_lossy_image_subsample_threshold = property(_mupdf.pdf_image_rewriter_options_gray_lossy_image_subsample_threshold_get, _mupdf.pdf_image_rewriter_options_gray_lossy_image_subsample_threshold_set)
    gray_lossy_image_subsample_to = property(_mupdf.pdf_image_rewriter_options_gray_lossy_image_subsample_to_get, _mupdf.pdf_image_rewriter_options_gray_lossy_image_subsample_to_set)
    gray_lossless_image_recompress_method = property(_mupdf.pdf_image_rewriter_options_gray_lossless_image_recompress_method_get, _mupdf.pdf_image_rewriter_options_gray_lossless_image_recompress_method_set)
    gray_lossy_image_recompress_method = property(_mupdf.pdf_image_rewriter_options_gray_lossy_image_recompress_method_get, _mupdf.pdf_image_rewriter_options_gray_lossy_image_recompress_method_set)
    gray_lossy_image_recompress_quality = property(_mupdf.pdf_image_rewriter_options_gray_lossy_image_recompress_quality_get, _mupdf.pdf_image_rewriter_options_gray_lossy_image_recompress_quality_set)
    gray_lossless_image_recompress_quality = property(_mupdf.pdf_image_rewriter_options_gray_lossless_image_recompress_quality_get, _mupdf.pdf_image_rewriter_options_gray_lossless_image_recompress_quality_set)
    bitonal_image_subsample_method = property(_mupdf.pdf_image_rewriter_options_bitonal_image_subsample_method_get, _mupdf.pdf_image_rewriter_options_bitonal_image_subsample_method_set)
    bitonal_image_subsample_threshold = property(_mupdf.pdf_image_rewriter_options_bitonal_image_subsample_threshold_get, _mupdf.pdf_image_rewriter_options_bitonal_image_subsample_threshold_set)
    bitonal_image_subsample_to = property(_mupdf.pdf_image_rewriter_options_bitonal_image_subsample_to_get, _mupdf.pdf_image_rewriter_options_bitonal_image_subsample_to_set)
    bitonal_image_recompress_method = property(_mupdf.pdf_image_rewriter_options_bitonal_image_recompress_method_get, _mupdf.pdf_image_rewriter_options_bitonal_image_recompress_method_set)
    bitonal_image_recompress_quality = property(_mupdf.pdf_image_rewriter_options_bitonal_image_recompress_quality_get, _mupdf.pdf_image_rewriter_options_bitonal_image_recompress_quality_set)

    def __init__(self):
        _mupdf.pdf_image_rewriter_options_swiginit(self, _mupdf.new_pdf_image_rewriter_options())
    __swig_destroy__ = _mupdf.delete_pdf_image_rewriter_options

# Register pdf_image_rewriter_options in _mupdf:
_mupdf.pdf_image_rewriter_options_swigregister(pdf_image_rewriter_options)
class pdf_clean_options(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    write = property(_mupdf.pdf_clean_options_write_get, _mupdf.pdf_clean_options_write_set)
    image = property(_mupdf.pdf_clean_options_image_get, _mupdf.pdf_clean_options_image_set)
    subset_fonts = property(_mupdf.pdf_clean_options_subset_fonts_get, _mupdf.pdf_clean_options_subset_fonts_set)

    def __init__(self):
        _mupdf.pdf_clean_options_swiginit(self, _mupdf.new_pdf_clean_options())
    __swig_destroy__ = _mupdf.delete_pdf_clean_options

# Register pdf_clean_options in _mupdf:
_mupdf.pdf_clean_options_swigregister(pdf_clean_options)
class fz_search_page2_hit(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    quad = property(_mupdf.fz_search_page2_hit_quad_get, _mupdf.fz_search_page2_hit_quad_set)
    mark = property(_mupdf.fz_search_page2_hit_mark_get, _mupdf.fz_search_page2_hit_mark_set)

    def __init__(self):
        _mupdf.fz_search_page2_hit_swiginit(self, _mupdf.new_fz_search_page2_hit())
    __swig_destroy__ = _mupdf.delete_fz_search_page2_hit

# Register fz_search_page2_hit in _mupdf:
_mupdf.fz_search_page2_hit_swigregister(fz_search_page2_hit)
class fz_install_load_system_font_funcs_args(object):
    r"""
    Extra struct containing fz_install_load_system_font_funcs()'s args,
    which we wrap with virtual_fnptrs set to allow use from Python/C# via
    Swig Directors.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    f = property(_mupdf.fz_install_load_system_font_funcs_args_f_get, _mupdf.fz_install_load_system_font_funcs_args_f_set)
    f_cjk = property(_mupdf.fz_install_load_system_font_funcs_args_f_cjk_get, _mupdf.fz_install_load_system_font_funcs_args_f_cjk_set)
    f_fallback = property(_mupdf.fz_install_load_system_font_funcs_args_f_fallback_get, _mupdf.fz_install_load_system_font_funcs_args_f_fallback_set)

    def __init__(self):
        _mupdf.fz_install_load_system_font_funcs_args_swiginit(self, _mupdf.new_fz_install_load_system_font_funcs_args())
    __swig_destroy__ = _mupdf.delete_fz_install_load_system_font_funcs_args

# Register fz_install_load_system_font_funcs_args in _mupdf:
_mupdf.fz_install_load_system_font_funcs_args_swigregister(fz_install_load_system_font_funcs_args)

def ll_fz_aa_level():
    r"""
    Low-level wrapper for `::fz_aa_level()`.
    Get the number of bits of antialiasing we are
    using (for graphics). Between 0 and 8.
    """
    return _mupdf.ll_fz_aa_level()

def ll_fz_abs(f):
    r"""
    Low-level wrapper for `::fz_abs()`.
    Some standard math functions, done as static inlines for speed.
    People with compilers that do not adequately implement inline
    may like to reimplement these using macros.
    """
    return _mupdf.ll_fz_abs(f)

def ll_fz_absi(i):
    r""" Low-level wrapper for `::fz_absi()`."""
    return _mupdf.ll_fz_absi(i)

def ll_fz_add_layout_char(block, x, w, p):
    r"""
    Low-level wrapper for `::fz_add_layout_char()`.
    Add a new char to the line at the end of the layout block.
    """
    return _mupdf.ll_fz_add_layout_char(block, x, w, p)

def ll_fz_add_layout_line(block, x, y, h, p):
    r"""
    Low-level wrapper for `::fz_add_layout_line()`.
    Add a new line to the end of the layout block.
    """
    return _mupdf.ll_fz_add_layout_line(block, x, y, h, p)

def ll_fz_add_separation(sep, name, cs, cs_channel):
    r"""
    Low-level wrapper for `::fz_add_separation()`.
    Add a separation (null terminated name, colorspace)
    """
    return _mupdf.ll_fz_add_separation(sep, name, cs, cs_channel)

def ll_fz_add_separation_equivalents(sep, rgba, cmyk, name):
    r"""
    Low-level wrapper for `::fz_add_separation_equivalents()`.
    Add a separation with equivalents (null terminated name,
    colorspace)

    (old, deprecated)
    """
    return _mupdf.ll_fz_add_separation_equivalents(sep, rgba, cmyk, name)

def ll_fz_adjust_rect_for_stroke(rect, stroke, ctm):
    r"""
    Low-level wrapper for `::fz_adjust_rect_for_stroke()`.
    Given a rectangle (assumed to be the bounding box for a path),
    expand it to allow for the expansion of the bbox that would be
    seen by stroking the path with the given stroke state and
    transform.
    """
    return _mupdf.ll_fz_adjust_rect_for_stroke(rect, stroke, ctm)

def ll_fz_advance_glyph(font, glyph, wmode):
    r"""
    Low-level wrapper for `::fz_advance_glyph()`.
    Return the advance for a given glyph.

    font: The font to look for the glyph in.

    glyph: The glyph to find the advance for.

    wmode: 1 for vertical mode, 0 for horizontal.

    Returns the advance for the glyph.
    """
    return _mupdf.ll_fz_advance_glyph(font, glyph, wmode)

def ll_fz_aes_crypt_cbc(ctx, mode, length, iv, input, output):
    r"""
    Low-level wrapper for `::fz_aes_crypt_cbc()`.
    AES block processing. Encrypts or Decrypts (according to mode,
    which must match what was initially set up) length bytes (which
    must be a multiple of 16), using (and modifying) the insertion
    vector iv, reading from input, and writing to output.

    Never throws an exception.
    """
    return _mupdf.ll_fz_aes_crypt_cbc(ctx, mode, length, iv, input, output)

def ll_fz_aes_setkey_dec(ctx, key, keysize):
    r"""
    Low-level wrapper for `::fz_aes_setkey_dec()`.
    AES decryption intialisation. Fills in the supplied context
    and prepares for decryption using the given key.

    Returns non-zero for error (key size other than 128/192/256).

    Never throws an exception.
    """
    return _mupdf.ll_fz_aes_setkey_dec(ctx, key, keysize)

def ll_fz_aes_setkey_enc(ctx, key, keysize):
    r"""
    Low-level wrapper for `::fz_aes_setkey_enc()`.
    AES encryption intialisation. Fills in the supplied context
    and prepares for encryption using the given key.

    Returns non-zero for error (key size other than 128/192/256).

    Never throws an exception.
    """
    return _mupdf.ll_fz_aes_setkey_enc(ctx, key, keysize)

def ll_fz_alpha_from_gray(gray):
    r""" Low-level wrapper for `::fz_alpha_from_gray()`."""
    return _mupdf.ll_fz_alpha_from_gray(gray)

def ll_fz_append_base64(out, data, size, newline):
    r"""
    Low-level wrapper for `::fz_append_base64()`.
    Write a base64 encoded data block, optionally with periodic newlines.
    """
    return _mupdf.ll_fz_append_base64(out, data, size, newline)

def ll_fz_append_base64_buffer(out, data, newline):
    r"""
    Low-level wrapper for `::fz_append_base64_buffer()`.
    Append a base64 encoded fz_buffer, optionally with periodic newlines.
    """
    return _mupdf.ll_fz_append_base64_buffer(out, data, newline)

def ll_fz_append_bits(buf, value, count):
    r""" Low-level wrapper for `::fz_append_bits()`."""
    return _mupdf.ll_fz_append_bits(buf, value, count)

def ll_fz_append_bits_pad(buf):
    r""" Low-level wrapper for `::fz_append_bits_pad()`."""
    return _mupdf.ll_fz_append_bits_pad(buf)

def ll_fz_append_buffer(destination, source):
    r"""
    Low-level wrapper for `::fz_append_buffer()`.
    Append the contents of the source buffer onto the end of the
    destination buffer, extending automatically as required.

    Ownership of buffers does not change.
    """
    return _mupdf.ll_fz_append_buffer(destination, source)

def ll_fz_append_byte(buf, c):
    r""" Low-level wrapper for `::fz_append_byte()`."""
    return _mupdf.ll_fz_append_byte(buf, c)

def ll_fz_append_data(buf, data, len):
    r"""
    Low-level wrapper for `::fz_append_data()`.
    fz_append_*: Append data to a buffer.

    The buffer will automatically grow as required.
    """
    return _mupdf.ll_fz_append_data(buf, data, len)

def ll_fz_append_image_as_data_uri(out, image):
    r""" Low-level wrapper for `::fz_append_image_as_data_uri()`."""
    return _mupdf.ll_fz_append_image_as_data_uri(out, image)

def ll_fz_append_int16_be(buf, x):
    r""" Low-level wrapper for `::fz_append_int16_be()`."""
    return _mupdf.ll_fz_append_int16_be(buf, x)

def ll_fz_append_int16_le(buf, x):
    r""" Low-level wrapper for `::fz_append_int16_le()`."""
    return _mupdf.ll_fz_append_int16_le(buf, x)

def ll_fz_append_int32_be(buf, x):
    r""" Low-level wrapper for `::fz_append_int32_be()`."""
    return _mupdf.ll_fz_append_int32_be(buf, x)

def ll_fz_append_int32_le(buf, x):
    r""" Low-level wrapper for `::fz_append_int32_le()`."""
    return _mupdf.ll_fz_append_int32_le(buf, x)

def ll_fz_append_pdf_string(buffer, text):
    r"""
    Low-level wrapper for `::fz_append_pdf_string()`.
    fz_append_pdf_string: Append a string with PDF syntax quotes and
    escapes.

    The buffer will automatically grow as required.
    """
    return _mupdf.ll_fz_append_pdf_string(buffer, text)

def ll_fz_append_pixmap_as_data_uri(out, pixmap):
    r""" Low-level wrapper for `::fz_append_pixmap_as_data_uri()`."""
    return _mupdf.ll_fz_append_pixmap_as_data_uri(out, pixmap)

def ll_fz_append_rune(buf, c):
    r""" Low-level wrapper for `::fz_append_rune()`."""
    return _mupdf.ll_fz_append_rune(buf, c)

def ll_fz_append_string(buf, data):
    r""" Low-level wrapper for `::fz_append_string()`."""
    return _mupdf.ll_fz_append_string(buf, data)

def ll_fz_arc4_encrypt(state, dest, src, len):
    r"""
    Low-level wrapper for `::fz_arc4_encrypt()`.
    RC4 block encrypt operation; encrypt src into dst (both of
    length len) updating the RC4 state as we go.

    Never throws an exception.
    """
    return _mupdf.ll_fz_arc4_encrypt(state, dest, src, len)

def ll_fz_arc4_final(state):
    r"""
    Low-level wrapper for `::fz_arc4_final()`.
    RC4 finalization. Zero the context.

    Never throws an exception.
    """
    return _mupdf.ll_fz_arc4_final(state)

def ll_fz_arc4_init(state, key, len):
    r"""
    Low-level wrapper for `::fz_arc4_init()`.
    RC4 initialization. Begins an RC4 operation, writing a new
    context.

    Never throws an exception.
    """
    return _mupdf.ll_fz_arc4_init(state, key, len)

def ll_fz_archive_format(arch):
    r"""
    Low-level wrapper for `::fz_archive_format()`.
    Return a pointer to a string describing the format of the
    archive.

    The lifetime of the string is unspecified (in current
    implementations the string will persist until the archive
    is closed, but this is not guaranteed).
    """
    return _mupdf.ll_fz_archive_format(arch)

def ll_fz_atof(s):
    r"""
    Low-level wrapper for `::fz_atof()`.
    Range checking atof
    """
    return _mupdf.ll_fz_atof(s)

def ll_fz_atoi(s):
    r"""
    Low-level wrapper for `::fz_atoi()`.
    atoi that copes with NULL
    """
    return _mupdf.ll_fz_atoi(s)

def ll_fz_atoi64(s):
    r"""
    Low-level wrapper for `::fz_atoi64()`.
    64bit atoi that copes with NULL
    """
    return _mupdf.ll_fz_atoi64(s)

def ll_fz_authenticate_password(doc, password):
    r"""
    Low-level wrapper for `::fz_authenticate_password()`.
    Test if the given password can decrypt the document.

    password: The password string to be checked. Some document
    specifications do not specify any particular text encoding, so
    neither do we.

    Returns 0 for failure to authenticate, non-zero for success.

    For PDF documents, further information can be given by examining
    the bits in the return code.

    	Bit 0 => No password required
    	Bit 1 => User password authenticated
    	Bit 2 => Owner password authenticated
    """
    return _mupdf.ll_fz_authenticate_password(doc, password)

def ll_fz_available(stm, max):
    r"""
    Low-level wrapper for `::fz_available()`.
    Ask how many bytes are available immediately from
    a given stream.

    stm: The stream to read from.

    max: A hint for the underlying stream; the maximum number of
    bytes that we are sure we will want to read. If you do not know
    this number, give 1.

    Returns the number of bytes immediately available between the
    read and write pointers. This number is guaranteed only to be 0
    if we have hit EOF. The number of bytes returned here need have
    no relation to max (could be larger, could be smaller).
    """
    return _mupdf.ll_fz_available(stm, max)

def ll_fz_base_colorspace(cs):
    r"""
    Low-level wrapper for `::fz_base_colorspace()`.
    Get the 'base' colorspace for a colorspace.

    For indexed colorspaces, this is the colorspace the index
    decodes into. For all other colorspaces, it is the colorspace
    itself.

    The returned colorspace is 'borrowed' (i.e. no additional
    references are taken or dropped).
    """
    return _mupdf.ll_fz_base_colorspace(cs)

def ll_fz_basename(path):
    r"""
    Low-level wrapper for `::fz_basename()`.
    Find the filename component in a path.
    """
    return _mupdf.ll_fz_basename(path)

def ll_fz_begin_group(dev, area, cs, isolated, knockout, blendmode, alpha):
    r""" Low-level wrapper for `::fz_begin_group()`."""
    return _mupdf.ll_fz_begin_group(dev, area, cs, isolated, knockout, blendmode, alpha)

def ll_fz_begin_layer(dev, layer_name):
    r""" Low-level wrapper for `::fz_begin_layer()`."""
    return _mupdf.ll_fz_begin_layer(dev, layer_name)

def ll_fz_begin_mask(dev, area, luminosity, colorspace, bc, color_params):
    r""" Low-level wrapper for `::fz_begin_mask()`."""
    return _mupdf.ll_fz_begin_mask(dev, area, luminosity, colorspace, bc, color_params)

def ll_fz_begin_metatext(dev, meta, text):
    r""" Low-level wrapper for `::fz_begin_metatext()`."""
    return _mupdf.ll_fz_begin_metatext(dev, meta, text)

def ll_fz_begin_page(wri, mediabox):
    r"""
    Low-level wrapper for `::fz_begin_page()`.
    Called to start the process of writing a page to
    a document.

    mediabox: page size rectangle in points.

    Returns a borrowed fz_device to write page contents to. This
    should be kept if required, and only dropped if it was kept.
    """
    return _mupdf.ll_fz_begin_page(wri, mediabox)

def ll_fz_begin_structure(dev, standard, raw, idx):
    r""" Low-level wrapper for `::fz_begin_structure()`."""
    return _mupdf.ll_fz_begin_structure(dev, standard, raw, idx)

def ll_fz_begin_tile(dev, area, view, xstep, ystep, ctm):
    r""" Low-level wrapper for `::fz_begin_tile()`."""
    return _mupdf.ll_fz_begin_tile(dev, area, view, xstep, ystep, ctm)

def ll_fz_begin_tile_id(dev, area, view, xstep, ystep, ctm, id):
    r""" Low-level wrapper for `::fz_begin_tile_id()`."""
    return _mupdf.ll_fz_begin_tile_id(dev, area, view, xstep, ystep, ctm, id)

def ll_fz_bidi_fragment_text(text, textlen, baseDir, callback, arg, flags):
    r"""
     Low-level wrapper for `::fz_bidi_fragment_text()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_fz_bidi_fragment_text(const uint32_t *text, size_t textlen, ::fz_bidi_fragment_fn *callback, void *arg, int flags)` => ::fz_bidi_direction baseDir

    	Partitions the given Unicode sequence into one or more
    	unidirectional fragments and invokes the given callback
    	function for each fragment.

    	For example, if directionality of text is:
    			0123456789
    			rrlllrrrrr,
    	we'll invoke callback with:
    			&text[0], length == 2
    			&text[2], length == 3
    			&text[5], length == 5

    	:type text: int, in
    :param text:	start of Unicode sequence
        	:type textlen: int, in
    :param textlen:   number of Unicodes to analyse
        	:type baseDir: int, in
    :param baseDir:   direction of paragraph (specify FZ_BIDI_NEUTRAL to force auto-detection)
        	:type callback: ::fz_bidi_fragment_fn, in
    :param callback:  function to be called for each fragment
        	:type arg: void, in
    :param arg:	data to be passed to the callback function
        	:type flags: int, in
    :param flags:     flags to control operation (see fz_bidi_flags above)
    """
    return _mupdf.ll_fz_bidi_fragment_text(text, textlen, baseDir, callback, arg, flags)

def ll_fz_bitmap_details(bitmap, w, h, n, stride):
    r"""
     Low-level wrapper for `::fz_bitmap_details()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_fz_bitmap_details(::fz_bitmap *bitmap)` => `(int w, int h, int n, int stride)`

    	Retrieve details of a given bitmap.

    	bitmap: The bitmap to query.

    	w: Pointer to storage to retrieve width (or NULL).

    	h: Pointer to storage to retrieve height (or NULL).

    	n: Pointer to storage to retrieve number of color components (or
    	NULL).

    	stride: Pointer to storage to retrieve bitmap stride (or NULL).
    """
    return _mupdf.ll_fz_bitmap_details(bitmap, w, h, n, stride)

def ll_fz_blendmode_name(blendmode):
    r"""
    Low-level wrapper for `::fz_blendmode_name()`.
    Map from enumeration to blend mode string.

    The string is static, with arbitrary lifespan.
    """
    return _mupdf.ll_fz_blendmode_name(blendmode)

def ll_fz_bound_display_list(list):
    r"""
    Low-level wrapper for `::fz_bound_display_list()`.
    Return the bounding box of the page recorded in a display list.
    """
    return _mupdf.ll_fz_bound_display_list(list)

def ll_fz_bound_glyph(font, gid, trm):
    r"""
    Low-level wrapper for `::fz_bound_glyph()`.
    Return a bbox for a given glyph in a font.

    font: The font to look for the glyph in.

    gid: The glyph to bound.

    trm: The matrix to apply to the glyph before bounding.

    Returns rectangle by value containing the bounds of the given
    glyph.
    """
    return _mupdf.ll_fz_bound_glyph(font, gid, trm)

def ll_fz_bound_page(page):
    r"""
    Low-level wrapper for `::fz_bound_page()`.
    Determine the size of a page at 72 dpi.
    """
    return _mupdf.ll_fz_bound_page(page)

def ll_fz_bound_page_box(page, box):
    r""" Low-level wrapper for `::fz_bound_page_box()`."""
    return _mupdf.ll_fz_bound_page_box(page, box)

def ll_fz_bound_path(path, stroke, ctm):
    r"""
    Low-level wrapper for `::fz_bound_path()`.
    Return a bounding rectangle for a path.

    path: The path to bound.

    stroke: If NULL, the bounding rectangle given is for
    the filled path. If non-NULL the bounding rectangle
    given is for the path stroked with the given attributes.

    ctm: The matrix to apply to the path during stroking.

    r: Pointer to a fz_rect which will be used to hold
    the result.

    Returns r, updated to contain the bounding rectangle.
    """
    return _mupdf.ll_fz_bound_path(path, stroke, ctm)

def ll_fz_bound_shade(shade, ctm):
    r"""
    Low-level wrapper for `::fz_bound_shade()`.
    Bound a given shading.

    shade: The shade to bound.

    ctm: The transform to apply to the shade before bounding.

    r: Pointer to storage to put the bounds in.

    Returns r, updated to contain the bounds for the shading.
    """
    return _mupdf.ll_fz_bound_shade(shade, ctm)

def ll_fz_bound_text(text, stroke, ctm):
    r"""
    Low-level wrapper for `::fz_bound_text()`.
    Find the bounds of a given text object.

    text: The text object to find the bounds of.

    stroke: Pointer to the stroke attributes (for stroked
    text), or NULL (for filled text).

    ctm: The matrix in use.

    r: pointer to storage for the bounds.

    Returns a pointer to r, which is updated to contain the
    bounding box for the text object.
    """
    return _mupdf.ll_fz_bound_text(text, stroke, ctm)

def ll_fz_box_type_from_string(name):
    r""" Low-level wrapper for `::fz_box_type_from_string()`."""
    return _mupdf.ll_fz_box_type_from_string(name)

def ll_fz_buffer_extract(buf, data):
    r"""
     Low-level wrapper for `::fz_buffer_extract()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_fz_buffer_extract(::fz_buffer *buf)` => `(size_t, unsigned char *data)`

    	Take ownership of buffer contents.

    	Performs the same task as fz_buffer_storage, but ownership of
    	the data buffer returns with this call. The buffer is left
    	empty.

    	Note: Bad things may happen if this is called on a buffer with
    	multiple references that is being used from multiple threads.

    	data: Pointer to place to retrieve data pointer.

    	Returns length of stream.
    """
    return _mupdf.ll_fz_buffer_extract(buf, data)

def ll_fz_buffer_storage(buf, datap):
    r"""
     Low-level wrapper for `::fz_buffer_storage()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_fz_buffer_storage(::fz_buffer *buf)` => `(size_t, unsigned char *datap)`

    	Retrieve internal memory of buffer.

    	datap: Output parameter that will be pointed to the data.

    	Returns the current size of the data in bytes.
    """
    return _mupdf.ll_fz_buffer_storage(buf, datap)

def ll_fz_calloc(count, size):
    r"""
    Low-level wrapper for `::fz_calloc()`.
    Allocate array of memory of count entries of size bytes.
    Clears the memory to zero.

    Throws exception in the event of failure to allocate.
    """
    return _mupdf.ll_fz_calloc(count, size)

def ll_fz_calloc_no_throw(count, size):
    r"""
    Low-level wrapper for `::fz_calloc_no_throw()`.
    fz_calloc equivalent that returns NULL rather than throwing
    exceptions.
    """
    return _mupdf.ll_fz_calloc_no_throw(count, size)

def ll_fz_caught():
    r"""
    Low-level wrapper for `::fz_caught()`.
    Within an fz_catch() block, retrieve the error code for
    the current exception.

    This assumes no intervening use of fz_try/fz_catch.
    """
    return _mupdf.ll_fz_caught()

def ll_fz_caught_errno():
    r""" Low-level wrapper for `::fz_caught_errno()`."""
    return _mupdf.ll_fz_caught_errno()

def ll_fz_caught_message():
    r"""
    Low-level wrapper for `::fz_caught_message()`.
    Within an fz_catch() block, retrieve the formatted message
    string for the current exception.

    This assumes no intervening use of fz_try/fz_catch.
    """
    return _mupdf.ll_fz_caught_message()

def ll_fz_chartorune(rune, str):
    r"""
     Low-level wrapper for `::fz_chartorune()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_fz_chartorune(const char *str)` => `(int, int rune)`

    	UTF8 decode a single rune from a sequence of chars.

    	rune: Pointer to an int to assign the decoded 'rune' to.

    	str: Pointer to a UTF8 encoded string.

    	Returns the number of bytes consumed.
    """
    return _mupdf.ll_fz_chartorune(rune, str)

def ll_fz_clamp(x, min, max):
    r""" Low-level wrapper for `::fz_clamp()`."""
    return _mupdf.ll_fz_clamp(x, min, max)

def ll_fz_clamp64(x, min, max):
    r""" Low-level wrapper for `::fz_clamp64()`."""
    return _mupdf.ll_fz_clamp64(x, min, max)

def ll_fz_clamp_color(cs, _in, out):
    r"""
     Low-level wrapper for `::fz_clamp_color()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_fz_clamp_color(::fz_colorspace *cs, const float *in)` => float out

    	Clamp the samples in a color to the correct ranges for a
    	given colorspace.
    """
    return _mupdf.ll_fz_clamp_color(cs, _in, out)

def ll_fz_clamp_location(doc, loc):
    r"""
    Low-level wrapper for `::fz_clamp_location()`.
    Clamps a location into valid chapter/page range. (First clamps
    the chapter into range, then the page into range).
    """
    return _mupdf.ll_fz_clamp_location(doc, loc)

def ll_fz_clampd(x, min, max):
    r""" Low-level wrapper for `::fz_clampd()`."""
    return _mupdf.ll_fz_clampd(x, min, max)

def ll_fz_clampi(x, min, max):
    r""" Low-level wrapper for `::fz_clampi()`."""
    return _mupdf.ll_fz_clampi(x, min, max)

def ll_fz_clampp(x, min, max):
    r""" Low-level wrapper for `::fz_clampp()`."""
    return _mupdf.ll_fz_clampp(x, min, max)

def ll_fz_cleanname(name):
    r"""
    Low-level wrapper for `::fz_cleanname()`.
    rewrite path to the shortest string that names the same path.

    Eliminates multiple and trailing slashes, interprets "." and
    "..". Overwrites the string in place.
    """
    return _mupdf.ll_fz_cleanname(name)

def ll_fz_cleanname_strdup(name):
    r"""
    Low-level wrapper for `::fz_cleanname_strdup()`.
    rewrite path to the shortest string that names the same path.

    Eliminates multiple and trailing slashes, interprets "." and
    "..". Allocates a new string that the caller must free.
    """
    return _mupdf.ll_fz_cleanname_strdup(name)

def ll_fz_clear_bitmap(bit):
    r"""
    Low-level wrapper for `::fz_clear_bitmap()`.
    Set the entire bitmap to 0.

    Never throws exceptions.
    """
    return _mupdf.ll_fz_clear_bitmap(bit)

def ll_fz_clear_buffer(buf):
    r"""
    Low-level wrapper for `::fz_clear_buffer()`.
    Empties the buffer. Storage is not freed, but is held ready
    to be reused as the buffer is refilled.

    Never throws exceptions.
    """
    return _mupdf.ll_fz_clear_buffer(buf)

def ll_fz_clear_pixmap(pix):
    r"""
    Low-level wrapper for `::fz_clear_pixmap()`.
    Sets all components (including alpha) of
    all pixels in a pixmap to 0.

    pix: The pixmap to clear.
    """
    return _mupdf.ll_fz_clear_pixmap(pix)

def ll_fz_clear_pixmap_rect_with_value(pix, value, r):
    r"""
    Low-level wrapper for `::fz_clear_pixmap_rect_with_value()`.
    Clears a subrect of a pixmap with the given value.

    pix: The pixmap to clear.

    value: Values in the range 0 to 255 are valid. Each component
    sample for each pixel in the pixmap will be set to this value,
    while alpha will always be set to 255 (non-transparent).

    r: the rectangle.
    """
    return _mupdf.ll_fz_clear_pixmap_rect_with_value(pix, value, r)

def ll_fz_clear_pixmap_with_value(pix, value):
    r"""
    Low-level wrapper for `::fz_clear_pixmap_with_value()`.
    Clears a pixmap with the given value.

    pix: The pixmap to clear.

    value: Values in the range 0 to 255 are valid. Each component
    sample for each pixel in the pixmap will be set to this value,
    while alpha will always be set to 255 (non-transparent).

    This function is horrible, and should be removed from the
    API and replaced with a less magic one.
    """
    return _mupdf.ll_fz_clear_pixmap_with_value(pix, value)

def ll_fz_clip_image_mask(dev, image, ctm, scissor):
    r""" Low-level wrapper for `::fz_clip_image_mask()`."""
    return _mupdf.ll_fz_clip_image_mask(dev, image, ctm, scissor)

def ll_fz_clip_path(dev, path, even_odd, ctm, scissor):
    r""" Low-level wrapper for `::fz_clip_path()`."""
    return _mupdf.ll_fz_clip_path(dev, path, even_odd, ctm, scissor)

def ll_fz_clip_stroke_path(dev, path, stroke, ctm, scissor):
    r""" Low-level wrapper for `::fz_clip_stroke_path()`."""
    return _mupdf.ll_fz_clip_stroke_path(dev, path, stroke, ctm, scissor)

def ll_fz_clip_stroke_text(dev, text, stroke, ctm, scissor):
    r""" Low-level wrapper for `::fz_clip_stroke_text()`."""
    return _mupdf.ll_fz_clip_stroke_text(dev, text, stroke, ctm, scissor)

def ll_fz_clip_text(dev, text, ctm, scissor):
    r""" Low-level wrapper for `::fz_clip_text()`."""
    return _mupdf.ll_fz_clip_text(dev, text, ctm, scissor)

def ll_fz_clone_buffer(buf):
    r"""
    Low-level wrapper for `::fz_clone_buffer()`.
    Make a new buffer, containing a copy of the data used in
    the original.
    """
    return _mupdf.ll_fz_clone_buffer(buf)

def ll_fz_clone_context():
    r"""
    Low-level wrapper for `::fz_clone_context()`.
    Make a clone of an existing context.

    This function is meant to be used in multi-threaded
    applications where each thread requires its own context, yet
    parts of the global state, for example caching, are shared.

    ctx: Context obtained from fz_new_context to make a copy of.
    ctx must have had locks and lock/functions setup when created.
    The two contexts will share the memory allocator, resource
    store, locks and lock/unlock functions. They will each have
    their own exception stacks though.

    May return NULL.
    """
    return _mupdf.ll_fz_clone_context()

def ll_fz_clone_default_colorspaces(base):
    r"""
    Low-level wrapper for `::fz_clone_default_colorspaces()`.
    Returns a reference to a newly cloned default colorspaces
    structure.

    The new clone may safely be altered without fear of race
    conditions as the caller is the only reference holder.
    """
    return _mupdf.ll_fz_clone_default_colorspaces(base)

def ll_fz_clone_path(path):
    r"""
    Low-level wrapper for `::fz_clone_path()`.
    Clone the data for a path.

    This is used in preference to fz_keep_path when a whole
    new copy of a path is required, rather than just a shared
    pointer. This probably indicates that the path is about to
    be modified.

    path: path to clone.

    Throws exceptions on failure to allocate.
    """
    return _mupdf.ll_fz_clone_path(path)

def ll_fz_clone_pixmap(old):
    r"""
    Low-level wrapper for `::fz_clone_pixmap()`.
    Clone a pixmap, copying the pixels and associated data to new
    storage.

    The reference count of 'old' is unchanged.
    """
    return _mupdf.ll_fz_clone_pixmap(old)

def ll_fz_clone_pixmap_area_with_different_seps(src, bbox, dcs, seps, color_params, default_cs):
    r""" Low-level wrapper for `::fz_clone_pixmap_area_with_different_seps()`."""
    return _mupdf.ll_fz_clone_pixmap_area_with_different_seps(src, bbox, dcs, seps, color_params, default_cs)

def ll_fz_clone_separations_for_overprint(seps):
    r"""
    Low-level wrapper for `::fz_clone_separations_for_overprint()`.
    Return a separations object with all the spots in the input
    separations object that are set to composite, reset to be
    enabled. If there ARE no spots in the object, this returns
    NULL. If the object already has all its spots enabled, then
    just returns another handle on the same object.
    """
    return _mupdf.ll_fz_clone_separations_for_overprint(seps)

def ll_fz_clone_stroke_state(stroke):
    r"""
    Low-level wrapper for `::fz_clone_stroke_state()`.
    Create an identical stroke_state structure and return a
    reference to it.

    stroke: The stroke state reference to clone.

    Exceptions may be thrown in the event of a failure to
    allocate.
    """
    return _mupdf.ll_fz_clone_stroke_state(stroke)

def ll_fz_close_band_writer(writer):
    r"""
    Low-level wrapper for `::fz_close_band_writer()`.
    Finishes up the output and closes the band writer. After this
    call no more headers or bands may be written.
    """
    return _mupdf.ll_fz_close_band_writer(writer)

def ll_fz_close_device(dev):
    r"""
    Low-level wrapper for `::fz_close_device()`.
    Signal the end of input, and flush any buffered output.
    This is NOT called implicitly on fz_drop_device. This
    may throw exceptions.
    """
    return _mupdf.ll_fz_close_device(dev)

def ll_fz_close_document_writer(wri):
    r"""
    Low-level wrapper for `::fz_close_document_writer()`.
    Called to end the process of writing
    pages to a document.

    This writes any file level trailers required. After this
    completes successfully the file is up to date and complete.
    """
    return _mupdf.ll_fz_close_document_writer(wri)

def ll_fz_close_output(arg_1):
    r"""
    Low-level wrapper for `::fz_close_output()`.
    Flush pending output and close an output stream.
    """
    return _mupdf.ll_fz_close_output(arg_1)

def ll_fz_close_zip_writer(zip):
    r"""
    Low-level wrapper for `::fz_close_zip_writer()`.
    Close the zip file for writing.

    This flushes any pending data to the file. This can throw
    exceptions.
    """
    return _mupdf.ll_fz_close_zip_writer(zip)

def ll_fz_closepath(path):
    r"""
    Low-level wrapper for `::fz_closepath()`.
    Close the current subpath.

    path: The path to modify.

    Throws exceptions on failure to allocate, attempting to modify
    a packed path, and illegal path closes (i.e. closing a non open
    path).
    """
    return _mupdf.ll_fz_closepath(path)

def ll_fz_colorspace_colorant(cs, n):
    r"""
    Low-level wrapper for `::fz_colorspace_colorant()`.
    Retrieve a the name for a colorant.

    Returns a pointer with the same lifespan as the colorspace.
    """
    return _mupdf.ll_fz_colorspace_colorant(cs, n)

def ll_fz_colorspace_device_n_has_cmyk(cs):
    r"""
    Low-level wrapper for `::fz_colorspace_device_n_has_cmyk()`.
    True if DeviceN color space has cyan magenta yellow or black as
    one of its colorants.
    """
    return _mupdf.ll_fz_colorspace_device_n_has_cmyk(cs)

def ll_fz_colorspace_device_n_has_only_cmyk(cs):
    r"""
    Low-level wrapper for `::fz_colorspace_device_n_has_only_cmyk()`.
    True if DeviceN color space has only colorants from the CMYK set.
    """
    return _mupdf.ll_fz_colorspace_device_n_has_only_cmyk(cs)

def ll_fz_colorspace_is_cmyk(cs):
    r""" Low-level wrapper for `::fz_colorspace_is_cmyk()`."""
    return _mupdf.ll_fz_colorspace_is_cmyk(cs)

def ll_fz_colorspace_is_device(cs):
    r""" Low-level wrapper for `::fz_colorspace_is_device()`."""
    return _mupdf.ll_fz_colorspace_is_device(cs)

def ll_fz_colorspace_is_device_cmyk(cs):
    r""" Low-level wrapper for `::fz_colorspace_is_device_cmyk()`."""
    return _mupdf.ll_fz_colorspace_is_device_cmyk(cs)

def ll_fz_colorspace_is_device_gray(cs):
    r""" Low-level wrapper for `::fz_colorspace_is_device_gray()`."""
    return _mupdf.ll_fz_colorspace_is_device_gray(cs)

def ll_fz_colorspace_is_device_n(cs):
    r""" Low-level wrapper for `::fz_colorspace_is_device_n()`."""
    return _mupdf.ll_fz_colorspace_is_device_n(cs)

def ll_fz_colorspace_is_gray(cs):
    r"""
    Low-level wrapper for `::fz_colorspace_is_gray()`.
    Tests for particular types of colorspaces
    """
    return _mupdf.ll_fz_colorspace_is_gray(cs)

def ll_fz_colorspace_is_indexed(cs):
    r""" Low-level wrapper for `::fz_colorspace_is_indexed()`."""
    return _mupdf.ll_fz_colorspace_is_indexed(cs)

def ll_fz_colorspace_is_lab(cs):
    r""" Low-level wrapper for `::fz_colorspace_is_lab()`."""
    return _mupdf.ll_fz_colorspace_is_lab(cs)

def ll_fz_colorspace_is_lab_icc(cs):
    r""" Low-level wrapper for `::fz_colorspace_is_lab_icc()`."""
    return _mupdf.ll_fz_colorspace_is_lab_icc(cs)

def ll_fz_colorspace_is_rgb(cs):
    r""" Low-level wrapper for `::fz_colorspace_is_rgb()`."""
    return _mupdf.ll_fz_colorspace_is_rgb(cs)

def ll_fz_colorspace_is_subtractive(cs):
    r"""
    Low-level wrapper for `::fz_colorspace_is_subtractive()`.
    True for CMYK, Separation and DeviceN colorspaces.
    """
    return _mupdf.ll_fz_colorspace_is_subtractive(cs)

def ll_fz_colorspace_n(cs):
    r"""
    Low-level wrapper for `::fz_colorspace_n()`.
    Query the number of colorants in a colorspace.
    """
    return _mupdf.ll_fz_colorspace_n(cs)

def ll_fz_colorspace_name(cs):
    r"""
    Low-level wrapper for `::fz_colorspace_name()`.
    Query the name of a colorspace.

    The returned string has the same lifespan as the colorspace
    does. Caller should not free it.
    """
    return _mupdf.ll_fz_colorspace_name(cs)

def ll_fz_colorspace_name_colorant(cs, n, name):
    r"""
    Low-level wrapper for `::fz_colorspace_name_colorant()`.
    Assign a name for a given colorant in a colorspace.

    Used while initially setting up a colorspace. The string is
    copied into local storage, so need not be retained by the
    caller.
    """
    return _mupdf.ll_fz_colorspace_name_colorant(cs, n, name)

def ll_fz_colorspace_type(cs):
    r"""
    Low-level wrapper for `::fz_colorspace_type()`.
    Query the type of colorspace.
    """
    return _mupdf.ll_fz_colorspace_type(cs)

def ll_fz_compare_separations(sep1, sep2):
    r"""
    Low-level wrapper for `::fz_compare_separations()`.
    Compare 2 separations structures (or NULLs).

    Return 0 if identical, non-zero if not identical.
    """
    return _mupdf.ll_fz_compare_separations(sep1, sep2)

def ll_fz_compress_ccitt_fax_g3(data, columns, rows, stride):
    r"""
    Low-level wrapper for `::fz_compress_ccitt_fax_g3()`.
    Compress bitmap data as CCITT Group 3 1D fax image.
    Creates a stream assuming the default PDF parameters,
    except the number of columns.
    """
    return _mupdf.ll_fz_compress_ccitt_fax_g3(data, columns, rows, stride)

def ll_fz_compress_ccitt_fax_g4(data, columns, rows, stride):
    r"""
    Low-level wrapper for `::fz_compress_ccitt_fax_g4()`.
    Compress bitmap data as CCITT Group 4 2D fax image.
    Creates a stream assuming the default PDF parameters, except
    K=-1 and the number of columns.
    """
    return _mupdf.ll_fz_compress_ccitt_fax_g4(data, columns, rows, stride)

def ll_fz_compressed_buffer_size(buffer):
    r"""
    Low-level wrapper for `::fz_compressed_buffer_size()`.
    Return the storage size used for a buffer and its data.
    Used in implementing store handling.

    Never throws exceptions.
    """
    return _mupdf.ll_fz_compressed_buffer_size(buffer)

def ll_fz_compressed_image_buffer(image):
    r"""
    Low-level wrapper for `::fz_compressed_image_buffer()`.
    Retrieve the underlying compressed data for an image.

    Returns a pointer to the underlying data buffer for an image,
    or NULL if this image is not based upon a compressed data
    buffer.

    This is not a reference counted structure, so no reference is
    returned. Lifespan is limited to that of the image itself.
    """
    return _mupdf.ll_fz_compressed_image_buffer(image)

def ll_fz_compressed_image_type(image):
    r"""
    Low-level wrapper for `::fz_compressed_image_type()`.
    Return the type of a compressed image.

    Any non-compressed image will have the type returned as UNKNOWN.
    """
    return _mupdf.ll_fz_compressed_image_type(image)

def ll_fz_concat(left, right):
    r"""
    Low-level wrapper for `::fz_concat()`.
    Multiply two matrices.

    The order of the two matrices are important since matrix
    multiplication is not commutative.

    Returns result.
    """
    return _mupdf.ll_fz_concat(left, right)

def ll_fz_concat_push_drop(concat, chain):
    r"""
    Low-level wrapper for `::fz_concat_push_drop()`.
    Add a chained stream to the end of the concatenate filter.

    Ownership of chain is passed in.
    """
    return _mupdf.ll_fz_concat_push_drop(concat, chain)

def ll_fz_contains_rect(a, b):
    r"""
    Low-level wrapper for `::fz_contains_rect()`.
    Test rectangle inclusion.

    Return true if a entirely contains b.
    """
    return _mupdf.ll_fz_contains_rect(a, b)

def ll_fz_convert_color(ss, sv, ds, dv, _is, params):
    r"""
     Low-level wrapper for `::fz_convert_color()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_fz_convert_color(::fz_colorspace *ss, const float *sv, ::fz_colorspace *ds, ::fz_colorspace *is, ::fz_color_params params)` => float dv

    	Convert color values sv from colorspace ss into colorvalues dv
    	for colorspace ds, via an optional intervening space is,
    	respecting the given color_params.
    """
    return _mupdf.ll_fz_convert_color(ss, sv, ds, dv, _is, params)

def ll_fz_convert_error(code):
    r"""
     Low-level wrapper for `::fz_convert_error()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_fz_convert_error()` => `(const char *, int code)`
    """
    return _mupdf.ll_fz_convert_error(code)

def ll_fz_convert_indexed_pixmap_to_base(src):
    r"""
    Low-level wrapper for `::fz_convert_indexed_pixmap_to_base()`.
    Convert pixmap from indexed to base colorspace.

    This creates a new bitmap containing the converted pixmap data.
    """
    return _mupdf.ll_fz_convert_indexed_pixmap_to_base(src)

def ll_fz_convert_pixmap(pix, cs_des, prf, default_cs, color_params, keep_alpha):
    r"""
    Low-level wrapper for `::fz_convert_pixmap()`.
    Convert an existing pixmap to a desired
    colorspace. Other properties of the pixmap, such as resolution
    and position are copied to the converted pixmap.

    pix: The pixmap to convert.

    default_cs: If NULL pix->colorspace is used. It is possible that
    the data may need to be interpreted as one of the color spaces
    in default_cs.

    cs_des: Desired colorspace, may be NULL to denote alpha-only.

    prf: Proofing color space through which we need to convert.

    color_params: Parameters that may be used in conversion (e.g.
    ri).

    keep_alpha: If 0 any alpha component is removed, otherwise
    alpha is kept if present in the pixmap.
    """
    return _mupdf.ll_fz_convert_pixmap(pix, cs_des, prf, default_cs, color_params, keep_alpha)

def ll_fz_convert_separation_colors(src_cs, src_color, dst_seps, dst_cs, dst_color, color_params):
    r"""
     Low-level wrapper for `::fz_convert_separation_colors()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_fz_convert_separation_colors(::fz_colorspace *src_cs, const float *src_color, ::fz_separations *dst_seps, ::fz_colorspace *dst_cs, ::fz_color_params color_params)` => float dst_color

    	Convert a color given in terms of one colorspace,
    	to a color in terms of another colorspace/separations.
    """
    return _mupdf.ll_fz_convert_separation_colors(src_cs, src_color, dst_seps, dst_cs, dst_color, color_params)

def ll_fz_convert_separation_pixmap_to_base(src):
    r"""
    Low-level wrapper for `::fz_convert_separation_pixmap_to_base()`.
    Convert pixmap from DeviceN/Separation to base colorspace.

    This creates a new bitmap containing the converted pixmap data.
    """
    return _mupdf.ll_fz_convert_separation_pixmap_to_base(src)

def ll_fz_copy_option(val, dest, maxlen):
    r"""
    Low-level wrapper for `::fz_copy_option()`.
    Copy an option (val) into a destination buffer (dest), of maxlen
    bytes.

    Returns the number of bytes (including terminator) that did not
    fit. If val is maxlen or greater bytes in size, it will be left
    unterminated.
    """
    return _mupdf.ll_fz_copy_option(val, dest, maxlen)

def ll_fz_copy_pixmap_rect(dest, src, r, default_cs):
    r""" Low-level wrapper for `::fz_copy_pixmap_rect()`."""
    return _mupdf.ll_fz_copy_pixmap_rect(dest, src, r, default_cs)

def ll_fz_copy_rectangle(page, area, crlf):
    r"""
    Low-level wrapper for `::fz_copy_rectangle()`.
    Return a newly allocated UTF-8 string with the text for a given
    selection rectangle.

    crlf: If true, write "\r\n" style line endings (otherwise "\n"
    only).
    """
    return _mupdf.ll_fz_copy_rectangle(page, area, crlf)

def ll_fz_copy_selection(page, a, b, crlf):
    r"""
    Low-level wrapper for `::fz_copy_selection()`.
    Return a newly allocated UTF-8 string with the text for a given
    selection.

    crlf: If true, write "\r\n" style line endings (otherwise "\n"
    only).
    """
    return _mupdf.ll_fz_copy_selection(page, a, b, crlf)

def ll_fz_count_active_separations(seps):
    r"""
    Low-level wrapper for `::fz_count_active_separations()`.
    Return the number of active separations.
    """
    return _mupdf.ll_fz_count_active_separations(seps)

def ll_fz_count_archive_entries(arch):
    r"""
    Low-level wrapper for `::fz_count_archive_entries()`.
    Number of entries in archive.

    Will always return a value >= 0.

    May throw an exception if this type of archive cannot count the
    entries (such as a directory).
    """
    return _mupdf.ll_fz_count_archive_entries(arch)

def ll_fz_count_chapter_pages(doc, chapter):
    r"""
    Low-level wrapper for `::fz_count_chapter_pages()`.
    Return the number of pages in a chapter.
    May return 0.
    """
    return _mupdf.ll_fz_count_chapter_pages(doc, chapter)

def ll_fz_count_chapters(doc):
    r"""
    Low-level wrapper for `::fz_count_chapters()`.
    Return the number of chapters in the document.
    At least 1.
    """
    return _mupdf.ll_fz_count_chapters(doc)

def ll_fz_count_pages(doc):
    r"""
    Low-level wrapper for `::fz_count_pages()`.
    Return the number of pages in document

    May return 0 for documents with no pages.
    """
    return _mupdf.ll_fz_count_pages(doc)

def ll_fz_count_separations(sep):
    r""" Low-level wrapper for `::fz_count_separations()`."""
    return _mupdf.ll_fz_count_separations(sep)

def ll_fz_create_link(page, bbox, uri):
    r"""
    Low-level wrapper for `::fz_create_link()`.
    Create a new link on a page.
    """
    return _mupdf.ll_fz_create_link(page, bbox, uri)

def ll_fz_currentpoint(path):
    r"""
    Low-level wrapper for `::fz_currentpoint()`.
    Return the current point that a path has
    reached or (0,0) if empty.

    path: path to return the current point of.
    """
    return _mupdf.ll_fz_currentpoint(path)

def ll_fz_curveto(path, x0, y0, x1, y1, x2, y2):
    r"""
    Low-level wrapper for `::fz_curveto()`.
    Append a 'curveto' command to an open path. (For a
    cubic bezier).

    path: The path to modify.

    x0, y0: The coordinates of the first control point for the
    curve.

    x1, y1: The coordinates of the second control point for the
    curve.

    x2, y2: The end coordinates for the curve.

    Throws exceptions on failure to allocate, or attempting to
    modify a packed path.
    """
    return _mupdf.ll_fz_curveto(path, x0, y0, x1, y1, x2, y2)

def ll_fz_curvetov(path, x1, y1, x2, y2):
    r"""
    Low-level wrapper for `::fz_curvetov()`.
    Append a 'curvetov' command to an open path. (For a
    cubic bezier with the first control coordinate equal to
    the start point).

    path: The path to modify.

    x1, y1: The coordinates of the second control point for the
    curve.

    x2, y2: The end coordinates for the curve.

    Throws exceptions on failure to allocate, or attempting to
    modify a packed path.
    """
    return _mupdf.ll_fz_curvetov(path, x1, y1, x2, y2)

def ll_fz_curvetoy(path, x0, y0, x2, y2):
    r"""
    Low-level wrapper for `::fz_curvetoy()`.
    Append a 'curvetoy' command to an open path. (For a
    cubic bezier with the second control coordinate equal to
    the end point).

    path: The path to modify.

    x0, y0: The coordinates of the first control point for the
    curve.

    x2, y2: The end coordinates for the curve (and the second
    control coordinate).

    Throws exceptions on failure to allocate, or attempting to
    modify a packed path.
    """
    return _mupdf.ll_fz_curvetoy(path, x0, y0, x2, y2)

def ll_fz_debug_store(out):
    r"""
    Low-level wrapper for `::fz_debug_store()`.
    Output debugging information for the current state of the store
    to the given output channel.
    """
    return _mupdf.ll_fz_debug_store(out)

def ll_fz_debug_xml(item, level):
    r"""
    Low-level wrapper for `::fz_debug_xml()`.
    Pretty-print an XML tree to stdout. (Deprecated, use
    fz_output_xml in preference).
    """
    return _mupdf.ll_fz_debug_xml(item, level)

def ll_fz_decode_tile(pix, decode):
    r""" Low-level wrapper for `::fz_decode_tile()`."""
    return _mupdf.ll_fz_decode_tile(pix, decode)

def ll_fz_decode_uri(s):
    r"""
     Low-level wrapper for `::fz_decode_uri()`.
    Return a new string representing the unencoded version of the given URI.
    This decodes all escape sequences except those that would result in a reserved
    character that are part of the URI syntax (; / ? : @ & = + $ , #).
    """
    return _mupdf.ll_fz_decode_uri(s)

def ll_fz_decode_uri_component(s):
    r"""
     Low-level wrapper for `::fz_decode_uri_component()`.
    Return a new string representing the unencoded version of the given URI component.
    This decodes all escape sequences!
    """
    return _mupdf.ll_fz_decode_uri_component(s)

def ll_fz_decomp_image_from_stream(stm, image, subarea, indexed, l2factor, l2extra):
    r"""
     Low-level wrapper for `::fz_decomp_image_from_stream()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_fz_decomp_image_from_stream(::fz_stream *stm, ::fz_compressed_image *image, ::fz_irect *subarea, int indexed, int l2factor)` => `(fz_pixmap *, int l2extra)`

    	Decode a subarea of a compressed image. l2factor is the amount
    	of subsampling inbuilt to the stream (i.e. performed by the
    	decoder). If non NULL, l2extra is the extra amount of
    	subsampling that should be performed by this routine. This will
    	be updated on exit to the amount of subsampling that is still
    	required to be done.

    	Returns a kept reference.
    """
    return _mupdf.ll_fz_decomp_image_from_stream(stm, image, subarea, indexed, l2factor, l2extra)

def ll_fz_decouple_type3_font(font, t3doc):
    r""" Low-level wrapper for `::fz_decouple_type3_font()`."""
    return _mupdf.ll_fz_decouple_type3_font(font, t3doc)

def ll_fz_default_cmyk(default_cs):
    r""" Low-level wrapper for `::fz_default_cmyk()`."""
    return _mupdf.ll_fz_default_cmyk(default_cs)

def ll_fz_default_error_callback(user, message):
    r"""
    Low-level wrapper for `::fz_default_error_callback()`.
    FIXME: Better not to expose fz_default_error_callback, and
    fz_default_warning callback and to allow 'NULL' to be used
    int fz_set_xxxx_callback to mean "defaults".

    FIXME: Do we need/want functions like
    fz_error_callback(ctx, message) to allow callers to inject
    stuff into the error/warning streams?

    The default error callback. Declared publicly just so that the
    error callback can be set back to this after it has been
    overridden.
    """
    return _mupdf.ll_fz_default_error_callback(user, message)

def ll_fz_default_gray(default_cs):
    r"""
    Low-level wrapper for `::fz_default_gray()`.
    Retrieve default colorspaces (typically page local).

    If default_cs is non NULL, the default is retrieved from there,
    otherwise the global default is retrieved.

    These return borrowed references that should not be dropped,
    unless they are kept first.
    """
    return _mupdf.ll_fz_default_gray(default_cs)

def ll_fz_default_halftone(num_comps):
    r"""
    Low-level wrapper for `::fz_default_halftone()`.
    Create a 'default' halftone structure
    for the given number of components.

    num_comps: The number of components to use.

    Returns a simple default halftone. The default halftone uses
    the same halftone tile for each plane, which may not be ideal
    for all purposes.
    """
    return _mupdf.ll_fz_default_halftone(num_comps)

def ll_fz_default_output_intent(default_cs):
    r""" Low-level wrapper for `::fz_default_output_intent()`."""
    return _mupdf.ll_fz_default_output_intent(default_cs)

def ll_fz_default_rgb(default_cs):
    r""" Low-level wrapper for `::fz_default_rgb()`."""
    return _mupdf.ll_fz_default_rgb(default_cs)

def ll_fz_default_warning_callback(user, message):
    r"""
    Low-level wrapper for `::fz_default_warning_callback()`.
    The default warning callback. Declared publicly just so that
    the warning callback can be set back to this after it has been
    overridden.
    """
    return _mupdf.ll_fz_default_warning_callback(user, message)

def ll_fz_defer_reap_end():
    r"""
    Low-level wrapper for `::fz_defer_reap_end()`.
    Decrement the defer reap count.

    If the defer reap count returns to 0, and the store
    has reapable objects in, a reap pass will begin.

    Call this at the end of a process during which you
    potentially might drop many reapable objects.

    It is vital that every fz_defer_reap_start is matched
    by a fz_defer_reap_end call.
    """
    return _mupdf.ll_fz_defer_reap_end()

def ll_fz_defer_reap_start():
    r"""
    Low-level wrapper for `::fz_defer_reap_start()`.
    Increment the defer reap count.

    No reap operations will take place (except for those
    triggered by an immediate failed malloc) until the
    defer reap count returns to 0.

    Call this at the start of a process during which you
    potentially might drop many reapable objects.

    It is vital that every fz_defer_reap_start is matched
    by a fz_defer_reap_end call.
    """
    return _mupdf.ll_fz_defer_reap_start()

def ll_fz_deflate(dest, compressed_length, source, source_length, level):
    r"""
     Low-level wrapper for `::fz_deflate()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_fz_deflate(unsigned char *dest, const unsigned char *source, size_t source_length, ::fz_deflate_level level)` => size_t compressed_length

    	Compress source_length bytes of data starting
    	at source, into a buffer of length *destLen, starting at dest.
    compressed_length will be updated on exit to contain the size
    	actually used.
    """
    return _mupdf.ll_fz_deflate(dest, compressed_length, source, source_length, level)

def ll_fz_deflate_bound(size):
    r"""
    Low-level wrapper for `::fz_deflate_bound()`.
    Returns the upper bound on the
    size of flated data of length size.
    """
    return _mupdf.ll_fz_deflate_bound(size)

def ll_fz_delete_link(page, link):
    r"""
    Low-level wrapper for `::fz_delete_link()`.
    Delete an existing link on a page.
    """
    return _mupdf.ll_fz_delete_link(page, link)

def ll_fz_detach_xml(node):
    r"""
    Low-level wrapper for `::fz_detach_xml()`.
    Detach a node from the tree, unlinking it from its parent,
    and setting the document root to the node.
    """
    return _mupdf.ll_fz_detach_xml(node)

def ll_fz_device_bgr():
    r""" Low-level wrapper for `::fz_device_bgr()`."""
    return _mupdf.ll_fz_device_bgr()

def ll_fz_device_cmyk():
    r""" Low-level wrapper for `::fz_device_cmyk()`."""
    return _mupdf.ll_fz_device_cmyk()

def ll_fz_device_current_scissor(dev):
    r"""
    Low-level wrapper for `::fz_device_current_scissor()`.
    Find current scissor region as tracked by the device.
    """
    return _mupdf.ll_fz_device_current_scissor(dev)

def ll_fz_device_gray():
    r"""
    Low-level wrapper for `::fz_device_gray()`.
    Retrieve global default colorspaces.

    These return borrowed references that should not be dropped,
    unless they are kept first.
    """
    return _mupdf.ll_fz_device_gray()

def ll_fz_device_lab():
    r""" Low-level wrapper for `::fz_device_lab()`."""
    return _mupdf.ll_fz_device_lab()

def ll_fz_device_rgb():
    r""" Low-level wrapper for `::fz_device_rgb()`."""
    return _mupdf.ll_fz_device_rgb()

def ll_fz_dirname(dir, path, dirsize):
    r"""
    Low-level wrapper for `::fz_dirname()`.
    extract the directory component from a path.
    """
    return _mupdf.ll_fz_dirname(dir, path, dirsize)

def ll_fz_disable_device_hints(dev, hints):
    r"""
    Low-level wrapper for `::fz_disable_device_hints()`.
    Disable (clear) hint bits within the hint bitfield for a device.
    """
    return _mupdf.ll_fz_disable_device_hints(dev, hints)

def ll_fz_disable_icc():
    r"""
    Low-level wrapper for `::fz_disable_icc()`.
    Disable icc profile based operation.
    """
    return _mupdf.ll_fz_disable_icc()

def ll_fz_display_list_is_empty(list):
    r"""
    Low-level wrapper for `::fz_display_list_is_empty()`.
    Check for a display list being empty

    list: The list to check.

    Returns true if empty, false otherwise.
    """
    return _mupdf.ll_fz_display_list_is_empty(list)

def ll_fz_div255(c, a):
    r"""
    Low-level wrapper for `::fz_div255()`.
    Undo alpha premultiplication.
    """
    return _mupdf.ll_fz_div255(c, a)

def ll_fz_do_always():
    r""" Low-level wrapper for `::fz_do_always()`."""
    return _mupdf.ll_fz_do_always()

def ll_fz_do_catch():
    r""" Low-level wrapper for `::fz_do_catch()`."""
    return _mupdf.ll_fz_do_catch()

def ll_fz_do_try():
    r""" Low-level wrapper for `::fz_do_try()`."""
    return _mupdf.ll_fz_do_try()

def ll_fz_document_open_fn_call(fn, stream, accel, dir):
    r"""
     Low-level wrapper for `::fz_document_open_fn_call()`.  Helper for calling a `fz_document_open_fn` function pointer via Swig
    from Python/C#.
    """
    return _mupdf.ll_fz_document_open_fn_call(fn, stream, accel, dir)

def ll_fz_document_output_intent(doc):
    r"""
    Low-level wrapper for `::fz_document_output_intent()`.
    Find the output intent colorspace if the document has defined
    one.

    Returns a borrowed reference that should not be dropped, unless
    it is kept first.
    """
    return _mupdf.ll_fz_document_output_intent(doc)

def ll_fz_document_recognize_content_fn_call(fn, stream, dir):
    r"""
     Low-level wrapper for `::fz_document_recognize_content_fn_call()`.  Helper for calling a `fz_document_recognize_content_fn` function
    pointer via Swig from Python/C#.
    """
    return _mupdf.ll_fz_document_recognize_content_fn_call(fn, stream, dir)

def ll_fz_document_supports_accelerator(doc):
    r"""
    Low-level wrapper for `::fz_document_supports_accelerator()`.
    Query if the document supports the saving of accelerator data.
    """
    return _mupdf.ll_fz_document_supports_accelerator(doc)

def ll_fz_dom_add_attribute(elt, att, value):
    r"""
    Low-level wrapper for `::fz_dom_add_attribute()`.
    Add an attribute to an element.

    Ownership of att and value remain with the caller.
    """
    return _mupdf.ll_fz_dom_add_attribute(elt, att, value)

def ll_fz_dom_append_child(parent, child):
    r"""
    Low-level wrapper for `::fz_dom_append_child()`.
    Insert an element as the last child of a parent, unlinking the
    child from its current position if required.
    """
    return _mupdf.ll_fz_dom_append_child(parent, child)

def ll_fz_dom_attribute(elt, att):
    r"""
    Low-level wrapper for `::fz_dom_attribute()`.
    Retrieve the value of a given attribute from a given element.

    Returns a borrowed pointer to the value or NULL if not found.
    """
    return _mupdf.ll_fz_dom_attribute(elt, att)

def ll_fz_dom_body(dom):
    r"""
    Low-level wrapper for `::fz_dom_body()`.
    Return a borrowed reference for the 'body' element of
    the given DOM.
    """
    return _mupdf.ll_fz_dom_body(dom)

def ll_fz_dom_clone(elt):
    r"""
    Low-level wrapper for `::fz_dom_clone()`.
    Clone an element (and its children).

    A borrowed reference to the clone is returned. The clone is not
    yet linked into the DOM.
    """
    return _mupdf.ll_fz_dom_clone(elt)

def ll_fz_dom_create_element(dom, tag):
    r"""
    Low-level wrapper for `::fz_dom_create_element()`.
    Create an element of a given tag type for the given DOM.

    The element is not linked into the DOM yet.
    """
    return _mupdf.ll_fz_dom_create_element(dom, tag)

def ll_fz_dom_create_text_node(dom, text):
    r"""
    Low-level wrapper for `::fz_dom_create_text_node()`.
    Create a text node for the given DOM.

    The element is not linked into the DOM yet.
    """
    return _mupdf.ll_fz_dom_create_text_node(dom, text)

def ll_fz_dom_document_element(dom):
    r"""
    Low-level wrapper for `::fz_dom_document_element()`.
    Return a borrowed reference for the document (the top
    level element) of the DOM.
    """
    return _mupdf.ll_fz_dom_document_element(dom)

def ll_fz_dom_find(elt, tag, att, match):
    r"""
    Low-level wrapper for `::fz_dom_find()`.
    Find the first element matching the requirements in a depth first traversal from elt.

    The tagname must match tag, unless tag is NULL, when all tag names are considered to match.

    If att is NULL, then all tags match.
    Otherwise:
    	If match is NULL, then only nodes that have an att attribute match.
    	If match is non-NULL, then only nodes that have an att attribute that matches match match.

    Returns NULL (if no match found), or a borrowed reference to the first matching element.
    """
    return _mupdf.ll_fz_dom_find(elt, tag, att, match)

def ll_fz_dom_find_next(elt, tag, att, match):
    r"""
    Low-level wrapper for `::fz_dom_find_next()`.
    Find the next element matching the requirements.
    """
    return _mupdf.ll_fz_dom_find_next(elt, tag, att, match)

def ll_fz_dom_first_child(elt):
    r"""
    Low-level wrapper for `::fz_dom_first_child()`.
    Return a borrowed reference to the first child of a node,
    or NULL if there isn't one.
    """
    return _mupdf.ll_fz_dom_first_child(elt)

def ll_fz_dom_get_attribute(elt, i, att):
    r"""
     Low-level wrapper for `::fz_dom_get_attribute()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_fz_dom_get_attribute(::fz_xml *elt, int i)` => `(const char *, const char *att)`

    	Enumerate through the attributes of an element.

    	Call with i=0,1,2,3... to enumerate attributes.

    	On return *att and the return value will be NULL if there are not
    	that many attributes to read. Otherwise, *att will be filled in
    	with a borrowed pointer to the attribute name, and the return
    	value will be a borrowed pointer to the value.
    """
    return _mupdf.ll_fz_dom_get_attribute(elt, i, att)

def ll_fz_dom_insert_after(node, new_elt):
    r"""
    Low-level wrapper for `::fz_dom_insert_after()`.
    Insert an element (new_elt), after another element (node),
    unlinking the new_elt from its current position if required.
    """
    return _mupdf.ll_fz_dom_insert_after(node, new_elt)

def ll_fz_dom_insert_before(node, new_elt):
    r"""
    Low-level wrapper for `::fz_dom_insert_before()`.
    Insert an element (new_elt), before another element (node),
    unlinking the new_elt from its current position if required.
    """
    return _mupdf.ll_fz_dom_insert_before(node, new_elt)

def ll_fz_dom_next(elt):
    r"""
    Low-level wrapper for `::fz_dom_next()`.
    Return a borrowed reference to the next sibling of a node,
    or NULL if there isn't one.
    """
    return _mupdf.ll_fz_dom_next(elt)

def ll_fz_dom_parent(elt):
    r"""
    Low-level wrapper for `::fz_dom_parent()`.
    Return a borrowed reference to the parent of a node,
    or NULL if there isn't one.
    """
    return _mupdf.ll_fz_dom_parent(elt)

def ll_fz_dom_previous(elt):
    r"""
    Low-level wrapper for `::fz_dom_previous()`.
    Return a borrowed reference to the previous sibling of a node,
    or NULL if there isn't one.
    """
    return _mupdf.ll_fz_dom_previous(elt)

def ll_fz_dom_remove(elt):
    r"""
    Low-level wrapper for `::fz_dom_remove()`.
    Remove an element from the DOM. The element can be added back elsewhere
    if required.

    No reference counting changes for the element.
    """
    return _mupdf.ll_fz_dom_remove(elt)

def ll_fz_dom_remove_attribute(elt, att):
    r"""
    Low-level wrapper for `::fz_dom_remove_attribute()`.
    Remove an attribute from an element.
    """
    return _mupdf.ll_fz_dom_remove_attribute(elt, att)

def ll_fz_draw_story(story, dev, ctm):
    r""" Low-level wrapper for `::fz_draw_story()`."""
    return _mupdf.ll_fz_draw_story(story, dev, ctm)

def ll_fz_drop_archive(arch):
    r"""
    Low-level wrapper for `::fz_drop_archive()`.
    Drop a reference to an archive.

    When the last reference is dropped, this closes and releases
    any memory or filehandles associated with the archive.
    """
    return _mupdf.ll_fz_drop_archive(arch)

def ll_fz_drop_band_writer(writer):
    r"""
    Low-level wrapper for `::fz_drop_band_writer()`.
    Drop the reference to the band writer, causing it to be
    destroyed.

    Never throws an exception.
    """
    return _mupdf.ll_fz_drop_band_writer(writer)

def ll_fz_drop_bitmap(bit):
    r"""
    Low-level wrapper for `::fz_drop_bitmap()`.
    Drop a reference to the bitmap. When the reference count reaches
    zero, the bitmap will be destroyed.

    Never throws exceptions.
    """
    return _mupdf.ll_fz_drop_bitmap(bit)

def ll_fz_drop_buffer(buf):
    r"""
    Low-level wrapper for `::fz_drop_buffer()`.
    Drop a reference to the buffer. When the reference count reaches
    zero, the buffer is destroyed.

    Never throws exceptions.
    """
    return _mupdf.ll_fz_drop_buffer(buf)

def ll_fz_drop_colorspace(colorspace):
    r"""
    Low-level wrapper for `::fz_drop_colorspace()`.
    Drops a reference to the colorspace.

    When the reference count reaches zero, the colorspace is
    destroyed.
    """
    return _mupdf.ll_fz_drop_colorspace(colorspace)

def ll_fz_drop_colorspace_imp(cs_):
    r""" Low-level wrapper for `::fz_drop_colorspace_imp()`."""
    return _mupdf.ll_fz_drop_colorspace_imp(cs_)

def ll_fz_drop_compressed_buffer(buf):
    r"""
    Low-level wrapper for `::fz_drop_compressed_buffer()`.
    Drop a reference to a compressed buffer. Destroys the buffer
    and frees any storage/other references held by it.

    Never throws exceptions.
    """
    return _mupdf.ll_fz_drop_compressed_buffer(buf)

def ll_fz_drop_context():
    r"""
    Low-level wrapper for `::fz_drop_context()`.
    Free a context and its global state.

    The context and all of its global state is freed, and any
    buffered warnings are flushed (see fz_flush_warnings). If NULL
    is passed in nothing will happen.

    Must not be called for a context that is being used in an active
    fz_try(), fz_always() or fz_catch() block.
    """
    return _mupdf.ll_fz_drop_context()

def ll_fz_drop_default_colorspaces(default_cs):
    r"""
    Low-level wrapper for `::fz_drop_default_colorspaces()`.
    Drop a reference to the default colorspaces structure. When the
    reference count reaches 0, the references it holds internally
    to the underlying colorspaces will be dropped, and the structure
    will be destroyed.

    Never throws exceptions.
    """
    return _mupdf.ll_fz_drop_default_colorspaces(default_cs)

def ll_fz_drop_device(dev):
    r"""
    Low-level wrapper for `::fz_drop_device()`.
    Reduce the reference count on a device. When the reference count
    reaches zero, the device and its resources will be freed.
    Don't forget to call fz_close_device before dropping the device,
    or you may get incomplete output!

    Never throws exceptions.
    """
    return _mupdf.ll_fz_drop_device(dev)

def ll_fz_drop_display_list(list):
    r"""
    Low-level wrapper for `::fz_drop_display_list()`.
    Decrement the reference count for a display list. When the
    reference count reaches zero, all the references in the display
    list itself are dropped, and the display list is freed.

    Never throws exceptions.
    """
    return _mupdf.ll_fz_drop_display_list(list)

def ll_fz_drop_document(doc):
    r"""
    Low-level wrapper for `::fz_drop_document()`.
    Decrement the document reference count. When the reference
    count reaches 0, the document and all it's references are
    freed.

    Never throws exceptions.
    """
    return _mupdf.ll_fz_drop_document(doc)

def ll_fz_drop_document_writer(wri):
    r"""
    Low-level wrapper for `::fz_drop_document_writer()`.
    Called to discard a fz_document_writer.
    This may be called at any time during the process to release all
    the resources owned by the writer.

    Calling drop without having previously called close may leave
    the file in an inconsistent state.
    """
    return _mupdf.ll_fz_drop_document_writer(wri)

def ll_fz_drop_font(font):
    r"""
    Low-level wrapper for `::fz_drop_font()`.
    Drop a reference to a fz_font, destroying the
    font when the last reference is dropped.

    font: The font to drop a reference to.
    """
    return _mupdf.ll_fz_drop_font(font)

def ll_fz_drop_function(func):
    r""" Low-level wrapper for `::fz_drop_function()`."""
    return _mupdf.ll_fz_drop_function(func)

def ll_fz_drop_glyph(pix):
    r"""
    Low-level wrapper for `::fz_drop_glyph()`.
    Drop a reference and free a glyph.

    Decrement the reference count for the glyph. When no
    references remain the glyph will be freed.
    """
    return _mupdf.ll_fz_drop_glyph(pix)

def ll_fz_drop_halftone(ht):
    r"""
    Low-level wrapper for `::fz_drop_halftone()`.
    Drop a reference to the halftone. When the reference count
    reaches zero, the halftone is destroyed.

    Never throws exceptions.
    """
    return _mupdf.ll_fz_drop_halftone(ht)

def ll_fz_drop_hash_table(table):
    r"""
    Low-level wrapper for `::fz_drop_hash_table()`.
    Destroy the hash table.

    Values are dropped using the drop function.
    """
    return _mupdf.ll_fz_drop_hash_table(table)

def ll_fz_drop_image(image):
    r"""
    Low-level wrapper for `::fz_drop_image()`.
    Decrement the (normal) reference count for an image. When the
    total (normal + key) reference count reaches zero, the image and
    its resources are freed.

    Never throws exceptions.
    """
    return _mupdf.ll_fz_drop_image(image)

def ll_fz_drop_image_base(image):
    r"""
    Low-level wrapper for `::fz_drop_image_base()`.
    Internal destructor for the base image class members.

    Exposed to allow derived image classes to be written.
    """
    return _mupdf.ll_fz_drop_image_base(image)

def ll_fz_drop_image_imp(image):
    r"""
    Low-level wrapper for `::fz_drop_image_imp()`.
    Internal destructor exposed for fz_store integration.
    """
    return _mupdf.ll_fz_drop_image_imp(image)

def ll_fz_drop_image_store_key(image):
    r"""
    Low-level wrapper for `::fz_drop_image_store_key()`.
    Decrement the store key reference count for an image. When the
    total (normal + key) reference count reaches zero, the image and
    its resources are freed.

    Never throws exceptions.
    """
    return _mupdf.ll_fz_drop_image_store_key(image)

def ll_fz_drop_imp(p, refs):
    r"""
     Low-level wrapper for `::fz_drop_imp()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_fz_drop_imp(void *p)` => `(int, int refs)`
    """
    return _mupdf.ll_fz_drop_imp(p, refs)

def ll_fz_drop_imp16(p, refs):
    r"""
     Low-level wrapper for `::fz_drop_imp16()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_fz_drop_imp16(void *p)` => `(int, int16_t refs)`
    """
    return _mupdf.ll_fz_drop_imp16(p, refs)

def ll_fz_drop_imp8(p, refs):
    r""" Low-level wrapper for `::fz_drop_imp8()`."""
    return _mupdf.ll_fz_drop_imp8(p, refs)

def ll_fz_drop_jbig2_globals(globals):
    r"""
    Low-level wrapper for `::fz_drop_jbig2_globals()`.
    Decrement the reference count for a jbig2 globals record.
    When the reference count hits zero, the record is freed.

    Never throws an exception.
    """
    return _mupdf.ll_fz_drop_jbig2_globals(globals)

def ll_fz_drop_jbig2_globals_imp(globals):
    r"""
    Low-level wrapper for `::fz_drop_jbig2_globals_imp()`.
    Special jbig2 globals drop function for use in implementing
    store support.
    """
    return _mupdf.ll_fz_drop_jbig2_globals_imp(globals)

def ll_fz_drop_key_storable(arg_1):
    r"""
    Low-level wrapper for `::fz_drop_key_storable()`.
    Decrement the (normal) reference count for a storable object.
    When the total reference count hits zero, the drop function for
    that object is called to free the object.

    Never throws exceptions.
    """
    return _mupdf.ll_fz_drop_key_storable(arg_1)

def ll_fz_drop_key_storable_key(arg_1):
    r"""
    Low-level wrapper for `::fz_drop_key_storable_key()`.
    Decrement the (key) reference count for a storable object.
    When the total reference count hits zero, the drop function for
    that object is called to free the object.

    Never throws exceptions.
    """
    return _mupdf.ll_fz_drop_key_storable_key(arg_1)

def ll_fz_drop_layout(block):
    r"""
    Low-level wrapper for `::fz_drop_layout()`.
    Drop layout block. Free the pool, and linked blocks.

    Never throws exceptions.
    """
    return _mupdf.ll_fz_drop_layout(block)

def ll_fz_drop_link(link):
    r"""
    Low-level wrapper for `::fz_drop_link()`.
    Decrement the reference count for a link. When the reference
    count reaches zero, the link is destroyed.

    When a link is freed, the reference for any linked link (next)
    is dropped too, thus an entire linked list of fz_link's can be
    freed by just dropping the head.
    """
    return _mupdf.ll_fz_drop_link(link)

def ll_fz_drop_outline(outline):
    r"""
    Low-level wrapper for `::fz_drop_outline()`.
    Decrements the reference count. When the reference point
    reaches zero, the outline is freed.

    When freed, it will drop linked	outline entries (next and down)
    too, thus a whole outline structure can be dropped by dropping
    the top entry.

    Never throws exceptions.
    """
    return _mupdf.ll_fz_drop_outline(outline)

def ll_fz_drop_outline_iterator(iter):
    r"""
    Low-level wrapper for `::fz_drop_outline_iterator()`.
    Drop the current iterator.
    """
    return _mupdf.ll_fz_drop_outline_iterator(iter)

def ll_fz_drop_output(arg_1):
    r"""
    Low-level wrapper for `::fz_drop_output()`.
    Free an output stream. Don't forget to close it first!
    """
    return _mupdf.ll_fz_drop_output(arg_1)

def ll_fz_drop_page(page):
    r"""
    Low-level wrapper for `::fz_drop_page()`.
    Decrements the reference count for the page. When the reference
    count hits 0, the page and its references are freed.

    Never throws exceptions.
    """
    return _mupdf.ll_fz_drop_page(page)

def ll_fz_drop_path(path):
    r"""
    Low-level wrapper for `::fz_drop_path()`.
    Decrement the reference count. When the reference count hits
    zero, free the path.

    All paths can be dropped, regardless of their packing type.
    Packed paths do not own the blocks into which they are packed
    so dropping them does not free those blocks.

    Never throws exceptions.
    """
    return _mupdf.ll_fz_drop_path(path)

def ll_fz_drop_pixmap(pix):
    r"""
    Low-level wrapper for `::fz_drop_pixmap()`.
    Decrement the reference count for the pixmap. When the
    reference count hits 0, the pixmap is freed.

    Never throws exceptions.
    """
    return _mupdf.ll_fz_drop_pixmap(pix)

def ll_fz_drop_pool(pool):
    r"""
    Low-level wrapper for `::fz_drop_pool()`.
    Drop a pool, freeing and invalidating all storage returned from
    the pool.
    """
    return _mupdf.ll_fz_drop_pool(pool)

def ll_fz_drop_separations(sep):
    r"""
    Low-level wrapper for `::fz_drop_separations()`.
    Decrement the reference count for a separations structure.
    When the reference count hits zero, the separations structure
    is freed.

    Never throws exceptions.
    """
    return _mupdf.ll_fz_drop_separations(sep)

def ll_fz_drop_shade(shade):
    r"""
    Low-level wrapper for `::fz_drop_shade()`.
    Decrement the reference count for the shade structure. When
    the reference count hits zero, the structure is freed.

    Never throws exceptions.
    """
    return _mupdf.ll_fz_drop_shade(shade)

def ll_fz_drop_shade_color_cache(cache):
    r""" Low-level wrapper for `::fz_drop_shade_color_cache()`."""
    return _mupdf.ll_fz_drop_shade_color_cache(cache)

def ll_fz_drop_shade_imp(shade):
    r"""
    Low-level wrapper for `::fz_drop_shade_imp()`.
    Internal function to destroy a
    shade. Only exposed for use with the fz_store.

    shade: The reference to destroy.
    """
    return _mupdf.ll_fz_drop_shade_imp(shade)

def ll_fz_drop_stext_page(page):
    r""" Low-level wrapper for `::fz_drop_stext_page()`."""
    return _mupdf.ll_fz_drop_stext_page(page)

def ll_fz_drop_storable(arg_1):
    r"""
    Low-level wrapper for `::fz_drop_storable()`.
    Decrement the reference count for a storable object. When the
    reference count hits zero, the drop function for that object
    is called to free the object.

    Never throws exceptions.
    """
    return _mupdf.ll_fz_drop_storable(arg_1)

def ll_fz_drop_store_context():
    r"""
    Low-level wrapper for `::fz_drop_store_context()`.
    Decrement the reference count for the store context. When the
    reference count hits zero, the store context is freed.

    Never throws exceptions.
    """
    return _mupdf.ll_fz_drop_store_context()

def ll_fz_drop_story(story):
    r""" Low-level wrapper for `::fz_drop_story()`."""
    return _mupdf.ll_fz_drop_story(story)

def ll_fz_drop_stream(stm):
    r"""
    Low-level wrapper for `::fz_drop_stream()`.
    Decrements the reference count for a stream.

    When the reference count for the stream hits zero, frees the
    storage used for the fz_stream itself, and (usually)
    releases the underlying resources that the stream is based upon
    (depends on the method used to open the stream initially).
    """
    return _mupdf.ll_fz_drop_stream(stm)

def ll_fz_drop_string(str):
    r""" Low-level wrapper for `::fz_drop_string()`."""
    return _mupdf.ll_fz_drop_string(str)

def ll_fz_drop_stroke_state(stroke):
    r"""
    Low-level wrapper for `::fz_drop_stroke_state()`.
    Drop a reference to a stroke state structure, destroying the
    structure if it is the last reference.
    """
    return _mupdf.ll_fz_drop_stroke_state(stroke)

def ll_fz_drop_text(text):
    r"""
    Low-level wrapper for `::fz_drop_text()`.
    Decrement the reference count for the text object. When the
    reference count hits zero, the text object is freed.

    Never throws exceptions.
    """
    return _mupdf.ll_fz_drop_text(text)

def ll_fz_drop_tree(node, dropfunc):
    r"""
    Low-level wrapper for `::fz_drop_tree()`.
    Drop the tree.

    The storage used by the tree is freed, and each value has
    dropfunc called on it.
    """
    return _mupdf.ll_fz_drop_tree(node, dropfunc)

def ll_fz_drop_xml(xml):
    r"""
    Low-level wrapper for `::fz_drop_xml()`.
    Drop a reference to the XML. When the last reference is
    dropped, the node and all its children and siblings will
    be freed.
    """
    return _mupdf.ll_fz_drop_xml(xml)

def ll_fz_drop_zip_writer(zip):
    r"""
    Low-level wrapper for `::fz_drop_zip_writer()`.
    Drop the reference to the zipfile.

    In common with other 'drop' methods, this will never throw an
    exception.
    """
    return _mupdf.ll_fz_drop_zip_writer(zip)

def ll_fz_dump_glyph_cache_stats(out):
    r"""
    Low-level wrapper for `::fz_dump_glyph_cache_stats()`.
    Dump debug statistics for the glyph cache.
    """
    return _mupdf.ll_fz_dump_glyph_cache_stats(out)

def ll_fz_duplicate_glyph_names_from_unicode(unicode):
    r""" Low-level wrapper for `::fz_duplicate_glyph_names_from_unicode()`."""
    return _mupdf.ll_fz_duplicate_glyph_names_from_unicode(unicode)

def ll_fz_empty_store():
    r"""
    Low-level wrapper for `::fz_empty_store()`.
    Evict every item from the store.
    """
    return _mupdf.ll_fz_empty_store()

def ll_fz_enable_device_hints(dev, hints):
    r"""
    Low-level wrapper for `::fz_enable_device_hints()`.
    Enable (set) hint bits within the hint bitfield for a device.
    """
    return _mupdf.ll_fz_enable_device_hints(dev, hints)

def ll_fz_enable_icc():
    r"""
    Low-level wrapper for `::fz_enable_icc()`.
    Enable icc profile based operation.
    """
    return _mupdf.ll_fz_enable_icc()

def ll_fz_encode_character(font, unicode):
    r"""
    Low-level wrapper for `::fz_encode_character()`.
    Find the glyph id for a given unicode
    character within a font.

    font: The font to look for the unicode character in.

    unicode: The unicode character to encode.

    Returns the glyph id for the given unicode value, or 0 if
    unknown.
    """
    return _mupdf.ll_fz_encode_character(font, unicode)

def ll_fz_encode_character_by_glyph_name(font, glyphname):
    r"""
    Low-level wrapper for `::fz_encode_character_by_glyph_name()`.
    Encode character.

    Either by direct lookup of glyphname within a font, or, failing
    that, by mapping glyphname to unicode and thence to the glyph
    index within the given font.

    Returns zero for type3 fonts.
    """
    return _mupdf.ll_fz_encode_character_by_glyph_name(font, glyphname)

def ll_fz_encode_character_sc(font, unicode):
    r"""
    Low-level wrapper for `::fz_encode_character_sc()`.
    Encode character, preferring small-caps variant if available.

    font: The font to look for the unicode character in.

    unicode: The unicode character to encode.

    Returns the glyph id for the given unicode value, or 0 if
    unknown.
    """
    return _mupdf.ll_fz_encode_character_sc(font, unicode)

def ll_fz_encode_character_with_fallback(font, unicode, script, language, out_font):
    r"""
     Low-level wrapper for `::fz_encode_character_with_fallback()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_fz_encode_character_with_fallback(::fz_font *font, int unicode, int script, int language, ::fz_font **out_font)` => `(int)`

    	Find the glyph id for
    	a given unicode character within a font, falling back to
    	an alternative if not found.

    	font: The font to look for the unicode character in.

    	unicode: The unicode character to encode.

    	script: The script in use.

    	language: The language in use.

    	out_font: The font handle in which the given glyph represents
    	the requested unicode character. The caller does not own the
    	reference it is passed, so should call fz_keep_font if it is
    	not simply to be used immediately.

    	Returns the glyph id for the given unicode value in the supplied
    	font (and sets *out_font to font) if it is present. Otherwise
    	an alternative fallback font (based on script/language) is
    	searched for. If the glyph is found therein, *out_font is set
    	to this reference, and the glyph reference is returned. If it
    	cannot be found anywhere, the function returns 0.
    """
    return _mupdf.ll_fz_encode_character_with_fallback(font, unicode, script, language, out_font)

def ll_fz_encode_uri(s):
    r"""
     Low-level wrapper for `::fz_encode_uri()`.
    Return a new string representing the provided string encoded as a URI.
    """
    return _mupdf.ll_fz_encode_uri(s)

def ll_fz_encode_uri_component(s):
    r"""
     Low-level wrapper for `::fz_encode_uri_component()`.
    Return a new string representing the provided string encoded as an URI component.
    This also encodes the special reserved characters (; / ? : @ & = + $ , #).
    """
    return _mupdf.ll_fz_encode_uri_component(s)

def ll_fz_encode_uri_pathname(s):
    r"""
     Low-level wrapper for `::fz_encode_uri_pathname()`.
    Return a new string representing the provided string encoded as an URI path name.
    This also encodes the special reserved characters except /.
    """
    return _mupdf.ll_fz_encode_uri_pathname(s)

def ll_fz_end_group(dev):
    r""" Low-level wrapper for `::fz_end_group()`."""
    return _mupdf.ll_fz_end_group(dev)

def ll_fz_end_layer(dev):
    r""" Low-level wrapper for `::fz_end_layer()`."""
    return _mupdf.ll_fz_end_layer(dev)

def ll_fz_end_mask(dev):
    r""" Low-level wrapper for `::fz_end_mask()`."""
    return _mupdf.ll_fz_end_mask(dev)

def ll_fz_end_mask_tr(dev, fn):
    r""" Low-level wrapper for `::fz_end_mask_tr()`."""
    return _mupdf.ll_fz_end_mask_tr(dev, fn)

def ll_fz_end_metatext(dev):
    r""" Low-level wrapper for `::fz_end_metatext()`."""
    return _mupdf.ll_fz_end_metatext(dev)

def ll_fz_end_page(wri):
    r"""
    Low-level wrapper for `::fz_end_page()`.
    Called to end the process of writing a page to a
    document.
    """
    return _mupdf.ll_fz_end_page(wri)

def ll_fz_end_structure(dev):
    r""" Low-level wrapper for `::fz_end_structure()`."""
    return _mupdf.ll_fz_end_structure(dev)

def ll_fz_end_throw_on_repair():
    r""" Low-level wrapper for `::fz_end_throw_on_repair()`."""
    return _mupdf.ll_fz_end_throw_on_repair()

def ll_fz_end_tile(dev):
    r""" Low-level wrapper for `::fz_end_tile()`."""
    return _mupdf.ll_fz_end_tile(dev)

def ll_fz_error_callback(user):
    r"""
     Low-level wrapper for `::fz_error_callback()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_fz_error_callback()` => `(fz_error_cb *, void *user)`

    	Retrieve the currently set error callback, or NULL if none
    	has been set. Optionally, if user is non-NULL, the user pointer
    	given when the warning callback was set is also passed back to
    	the caller.
    """
    return _mupdf.ll_fz_error_callback(user)

def ll_fz_eval_function(func, _in, inlen, out, outlen):
    r"""
     Low-level wrapper for `::fz_eval_function()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_fz_eval_function(::fz_function *func, const float *in, int inlen, int outlen)` => float out
    """
    return _mupdf.ll_fz_eval_function(func, _in, inlen, out, outlen)

def ll_fz_expand_irect(a, expand):
    r""" Low-level wrapper for `::fz_expand_irect()`."""
    return _mupdf.ll_fz_expand_irect(a, expand)

def ll_fz_expand_rect(b, expand):
    r"""
    Low-level wrapper for `::fz_expand_rect()`.
    Expand a bbox by a given amount in all directions.
    """
    return _mupdf.ll_fz_expand_rect(b, expand)

def ll_fz_extract_ttf_from_ttc(font):
    r""" Low-level wrapper for `::fz_extract_ttf_from_ttc()`."""
    return _mupdf.ll_fz_extract_ttf_from_ttc(font)

def ll_fz_file_exists(path):
    r"""
    Low-level wrapper for `::fz_file_exists()`.
    Return true if the named file exists and is readable.
    """
    return _mupdf.ll_fz_file_exists(path)

def ll_fz_fill_image(dev, image, ctm, alpha, color_params):
    r""" Low-level wrapper for `::fz_fill_image()`."""
    return _mupdf.ll_fz_fill_image(dev, image, ctm, alpha, color_params)

def ll_fz_fill_image_mask(dev, image, ctm, colorspace, color, alpha, color_params):
    r""" Low-level wrapper for `::fz_fill_image_mask()`."""
    return _mupdf.ll_fz_fill_image_mask(dev, image, ctm, colorspace, color, alpha, color_params)

def ll_fz_fill_path(dev, path, even_odd, ctm, colorspace, color, alpha, color_params):
    r"""
    Low-level wrapper for `::fz_fill_path()`.
    Device calls; graphics primitives and containers.
    """
    return _mupdf.ll_fz_fill_path(dev, path, even_odd, ctm, colorspace, color, alpha, color_params)

def ll_fz_fill_pixmap_from_display_list(list, ctm, pix):
    r""" Low-level wrapper for `::fz_fill_pixmap_from_display_list()`."""
    return _mupdf.ll_fz_fill_pixmap_from_display_list(list, ctm, pix)

def ll_fz_fill_pixmap_with_color(pix, colorspace, color, color_params):
    r"""
     Low-level wrapper for `::fz_fill_pixmap_with_color()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_fz_fill_pixmap_with_color(::fz_pixmap *pix, ::fz_colorspace *colorspace, ::fz_color_params color_params)` => float color

    	Fill pixmap with solid color.
    """
    return _mupdf.ll_fz_fill_pixmap_with_color(pix, colorspace, color, color_params)

def ll_fz_fill_shade(dev, shade, ctm, alpha, color_params):
    r""" Low-level wrapper for `::fz_fill_shade()`."""
    return _mupdf.ll_fz_fill_shade(dev, shade, ctm, alpha, color_params)

def ll_fz_fill_text(dev, text, ctm, colorspace, color, alpha, color_params):
    r""" Low-level wrapper for `::fz_fill_text()`."""
    return _mupdf.ll_fz_fill_text(dev, text, ctm, colorspace, color, alpha, color_params)

def ll_fz_filter_store(fn, arg, type):
    r"""
    Low-level wrapper for `::fz_filter_store()`.
    Filter every element in the store with a matching type with the
    given function.

    If the function returns 1 for an element, drop the element.
    """
    return _mupdf.ll_fz_filter_store(fn, arg, type)

def ll_fz_find_item(drop, key, type):
    r"""
    Low-level wrapper for `::fz_find_item()`.
    Find an item within the store.

    drop: The function used to free the value (to ensure we get a
    value of the correct type).

    key: The key used to index the item.

    type: Functions used to manipulate the key.

    Returns NULL for not found, otherwise returns a pointer to the
    value indexed by key to which a reference has been taken.
    """
    return _mupdf.ll_fz_find_item(drop, key, type)

def ll_fz_flush_output(out):
    r"""
    Low-level wrapper for `::fz_flush_output()`.
    Flush unwritten data.
    """
    return _mupdf.ll_fz_flush_output(out)

def ll_fz_flush_warnings():
    r"""
    Low-level wrapper for `::fz_flush_warnings()`.
    Flush any repeated warnings.

    Repeated warnings are buffered, counted and eventually printed
    along with the number of repetitions. Call fz_flush_warnings
    to force printing of the latest buffered warning and the
    number of repetitions, for example to make sure that all
    warnings are printed before exiting an application.
    """
    return _mupdf.ll_fz_flush_warnings()

def ll_fz_font_ascender(font):
    r"""
    Low-level wrapper for `::fz_font_ascender()`.
    Retrieve font ascender in ems.
    """
    return _mupdf.ll_fz_font_ascender(font)

def ll_fz_font_bbox(font):
    r"""
    Low-level wrapper for `::fz_font_bbox()`.
    Retrieve the font bbox.

    font: The font to query.

    Returns the font bbox by value; it is valid only if
    fz_font_flags(font)->invalid_bbox is zero.
    """
    return _mupdf.ll_fz_font_bbox(font)

def ll_fz_font_descender(font):
    r"""
    Low-level wrapper for `::fz_font_descender()`.
    Retrieve font descender in ems.
    """
    return _mupdf.ll_fz_font_descender(font)

def ll_fz_font_digest(font, digest):
    r"""
    Low-level wrapper for `::fz_font_digest()`.
    Retrieve the MD5 digest for the font's data.
    """
    return _mupdf.ll_fz_font_digest(font, digest)

def ll_fz_font_flags(font):
    r"""
    Low-level wrapper for `::fz_font_flags()`.
    Retrieve a pointer to the font flags
    for a given font. These can then be updated as required.

    font: The font to query

    Returns a pointer to the flags structure (or NULL, if
    the font is NULL).
    """
    return _mupdf.ll_fz_font_flags(font)

def ll_fz_font_ft_face(font):
    r"""
    Low-level wrapper for `::fz_font_ft_face()`.
    Retrieve the FT_Face handle
    for the font.

    font: The font to query

    Returns the FT_Face handle for the font, or NULL
    if not a freetype handled font. (Cast to void *
    to avoid nasty header exposure).
    """
    return _mupdf.ll_fz_font_ft_face(font)

def ll_fz_font_is_bold(font):
    r"""
    Low-level wrapper for `::fz_font_is_bold()`.
    Query whether the font flags say that this font is bold.
    """
    return _mupdf.ll_fz_font_is_bold(font)

def ll_fz_font_is_italic(font):
    r"""
    Low-level wrapper for `::fz_font_is_italic()`.
    Query whether the font flags say that this font is italic.
    """
    return _mupdf.ll_fz_font_is_italic(font)

def ll_fz_font_is_monospaced(font):
    r"""
    Low-level wrapper for `::fz_font_is_monospaced()`.
    Query whether the font flags say that this font is monospaced.
    """
    return _mupdf.ll_fz_font_is_monospaced(font)

def ll_fz_font_is_serif(font):
    r"""
    Low-level wrapper for `::fz_font_is_serif()`.
    Query whether the font flags say that this font is serif.
    """
    return _mupdf.ll_fz_font_is_serif(font)

def ll_fz_font_name(font):
    r"""
    Low-level wrapper for `::fz_font_name()`.
    Retrieve a pointer to the name of the font.

    font: The font to query.

    Returns a pointer to an internal copy of the font name.
    Will never be NULL, but may be the empty string.
    """
    return _mupdf.ll_fz_font_name(font)

def ll_fz_font_shaper_data(font):
    r"""
    Low-level wrapper for `::fz_font_shaper_data()`.
    Retrieve a pointer to the shaper data
    structure for the given font.

    font: The font to query.

    Returns a pointer to the shaper data structure (or NULL if
    font is NULL).
    """
    return _mupdf.ll_fz_font_shaper_data(font)

def ll_fz_font_t3_procs(font):
    r"""
    Low-level wrapper for `::fz_font_t3_procs()`.
    Retrieve the Type3 procs
    for a font.

    font: The font to query

    Returns the t3_procs pointer. Will be NULL for a
    non type-3 font.
    """
    return _mupdf.ll_fz_font_t3_procs(font)

def ll_fz_format_double(fmt, value):
    r"""
     Low-level wrapper for `::fz_format_double()`.  Swig-friendly and typesafe way to do fz_snprintf(fmt, value). `fmt`
    must end with one of 'efg' otherwise we throw an exception.
    """
    return _mupdf.ll_fz_format_double(fmt, value)

def ll_fz_format_link_uri(doc, dest):
    r"""
    Low-level wrapper for `::fz_format_link_uri()`.
    Format an internal link to a page number, location, and possible viewing parameters,
    suitable for use with fz_create_link.

    Returns a newly allocated string that the caller must free.
    """
    return _mupdf.ll_fz_format_link_uri(doc, dest)

def ll_fz_format_output_path(path, size, fmt, page):
    r"""
    Low-level wrapper for `::fz_format_output_path()`.
    create output file name using a template.

    If the path contains %[0-9]*d, the first such pattern will be
    replaced with the page number. If the template does not contain
    such a pattern, the page number will be inserted before the
    filename extension. If the template does not have a filename
    extension, the page number will be added to the end.
    """
    return _mupdf.ll_fz_format_output_path(path, size, fmt, page)

def ll_fz_free(p):
    r"""
    Low-level wrapper for `::fz_free()`.
    Free a previously allocated block of memory.

    fz_free(ctx, NULL) does nothing.

    Never throws exceptions.
    """
    return _mupdf.ll_fz_free(p)

def ll_fz_ft_lock():
    r""" Low-level wrapper for `::fz_ft_lock()`."""
    return _mupdf.ll_fz_ft_lock()

def ll_fz_ft_lock_held():
    r""" Low-level wrapper for `::fz_ft_lock_held()`."""
    return _mupdf.ll_fz_ft_lock_held()

def ll_fz_ft_unlock():
    r""" Low-level wrapper for `::fz_ft_unlock()`."""
    return _mupdf.ll_fz_ft_unlock()

def ll_fz_function_size(func):
    r""" Low-level wrapper for `::fz_function_size()`."""
    return _mupdf.ll_fz_function_size(func)

def ll_fz_gamma_pixmap(pix, gamma):
    r"""
    Low-level wrapper for `::fz_gamma_pixmap()`.
    Apply gamma correction to a pixmap. All components
    of all pixels are modified (except alpha, which is unchanged).

    gamma: The gamma value to apply; 1.0 for no change.
    """
    return _mupdf.ll_fz_gamma_pixmap(pix, gamma)

def ll_fz_generate_transition(tpix, opix, npix, time, trans):
    r"""
    Low-level wrapper for `::fz_generate_transition()`.
    Generate a frame of a transition.

    tpix: Target pixmap
    opix: Old pixmap
    npix: New pixmap
    time: Position within the transition (0 to 256)
    trans: Transition details

    Returns 1 if successfully generated a frame.

    Note: Pixmaps must include alpha.
    """
    return _mupdf.ll_fz_generate_transition(tpix, opix, npix, time, trans)

def ll_fz_get_glyph_name(font, glyph, buf, size):
    r"""
    Low-level wrapper for `::fz_get_glyph_name()`.
    Find the name of a glyph

    font: The font to look for the glyph in.

    glyph: The glyph id to look for.

    buf: Pointer to a buffer for the name to be inserted into.

    size: The size of the buffer.

    If a font contains a name table, then the name of the glyph
    will be returned in the supplied buffer. Otherwise a name
    is synthesised. The name will be truncated to fit in
    the buffer.
    """
    return _mupdf.ll_fz_get_glyph_name(font, glyph, buf, size)

def ll_fz_get_glyph_name2(font, glyph):
    r"""
     Low-level wrapper for `::fz_get_glyph_name2()`.
    C++ alternative to fz_get_glyph_name() that returns information in a std::string.
    """
    return _mupdf.ll_fz_get_glyph_name2(font, glyph)

def ll_fz_get_pixmap_from_image(image, subarea, ctm, w, h):
    r"""
     Low-level wrapper for `::fz_get_pixmap_from_image()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_fz_get_pixmap_from_image(::fz_image *image, const ::fz_irect *subarea, ::fz_matrix *ctm)` => `(fz_pixmap *, int w, int h)`

    	Called to get a handle to a pixmap from an image.

    	image: The image to retrieve a pixmap from.

    	subarea: The subarea of the image that we actually care about
    	(or NULL to indicate the whole image).

    	ctm: Optional, unless subarea is given. If given, then on
    	entry this is the transform that will be applied to the complete
    	image. It should be updated on exit to the transform to apply to
    	the given subarea of the image. This is used to calculate the
    	desired width/height for subsampling.

    	w: If non-NULL, a pointer to an int to be updated on exit to the
    	width (in pixels) that the scaled output will cover.

    	h: If non-NULL, a pointer to an int to be updated on exit to the
    	height (in pixels) that the scaled output will cover.

    	Returns a non NULL kept pixmap pointer. May throw exceptions.
    """
    return _mupdf.ll_fz_get_pixmap_from_image(image, subarea, ctm, w, h)

def ll_fz_get_unscaled_pixmap_from_image(image):
    r"""
    Low-level wrapper for `::fz_get_unscaled_pixmap_from_image()`.
    Calls fz_get_pixmap_from_image() with ctm, subarea, w and h all set to NULL.
    """
    return _mupdf.ll_fz_get_unscaled_pixmap_from_image(image)

def ll_fz_getopt(nargc, nargv, ostr):
    r"""
     Low-level wrapper for `::fz_getopt()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_fz_getopt(int nargc, const char *ostr)` => `(int, char *nargv)`

    	Identical to fz_getopt_long, but with a NULL longopts field, signifying no long
    	options.
    """
    return _mupdf.ll_fz_getopt(nargc, nargv, ostr)

def ll_fz_getopt_long(nargc, nargv, ostr, longopts):
    r"""
     Low-level wrapper for `::fz_getopt_long()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_fz_getopt_long(int nargc, const char *ostr, const ::fz_getopt_long_options *longopts)` => `(int, char *nargv)`

    	Simple functions/variables for use in tools.

    	ostr = option string. Comprises single letter options, followed by : if there
    	is an argument to the option.

    	longopts: NULL (indicating no long options), or a pointer to an array of
    	longoptions, terminated by an entry with option == NULL.

    	In the event of matching a single char option, this function will normally
    	return the char. The exception to this is when the option requires an
    	argument and none is supplied; in this case we return ':'.

    	In the event of matching a long option, this function returns 0, with fz_optlong
    	set to point to the matching option.

    	A long option entry may be followed with : to indicate there is an argument to the
    	option. If the need for an argument is specified in this way, and no argument is
    	given, an error will be displayed and argument processing will stop. If an argument
    	is given, and the long option record contains a non-null flag pointer, then the code
    	will decode the argument and fill in that flag pointer. Specifically,
    	case-insensitive matches to 'yes', 'no', 'true' and 'false' will cause a value of 0
    	or 1 as appropriate to be written; failing this the arg will be interpreted as a
    	decimal integer using atoi.

    	A long option entry may be followed by an list of options (e.g. myoption=foo|bar|baz)
    	and the option will be passed to fz_opt_from_list. The return value of that will be
    	placed in fz_optitem. If the return value of that function is -1, then an error will
    	be displayed and argument processing will stop.

    	In the event of reaching the end of the arg list or '--', this function returns EOF.

    	In the event of failing to match anything, an error is printed, and we return '?'.

    	If an argument is expected for the option, then fz_optarg will be returned pointing
    	at the start of the argument. Examples of supported argument formats: '-r500', '-r 500',
    	'--resolution 500', '--resolution=500'.
    """
    return _mupdf.ll_fz_getopt_long(nargc, nargv, ostr, longopts)

def ll_fz_glyph_bbox(glyph):
    r"""
    Low-level wrapper for `::fz_glyph_bbox()`.
    Return the bounding box of the glyph in pixels.
    """
    return _mupdf.ll_fz_glyph_bbox(glyph)

def ll_fz_glyph_bbox_no_ctx(src):
    r""" Low-level wrapper for `::fz_glyph_bbox_no_ctx()`."""
    return _mupdf.ll_fz_glyph_bbox_no_ctx(src)

def ll_fz_glyph_cacheable(font, gid):
    r"""
    Low-level wrapper for `::fz_glyph_cacheable()`.
    Determine if a given glyph in a font
    is cacheable. Certain glyphs in a type 3 font cannot safely
    be cached, as their appearance depends on the enclosing
    graphic state.

    font: The font to look for the glyph in.

    gif: The glyph to query.

    Returns non-zero if cacheable, 0 if not.
    """
    return _mupdf.ll_fz_glyph_cacheable(font, gid)

def ll_fz_glyph_height(glyph):
    r"""
    Low-level wrapper for `::fz_glyph_height()`.
    Return the height of the glyph in pixels.
    """
    return _mupdf.ll_fz_glyph_height(glyph)

def ll_fz_glyph_name_from_unicode_sc(unicode):
    r""" Low-level wrapper for `::fz_glyph_name_from_unicode_sc()`."""
    return _mupdf.ll_fz_glyph_name_from_unicode_sc(unicode)

def ll_fz_glyph_width(glyph):
    r"""
    Low-level wrapper for `::fz_glyph_width()`.
    Return the width of the glyph in pixels.
    """
    return _mupdf.ll_fz_glyph_width(glyph)

def ll_fz_graphics_aa_level():
    r"""
    Low-level wrapper for `::fz_graphics_aa_level()`.
    Get the number of bits of antialiasing we are
    using for graphics. Between 0 and 8.
    """
    return _mupdf.ll_fz_graphics_aa_level()

def ll_fz_graphics_min_line_width():
    r"""
    Low-level wrapper for `::fz_graphics_min_line_width()`.
    Get the minimum line width to be
    used for stroked lines.

    min_line_width: The minimum line width to use (in pixels).
    """
    return _mupdf.ll_fz_graphics_min_line_width()

def ll_fz_gridfit_matrix(as_tiled, m):
    r"""
    Low-level wrapper for `::fz_gridfit_matrix()`.
    Grid fit a matrix.

    as_tiled = 0 => adjust the matrix so that the image of the unit
    square completely covers any pixel that was touched by the
    image of the unit square under the original matrix.

    as_tiled = 1 => adjust the matrix so that the corners of the
    image of the unit square align with the closest integer corner
    of the image of the unit square under the original matrix.
    """
    return _mupdf.ll_fz_gridfit_matrix(as_tiled, m)

def ll_fz_grisu(f, s, exp):
    r"""
     Low-level wrapper for `::fz_grisu()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_fz_grisu(float f, char *s)` => `(int, int exp)`
    """
    return _mupdf.ll_fz_grisu(f, s, exp)

def ll_fz_grow_buffer(buf):
    r"""
    Low-level wrapper for `::fz_grow_buffer()`.
    Make some space within a buffer (i.e. ensure that
    capacity > size).
    """
    return _mupdf.ll_fz_grow_buffer(buf)

def ll_fz_has_archive_entry(arch, name):
    r"""
    Low-level wrapper for `::fz_has_archive_entry()`.
    Check if entry by given name exists.

    If named entry does not exist 0 will be returned, if it does
    exist 1 is returned.

    name: Entry name to look for, this must be an exact match to
    the entry name in the archive.
    """
    return _mupdf.ll_fz_has_archive_entry(arch, name)

def ll_fz_has_option(opts, key, val):
    r"""
     Low-level wrapper for `::fz_has_option()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_fz_has_option(const char *opts, const char *key)` => `(int, const char *val)`

    	Look for a given option (key) in the opts string. Return 1 if
    	it has it, and update *val to point to the value within opts.
    """
    return _mupdf.ll_fz_has_option(opts, key, val)

def ll_fz_has_permission(doc, p):
    r"""
    Low-level wrapper for `::fz_has_permission()`.
    Check permission flags on document.
    """
    return _mupdf.ll_fz_has_permission(doc, p)

def ll_fz_hash_filter(table, state, callback):
    r"""
    Low-level wrapper for `::fz_hash_filter()`.
    Iterate over the entries in a hash table, removing all the ones where callback returns true.
    Does NOT free the value of the entry, so the caller is expected to take care of this.
    """
    return _mupdf.ll_fz_hash_filter(table, state, callback)

def ll_fz_hash_find(table, key):
    r"""
    Low-level wrapper for `::fz_hash_find()`.
    Search for a matching hash within the table, and return the
    associated value.
    """
    return _mupdf.ll_fz_hash_find(table, key)

def ll_fz_hash_for_each(table, state, callback):
    r"""
    Low-level wrapper for `::fz_hash_for_each()`.
    Iterate over the entries in a hash table.
    """
    return _mupdf.ll_fz_hash_for_each(table, state, callback)

def ll_fz_hash_insert(table, key, val):
    r"""
    Low-level wrapper for `::fz_hash_insert()`.
    Insert a new key/value pair into the hash table.

    If an existing entry with the same key is found, no change is
    made to the hash table, and a pointer to the existing value is
    returned.

    If no existing entry with the same key is found, ownership of
    val passes in, key is copied, and NULL is returned.
    """
    return _mupdf.ll_fz_hash_insert(table, key, val)

def ll_fz_hash_remove(table, key):
    r"""
    Low-level wrapper for `::fz_hash_remove()`.
    Remove the entry for a given key.

    The value is NOT freed, so the caller is expected to take care
    of this.
    """
    return _mupdf.ll_fz_hash_remove(table, key)

def ll_fz_hb_lock():
    r"""
    Low-level wrapper for `::fz_hb_lock()`.
    Lock against Harfbuzz being called
    simultaneously in several threads. This reuses
    FZ_LOCK_FREETYPE.
    """
    return _mupdf.ll_fz_hb_lock()

def ll_fz_hb_unlock():
    r"""
    Low-level wrapper for `::fz_hb_unlock()`.
    Unlock after a Harfbuzz call. This reuses
    FZ_LOCK_FREETYPE.
    """
    return _mupdf.ll_fz_hb_unlock()

def ll_fz_highlight_selection(page, a, b, quads, max_quads):
    r"""
    Low-level wrapper for `::fz_highlight_selection()`.
    Return a list of quads to highlight lines inside the selection
    points.
    """
    return _mupdf.ll_fz_highlight_selection(page, a, b, quads, max_quads)

def ll_fz_highlight_selection2(page, a, b, max_quads):
    r"""
     Low-level wrapper for `::fz_highlight_selection2()`.
    C++ alternative to fz_highlight_selection() that returns quads in a
    std::vector.
    """
    return _mupdf.ll_fz_highlight_selection2(page, a, b, max_quads)

def ll_fz_ignore_error():
    r""" Low-level wrapper for `::fz_ignore_error()`."""
    return _mupdf.ll_fz_ignore_error()

def ll_fz_ignore_text(dev, text, ctm):
    r""" Low-level wrapper for `::fz_ignore_text()`."""
    return _mupdf.ll_fz_ignore_text(dev, text, ctm)

def ll_fz_image_orientation(image):
    r"""
    Low-level wrapper for `::fz_image_orientation()`.
    Request the natural orientation of an image.

    This is for images (such as JPEG) that can contain internal
    specifications of rotation/flips. This is ignored by all the
    internal decode/rendering routines, but can be used by callers
    (such as the image document handler) to respect such
    specifications.

    The values used by MuPDF are as follows, with the equivalent
    Exif specifications given for information:

    0: Undefined
    1: 0 degree ccw rotation. (Exif = 1)
    2: 90 degree ccw rotation. (Exif = 8)
    3: 180 degree ccw rotation. (Exif = 3)
    4: 270 degree ccw rotation. (Exif = 6)
    5: flip on X. (Exif = 2)
    6: flip on X, then rotate ccw by 90 degrees. (Exif = 5)
    7: flip on X, then rotate ccw by 180 degrees. (Exif = 4)
    8: flip on X, then rotate ccw by 270 degrees. (Exif = 7)
    """
    return _mupdf.ll_fz_image_orientation(image)

def ll_fz_image_orientation_matrix(image):
    r""" Low-level wrapper for `::fz_image_orientation_matrix()`."""
    return _mupdf.ll_fz_image_orientation_matrix(image)

def ll_fz_image_resolution(image, xres, yres):
    r"""
     Low-level wrapper for `::fz_image_resolution()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_fz_image_resolution(::fz_image *image)` => `(int xres, int yres)`

    	Request the natural resolution
    	of an image.

    	xres, yres: Pointers to ints to be updated with the
    	natural resolution of an image (or a sensible default
    	if not encoded).
    """
    return _mupdf.ll_fz_image_resolution(image, xres, yres)

def ll_fz_image_size(im):
    r"""
    Low-level wrapper for `::fz_image_size()`.
    Return the size of the storage used by an image.
    """
    return _mupdf.ll_fz_image_size(im)

def ll_fz_image_type_name(type):
    r"""
    Low-level wrapper for `::fz_image_type_name()`.
    Map from FZ_IMAGE_* value to string.

    The returned string is static and therefore must not be freed.
    """
    return _mupdf.ll_fz_image_type_name(type)

def ll_fz_include_point_in_rect(r, p):
    r"""
    Low-level wrapper for `::fz_include_point_in_rect()`.
    Expand a bbox to include a given point.
    To create a rectangle that encompasses a sequence of points, the
    rectangle must first be set to be the empty rectangle at one of
    the points before including the others.
    """
    return _mupdf.ll_fz_include_point_in_rect(r, p)

def ll_fz_init_text_decoder(dec, encoding):
    r""" Low-level wrapper for `::fz_init_text_decoder()`."""
    return _mupdf.ll_fz_init_text_decoder(dec, encoding)

def ll_fz_install_load_system_font_funcs(f, f_cjk, f_fallback):
    r"""
    Low-level wrapper for `::fz_install_load_system_font_funcs()`.
    Install functions to allow MuPDF to request fonts from the
    system.

    Only one set of hooks can be in use at a time.
    """
    return _mupdf.ll_fz_install_load_system_font_funcs(f, f_cjk, f_fallback)

def ll_fz_install_load_system_font_funcs2(args):
    r"""
     Low-level wrapper for `::fz_install_load_system_font_funcs2()`.
    Alternative to fz_install_load_system_font_funcs() that takes args in a
    struct, to allow use from Python/C# via Swig Directors.
    """
    return _mupdf.ll_fz_install_load_system_font_funcs2(args)

def ll_fz_int2_heap_insert(heap, v):
    r""" Low-level wrapper for `::fz_int2_heap_insert()`."""
    return _mupdf.ll_fz_int2_heap_insert(heap, v)

def ll_fz_int2_heap_sort(heap):
    r""" Low-level wrapper for `::fz_int2_heap_sort()`."""
    return _mupdf.ll_fz_int2_heap_sort(heap)

def ll_fz_int2_heap_uniq(heap):
    r""" Low-level wrapper for `::fz_int2_heap_uniq()`."""
    return _mupdf.ll_fz_int2_heap_uniq(heap)

def ll_fz_int_heap_insert(heap, v):
    r""" Low-level wrapper for `::fz_int_heap_insert()`."""
    return _mupdf.ll_fz_int_heap_insert(heap, v)

def ll_fz_int_heap_sort(heap):
    r""" Low-level wrapper for `::fz_int_heap_sort()`."""
    return _mupdf.ll_fz_int_heap_sort(heap)

def ll_fz_int_heap_uniq(heap):
    r""" Low-level wrapper for `::fz_int_heap_uniq()`."""
    return _mupdf.ll_fz_int_heap_uniq(heap)

def ll_fz_intersect_irect(a, b):
    r"""
    Low-level wrapper for `::fz_intersect_irect()`.
    Compute intersection of two bounding boxes.

    Similar to fz_intersect_rect but operates on two bounding
    boxes instead of two rectangles.
    """
    return _mupdf.ll_fz_intersect_irect(a, b)

def ll_fz_intersect_rect(a, b):
    r"""
    Low-level wrapper for `::fz_intersect_rect()`.
    Compute intersection of two rectangles.

    Given two rectangles, update the first to be the smallest
    axis-aligned rectangle that covers the area covered by both
    given rectangles. If either rectangle is empty then the
    intersection is also empty. If either rectangle is infinite
    then the intersection is simply the non-infinite rectangle.
    Should both rectangles be infinite, then the intersection is
    also infinite.
    """
    return _mupdf.ll_fz_intersect_rect(a, b)

def ll_fz_intptr_heap_insert(heap, v):
    r""" Low-level wrapper for `::fz_intptr_heap_insert()`."""
    return _mupdf.ll_fz_intptr_heap_insert(heap, v)

def ll_fz_intptr_heap_sort(heap):
    r""" Low-level wrapper for `::fz_intptr_heap_sort()`."""
    return _mupdf.ll_fz_intptr_heap_sort(heap)

def ll_fz_intptr_heap_uniq(heap):
    r""" Low-level wrapper for `::fz_intptr_heap_uniq()`."""
    return _mupdf.ll_fz_intptr_heap_uniq(heap)

def ll_fz_invert_bitmap(bmp):
    r"""
    Low-level wrapper for `::fz_invert_bitmap()`.
    Invert bitmap.

    Never throws exceptions.
    """
    return _mupdf.ll_fz_invert_bitmap(bmp)

def ll_fz_invert_matrix(matrix):
    r"""
    Low-level wrapper for `::fz_invert_matrix()`.
    Create an inverse matrix.

    inverse: Place to store inverse matrix.

    matrix: Matrix to invert. A degenerate matrix, where the
    determinant is equal to zero, can not be inverted and the
    original matrix is returned instead.

    Returns inverse.
    """
    return _mupdf.ll_fz_invert_matrix(matrix)

def ll_fz_invert_pixmap(pix):
    r"""
    Low-level wrapper for `::fz_invert_pixmap()`.
    Invert all the pixels in a pixmap. All components (process and
    spots) of all pixels are inverted (except alpha, which is
    unchanged).
    """
    return _mupdf.ll_fz_invert_pixmap(pix)

def ll_fz_invert_pixmap_alpha(pix):
    r"""
    Low-level wrapper for `::fz_invert_pixmap_alpha()`.
    Invert the alpha fo all the pixels in a pixmap.
    """
    return _mupdf.ll_fz_invert_pixmap_alpha(pix)

def ll_fz_invert_pixmap_luminance(pix):
    r"""
    Low-level wrapper for `::fz_invert_pixmap_luminance()`.
    Transform the pixels in a pixmap so that luminance of each
    pixel is inverted, and the chrominance remains unchanged (as
    much as accuracy allows).

    All components of all pixels are inverted (except alpha, which
    is unchanged). Only supports Grey and RGB bitmaps.
    """
    return _mupdf.ll_fz_invert_pixmap_luminance(pix)

def ll_fz_invert_pixmap_raw(pix):
    r"""
    Low-level wrapper for `::fz_invert_pixmap_raw()`.
    Invert all the pixels in a non-premultiplied pixmap in a
    very naive manner.
    """
    return _mupdf.ll_fz_invert_pixmap_raw(pix)

def ll_fz_invert_pixmap_rect(image, rect):
    r"""
    Low-level wrapper for `::fz_invert_pixmap_rect()`.
    Invert all the pixels in a given rectangle of a (premultiplied)
    pixmap. All components of all pixels in the rectangle are
    inverted (except alpha, which is unchanged).
    """
    return _mupdf.ll_fz_invert_pixmap_rect(image, rect)

def ll_fz_irect_from_rect(rect):
    r"""
    Low-level wrapper for `::fz_irect_from_rect()`.
    Convert a rect into the minimal bounding box
    that covers the rectangle.

    Coordinates in a bounding box are integers, so rounding of the
    rects coordinates takes place. The top left corner is rounded
    upwards and left while the bottom right corner is rounded
    downwards and to the right.
    """
    return _mupdf.ll_fz_irect_from_rect(rect)

def ll_fz_irect_height(r):
    r"""
    Low-level wrapper for `::fz_irect_height()`.
    Return the height of an irect. Invalid irects return 0.
    """
    return _mupdf.ll_fz_irect_height(r)

def ll_fz_irect_width(r):
    r"""
    Low-level wrapper for `::fz_irect_width()`.
    Return the width of an irect. Invalid irects return 0.
    """
    return _mupdf.ll_fz_irect_width(r)

def ll_fz_is_cfb_archive(file):
    r"""
    Low-level wrapper for `::fz_is_cfb_archive()`.
    Detect if stream object is a cfb archive.

    Assumes that the stream object is seekable.
    """
    return _mupdf.ll_fz_is_cfb_archive(file)

def ll_fz_is_directory(path):
    r"""
    Low-level wrapper for `::fz_is_directory()`.
    Determine if a given path is a directory.

    In the case of the path not existing, or having no access
    we will return 0.
    """
    return _mupdf.ll_fz_is_directory(path)

def ll_fz_is_document_reflowable(doc):
    r"""
    Low-level wrapper for `::fz_is_document_reflowable()`.
    Is the document reflowable.

    Returns 1 to indicate reflowable documents, otherwise 0.
    """
    return _mupdf.ll_fz_is_document_reflowable(doc)

def ll_fz_is_empty_irect(r):
    r""" Low-level wrapper for `::fz_is_empty_irect()`."""
    return _mupdf.ll_fz_is_empty_irect(r)

def ll_fz_is_empty_rect(r):
    r"""
    Low-level wrapper for `::fz_is_empty_rect()`.
    Check if rectangle is empty.

    An empty rectangle is defined as one whose area is zero.
    All invalid rectangles are empty.
    """
    return _mupdf.ll_fz_is_empty_rect(r)

def ll_fz_is_eof(stm):
    r"""
    Low-level wrapper for `::fz_is_eof()`.
    Query if the stream has reached EOF (during normal bytewise
    reading).

    See fz_is_eof_bits for the equivalent function for bitwise
    reading.
    """
    return _mupdf.ll_fz_is_eof(stm)

def ll_fz_is_eof_bits(stm):
    r"""
    Low-level wrapper for `::fz_is_eof_bits()`.
    Query if the stream has reached EOF (during bitwise
    reading).

    See fz_is_eof for the equivalent function for bytewise
    reading.
    """
    return _mupdf.ll_fz_is_eof_bits(stm)

def ll_fz_is_external_link(uri):
    r"""
    Low-level wrapper for `::fz_is_external_link()`.
    Query whether a link is external to a document (determined by
    uri containing a ':', intended to match with '://' which
    separates the scheme from the scheme specific parts in URIs).
    """
    return _mupdf.ll_fz_is_external_link(uri)

def ll_fz_is_identity(m):
    r""" Low-level wrapper for `::fz_is_identity()`."""
    return _mupdf.ll_fz_is_identity(m)

def ll_fz_is_infinite_irect(r):
    r"""
    Low-level wrapper for `::fz_is_infinite_irect()`.
    Check if an integer rectangle
    is infinite.
    """
    return _mupdf.ll_fz_is_infinite_irect(r)

def ll_fz_is_infinite_rect(r):
    r"""
    Low-level wrapper for `::fz_is_infinite_rect()`.
    Check if rectangle is infinite.
    """
    return _mupdf.ll_fz_is_infinite_rect(r)

def ll_fz_is_libarchive_archive(file):
    r"""
    Low-level wrapper for `::fz_is_libarchive_archive()`.
    Detect if stream object is an archive supported by libarchive.

    Assumes that the stream object is seekable.
    """
    return _mupdf.ll_fz_is_libarchive_archive(file)

def ll_fz_is_page_range(s):
    r"""
     Low-level wrapper for `::fz_is_page_range()`.
    	Check and parse string into page ranges:
    ,?(-?+|N)(-(-?+|N))?/
    """
    return _mupdf.ll_fz_is_page_range(s)

def ll_fz_is_pixmap_monochrome(pixmap):
    r"""
    Low-level wrapper for `::fz_is_pixmap_monochrome()`.
    Check if the pixmap is a 1-channel image containing samples with
    only values 0 and 255
    """
    return _mupdf.ll_fz_is_pixmap_monochrome(pixmap)

def ll_fz_is_point_inside_irect(x, y, r):
    r"""
    Low-level wrapper for `::fz_is_point_inside_irect()`.
    Inclusion test for irects. (Rect is assumed to be open, i.e.
    top right corner is not included).
    """
    return _mupdf.ll_fz_is_point_inside_irect(x, y, r)

def ll_fz_is_point_inside_quad(p, q):
    r"""
    Low-level wrapper for `::fz_is_point_inside_quad()`.
    Inclusion test for quads.
    """
    return _mupdf.ll_fz_is_point_inside_quad(p, q)

def ll_fz_is_point_inside_rect(p, r):
    r"""
    Low-level wrapper for `::fz_is_point_inside_rect()`.
    Inclusion test for rects. (Rect is assumed to be open, i.e.
    top right corner is not included).
    """
    return _mupdf.ll_fz_is_point_inside_rect(p, r)

def ll_fz_is_pow2(a):
    r""" Low-level wrapper for `::fz_is_pow2()`."""
    return _mupdf.ll_fz_is_pow2(a)

def ll_fz_is_quad_inside_quad(needle, haystack):
    r"""
    Low-level wrapper for `::fz_is_quad_inside_quad()`.
    Inclusion test for quad in quad.

    This may break down if quads are not 'well formed'.
    """
    return _mupdf.ll_fz_is_quad_inside_quad(needle, haystack)

def ll_fz_is_quad_intersecting_quad(a, b):
    r"""
    Low-level wrapper for `::fz_is_quad_intersecting_quad()`.
    Intersection test for quads.

    This may break down if quads are not 'well formed'.
    """
    return _mupdf.ll_fz_is_quad_intersecting_quad(a, b)

def ll_fz_is_rectilinear(m):
    r"""
    Low-level wrapper for `::fz_is_rectilinear()`.
    Check if a transformation is rectilinear.

    Rectilinear means that no shearing is present and that any
    rotations present are a multiple of 90 degrees. Usually this
    is used to make sure that axis-aligned rectangles before the
    transformation are still axis-aligned rectangles afterwards.
    """
    return _mupdf.ll_fz_is_rectilinear(m)

def ll_fz_is_tar_archive(file):
    r"""
    Low-level wrapper for `::fz_is_tar_archive()`.
    Detect if stream object is a tar archive.

    Assumes that the stream object is seekable.
    """
    return _mupdf.ll_fz_is_tar_archive(file)

def ll_fz_is_valid_blend_colorspace(cs):
    r"""
    Low-level wrapper for `::fz_is_valid_blend_colorspace()`.
    Check to see that a colorspace is appropriate to be used as
    a blending space (i.e. only grey, rgb or cmyk).
    """
    return _mupdf.ll_fz_is_valid_blend_colorspace(cs)

def ll_fz_is_valid_irect(r):
    r"""
    Low-level wrapper for `::fz_is_valid_irect()`.
    Check if an integer rectangle is valid.
    """
    return _mupdf.ll_fz_is_valid_irect(r)

def ll_fz_is_valid_rect(r):
    r"""
    Low-level wrapper for `::fz_is_valid_rect()`.
    Check if rectangle is valid.
    """
    return _mupdf.ll_fz_is_valid_rect(r)

def ll_fz_is_zip_archive(file):
    r"""
    Low-level wrapper for `::fz_is_zip_archive()`.
    Detect if stream object is a zip archive.

    Assumes that the stream object is seekable.
    """
    return _mupdf.ll_fz_is_zip_archive(file)

def ll_fz_iso8859_1_from_unicode(u):
    r""" Low-level wrapper for `::fz_iso8859_1_from_unicode()`."""
    return _mupdf.ll_fz_iso8859_1_from_unicode(u)

def ll_fz_iso8859_7_from_unicode(u):
    r""" Low-level wrapper for `::fz_iso8859_7_from_unicode()`."""
    return _mupdf.ll_fz_iso8859_7_from_unicode(u)

def ll_fz_jbig2_globals_data(globals):
    r"""
    Low-level wrapper for `::fz_jbig2_globals_data()`.
    Return buffer containing jbig2 globals data stream.
    """
    return _mupdf.ll_fz_jbig2_globals_data(globals)

def ll_fz_keep_archive(arch):
    r"""
    Low-level wrapper for `::fz_keep_archive()`.
    Keep a reference to an archive.
    """
    return _mupdf.ll_fz_keep_archive(arch)

def ll_fz_keep_bitmap(bit):
    r"""
    Low-level wrapper for `::fz_keep_bitmap()`.
    Take an additional reference to the bitmap. The same pointer
    is returned.

    Never throws exceptions.
    """
    return _mupdf.ll_fz_keep_bitmap(bit)

def ll_fz_keep_buffer(buf):
    r"""
    Low-level wrapper for `::fz_keep_buffer()`.
    Take an additional reference to the buffer. The same pointer
    is returned.

    Never throws exceptions.
    """
    return _mupdf.ll_fz_keep_buffer(buf)

def ll_fz_keep_colorspace(colorspace):
    r"""
    Low-level wrapper for `::fz_keep_colorspace()`.
    Increment the reference count for the colorspace.

    Returns the same pointer. Never throws an exception.
    """
    return _mupdf.ll_fz_keep_colorspace(colorspace)

def ll_fz_keep_compressed_buffer(cbuf):
    r"""
    Low-level wrapper for `::fz_keep_compressed_buffer()`.
    Take a reference to an fz_compressed_buffer.
    """
    return _mupdf.ll_fz_keep_compressed_buffer(cbuf)

def ll_fz_keep_default_colorspaces(default_cs):
    r"""
    Low-level wrapper for `::fz_keep_default_colorspaces()`.
    Keep an additional reference to the default colorspaces
    structure.

    Never throws exceptions.
    """
    return _mupdf.ll_fz_keep_default_colorspaces(default_cs)

def ll_fz_keep_device(dev):
    r"""
    Low-level wrapper for `::fz_keep_device()`.
    Increment the reference count for a device. Returns the same
    pointer.

    Never throws exceptions.
    """
    return _mupdf.ll_fz_keep_device(dev)

def ll_fz_keep_display_list(list):
    r"""
    Low-level wrapper for `::fz_keep_display_list()`.
    Increment the reference count for a display list. Returns the
    same pointer.

    Never throws exceptions.
    """
    return _mupdf.ll_fz_keep_display_list(list)

def ll_fz_keep_document(doc):
    r"""
    Low-level wrapper for `::fz_keep_document()`.
    Increment the document reference count. The same pointer is
    returned.

    Never throws exceptions.
    """
    return _mupdf.ll_fz_keep_document(doc)

def ll_fz_keep_font(font):
    r"""
    Low-level wrapper for `::fz_keep_font()`.
    Add a reference to an existing fz_font.

    font: The font to add a reference to.

    Returns the same font.
    """
    return _mupdf.ll_fz_keep_font(font)

def ll_fz_keep_function(func):
    r""" Low-level wrapper for `::fz_keep_function()`."""
    return _mupdf.ll_fz_keep_function(func)

def ll_fz_keep_glyph(pix):
    r"""
    Low-level wrapper for `::fz_keep_glyph()`.
    Take a reference to a glyph.

    pix: The glyph to increment the reference for.

    Returns pix.
    """
    return _mupdf.ll_fz_keep_glyph(pix)

def ll_fz_keep_halftone(half):
    r"""
    Low-level wrapper for `::fz_keep_halftone()`.
    Take an additional reference to the halftone. The same pointer
    is returned.

    Never throws exceptions.
    """
    return _mupdf.ll_fz_keep_halftone(half)

def ll_fz_keep_image(image):
    r"""
    Low-level wrapper for `::fz_keep_image()`.
    Increment the (normal) reference count for an image. Returns the
    same pointer.

    Never throws exceptions.
    """
    return _mupdf.ll_fz_keep_image(image)

def ll_fz_keep_image_store_key(image):
    r"""
    Low-level wrapper for `::fz_keep_image_store_key()`.
    Increment the store key reference for an image. Returns the same
    pointer. (This is the count of references for an image held by
    keys in the image store).

    Never throws exceptions.
    """
    return _mupdf.ll_fz_keep_image_store_key(image)

def ll_fz_keep_imp(p, refs):
    r"""
     Low-level wrapper for `::fz_keep_imp()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_fz_keep_imp(void *p)` => `(void *, int refs)`
    """
    return _mupdf.ll_fz_keep_imp(p, refs)

def ll_fz_keep_imp16(p, refs):
    r"""
     Low-level wrapper for `::fz_keep_imp16()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_fz_keep_imp16(void *p)` => `(void *, int16_t refs)`
    """
    return _mupdf.ll_fz_keep_imp16(p, refs)

def ll_fz_keep_imp8(p, refs):
    r""" Low-level wrapper for `::fz_keep_imp8()`."""
    return _mupdf.ll_fz_keep_imp8(p, refs)

def ll_fz_keep_imp8_locked(p, refs):
    r""" Low-level wrapper for `::fz_keep_imp8_locked()`."""
    return _mupdf.ll_fz_keep_imp8_locked(p, refs)

def ll_fz_keep_imp_locked(p, refs):
    r"""
     Low-level wrapper for `::fz_keep_imp_locked()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_fz_keep_imp_locked(void *p)` => `(void *, int refs)`
    """
    return _mupdf.ll_fz_keep_imp_locked(p, refs)

def ll_fz_keep_jbig2_globals(globals):
    r"""
    Low-level wrapper for `::fz_keep_jbig2_globals()`.
    Increment the reference count for a jbig2 globals record.

    Never throws an exception.
    """
    return _mupdf.ll_fz_keep_jbig2_globals(globals)

def ll_fz_keep_key_storable(arg_1):
    r"""
    Low-level wrapper for `::fz_keep_key_storable()`.
    Increment the (normal) reference count for a key storable
    object. Returns the same pointer.

    Never throws exceptions.
    """
    return _mupdf.ll_fz_keep_key_storable(arg_1)

def ll_fz_keep_key_storable_key(arg_1):
    r"""
    Low-level wrapper for `::fz_keep_key_storable_key()`.
    Increment the (key) reference count for a key storable
    object. Returns the same pointer.

    Never throws exceptions.
    """
    return _mupdf.ll_fz_keep_key_storable_key(arg_1)

def ll_fz_keep_link(link):
    r"""
    Low-level wrapper for `::fz_keep_link()`.
    Increment the reference count for a link. The same pointer is
    returned.

    Never throws exceptions.
    """
    return _mupdf.ll_fz_keep_link(link)

def ll_fz_keep_outline(outline):
    r"""
    Low-level wrapper for `::fz_keep_outline()`.
    Increment the reference count. Returns the same pointer.

    Never throws exceptions.
    """
    return _mupdf.ll_fz_keep_outline(outline)

def ll_fz_keep_page(page):
    r"""
    Low-level wrapper for `::fz_keep_page()`.
    Increment the reference count for the page. Returns the same
    pointer.

    Never throws exceptions.
    """
    return _mupdf.ll_fz_keep_page(page)

def ll_fz_keep_page_locked(page):
    r"""
    Low-level wrapper for `::fz_keep_page_locked()`.
    Increment the reference count for the page. Returns the same
    pointer. Must only be used when the alloc lock is already taken.

    Never throws exceptions.
    """
    return _mupdf.ll_fz_keep_page_locked(page)

def ll_fz_keep_path(path):
    r"""
    Low-level wrapper for `::fz_keep_path()`.
    Increment the reference count. Returns the same pointer.

    All paths can be kept, regardless of their packing type.

    Never throws exceptions.
    """
    return _mupdf.ll_fz_keep_path(path)

def ll_fz_keep_pixmap(pix):
    r"""
    Low-level wrapper for `::fz_keep_pixmap()`.
    Increment the reference count for the pixmap. The same pointer
    is returned.

    Never throws exceptions.
    """
    return _mupdf.ll_fz_keep_pixmap(pix)

def ll_fz_keep_separations(sep):
    r"""
    Low-level wrapper for `::fz_keep_separations()`.
    Increment the reference count for a separations structure.
    Returns the same pointer.

    Never throws exceptions.
    """
    return _mupdf.ll_fz_keep_separations(sep)

def ll_fz_keep_shade(shade):
    r"""
    Low-level wrapper for `::fz_keep_shade()`.
    Increment the reference count for the shade structure. The
    same pointer is returned.

    Never throws exceptions.
    """
    return _mupdf.ll_fz_keep_shade(shade)

def ll_fz_keep_storable(arg_1):
    r"""
    Low-level wrapper for `::fz_keep_storable()`.
    Increment the reference count for a storable object.
    Returns the same pointer.

    Never throws exceptions.
    """
    return _mupdf.ll_fz_keep_storable(arg_1)

def ll_fz_keep_store_context():
    r"""
    Low-level wrapper for `::fz_keep_store_context()`.
    Increment the reference count for the store context. Returns
    the same pointer.

    Never throws exceptions.
    """
    return _mupdf.ll_fz_keep_store_context()

def ll_fz_keep_stream(stm):
    r"""
    Low-level wrapper for `::fz_keep_stream()`.
    Increments the reference count for a stream. Returns the same
    pointer.

    Never throws exceptions.
    """
    return _mupdf.ll_fz_keep_stream(stm)

def ll_fz_keep_string(str):
    r""" Low-level wrapper for `::fz_keep_string()`."""
    return _mupdf.ll_fz_keep_string(str)

def ll_fz_keep_stroke_state(stroke):
    r"""
    Low-level wrapper for `::fz_keep_stroke_state()`.
    Take an additional reference to a stroke state structure.

    No modifications should be carried out on a stroke
    state to which more than one reference is held, as
    this can cause race conditions.
    """
    return _mupdf.ll_fz_keep_stroke_state(stroke)

def ll_fz_keep_text(text):
    r"""
    Low-level wrapper for `::fz_keep_text()`.
    Increment the reference count for the text object. The same
    pointer is returned.

    Never throws exceptions.
    """
    return _mupdf.ll_fz_keep_text(text)

def ll_fz_keep_xml(xml):
    r"""
    Low-level wrapper for `::fz_keep_xml()`.
    Add a reference to the XML.
    """
    return _mupdf.ll_fz_keep_xml(xml)

def ll_fz_koi8u_from_unicode(u):
    r""" Low-level wrapper for `::fz_koi8u_from_unicode()`."""
    return _mupdf.ll_fz_koi8u_from_unicode(u)

def ll_fz_last_page(doc):
    r"""
    Low-level wrapper for `::fz_last_page()`.
    Function to get the location for the last page in the document.
    Using this can be far more efficient in some cases than calling
    fz_count_pages and using the page number.
    """
    return _mupdf.ll_fz_last_page(doc)

def ll_fz_layout_document(doc, w, h, em):
    r"""
    Low-level wrapper for `::fz_layout_document()`.
    Layout reflowable document types.

    w, h: Page size in points.
    em: Default font size in points.
    """
    return _mupdf.ll_fz_layout_document(doc, w, h, em)

def ll_fz_lineto(path, x, y):
    r"""
    Low-level wrapper for `::fz_lineto()`.
    Append a 'lineto' command to an open path.

    path: The path to modify.

    x, y: The coordinate to line to.

    Throws exceptions on failure to allocate, or attempting to
    modify a packed path.
    """
    return _mupdf.ll_fz_lineto(path, x, y)

def ll_fz_list_archive_entry(arch, idx):
    r"""
    Low-level wrapper for `::fz_list_archive_entry()`.
    Get listed name of entry position idx.

    idx: Must be a value >= 0 < return value from
    fz_count_archive_entries. If not in range NULL will be
    returned.

    May throw an exception if this type of archive cannot list the
    entries (such as a directory).
    """
    return _mupdf.ll_fz_list_archive_entry(arch, idx)

def ll_fz_load_bmp_subimage(buf, len, subimage):
    r""" Low-level wrapper for `::fz_load_bmp_subimage()`."""
    return _mupdf.ll_fz_load_bmp_subimage(buf, len, subimage)

def ll_fz_load_bmp_subimage_count(buf, len):
    r""" Low-level wrapper for `::fz_load_bmp_subimage_count()`."""
    return _mupdf.ll_fz_load_bmp_subimage_count(buf, len)

def ll_fz_load_chapter_page(doc, chapter, page):
    r"""
    Low-level wrapper for `::fz_load_chapter_page()`.
    Load a page.

    After fz_load_page is it possible to retrieve the size of the
    page using fz_bound_page, or to render the page using
    fz_run_page_*. Free the page by calling fz_drop_page.

    chapter: chapter number, 0 is the first chapter of the document.
    number: page number, 0 is the first page of the chapter.
    """
    return _mupdf.ll_fz_load_chapter_page(doc, chapter, page)

def ll_fz_load_fallback_font(script, language, serif, bold, italic):
    r"""
    Low-level wrapper for `::fz_load_fallback_font()`.
    Try to load a fallback font for the
    given combination of font attributes. Whether a font is
    present or not will depend on the configuration in which
    MuPDF is built.

    script: The script desired (e.g. UCDN_SCRIPT_KATAKANA).

    language: The language desired (e.g. FZ_LANG_ja).

    serif: 1 if serif desired, 0 otherwise.

    bold: 1 if bold desired, 0 otherwise.

    italic: 1 if italic desired, 0 otherwise.

    Returns a new font handle, or NULL if not available.
    """
    return _mupdf.ll_fz_load_fallback_font(script, language, serif, bold, italic)

def ll_fz_load_jbig2_globals(buf):
    r"""
    Low-level wrapper for `::fz_load_jbig2_globals()`.
    Create a jbig2 globals record from a buffer.

    Immutable once created.
    """
    return _mupdf.ll_fz_load_jbig2_globals(buf)

def ll_fz_load_jbig2_subimage(buf, len, subimage):
    r""" Low-level wrapper for `::fz_load_jbig2_subimage()`."""
    return _mupdf.ll_fz_load_jbig2_subimage(buf, len, subimage)

def ll_fz_load_jbig2_subimage_count(buf, len):
    r""" Low-level wrapper for `::fz_load_jbig2_subimage_count()`."""
    return _mupdf.ll_fz_load_jbig2_subimage_count(buf, len)

def ll_fz_load_jpx(data, size, cs):
    r"""
    Low-level wrapper for `::fz_load_jpx()`.
    Exposed for PDF.
    """
    return _mupdf.ll_fz_load_jpx(data, size, cs)

def ll_fz_load_links(page):
    r"""
    Low-level wrapper for `::fz_load_links()`.
    Load the list of links for a page.

    Returns a linked list of all the links on the page, each with
    its clickable region and link destination. Each link is
    reference counted so drop and free the list of links by
    calling fz_drop_link on the pointer return from fz_load_links.

    page: Page obtained from fz_load_page.
    """
    return _mupdf.ll_fz_load_links(page)

def ll_fz_load_outline(doc):
    r"""
    Low-level wrapper for `::fz_load_outline()`.
    Load the hierarchical document outline.

    Should be freed by fz_drop_outline.
    """
    return _mupdf.ll_fz_load_outline(doc)

def ll_fz_load_outline_from_iterator(iter):
    r"""
    Low-level wrapper for `::fz_load_outline_from_iterator()`.
    Routine to implement the old Structure based API from an iterator.
    """
    return _mupdf.ll_fz_load_outline_from_iterator(iter)

def ll_fz_load_page(doc, number):
    r"""
    Low-level wrapper for `::fz_load_page()`.
    Load a given page number from a document. This may be much less
    efficient than loading by location (chapter+page) for some
    document types.
    """
    return _mupdf.ll_fz_load_page(doc, number)

def ll_fz_load_pnm_subimage(buf, len, subimage):
    r""" Low-level wrapper for `::fz_load_pnm_subimage()`."""
    return _mupdf.ll_fz_load_pnm_subimage(buf, len, subimage)

def ll_fz_load_pnm_subimage_count(buf, len):
    r""" Low-level wrapper for `::fz_load_pnm_subimage_count()`."""
    return _mupdf.ll_fz_load_pnm_subimage_count(buf, len)

def ll_fz_load_system_cjk_font(name, ordering, serif):
    r"""
    Low-level wrapper for `::fz_load_system_cjk_font()`.
    Attempt to load a given font from
    the system.

    name: The name of the desired font.

    ordering: The ordering to load the font from (e.g. FZ_ADOBE_KOREA)

    serif: 1 if serif desired, 0 otherwise.

    Returns a new font handle, or NULL if no matching font was found
    (or on error).
    """
    return _mupdf.ll_fz_load_system_cjk_font(name, ordering, serif)

def ll_fz_load_system_font(name, bold, italic, needs_exact_metrics):
    r"""
    Low-level wrapper for `::fz_load_system_font()`.
    Attempt to load a given font from the system.

    name: The name of the desired font.

    bold: 1 if bold desired, 0 otherwise.

    italic: 1 if italic desired, 0 otherwise.

    needs_exact_metrics: 1 if an exact metrical match is required,
    0 otherwise.

    Returns a new font handle, or NULL if no matching font was found
    (or on error).
    """
    return _mupdf.ll_fz_load_system_font(name, bold, italic, needs_exact_metrics)

def ll_fz_load_tiff_subimage(buf, len, subimage):
    r""" Low-level wrapper for `::fz_load_tiff_subimage()`."""
    return _mupdf.ll_fz_load_tiff_subimage(buf, len, subimage)

def ll_fz_load_tiff_subimage_count(buf, len):
    r"""
    Low-level wrapper for `::fz_load_tiff_subimage_count()`.
    Exposed for CBZ.
    """
    return _mupdf.ll_fz_load_tiff_subimage_count(buf, len)

def ll_fz_location_from_page_number(doc, number):
    r"""
    Low-level wrapper for `::fz_location_from_page_number()`.
    Converts from page number to chapter+page. This may cause many
    chapters to be laid out in order to calculate the number of
    pages within those chapters.
    """
    return _mupdf.ll_fz_location_from_page_number(doc, number)

def ll_fz_lock(lock):
    r"""
    Low-level wrapper for `::fz_lock()`.
    Lock one of the user supplied mutexes.
    """
    return _mupdf.ll_fz_lock(lock)

def ll_fz_log_error(str):
    r"""
    Low-level wrapper for `::fz_log_error()`.
    Log a (preformatted) string to the registered
    error stream (stderr by default).
    """
    return _mupdf.ll_fz_log_error(str)

def ll_fz_lookup_base14_font(name, len):
    r"""
     Low-level wrapper for `::fz_lookup_base14_font()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_fz_lookup_base14_font(const char *name)` => `(const unsigned char *, int len)`

    	Search the builtin base14 fonts for a match.
    	Whether a given font is present or not will depend on the
    	configuration in which MuPDF is built.

    	name: The name of the font desired.

    	len: Pointer to a place to receive the length of the discovered
    	font buffer.

    	Returns a pointer to the font file data, or NULL if not present.
    """
    return _mupdf.ll_fz_lookup_base14_font(name, len)

def ll_fz_lookup_blendmode(name):
    r"""
    Low-level wrapper for `::fz_lookup_blendmode()`.
    Map from (case sensitive) blend mode string to enumeration.
    """
    return _mupdf.ll_fz_lookup_blendmode(name)

def ll_fz_lookup_bookmark(doc, mark):
    r"""
    Low-level wrapper for `::fz_lookup_bookmark()`.
    Find a bookmark and return its page number.
    """
    return _mupdf.ll_fz_lookup_bookmark(doc, mark)

def ll_fz_lookup_builtin_font(name, bold, italic, len):
    r"""
     Low-level wrapper for `::fz_lookup_builtin_font()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_fz_lookup_builtin_font(const char *name, int bold, int italic)` => `(const unsigned char *, int len)`

    	Search the builtin fonts for a match.
    	Whether a given font is present or not will depend on the
    	configuration in which MuPDF is built.

    	name: The name of the font desired.

    	bold: 1 if bold desired, 0 otherwise.

    	italic: 1 if italic desired, 0 otherwise.

    	len: Pointer to a place to receive the length of the discovered
    	font buffer.

    	Returns a pointer to the font file data, or NULL if not present.
    """
    return _mupdf.ll_fz_lookup_builtin_font(name, bold, italic, len)

def ll_fz_lookup_cjk_font(ordering, len, index):
    r"""
     Low-level wrapper for `::fz_lookup_cjk_font()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_fz_lookup_cjk_font(int ordering)` => `(const unsigned char *, int len, int index)`

    	Search the builtin cjk fonts for a match.
    	Whether a font is present or not will depend on the
    	configuration in which MuPDF is built.

    	ordering: The desired ordering of the font (e.g. FZ_ADOBE_KOREA).

    	len: Pointer to a place to receive the length of the discovered
    	font buffer.

    	Returns a pointer to the font file data, or NULL if not present.
    """
    return _mupdf.ll_fz_lookup_cjk_font(ordering, len, index)

def ll_fz_lookup_cjk_font_by_language(lang, len, subfont):
    r"""
     Low-level wrapper for `::fz_lookup_cjk_font_by_language()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_fz_lookup_cjk_font_by_language(const char *lang)` => `(const unsigned char *, int len, int subfont)`

    	Search the builtin cjk fonts for a match for a given language.
    	Whether a font is present or not will depend on the
    	configuration in which MuPDF is built.

    	lang: Pointer to a (case sensitive) language string (e.g.
    	"ja", "ko", "zh-Hant" etc).

    	len: Pointer to a place to receive the length of the discovered
    	font buffer.

    	subfont: Pointer to a place to store the subfont index of the
    	discovered font.

    	Returns a pointer to the font file data, or NULL if not present.
    """
    return _mupdf.ll_fz_lookup_cjk_font_by_language(lang, len, subfont)

def ll_fz_lookup_cjk_ordering_by_language(name):
    r"""
    Low-level wrapper for `::fz_lookup_cjk_ordering_by_language()`.
    Return the matching FZ_ADOBE_* ordering
    for the given language tag, such as "zh-Hant", "zh-Hans", "ja", or "ko".
    """
    return _mupdf.ll_fz_lookup_cjk_ordering_by_language(name)

def ll_fz_lookup_image_type(type):
    r"""
    Low-level wrapper for `::fz_lookup_image_type()`.
    Map from (case sensitive) image type string to FZ_IMAGE_*
    type value.
    """
    return _mupdf.ll_fz_lookup_image_type(type)

def ll_fz_lookup_metadata(doc, key, buf, size):
    r"""
    Low-level wrapper for `::fz_lookup_metadata()`.
    Retrieve document meta data strings.

    doc: The document to query.

    key: Which meta data key to retrieve...

    Basic information:
    	'format'	-- Document format and version.
    	'encryption'	-- Description of the encryption used.

    From the document information dictionary:
    	'info:Title'
    	'info:Author'
    	'info:Subject'
    	'info:Keywords'
    	'info:Creator'
    	'info:Producer'
    	'info:CreationDate'
    	'info:ModDate'

    buf: The buffer to hold the results (a nul-terminated UTF-8
    string).

    size: Size of 'buf'.

    Returns the number of bytes need to store the string plus terminator
    (will be larger than 'size' if the output was truncated), or -1 if the
    key is not recognized or found.
    """
    return _mupdf.ll_fz_lookup_metadata(doc, key, buf, size)

def ll_fz_lookup_metadata2(doc, key):
    r"""
     Low-level wrapper for `::fz_lookup_metadata2()`.
    C++ alternative to `fz_lookup_metadata()` that returns a `std::string`
    or calls `fz_throw()` if not found.
    """
    return _mupdf.ll_fz_lookup_metadata2(doc, key)

def ll_fz_lookup_noto_boxes_font(len):
    r"""
     Low-level wrapper for `::fz_lookup_noto_boxes_font()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_fz_lookup_noto_boxes_font()` => `(const unsigned char *, int len)`
    """
    return _mupdf.ll_fz_lookup_noto_boxes_font(len)

def ll_fz_lookup_noto_emoji_font(len):
    r"""
     Low-level wrapper for `::fz_lookup_noto_emoji_font()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_fz_lookup_noto_emoji_font()` => `(const unsigned char *, int len)`
    """
    return _mupdf.ll_fz_lookup_noto_emoji_font(len)

def ll_fz_lookup_noto_font(script, lang, len, subfont):
    r"""
     Low-level wrapper for `::fz_lookup_noto_font()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_fz_lookup_noto_font(int script, int lang)` => `(const unsigned char *, int len, int subfont)`

    	Search the builtin noto fonts for a match.
    	Whether a font is present or not will depend on the
    	configuration in which MuPDF is built.

    	script: The script desired (e.g. UCDN_SCRIPT_KATAKANA).

    	lang: The language desired (e.g. FZ_LANG_ja).

    	len: Pointer to a place to receive the length of the discovered
    	font buffer.

    	Returns a pointer to the font file data, or NULL if not present.
    """
    return _mupdf.ll_fz_lookup_noto_font(script, lang, len, subfont)

def ll_fz_lookup_noto_math_font(len):
    r"""
     Low-level wrapper for `::fz_lookup_noto_math_font()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_fz_lookup_noto_math_font()` => `(const unsigned char *, int len)`

    	Search the builtin noto fonts specific symbol fonts.
    	Whether a font is present or not will depend on the
    	configuration in which MuPDF is built.
    """
    return _mupdf.ll_fz_lookup_noto_math_font(len)

def ll_fz_lookup_noto_music_font(len):
    r"""
     Low-level wrapper for `::fz_lookup_noto_music_font()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_fz_lookup_noto_music_font()` => `(const unsigned char *, int len)`
    """
    return _mupdf.ll_fz_lookup_noto_music_font(len)

def ll_fz_lookup_noto_symbol1_font(len):
    r"""
     Low-level wrapper for `::fz_lookup_noto_symbol1_font()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_fz_lookup_noto_symbol1_font()` => `(const unsigned char *, int len)`
    """
    return _mupdf.ll_fz_lookup_noto_symbol1_font(len)

def ll_fz_lookup_noto_symbol2_font(len):
    r"""
     Low-level wrapper for `::fz_lookup_noto_symbol2_font()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_fz_lookup_noto_symbol2_font()` => `(const unsigned char *, int len)`
    """
    return _mupdf.ll_fz_lookup_noto_symbol2_font(len)

def ll_fz_lookup_rendering_intent(name):
    r"""
    Low-level wrapper for `::fz_lookup_rendering_intent()`.
    Map from (case sensitive) rendering intent string to enumeration
    value.
    """
    return _mupdf.ll_fz_lookup_rendering_intent(name)

def ll_fz_make_bookmark(doc, loc):
    r"""
    Low-level wrapper for `::fz_make_bookmark()`.
    Create a bookmark for the given page, which can be used to find
    the same location after the document has been laid out with
    different parameters.
    """
    return _mupdf.ll_fz_make_bookmark(doc, loc)

def ll_fz_make_irect(x0, y0, x1, y1):
    r""" Low-level wrapper for `::fz_make_irect()`."""
    return _mupdf.ll_fz_make_irect(x0, y0, x1, y1)

def ll_fz_make_link_dest_none():
    r""" Low-level wrapper for `::fz_make_link_dest_none()`."""
    return _mupdf.ll_fz_make_link_dest_none()

def ll_fz_make_link_dest_xyz(chapter, page, x, y, z):
    r""" Low-level wrapper for `::fz_make_link_dest_xyz()`."""
    return _mupdf.ll_fz_make_link_dest_xyz(chapter, page, x, y, z)

def ll_fz_make_location(chapter, page):
    r"""
    Low-level wrapper for `::fz_make_location()`.
    Simple constructor for fz_locations.
    """
    return _mupdf.ll_fz_make_location(chapter, page)

def ll_fz_make_matrix(a, b, c, d, e, f):
    r""" Low-level wrapper for `::fz_make_matrix()`."""
    return _mupdf.ll_fz_make_matrix(a, b, c, d, e, f)

def ll_fz_make_point(x, y):
    r""" Low-level wrapper for `::fz_make_point()`."""
    return _mupdf.ll_fz_make_point(x, y)

def ll_fz_make_quad(ul_x, ul_y, ur_x, ur_y, ll_x, ll_y, lr_x, lr_y):
    r"""
    Low-level wrapper for `::fz_make_quad()`.
    Inline convenience construction function.
    """
    return _mupdf.ll_fz_make_quad(ul_x, ul_y, ur_x, ur_y, ll_x, ll_y, lr_x, lr_y)

def ll_fz_make_rect(x0, y0, x1, y1):
    r""" Low-level wrapper for `::fz_make_rect()`."""
    return _mupdf.ll_fz_make_rect(x0, y0, x1, y1)

def ll_fz_malloc(size):
    r"""
    Low-level wrapper for `::fz_malloc()`.
    Allocate uninitialized memory of a given size.
    Does NOT clear the memory!

    May return NULL for size = 0.

    Throws exception in the event of failure to allocate.
    """
    return _mupdf.ll_fz_malloc(size)

def ll_fz_malloc_no_throw(size):
    r"""
    Low-level wrapper for `::fz_malloc_no_throw()`.
    fz_malloc equivalent that returns NULL rather than throwing
    exceptions.
    """
    return _mupdf.ll_fz_malloc_no_throw(size)

def ll_fz_matrix_expansion(m):
    r"""
    Low-level wrapper for `::fz_matrix_expansion()`.
    Calculate average scaling factor of matrix.
    """
    return _mupdf.ll_fz_matrix_expansion(m)

def ll_fz_matrix_max_expansion(m):
    r"""
    Low-level wrapper for `::fz_matrix_max_expansion()`.
    Find the largest expansion performed by this matrix.
    (i.e. max(abs(m.a),abs(m.b),abs(m.c),abs(m.d))
    """
    return _mupdf.ll_fz_matrix_max_expansion(m)

def ll_fz_max(a, b):
    r""" Low-level wrapper for `::fz_max()`."""
    return _mupdf.ll_fz_max(a, b)

def ll_fz_maxi(a, b):
    r""" Low-level wrapper for `::fz_maxi()`."""
    return _mupdf.ll_fz_maxi(a, b)

def ll_fz_maxi64(a, b):
    r""" Low-level wrapper for `::fz_maxi64()`."""
    return _mupdf.ll_fz_maxi64(a, b)

def ll_fz_maxz(a, b):
    r""" Low-level wrapper for `::fz_maxz()`."""
    return _mupdf.ll_fz_maxz(a, b)

def ll_fz_md5_buffer(buffer, digest):
    r"""
    Low-level wrapper for `::fz_md5_buffer()`.
    Create an MD5 digest from buffer contents.

    Never throws exceptions.
    """
    return _mupdf.ll_fz_md5_buffer(buffer, digest)

def ll_fz_md5_final(state, digest):
    r"""
    Low-level wrapper for `::fz_md5_final()`.
    MD5 finalization. Ends an MD5 message-digest operation, writing
    the message digest and zeroizing the context.

    Never throws an exception.
    """
    return _mupdf.ll_fz_md5_final(state, digest)

def ll_fz_md5_final2(md5):
    r"""
     Low-level wrapper for `::fz_md5_final2()`.
    C++ alternative to fz_md5_final() that returns the digest by value.
    """
    return _mupdf.ll_fz_md5_final2(md5)

def ll_fz_md5_init(state):
    r"""
    Low-level wrapper for `::fz_md5_init()`.
    MD5 initialization. Begins an MD5 operation, writing a new
    context.

    Never throws an exception.
    """
    return _mupdf.ll_fz_md5_init(state)

def ll_fz_md5_pixmap(pixmap, digest):
    r""" Low-level wrapper for `::fz_md5_pixmap()`."""
    return _mupdf.ll_fz_md5_pixmap(pixmap, digest)

def ll_fz_md5_pixmap2(pixmap):
    r"""
     Low-level wrapper for `::fz_md5_pixmap2()`.
    C++ alternative to `fz_md5_pixmap()` that returns the digest by value.
    """
    return _mupdf.ll_fz_md5_pixmap2(pixmap)

def ll_fz_md5_update(state, input, inlen):
    r"""
    Low-level wrapper for `::fz_md5_update()`.
    MD5 block update operation. Continues an MD5 message-digest
    operation, processing another message block, and updating the
    context.

    Never throws an exception.
    """
    return _mupdf.ll_fz_md5_update(state, input, inlen)

def ll_fz_md5_update_int64(state, i):
    r"""
    Low-level wrapper for `::fz_md5_update_int64()`.
    MD5 block update operation. Continues an MD5 message-digest
    operation, processing an int64, and updating the context.

    Never throws an exception.
    """
    return _mupdf.ll_fz_md5_update_int64(state, i)

def ll_fz_measure_string(user_font, trm, s, wmode, bidi_level, markup_dir, language):
    r"""
    Low-level wrapper for `::fz_measure_string()`.
    Measure the advance width of a UTF8 string should it be added to a text object.

    This uses the same layout algorithms as fz_show_string, and can be used
    to calculate text alignment adjustments.
    """
    return _mupdf.ll_fz_measure_string(user_font, trm, s, wmode, bidi_level, markup_dir, language)

def ll_fz_memmem(haystack, haystacklen, needle, needlelen):
    r"""
    Low-level wrapper for `::fz_memmem()`.
    Find the start of the first occurrence of the substring needle in haystack.
    """
    return _mupdf.ll_fz_memmem(haystack, haystacklen, needle, needlelen)

def ll_fz_memrnd(block, len):
    r"""
    Low-level wrapper for `::fz_memrnd()`.
    Fill block with len bytes of pseudo-randomness.
    """
    return _mupdf.ll_fz_memrnd(block, len)

def ll_fz_min(a, b):
    r""" Low-level wrapper for `::fz_min()`."""
    return _mupdf.ll_fz_min(a, b)

def ll_fz_mini(a, b):
    r""" Low-level wrapper for `::fz_mini()`."""
    return _mupdf.ll_fz_mini(a, b)

def ll_fz_mini64(a, b):
    r""" Low-level wrapper for `::fz_mini64()`."""
    return _mupdf.ll_fz_mini64(a, b)

def ll_fz_minz(a, b):
    r""" Low-level wrapper for `::fz_minz()`."""
    return _mupdf.ll_fz_minz(a, b)

def ll_fz_mkdir(path):
    r""" Low-level wrapper for `::fz_mkdir()`."""
    return _mupdf.ll_fz_mkdir(path)

def ll_fz_morph_error(fromcode, tocode):
    r"""
    Low-level wrapper for `::fz_morph_error()`.
    Called within a catch block this modifies the current
    exception's code. If it's of type 'fromcode' it is
    modified to 'tocode'. Typically used for 'downgrading'
    exception severity.
    """
    return _mupdf.ll_fz_morph_error(fromcode, tocode)

def ll_fz_mount_multi_archive(arch_, sub, path):
    r"""
    Low-level wrapper for `::fz_mount_multi_archive()`.
    Add an archive to the set of archives handled by a multi
    archive.

    If path is NULL, then the archive contents will appear at the
    top level, otherwise, the archives contents will appear prefixed
    by path.
    """
    return _mupdf.ll_fz_mount_multi_archive(arch_, sub, path)

def ll_fz_moveto(path, x, y):
    r"""
    Low-level wrapper for `::fz_moveto()`.
    Append a 'moveto' command to a path.
    This 'opens' a path.

    path: The path to modify.

    x, y: The coordinate to move to.

    Throws exceptions on failure to allocate, or attempting to
    modify a packed path.
    """
    return _mupdf.ll_fz_moveto(path, x, y)

def ll_fz_mul255(a, b):
    r"""
    Low-level wrapper for `::fz_mul255()`.
    Multiply scaled two integers in the 0..255 range
    """
    return _mupdf.ll_fz_mul255(a, b)

def ll_fz_needs_password(doc):
    r"""
    Low-level wrapper for `::fz_needs_password()`.
    Check if a document is encrypted with a
    non-blank password.
    """
    return _mupdf.ll_fz_needs_password(doc)

def ll_fz_new_arc4_output(chain, key, keylen):
    r""" Low-level wrapper for `::fz_new_arc4_output()`."""
    return _mupdf.ll_fz_new_arc4_output(chain, key, keylen)

def ll_fz_new_archive_of_size(file, size):
    r""" Low-level wrapper for `::fz_new_archive_of_size()`."""
    return _mupdf.ll_fz_new_archive_of_size(file, size)

def ll_fz_new_ascii85_output(chain):
    r""" Low-level wrapper for `::fz_new_ascii85_output()`."""
    return _mupdf.ll_fz_new_ascii85_output(chain)

def ll_fz_new_asciihex_output(chain):
    r"""
    Low-level wrapper for `::fz_new_asciihex_output()`.
    Compression and other filtering outputs.

    These outputs write encoded data to another output. Create a
    filter output with the destination, write to the filter, then
    close and drop it when you're done. These can also be chained
    together, for example to write ASCII Hex encoded, Deflate
    compressed, and RC4 encrypted data to a buffer output.

    Output streams don't use reference counting, so make sure to
    close all of the filters in the reverse order of creation so
    that data is flushed properly.

    Accordingly, ownership of 'chain' is never passed into the
    following functions, but remains with the caller, whose
    responsibility it is to ensure they exist at least until
    the returned fz_output is dropped.
    """
    return _mupdf.ll_fz_new_asciihex_output(chain)

def ll_fz_new_band_writer_of_size(size, out):
    r""" Low-level wrapper for `::fz_new_band_writer_of_size()`."""
    return _mupdf.ll_fz_new_band_writer_of_size(size, out)

def ll_fz_new_base14_font(name):
    r"""
    Low-level wrapper for `::fz_new_base14_font()`.
    Create a new font from one of the built-in fonts.
    """
    return _mupdf.ll_fz_new_base14_font(name)

def ll_fz_new_bbox_device(rectp):
    r"""
    Low-level wrapper for `::fz_new_bbox_device()`.
    Create a device to compute the bounding
    box of all marks on a page.

    The returned bounding box will be the union of all bounding
    boxes of all objects on a page.
    """
    return _mupdf.ll_fz_new_bbox_device(rectp)

def ll_fz_new_bitmap(w, h, n, xres, yres):
    r"""
    Low-level wrapper for `::fz_new_bitmap()`.
    Create a new bitmap.

    w, h: Width and Height for the bitmap

    n: Number of color components (assumed to be a divisor of 8)

    xres, yres: X and Y resolutions (in pixels per inch).

    Returns pointer to created bitmap structure. The bitmap
    data is uninitialised.
    """
    return _mupdf.ll_fz_new_bitmap(w, h, n, xres, yres)

def ll_fz_new_bitmap_from_pixmap(pix, ht):
    r"""
    Low-level wrapper for `::fz_new_bitmap_from_pixmap()`.
    Make a bitmap from a pixmap and a halftone.

    pix: The pixmap to generate from. Currently must be a single
    color component with no alpha.

    ht: The halftone to use. NULL implies the default halftone.

    Returns the resultant bitmap. Throws exceptions in the case of
    failure to allocate.
    """
    return _mupdf.ll_fz_new_bitmap_from_pixmap(pix, ht)

def ll_fz_new_bitmap_from_pixmap_band(pix, ht, band_start):
    r"""
    Low-level wrapper for `::fz_new_bitmap_from_pixmap_band()`.
    Make a bitmap from a pixmap and a
    halftone, allowing for the position of the pixmap within an
    overall banded rendering.

    pix: The pixmap to generate from. Currently must be a single
    color component with no alpha.

    ht: The halftone to use. NULL implies the default halftone.

    band_start: Vertical offset within the overall banded rendering
    (in pixels)

    Returns the resultant bitmap. Throws exceptions in the case of
    failure to allocate.
    """
    return _mupdf.ll_fz_new_bitmap_from_pixmap_band(pix, ht, band_start)

def ll_fz_new_buffer(capacity):
    r""" Low-level wrapper for `::fz_new_buffer()`."""
    return _mupdf.ll_fz_new_buffer(capacity)

def ll_fz_new_buffer_from_base64(data, size):
    r"""
    Low-level wrapper for `::fz_new_buffer_from_base64()`.
    Create a new buffer with data decoded from a base64 input string.
    """
    return _mupdf.ll_fz_new_buffer_from_base64(data, size)

def ll_fz_new_buffer_from_copied_data(data, size):
    r"""
    Low-level wrapper for `::fz_new_buffer_from_copied_data()`.
    Create a new buffer containing a copy of the passed data.
    """
    return _mupdf.ll_fz_new_buffer_from_copied_data(data, size)

def ll_fz_new_buffer_from_data(data, size):
    r"""
    Low-level wrapper for `::fz_new_buffer_from_data()`.
    Create a new buffer with existing data.

    data: Pointer to existing data.
    size: Size of existing data.

    Takes ownership of data. Does not make a copy. Calls fz_free on
    the data when the buffer is deallocated. Do not use 'data' after
    passing to this function.

    Returns pointer to new buffer. Throws exception on allocation
    failure.
    """
    return _mupdf.ll_fz_new_buffer_from_data(data, size)

def ll_fz_new_buffer_from_display_list(list, options):
    r""" Low-level wrapper for `::fz_new_buffer_from_display_list()`."""
    return _mupdf.ll_fz_new_buffer_from_display_list(list, options)

def ll_fz_new_buffer_from_image_as_jpeg(image, color_params, quality, invert_cmyk):
    r""" Low-level wrapper for `::fz_new_buffer_from_image_as_jpeg()`."""
    return _mupdf.ll_fz_new_buffer_from_image_as_jpeg(image, color_params, quality, invert_cmyk)

def ll_fz_new_buffer_from_image_as_jpx(image, color_params, quality):
    r""" Low-level wrapper for `::fz_new_buffer_from_image_as_jpx()`."""
    return _mupdf.ll_fz_new_buffer_from_image_as_jpx(image, color_params, quality)

def ll_fz_new_buffer_from_image_as_pam(image, color_params):
    r""" Low-level wrapper for `::fz_new_buffer_from_image_as_pam()`."""
    return _mupdf.ll_fz_new_buffer_from_image_as_pam(image, color_params)

def ll_fz_new_buffer_from_image_as_png(image, color_params):
    r"""
    Low-level wrapper for `::fz_new_buffer_from_image_as_png()`.
    Reencode a given image as a PNG into a buffer.

    Ownership of the buffer is returned.
    """
    return _mupdf.ll_fz_new_buffer_from_image_as_png(image, color_params)

def ll_fz_new_buffer_from_image_as_pnm(image, color_params):
    r""" Low-level wrapper for `::fz_new_buffer_from_image_as_pnm()`."""
    return _mupdf.ll_fz_new_buffer_from_image_as_pnm(image, color_params)

def ll_fz_new_buffer_from_image_as_psd(image, color_params):
    r""" Low-level wrapper for `::fz_new_buffer_from_image_as_psd()`."""
    return _mupdf.ll_fz_new_buffer_from_image_as_psd(image, color_params)

def ll_fz_new_buffer_from_page(page, options):
    r""" Low-level wrapper for `::fz_new_buffer_from_page()`."""
    return _mupdf.ll_fz_new_buffer_from_page(page, options)

def ll_fz_new_buffer_from_page_number(doc, number, options):
    r""" Low-level wrapper for `::fz_new_buffer_from_page_number()`."""
    return _mupdf.ll_fz_new_buffer_from_page_number(doc, number, options)

def ll_fz_new_buffer_from_page_with_format(page, format, options, transform, cookie):
    r"""
    Low-level wrapper for `::fz_new_buffer_from_page_with_format()`.
    Returns an fz_buffer containing a page after conversion to specified format.

    page: The page to convert.
    format, options: Passed to fz_new_document_writer_with_output() internally.
    transform, cookie: Passed to fz_run_page() internally.
    """
    return _mupdf.ll_fz_new_buffer_from_page_with_format(page, format, options, transform, cookie)

def ll_fz_new_buffer_from_pixmap_as_jpeg(pixmap, color_params, quality, invert_cmyk):
    r""" Low-level wrapper for `::fz_new_buffer_from_pixmap_as_jpeg()`."""
    return _mupdf.ll_fz_new_buffer_from_pixmap_as_jpeg(pixmap, color_params, quality, invert_cmyk)

def ll_fz_new_buffer_from_pixmap_as_jpx(pix, color_params, quality):
    r""" Low-level wrapper for `::fz_new_buffer_from_pixmap_as_jpx()`."""
    return _mupdf.ll_fz_new_buffer_from_pixmap_as_jpx(pix, color_params, quality)

def ll_fz_new_buffer_from_pixmap_as_pam(pixmap, color_params):
    r""" Low-level wrapper for `::fz_new_buffer_from_pixmap_as_pam()`."""
    return _mupdf.ll_fz_new_buffer_from_pixmap_as_pam(pixmap, color_params)

def ll_fz_new_buffer_from_pixmap_as_png(pixmap, color_params):
    r"""
    Low-level wrapper for `::fz_new_buffer_from_pixmap_as_png()`.
    Reencode a given pixmap as a PNG into a buffer.

    Ownership of the buffer is returned.
    """
    return _mupdf.ll_fz_new_buffer_from_pixmap_as_png(pixmap, color_params)

def ll_fz_new_buffer_from_pixmap_as_pnm(pixmap, color_params):
    r""" Low-level wrapper for `::fz_new_buffer_from_pixmap_as_pnm()`."""
    return _mupdf.ll_fz_new_buffer_from_pixmap_as_pnm(pixmap, color_params)

def ll_fz_new_buffer_from_pixmap_as_psd(pix, color_params):
    r""" Low-level wrapper for `::fz_new_buffer_from_pixmap_as_psd()`."""
    return _mupdf.ll_fz_new_buffer_from_pixmap_as_psd(pix, color_params)

def ll_fz_new_buffer_from_shared_data(data, size):
    r"""
    Low-level wrapper for `::fz_new_buffer_from_shared_data()`.
    Like fz_new_buffer, but does not take ownership.
    """
    return _mupdf.ll_fz_new_buffer_from_shared_data(data, size)

def ll_fz_new_buffer_from_stext_page(text):
    r"""
    Low-level wrapper for `::fz_new_buffer_from_stext_page()`.
    Convert structured text into plain text.
    """
    return _mupdf.ll_fz_new_buffer_from_stext_page(text)

def ll_fz_new_builtin_font(name, is_bold, is_italic):
    r""" Low-level wrapper for `::fz_new_builtin_font()`."""
    return _mupdf.ll_fz_new_builtin_font(name, is_bold, is_italic)

def ll_fz_new_cal_gray_colorspace(wp, bp, gamma):
    r"""
    Low-level wrapper for `::fz_new_cal_gray_colorspace()`.
    Create a calibrated gray colorspace.

    The returned reference should be dropped when it is finished
    with.

    Colorspaces are immutable once created.
    """
    return _mupdf.ll_fz_new_cal_gray_colorspace(wp, bp, gamma)

def ll_fz_new_cal_rgb_colorspace(wp, bp, gamma, matrix):
    r"""
    Low-level wrapper for `::fz_new_cal_rgb_colorspace()`.
    Create a calibrated rgb colorspace.

    The returned reference should be dropped when it is finished
    with.

    Colorspaces are immutable once created.
    """
    return _mupdf.ll_fz_new_cal_rgb_colorspace(wp, bp, gamma, matrix)

def ll_fz_new_cbz_writer(path, options):
    r""" Low-level wrapper for `::fz_new_cbz_writer()`."""
    return _mupdf.ll_fz_new_cbz_writer(path, options)

def ll_fz_new_cbz_writer_with_output(out, options):
    r""" Low-level wrapper for `::fz_new_cbz_writer_with_output()`."""
    return _mupdf.ll_fz_new_cbz_writer_with_output(out, options)

def ll_fz_new_cjk_font(ordering):
    r""" Low-level wrapper for `::fz_new_cjk_font()`."""
    return _mupdf.ll_fz_new_cjk_font(ordering)

def ll_fz_new_color_pcl_band_writer(out, options):
    r"""
    Low-level wrapper for `::fz_new_color_pcl_band_writer()`.
    Create a new band writer, outputing color pcl.
    """
    return _mupdf.ll_fz_new_color_pcl_band_writer(out, options)

def ll_fz_new_colorspace(type, flags, n, name):
    r"""
    Low-level wrapper for `::fz_new_colorspace()`.
    Creates a new colorspace instance and returns a reference.

    No internal checking is done that the colorspace type (e.g.
    CMYK) matches with the flags (e.g. FZ_COLORSPACE_HAS_CMYK) or
    colorant count (n) or name.

    The reference should be dropped when it is finished with.

    Colorspaces are immutable once created (with the exception of
    setting up colorant names for separation spaces).
    """
    return _mupdf.ll_fz_new_colorspace(type, flags, n, name)

def ll_fz_new_compressed_buffer():
    r"""
    Low-level wrapper for `::fz_new_compressed_buffer()`.
    Create a new, UNKNOWN format, compressed_buffer.
    """
    return _mupdf.ll_fz_new_compressed_buffer()

def ll_fz_new_context_imp(alloc, locks, max_store, version):
    r""" Low-level wrapper for `::fz_new_context_imp()`."""
    return _mupdf.ll_fz_new_context_imp(alloc, locks, max_store, version)

def ll_fz_new_default_colorspaces():
    r"""
    Low-level wrapper for `::fz_new_default_colorspaces()`.
    Create a new default colorspace structure with values inherited
    from the context, and return a reference to it.

    These can be overridden using fz_set_default_xxxx.

    These should not be overridden while more than one caller has
    the reference for fear of race conditions.

    The caller should drop this reference once finished with it.
    """
    return _mupdf.ll_fz_new_default_colorspaces()

def ll_fz_new_deflate_output(chain, effort, raw):
    r""" Low-level wrapper for `::fz_new_deflate_output()`."""
    return _mupdf.ll_fz_new_deflate_output(chain, effort, raw)

def ll_fz_new_deflated_data(compressed_length, source, source_length, level):
    r"""
     Low-level wrapper for `::fz_new_deflated_data()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_fz_new_deflated_data(const unsigned char *source, size_t source_length, ::fz_deflate_level level)` => `(unsigned char *, size_t compressed_length)`

    	Compress source_length bytes of data starting
    	at source, into a new memory block malloced for that purpose.
    compressed_length is updated on exit to contain the size used.
    	Ownership of the block is returned from this function, and the
    	caller is therefore responsible for freeing it. The block may be
    	considerably larger than is actually required. The caller is
    	free to fz_realloc it down if it wants to.
    """
    return _mupdf.ll_fz_new_deflated_data(compressed_length, source, source_length, level)

def ll_fz_new_deflated_data_from_buffer(compressed_length, buffer, level):
    r"""
     Low-level wrapper for `::fz_new_deflated_data_from_buffer()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_fz_new_deflated_data_from_buffer(::fz_buffer *buffer, ::fz_deflate_level level)` => `(unsigned char *, size_t compressed_length)`

    	Compress the contents of a fz_buffer into a
    	new block malloced for that purpose. *compressed_length is
    	updated on exit to contain the size used. Ownership of the block
    	is returned from this function, and the caller is therefore
    	responsible for freeing it. The block may be considerably larger
    	than is actually required. The caller is free to fz_realloc it
    	down if it wants to.
    """
    return _mupdf.ll_fz_new_deflated_data_from_buffer(compressed_length, buffer, level)

def ll_fz_new_device_of_size(size):
    r"""
    Low-level wrapper for `::fz_new_device_of_size()`.
    Devices are created by calls to device implementations, for
    instance: foo_new_device(). These will be implemented by calling
    fz_new_derived_device(ctx, foo_device) where foo_device is a
    structure "derived from" fz_device, for instance
    typedef struct { fz_device base;  ...extras...} foo_device;
    """
    return _mupdf.ll_fz_new_device_of_size(size)

def ll_fz_new_display_list(mediabox):
    r"""
    Low-level wrapper for `::fz_new_display_list()`.
    Create an empty display list.

    A display list contains drawing commands (text, images, etc.).
    Use fz_new_list_device for populating the list.

    mediabox: Bounds of the page (in points) represented by the
    display list.
    """
    return _mupdf.ll_fz_new_display_list(mediabox)

def ll_fz_new_display_list_from_page(page):
    r"""
    Low-level wrapper for `::fz_new_display_list_from_page()`.
    Create a display list.

    Ownership of the display list is returned to the caller.
    """
    return _mupdf.ll_fz_new_display_list_from_page(page)

def ll_fz_new_display_list_from_page_contents(page):
    r"""
    Low-level wrapper for `::fz_new_display_list_from_page_contents()`.
    Create a display list from page contents (no annotations).

    Ownership of the display list is returned to the caller.
    """
    return _mupdf.ll_fz_new_display_list_from_page_contents(page)

def ll_fz_new_display_list_from_page_number(doc, number):
    r""" Low-level wrapper for `::fz_new_display_list_from_page_number()`."""
    return _mupdf.ll_fz_new_display_list_from_page_number(doc, number)

def ll_fz_new_display_list_from_svg(buf, base_uri, dir, w, h):
    r"""
     Low-level wrapper for `::fz_new_display_list_from_svg()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_fz_new_display_list_from_svg(::fz_buffer *buf, const char *base_uri, ::fz_archive *dir)` => `(fz_display_list *, float w, float h)`

    	Parse an SVG document into a display-list.
    """
    return _mupdf.ll_fz_new_display_list_from_svg(buf, base_uri, dir, w, h)

def ll_fz_new_display_list_from_svg_xml(xmldoc, xml, base_uri, dir, w, h):
    r"""
     Low-level wrapper for `::fz_new_display_list_from_svg_xml()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_fz_new_display_list_from_svg_xml(::fz_xml_doc *xmldoc, ::fz_xml *xml, const char *base_uri, ::fz_archive *dir)` => `(fz_display_list *, float w, float h)`

    	Parse an SVG document into a display-list.
    """
    return _mupdf.ll_fz_new_display_list_from_svg_xml(xmldoc, xml, base_uri, dir, w, h)

def ll_fz_new_document_of_size(size):
    r"""
    Low-level wrapper for `::fz_new_document_of_size()`.
    New documents are typically created by calls like
    foo_new_document(fz_context *ctx, ...). These work by
    deriving a new document type from fz_document, for instance:
    typedef struct { fz_document base; ...extras... } foo_document;
    These are allocated by calling
    fz_new_derived_document(ctx, foo_document)
    """
    return _mupdf.ll_fz_new_document_of_size(size)

def ll_fz_new_document_writer(path, format, options):
    r"""
    Low-level wrapper for `::fz_new_document_writer()`.
    Create a new fz_document_writer, for a
    file of the given type.

    path: The document name to write (or NULL for default)

    format: Which format to write (currently cbz, html, pdf, pam,
    pbm, pgm, pkm, png, ppm, pnm, svg, text, xhtml, docx, odt)

    options: NULL, or pointer to comma separated string to control
    file generation.
    """
    return _mupdf.ll_fz_new_document_writer(path, format, options)

def ll_fz_new_document_writer_of_size(size, begin_page, end_page, close, drop):
    r"""
    Low-level wrapper for `::fz_new_document_writer_of_size()`.
    Internal function to allocate a
    block for a derived document_writer structure, with the base
    structure's function pointers populated correctly, and the extra
    space zero initialised.
    """
    return _mupdf.ll_fz_new_document_writer_of_size(size, begin_page, end_page, close, drop)

def ll_fz_new_document_writer_with_buffer(buf, format, options):
    r""" Low-level wrapper for `::fz_new_document_writer_with_buffer()`."""
    return _mupdf.ll_fz_new_document_writer_with_buffer(buf, format, options)

def ll_fz_new_document_writer_with_output(out, format, options):
    r"""
    Low-level wrapper for `::fz_new_document_writer_with_output()`.
    Like fz_new_document_writer but takes a fz_output for writing
    the result. Only works for multi-page formats.
    """
    return _mupdf.ll_fz_new_document_writer_with_output(out, format, options)

def ll_fz_new_docx_writer(path, options):
    r""" Low-level wrapper for `::fz_new_docx_writer()`."""
    return _mupdf.ll_fz_new_docx_writer(path, options)

def ll_fz_new_docx_writer_with_output(out, options):
    r""" Low-level wrapper for `::fz_new_docx_writer_with_output()`."""
    return _mupdf.ll_fz_new_docx_writer_with_output(out, options)

def ll_fz_new_draw_device(transform, dest):
    r"""
    Low-level wrapper for `::fz_new_draw_device()`.
    Create a device to draw on a pixmap.

    dest: Target pixmap for the draw device. See fz_new_pixmap*
    for how to obtain a pixmap. The pixmap is not cleared by the
    draw device, see fz_clear_pixmap* for how to clear it prior to
    calling fz_new_draw_device. Free the device by calling
    fz_drop_device.

    transform: Transform from user space in points to device space
    in pixels.
    """
    return _mupdf.ll_fz_new_draw_device(transform, dest)

def ll_fz_new_draw_device_type3(transform, dest):
    r""" Low-level wrapper for `::fz_new_draw_device_type3()`."""
    return _mupdf.ll_fz_new_draw_device_type3(transform, dest)

def ll_fz_new_draw_device_with_bbox(transform, dest, clip):
    r"""
    Low-level wrapper for `::fz_new_draw_device_with_bbox()`.
    Create a device to draw on a pixmap.

    dest: Target pixmap for the draw device. See fz_new_pixmap*
    for how to obtain a pixmap. The pixmap is not cleared by the
    draw device, see fz_clear_pixmap* for how to clear it prior to
    calling fz_new_draw_device. Free the device by calling
    fz_drop_device.

    transform: Transform from user space in points to device space
    in pixels.

    clip: Bounding box to restrict any marking operations of the
    draw device.
    """
    return _mupdf.ll_fz_new_draw_device_with_bbox(transform, dest, clip)

def ll_fz_new_draw_device_with_bbox_proof(transform, dest, clip, cs):
    r"""
    Low-level wrapper for `::fz_new_draw_device_with_bbox_proof()`.
    Create a device to draw on a pixmap.

    dest: Target pixmap for the draw device. See fz_new_pixmap*
    for how to obtain a pixmap. The pixmap is not cleared by the
    draw device, see fz_clear_pixmap* for how to clear it prior to
    calling fz_new_draw_device. Free the device by calling
    fz_drop_device.

    transform: Transform from user space in points to device space
    in pixels.

    clip: Bounding box to restrict any marking operations of the
    draw device.

    proof_cs: Color space to render to prior to mapping to color
    space defined by pixmap.
    """
    return _mupdf.ll_fz_new_draw_device_with_bbox_proof(transform, dest, clip, cs)

def ll_fz_new_draw_device_with_options(options, mediabox, pixmap):
    r"""
     Low-level wrapper for `::fz_new_draw_device_with_options()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_fz_new_draw_device_with_options(const ::fz_draw_options *options, ::fz_rect mediabox, ::fz_pixmap **pixmap)` => `(fz_device *)`

    	Create a new pixmap and draw device, using the specified options.

    	options: Options to configure the draw device, and choose the
    	resolution and colorspace.

    	mediabox: The bounds of the page in points.

    	pixmap: An out parameter containing the newly created pixmap.
    """
    return _mupdf.ll_fz_new_draw_device_with_options(options, mediabox, pixmap)

def ll_fz_new_draw_device_with_proof(transform, dest, proof_cs):
    r"""
    Low-level wrapper for `::fz_new_draw_device_with_proof()`.
    Create a device to draw on a pixmap.

    dest: Target pixmap for the draw device. See fz_new_pixmap*
    for how to obtain a pixmap. The pixmap is not cleared by the
    draw device, see fz_clear_pixmap* for how to clear it prior to
    calling fz_new_draw_device. Free the device by calling
    fz_drop_device.

    transform: Transform from user space in points to device space
    in pixels.

    proof_cs: Intermediate color space to map though when mapping to
    color space defined by pixmap.
    """
    return _mupdf.ll_fz_new_draw_device_with_proof(transform, dest, proof_cs)

def ll_fz_new_font_from_buffer(name, buffer, index, use_glyph_bbox):
    r"""
    Low-level wrapper for `::fz_new_font_from_buffer()`.
    Create a new font from a font file in a fz_buffer.

    Fonts created in this way, will be eligible for embedding by default.

    name: Name of font (leave NULL to use name from font).

    buffer: Buffer to load from.

    index: Which font from the file to load (0 for default).

    use_glyph_box: 1 if we should use the glyph bbox, 0 otherwise.

    Returns new font handle, or throws exception on error.
    """
    return _mupdf.ll_fz_new_font_from_buffer(name, buffer, index, use_glyph_bbox)

def ll_fz_new_font_from_file(name, path, index, use_glyph_bbox):
    r"""
    Low-level wrapper for `::fz_new_font_from_file()`.
    Create a new font from a font file.

    Fonts created in this way, will be eligible for embedding by default.

    name: Name of font (leave NULL to use name from font).

    path: File path to load from.

    index: Which font from the file to load (0 for default).

    use_glyph_box: 1 if we should use the glyph bbox, 0 otherwise.

    Returns new font handle, or throws exception on error.
    """
    return _mupdf.ll_fz_new_font_from_file(name, path, index, use_glyph_bbox)

def ll_fz_new_font_from_memory(name, data, len, index, use_glyph_bbox):
    r"""
    Low-level wrapper for `::fz_new_font_from_memory()`.
    Create a new font from a font file in memory.

    Fonts created in this way, will be eligible for embedding by default.

    name: Name of font (leave NULL to use name from font).

    data: Pointer to the font file data.

    len: Length of the font file data.

    index: Which font from the file to load (0 for default).

    use_glyph_box: 1 if we should use the glyph bbox, 0 otherwise.

    Returns new font handle, or throws exception on error.
    """
    return _mupdf.ll_fz_new_font_from_memory(name, data, len, index, use_glyph_bbox)

def ll_fz_new_function_of_size(size, size2, m, n, eval, drop):
    r""" Low-level wrapper for `::fz_new_function_of_size()`."""
    return _mupdf.ll_fz_new_function_of_size(size, size2, m, n, eval, drop)

def ll_fz_new_hash_table(initialsize, keylen, lock, drop_val):
    r"""
    Low-level wrapper for `::fz_new_hash_table()`.
    Create a new hash table.

    initialsize: The initial size of the hashtable. The hashtable
    may grow (double in size) if it starts to get crowded (80%
    full).

    keylen: byte length for each key.

    lock: -1 for no lock, otherwise the FZ_LOCK to use to protect
    this table.

    drop_val: Function to use to destroy values on table drop.
    """
    return _mupdf.ll_fz_new_hash_table(initialsize, keylen, lock, drop_val)

def ll_fz_new_icc_colorspace(type, flags, name, buf):
    r"""
    Low-level wrapper for `::fz_new_icc_colorspace()`.
    Create a colorspace from an ICC profile supplied in buf.

    Limited checking is done to ensure that the colorspace type is
    appropriate for the supplied ICC profile.

    An additional reference is taken to buf, which will be dropped
    on destruction. Ownership is NOT passed in.

    The returned reference should be dropped when it is finished
    with.

    Colorspaces are immutable once created.
    """
    return _mupdf.ll_fz_new_icc_colorspace(type, flags, name, buf)

def ll_fz_new_image_from_buffer(buffer):
    r"""
    Low-level wrapper for `::fz_new_image_from_buffer()`.
    Create a new image from a
    buffer of data, inferring its type from the format
    of the data.
    """
    return _mupdf.ll_fz_new_image_from_buffer(buffer)

def ll_fz_new_image_from_compressed_buffer(w, h, bpc, colorspace, xres, yres, interpolate, imagemask, decode, colorkey, buffer, mask):
    r"""
    Low-level wrapper for `::fz_new_image_from_compressed_buffer()`.
    Create an image based on
    the data in the supplied compressed buffer.

    w,h: Width and height of the created image.

    bpc: Bits per component.

    colorspace: The colorspace (determines the number of components,
    and any color conversions required while decoding).

    xres, yres: The X and Y resolutions respectively.

    interpolate: 1 if interpolation should be used when decoding
    this image, 0 otherwise.

    imagemask: 1 if this is an imagemask (i.e. transparency bitmap
    mask), 0 otherwise.

    decode: NULL, or a pointer to to a decode array. The default
    decode array is [0 1] (repeated n times, for n color components).

    colorkey: NULL, or a pointer to a colorkey array. The default
    colorkey array is [0 255] (repeated n times, for n color
    components).

    buffer: Buffer of compressed data and compression parameters.
    Ownership of this reference is passed in.

    mask: NULL, or another image to use as a mask for this one.
    A new reference is taken to this image. Supplying a masked
    image as a mask to another image is illegal!
    """
    return _mupdf.ll_fz_new_image_from_compressed_buffer(w, h, bpc, colorspace, xres, yres, interpolate, imagemask, decode, colorkey, buffer, mask)

def ll_fz_new_image_from_compressed_buffer2(w, h, bpc, colorspace, xres, yres, interpolate, imagemask, decode, colorkey, buffer, mask):
    r"""
     Low-level wrapper for `::fz_new_image_from_compressed_buffer2()`.  Swig-friendly wrapper for fz_new_image_from_compressed_buffer(),
    uses specified `decode` and `colorkey` if they are not null (in which
    case we assert that they have size `2*fz_colorspace_n(colorspace)`).
    """
    return _mupdf.ll_fz_new_image_from_compressed_buffer2(w, h, bpc, colorspace, xres, yres, interpolate, imagemask, decode, colorkey, buffer, mask)

def ll_fz_new_image_from_display_list(w, h, list):
    r"""
    Low-level wrapper for `::fz_new_image_from_display_list()`.
    Create a new image from a display list.

    w, h: The conceptual width/height of the image.

    transform: The matrix that needs to be applied to the given
    list to make it render to the unit square.

    list: The display list.
    """
    return _mupdf.ll_fz_new_image_from_display_list(w, h, list)

def ll_fz_new_image_from_file(path):
    r"""
    Low-level wrapper for `::fz_new_image_from_file()`.
    Create a new image from the contents
    of a file, inferring its type from the format of the
    data.
    """
    return _mupdf.ll_fz_new_image_from_file(path)

def ll_fz_new_image_from_pixmap(pixmap, mask):
    r"""
    Low-level wrapper for `::fz_new_image_from_pixmap()`.
    Create an image from the given
    pixmap.

    pixmap: The pixmap to base the image upon. A new reference
    to this is taken.

    mask: NULL, or another image to use as a mask for this one.
    A new reference is taken to this image. Supplying a masked
    image as a mask to another image is illegal!
    """
    return _mupdf.ll_fz_new_image_from_pixmap(pixmap, mask)

def ll_fz_new_image_from_svg(buf, base_uri, dir):
    r"""
    Low-level wrapper for `::fz_new_image_from_svg()`.
    Create a scalable image from an SVG document.
    """
    return _mupdf.ll_fz_new_image_from_svg(buf, base_uri, dir)

def ll_fz_new_image_from_svg_xml(xmldoc, xml, base_uri, dir):
    r"""
    Low-level wrapper for `::fz_new_image_from_svg_xml()`.
    Create a scalable image from an SVG document.
    """
    return _mupdf.ll_fz_new_image_from_svg_xml(xmldoc, xml, base_uri, dir)

def ll_fz_new_image_of_size(w, h, bpc, colorspace, xres, yres, interpolate, imagemask, decode, colorkey, mask, size, get_pixmap, get_size, drop):
    r"""
    Low-level wrapper for `::fz_new_image_of_size()`.
    Internal function to make a new fz_image structure
    for a derived class.

    w,h: Width and height of the created image.

    bpc: Bits per component.

    colorspace: The colorspace (determines the number of components,
    and any color conversions required while decoding).

    xres, yres: The X and Y resolutions respectively.

    interpolate: 1 if interpolation should be used when decoding
    this image, 0 otherwise.

    imagemask: 1 if this is an imagemask (i.e. transparent), 0
    otherwise.

    decode: NULL, or a pointer to to a decode array. The default
    decode array is [0 1] (repeated n times, for n color components).

    colorkey: NULL, or a pointer to a colorkey array. The default
    colorkey array is [0 255] (repeated n times, for n color
    components).

    mask: NULL, or another image to use as a mask for this one.
    A new reference is taken to this image. Supplying a masked
    image as a mask to another image is illegal!

    size: The size of the required allocated structure (the size of
    the derived structure).

    get: The function to be called to obtain a decoded pixmap.

    get_size: The function to be called to return the storage size
    used by this image.

    drop: The function to be called to dispose of this image once
    the last reference is dropped.

    Returns a pointer to an allocated structure of the required size,
    with the first sizeof(fz_image) bytes initialised as appropriate
    given the supplied parameters, and the other bytes set to zero.
    """
    return _mupdf.ll_fz_new_image_of_size(w, h, bpc, colorspace, xres, yres, interpolate, imagemask, decode, colorkey, mask, size, get_pixmap, get_size, drop)

def ll_fz_new_indexed_colorspace(base, high, lookup):
    r"""
    Low-level wrapper for `::fz_new_indexed_colorspace()`.
    Create an indexed colorspace.

    The supplied lookup table is high palette entries long. Each
    entry is n bytes long, where n is given by the number of
    colorants in the base colorspace, one byte per colorant.

    Ownership of lookup is passed it; it will be freed on
    destruction, so must be heap allocated.

    The colorspace will keep an additional reference to the base
    colorspace that will be dropped on destruction.

    The returned reference should be dropped when it is finished
    with.

    Colorspaces are immutable once created.
    """
    return _mupdf.ll_fz_new_indexed_colorspace(base, high, lookup)

def ll_fz_new_jpeg_pixmap_writer(path, options):
    r""" Low-level wrapper for `::fz_new_jpeg_pixmap_writer()`."""
    return _mupdf.ll_fz_new_jpeg_pixmap_writer(path, options)

def ll_fz_new_layout():
    r"""
    Low-level wrapper for `::fz_new_layout()`.
    Create a new layout block, with new allocation pool, zero
    matrices, and initialise linked pointers.
    """
    return _mupdf.ll_fz_new_layout()

def ll_fz_new_link_of_size(size, rect, uri):
    r"""
    Low-level wrapper for `::fz_new_link_of_size()`.
    Create a new link record.

    next is set to NULL with the expectation that the caller will
    handle the linked list setup. Internal function.

    Different document types will be implemented by deriving from
    fz_link. This macro allocates such derived structures, and
    initialises the base sections.
    """
    return _mupdf.ll_fz_new_link_of_size(size, rect, uri)

def ll_fz_new_list_device(list):
    r"""
    Low-level wrapper for `::fz_new_list_device()`.
    Create a rendering device for a display list.

    When the device is rendering a page it will populate the
    display list with drawing commands (text, images, etc.). The
    display list can later be reused to render a page many times
    without having to re-interpret the page from the document file
    for each rendering. Once the device is no longer needed, free
    it with fz_drop_device.

    list: A display list that the list device takes a reference to.
    """
    return _mupdf.ll_fz_new_list_device(list)

def ll_fz_new_log_for_module(module):
    r"""
    Low-level wrapper for `::fz_new_log_for_module()`.
    Internal function to actually do the opening of the logfile.

    Caller should close/drop the output when finished with it.
    """
    return _mupdf.ll_fz_new_log_for_module(module)

def ll_fz_new_mono_pcl_band_writer(out, options):
    r"""
    Low-level wrapper for `::fz_new_mono_pcl_band_writer()`.
    Create a new band writer, outputing monochrome pcl.
    """
    return _mupdf.ll_fz_new_mono_pcl_band_writer(out, options)

def ll_fz_new_mono_pwg_band_writer(out, pwg):
    r"""
    Low-level wrapper for `::fz_new_mono_pwg_band_writer()`.
    Create a new monochrome pwg band writer.
    """
    return _mupdf.ll_fz_new_mono_pwg_band_writer(out, pwg)

def ll_fz_new_multi_archive():
    r"""
    Low-level wrapper for `::fz_new_multi_archive()`.
    Create a new multi archive (initially empty).
    """
    return _mupdf.ll_fz_new_multi_archive()

def ll_fz_new_ocr_device(target, ctm, mediabox, with_list, language, datadir, progress, progress_arg):
    r"""
    Low-level wrapper for `::fz_new_ocr_device()`.
    Create a device to OCR the text on the page.

    Renders the page internally to a bitmap that is then OCRd. Text
    is then forwarded onto the target device.

    target: The target device to receive the OCRd text.

    ctm: The transform to apply to the mediabox to get the size for
    the rendered page image. Also used to calculate the resolution
    for the page image. In general, this will be the same as the CTM
    that you pass to fz_run_page (or fz_run_display_list) to feed
    this device.

    mediabox: The mediabox (in points). Combined with the CTM to get
    the bounds of the pixmap used internally for the rendered page
    image.

    with_list: If with_list is false, then all non-text operations
    are forwarded instantly to the target device. This results in
    the target device seeing all NON-text operations, followed by
    all the text operations (derived from OCR).

    If with_list is true, then all the marking operations are
    collated into a display list which is then replayed to the
    target device at the end.

    language: NULL (for "eng"), or a pointer to a string to describe
    the languages/scripts that should be used for OCR (e.g.
    "eng,ara").

    datadir: NULL (for ""), or a pointer to a path string otherwise
    provided to Tesseract in the TESSDATA_PREFIX environment variable.

    progress: NULL, or function to be called periodically to indicate
    progress. Return 0 to continue, or 1 to cancel. progress_arg is
    returned as the void *. The int is a value between 0 and 100 to
    indicate progress.

    progress_arg: A void * value to be parrotted back to the progress
    function.
    """
    return _mupdf.ll_fz_new_ocr_device(target, ctm, mediabox, with_list, language, datadir, progress, progress_arg)

def ll_fz_new_odt_writer(path, options):
    r""" Low-level wrapper for `::fz_new_odt_writer()`."""
    return _mupdf.ll_fz_new_odt_writer(path, options)

def ll_fz_new_odt_writer_with_output(out, options):
    r""" Low-level wrapper for `::fz_new_odt_writer_with_output()`."""
    return _mupdf.ll_fz_new_odt_writer_with_output(out, options)

def ll_fz_new_outline():
    r"""
    Low-level wrapper for `::fz_new_outline()`.
    Create a new outline entry with zeroed fields for the caller
    to fill in.
    """
    return _mupdf.ll_fz_new_outline()

def ll_fz_new_outline_iterator(doc):
    r"""
    Low-level wrapper for `::fz_new_outline_iterator()`.
    Get an iterator for the document outline.

    Should be freed by fz_drop_outline_iterator.
    """
    return _mupdf.ll_fz_new_outline_iterator(doc)

def ll_fz_new_outline_iterator_of_size(size, doc):
    r""" Low-level wrapper for `::fz_new_outline_iterator_of_size()`."""
    return _mupdf.ll_fz_new_outline_iterator_of_size(size, doc)

def ll_fz_new_output(bufsiz, state, write, close, drop):
    r"""
    Low-level wrapper for `::fz_new_output()`.
    Create a new output object with the given
    internal state and function pointers.

    state: Internal state (opaque to everything but implementation).

    write: Function to output a given buffer.

    close: Cleanup function to destroy state when output closed.
    May permissibly be null.
    """
    return _mupdf.ll_fz_new_output(bufsiz, state, write, close, drop)

def ll_fz_new_output_with_buffer(buf):
    r"""
    Low-level wrapper for `::fz_new_output_with_buffer()`.
    Open an output stream that appends
    to a buffer.

    buf: The buffer to append to.
    """
    return _mupdf.ll_fz_new_output_with_buffer(buf)

def ll_fz_new_output_with_path(filename, append):
    r"""
    Low-level wrapper for `::fz_new_output_with_path()`.
    Open an output stream that writes to a
    given path.

    filename: The filename to write to (specified in UTF-8).

    append: non-zero if we should append to the file, rather than
    overwriting it.
    """
    return _mupdf.ll_fz_new_output_with_path(filename, append)

def ll_fz_new_page_of_size(size, doc):
    r"""
    Low-level wrapper for `::fz_new_page_of_size()`.
    Different document types will be implemented by deriving from
    fz_page. This macro allocates such derived structures, and
    initialises the base sections.
    """
    return _mupdf.ll_fz_new_page_of_size(size, doc)

def ll_fz_new_pam_band_writer(out):
    r"""
    Low-level wrapper for `::fz_new_pam_band_writer()`.
    Create a band writer targetting pnm (greyscale, rgb or cmyk,
    with or without alpha).
    """
    return _mupdf.ll_fz_new_pam_band_writer(out)

def ll_fz_new_pam_pixmap_writer(path, options):
    r""" Low-level wrapper for `::fz_new_pam_pixmap_writer()`."""
    return _mupdf.ll_fz_new_pam_pixmap_writer(path, options)

def ll_fz_new_path():
    r"""
    Low-level wrapper for `::fz_new_path()`.
    Create a new (empty) path structure.
    """
    return _mupdf.ll_fz_new_path()

def ll_fz_new_pbm_band_writer(out):
    r"""
    Low-level wrapper for `::fz_new_pbm_band_writer()`.
    Create a new band writer, targetting pbm.
    """
    return _mupdf.ll_fz_new_pbm_band_writer(out)

def ll_fz_new_pbm_pixmap_writer(path, options):
    r""" Low-level wrapper for `::fz_new_pbm_pixmap_writer()`."""
    return _mupdf.ll_fz_new_pbm_pixmap_writer(path, options)

def ll_fz_new_pcl_writer(path, options):
    r""" Low-level wrapper for `::fz_new_pcl_writer()`."""
    return _mupdf.ll_fz_new_pcl_writer(path, options)

def ll_fz_new_pcl_writer_with_output(out, options):
    r""" Low-level wrapper for `::fz_new_pcl_writer_with_output()`."""
    return _mupdf.ll_fz_new_pcl_writer_with_output(out, options)

def ll_fz_new_pclm_band_writer(out, options):
    r"""
    Low-level wrapper for `::fz_new_pclm_band_writer()`.
    Create a new band writer, outputing pclm
    """
    return _mupdf.ll_fz_new_pclm_band_writer(out, options)

def ll_fz_new_pclm_writer(path, options):
    r""" Low-level wrapper for `::fz_new_pclm_writer()`."""
    return _mupdf.ll_fz_new_pclm_writer(path, options)

def ll_fz_new_pclm_writer_with_output(out, options):
    r""" Low-level wrapper for `::fz_new_pclm_writer_with_output()`."""
    return _mupdf.ll_fz_new_pclm_writer_with_output(out, options)

def ll_fz_new_pdf_writer(path, options):
    r"""
    Low-level wrapper for `::fz_new_pdf_writer()`.
    Document writers for various possible output formats.

    All of the "_with_output" variants pass the ownership of out in
    immediately upon calling. The writers are responsible for
    dropping the fz_output when they are finished with it (even
    if they throw an exception during creation).
    """
    return _mupdf.ll_fz_new_pdf_writer(path, options)

def ll_fz_new_pdf_writer_with_output(out, options):
    r""" Low-level wrapper for `::fz_new_pdf_writer_with_output()`."""
    return _mupdf.ll_fz_new_pdf_writer_with_output(out, options)

def ll_fz_new_pdfocr_band_writer(out, options):
    r"""
    Low-level wrapper for `::fz_new_pdfocr_band_writer()`.
    Create a new band writer, outputing pdfocr.

    Ownership of output stays with the caller, the band writer
    borrows the reference. The caller must keep the output around
    for the duration of the band writer, and then close/drop as
    appropriate.
    """
    return _mupdf.ll_fz_new_pdfocr_band_writer(out, options)

def ll_fz_new_pdfocr_writer(path, options):
    r""" Low-level wrapper for `::fz_new_pdfocr_writer()`."""
    return _mupdf.ll_fz_new_pdfocr_writer(path, options)

def ll_fz_new_pdfocr_writer_with_output(out, options):
    r""" Low-level wrapper for `::fz_new_pdfocr_writer_with_output()`."""
    return _mupdf.ll_fz_new_pdfocr_writer_with_output(out, options)

def ll_fz_new_pgm_pixmap_writer(path, options):
    r""" Low-level wrapper for `::fz_new_pgm_pixmap_writer()`."""
    return _mupdf.ll_fz_new_pgm_pixmap_writer(path, options)

def ll_fz_new_pixmap(cs, w, h, seps, alpha):
    r"""
    Low-level wrapper for `::fz_new_pixmap()`.
    Create a new pixmap, with its origin at (0,0)

    cs: The colorspace to use for the pixmap, or NULL for an alpha
    plane/mask.

    w: The width of the pixmap (in pixels)

    h: The height of the pixmap (in pixels)

    seps: Details of separations.

    alpha: 0 for no alpha, 1 for alpha.

    Returns a pointer to the new pixmap. Throws exception on failure
    to allocate.
    """
    return _mupdf.ll_fz_new_pixmap(cs, w, h, seps, alpha)

def ll_fz_new_pixmap_from_alpha_channel(src):
    r""" Low-level wrapper for `::fz_new_pixmap_from_alpha_channel()`."""
    return _mupdf.ll_fz_new_pixmap_from_alpha_channel(src)

def ll_fz_new_pixmap_from_color_and_mask(color, mask):
    r""" Low-level wrapper for `::fz_new_pixmap_from_color_and_mask()`."""
    return _mupdf.ll_fz_new_pixmap_from_color_and_mask(color, mask)

def ll_fz_new_pixmap_from_display_list(list, ctm, cs, alpha):
    r"""
    Low-level wrapper for `::fz_new_pixmap_from_display_list()`.
    Render the page to a pixmap using the transform and colorspace.

    Ownership of the pixmap is returned to the caller.
    """
    return _mupdf.ll_fz_new_pixmap_from_display_list(list, ctm, cs, alpha)

def ll_fz_new_pixmap_from_display_list_with_separations(list, ctm, cs, seps, alpha):
    r"""
    Low-level wrapper for `::fz_new_pixmap_from_display_list_with_separations()`.
    Render the page contents with control over spot colors.

    Ownership of the pixmap is returned to the caller.
    """
    return _mupdf.ll_fz_new_pixmap_from_display_list_with_separations(list, ctm, cs, seps, alpha)

def ll_fz_new_pixmap_from_page(page, ctm, cs, alpha):
    r""" Low-level wrapper for `::fz_new_pixmap_from_page()`."""
    return _mupdf.ll_fz_new_pixmap_from_page(page, ctm, cs, alpha)

def ll_fz_new_pixmap_from_page_contents(page, ctm, cs, alpha):
    r"""
    Low-level wrapper for `::fz_new_pixmap_from_page_contents()`.
    Render the page contents without annotations.

    Ownership of the pixmap is returned to the caller.
    """
    return _mupdf.ll_fz_new_pixmap_from_page_contents(page, ctm, cs, alpha)

def ll_fz_new_pixmap_from_page_contents_with_separations(page, ctm, cs, seps, alpha):
    r""" Low-level wrapper for `::fz_new_pixmap_from_page_contents_with_separations()`."""
    return _mupdf.ll_fz_new_pixmap_from_page_contents_with_separations(page, ctm, cs, seps, alpha)

def ll_fz_new_pixmap_from_page_number(doc, number, ctm, cs, alpha):
    r""" Low-level wrapper for `::fz_new_pixmap_from_page_number()`."""
    return _mupdf.ll_fz_new_pixmap_from_page_number(doc, number, ctm, cs, alpha)

def ll_fz_new_pixmap_from_page_number_with_separations(doc, number, ctm, cs, seps, alpha):
    r""" Low-level wrapper for `::fz_new_pixmap_from_page_number_with_separations()`."""
    return _mupdf.ll_fz_new_pixmap_from_page_number_with_separations(doc, number, ctm, cs, seps, alpha)

def ll_fz_new_pixmap_from_page_with_separations(page, ctm, cs, seps, alpha):
    r""" Low-level wrapper for `::fz_new_pixmap_from_page_with_separations()`."""
    return _mupdf.ll_fz_new_pixmap_from_page_with_separations(page, ctm, cs, seps, alpha)

def ll_fz_new_pixmap_from_pixmap(pixmap, rect):
    r"""
    Low-level wrapper for `::fz_new_pixmap_from_pixmap()`.
    Create a new pixmap that represents a subarea of the specified
    pixmap. A reference is taken to this pixmap that will be dropped
    on destruction.

    The supplied rectangle must be wholly contained within the
    original pixmap.

    Returns a pointer to the new pixmap. Throws exception on failure
    to allocate.
    """
    return _mupdf.ll_fz_new_pixmap_from_pixmap(pixmap, rect)

def ll_fz_new_pixmap_with_bbox(colorspace, bbox, seps, alpha):
    r"""
    Low-level wrapper for `::fz_new_pixmap_with_bbox()`.
    Create a pixmap of a given size, location and pixel format.

    The bounding box specifies the size of the created pixmap and
    where it will be located. The colorspace determines the number
    of components per pixel. Alpha is always present. Pixmaps are
    reference counted, so drop references using fz_drop_pixmap.

    colorspace: Colorspace format used for the created pixmap. The
    pixmap will keep a reference to the colorspace.

    bbox: Bounding box specifying location/size of created pixmap.

    seps: Details of separations.

    alpha: 0 for no alpha, 1 for alpha.

    Returns a pointer to the new pixmap. Throws exception on failure
    to allocate.
    """
    return _mupdf.ll_fz_new_pixmap_with_bbox(colorspace, bbox, seps, alpha)

def ll_fz_new_pixmap_with_bbox_and_data(colorspace, rect, seps, alpha, samples):
    r"""
    Low-level wrapper for `::fz_new_pixmap_with_bbox_and_data()`.
    Create a pixmap of a given size, location and pixel format,
    using the supplied data block.

    The bounding box specifies the size of the created pixmap and
    where it will be located. The colorspace determines the number
    of components per pixel. Alpha is always present. Pixmaps are
    reference counted, so drop references using fz_drop_pixmap.

    colorspace: Colorspace format used for the created pixmap. The
    pixmap will keep a reference to the colorspace.

    rect: Bounding box specifying location/size of created pixmap.

    seps: Details of separations.

    alpha: Number of alpha planes (0 or 1).

    samples: The data block to keep the samples in.

    Returns a pointer to the new pixmap. Throws exception on failure
    to allocate.
    """
    return _mupdf.ll_fz_new_pixmap_with_bbox_and_data(colorspace, rect, seps, alpha, samples)

def ll_fz_new_pixmap_with_data(colorspace, w, h, seps, alpha, stride, samples):
    r"""
    Low-level wrapper for `::fz_new_pixmap_with_data()`.
    Create a new pixmap, with its origin at
    (0,0) using the supplied data block.

    cs: The colorspace to use for the pixmap, or NULL for an alpha
    plane/mask.

    w: The width of the pixmap (in pixels)

    h: The height of the pixmap (in pixels)

    seps: Details of separations.

    alpha: 0 for no alpha, 1 for alpha.

    stride: The byte offset from the pixel data in a row to the
    pixel data in the next row.

    samples: The data block to keep the samples in.

    Returns a pointer to the new pixmap. Throws exception on failure to
    allocate.
    """
    return _mupdf.ll_fz_new_pixmap_with_data(colorspace, w, h, seps, alpha, stride, samples)

def ll_fz_new_pixmap_writer(path, options, default_path, n, save):
    r""" Low-level wrapper for `::fz_new_pixmap_writer()`."""
    return _mupdf.ll_fz_new_pixmap_writer(path, options, default_path, n, save)

def ll_fz_new_pkm_band_writer(out):
    r"""
    Low-level wrapper for `::fz_new_pkm_band_writer()`.
    Create a new pkm band writer for CMYK pixmaps.
    """
    return _mupdf.ll_fz_new_pkm_band_writer(out)

def ll_fz_new_pkm_pixmap_writer(path, options):
    r""" Low-level wrapper for `::fz_new_pkm_pixmap_writer()`."""
    return _mupdf.ll_fz_new_pkm_pixmap_writer(path, options)

def ll_fz_new_png_band_writer(out):
    r"""
    Low-level wrapper for `::fz_new_png_band_writer()`.
    Create a new png band writer (greyscale or RGB, with or without
    alpha).
    """
    return _mupdf.ll_fz_new_png_band_writer(out)

def ll_fz_new_png_pixmap_writer(path, options):
    r""" Low-level wrapper for `::fz_new_png_pixmap_writer()`."""
    return _mupdf.ll_fz_new_png_pixmap_writer(path, options)

def ll_fz_new_pnm_band_writer(out):
    r"""
    Low-level wrapper for `::fz_new_pnm_band_writer()`.
    Create a band writer targetting pnm (greyscale or rgb, no
    alpha).
    """
    return _mupdf.ll_fz_new_pnm_band_writer(out)

def ll_fz_new_pnm_pixmap_writer(path, options):
    r""" Low-level wrapper for `::fz_new_pnm_pixmap_writer()`."""
    return _mupdf.ll_fz_new_pnm_pixmap_writer(path, options)

def ll_fz_new_pool():
    r"""
    Low-level wrapper for `::fz_new_pool()`.
    Create a new pool to allocate from.
    """
    return _mupdf.ll_fz_new_pool()

def ll_fz_new_ppm_pixmap_writer(path, options):
    r""" Low-level wrapper for `::fz_new_ppm_pixmap_writer()`."""
    return _mupdf.ll_fz_new_ppm_pixmap_writer(path, options)

def ll_fz_new_ps_band_writer(out):
    r"""
    Low-level wrapper for `::fz_new_ps_band_writer()`.
    Create a postscript band writer for gray, rgb, or cmyk, no
    alpha.
    """
    return _mupdf.ll_fz_new_ps_band_writer(out)

def ll_fz_new_ps_writer(path, options):
    r""" Low-level wrapper for `::fz_new_ps_writer()`."""
    return _mupdf.ll_fz_new_ps_writer(path, options)

def ll_fz_new_ps_writer_with_output(out, options):
    r""" Low-level wrapper for `::fz_new_ps_writer_with_output()`."""
    return _mupdf.ll_fz_new_ps_writer_with_output(out, options)

def ll_fz_new_psd_band_writer(out):
    r"""
    Low-level wrapper for `::fz_new_psd_band_writer()`.
    Open a PSD band writer.
    """
    return _mupdf.ll_fz_new_psd_band_writer(out)

def ll_fz_new_pwg_band_writer(out, pwg):
    r"""
    Low-level wrapper for `::fz_new_pwg_band_writer()`.
    Create a new color pwg band writer.
    """
    return _mupdf.ll_fz_new_pwg_band_writer(out, pwg)

def ll_fz_new_pwg_writer(path, options):
    r""" Low-level wrapper for `::fz_new_pwg_writer()`."""
    return _mupdf.ll_fz_new_pwg_writer(path, options)

def ll_fz_new_pwg_writer_with_output(out, options):
    r""" Low-level wrapper for `::fz_new_pwg_writer_with_output()`."""
    return _mupdf.ll_fz_new_pwg_writer_with_output(out, options)

def ll_fz_new_rle_output(chain):
    r""" Low-level wrapper for `::fz_new_rle_output()`."""
    return _mupdf.ll_fz_new_rle_output(chain)

def ll_fz_new_separations(controllable):
    r"""
    Low-level wrapper for `::fz_new_separations()`.
    Create a new separations structure (initially empty)
    """
    return _mupdf.ll_fz_new_separations(controllable)

def ll_fz_new_stext_device(page, options):
    r"""
    Low-level wrapper for `::fz_new_stext_device()`.
    Create a device to extract the text on a page.

    Gather the text on a page into blocks and lines.

    The reading order is taken from the order the text is drawn in
    the source file, so may not be accurate.

    page: The text page to which content should be added. This will
    usually be a newly created (empty) text page, but it can be one
    containing data already (for example when merging multiple
    pages, or watermarking).

    options: Options to configure the stext device.
    """
    return _mupdf.ll_fz_new_stext_device(page, options)

def ll_fz_new_stext_page(mediabox):
    r"""
    Low-level wrapper for `::fz_new_stext_page()`.
    Create an empty text page.

    The text page is filled out by the text device to contain the
    blocks and lines of text on the page.

    mediabox: optional mediabox information.
    """
    return _mupdf.ll_fz_new_stext_page(mediabox)

def ll_fz_new_stext_page_from_chapter_page_number(doc, chapter, number, options):
    r""" Low-level wrapper for `::fz_new_stext_page_from_chapter_page_number()`."""
    return _mupdf.ll_fz_new_stext_page_from_chapter_page_number(doc, chapter, number, options)

def ll_fz_new_stext_page_from_display_list(list, options):
    r""" Low-level wrapper for `::fz_new_stext_page_from_display_list()`."""
    return _mupdf.ll_fz_new_stext_page_from_display_list(list, options)

def ll_fz_new_stext_page_from_page(page, options):
    r"""
    Low-level wrapper for `::fz_new_stext_page_from_page()`.
    Extract text from page.

    Ownership of the fz_stext_page is returned to the caller.
    """
    return _mupdf.ll_fz_new_stext_page_from_page(page, options)

def ll_fz_new_stext_page_from_page_number(doc, number, options):
    r""" Low-level wrapper for `::fz_new_stext_page_from_page_number()`."""
    return _mupdf.ll_fz_new_stext_page_from_page_number(doc, number, options)

def ll_fz_new_store_context(max):
    r"""
    Low-level wrapper for `::fz_new_store_context()`.
    Create a new store inside the context

    max: The maximum size (in bytes) that the store is allowed to
    grow to. FZ_STORE_UNLIMITED means no limit.
    """
    return _mupdf.ll_fz_new_store_context(max)

def ll_fz_new_story(buf, user_css, em, dir):
    r""" Low-level wrapper for `::fz_new_story()`."""
    return _mupdf.ll_fz_new_story(buf, user_css, em, dir)

def ll_fz_new_stream(state, next, drop):
    r"""
    Low-level wrapper for `::fz_new_stream()`.
    Create a new stream object with the given
    internal state and function pointers.

    state: Internal state (opaque to everything but implementation).

    next: Should provide the next set of bytes (up to max) of stream
    data. Return the number of bytes read, or EOF when there is no
    more data.

    drop: Should clean up and free the internal state. May not
    throw exceptions.
    """
    return _mupdf.ll_fz_new_stream(state, next, drop)

def ll_fz_new_string(str):
    r""" Low-level wrapper for `::fz_new_string()`."""
    return _mupdf.ll_fz_new_string(str)

def ll_fz_new_stroke_state():
    r"""
    Low-level wrapper for `::fz_new_stroke_state()`.
    Create a new (empty) stroke state structure (with no dash
    data) and return a reference to it.

    Throws exception on failure to allocate.
    """
    return _mupdf.ll_fz_new_stroke_state()

def ll_fz_new_stroke_state_with_dash_len(len):
    r"""
    Low-level wrapper for `::fz_new_stroke_state_with_dash_len()`.
    Create a new (empty) stroke state structure, with room for
    dash data of the given length, and return a reference to it.

    len: The number of dash elements to allow room for.

    Throws exception on failure to allocate.
    """
    return _mupdf.ll_fz_new_stroke_state_with_dash_len(len)

def ll_fz_new_svg_device(out, page_width, page_height, text_format, reuse_images):
    r"""
    Low-level wrapper for `::fz_new_svg_device()`.
    Create a device that outputs (single page) SVG files to
    the given output stream.

    Equivalent to fz_new_svg_device_with_id passing id = NULL.
    """
    return _mupdf.ll_fz_new_svg_device(out, page_width, page_height, text_format, reuse_images)

def ll_fz_new_svg_device_with_id(out, page_width, page_height, text_format, reuse_images, id):
    r"""
     Low-level wrapper for `::fz_new_svg_device_with_id()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_fz_new_svg_device_with_id(::fz_output *out, float page_width, float page_height, int text_format, int reuse_images)` => `(fz_device *, int id)`

    	Create a device that outputs (single page) SVG files to
    	the given output stream.

    	output: The output stream to send the constructed SVG page to.

    	page_width, page_height: The page dimensions to use (in points).

    	text_format: How to emit text. One of the following values:
    		FZ_SVG_TEXT_AS_TEXT: As <text> elements with possible
    		layout errors and mismatching fonts.
    		FZ_SVG_TEXT_AS_PATH: As <path> elements with exact
    		visual appearance.

    	reuse_images: Share image resources using <symbol> definitions.

    	id: ID parameter to keep generated IDs unique across SVG files.
    """
    return _mupdf.ll_fz_new_svg_device_with_id(out, page_width, page_height, text_format, reuse_images, id)

def ll_fz_new_svg_writer(path, options):
    r""" Low-level wrapper for `::fz_new_svg_writer()`."""
    return _mupdf.ll_fz_new_svg_writer(path, options)

def ll_fz_new_test_device(is_color, threshold, options, passthrough):
    r"""
     Low-level wrapper for `::fz_new_test_device()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_fz_new_test_device(float threshold, int options, ::fz_device *passthrough)` => `(fz_device *, int is_color)`

    	Create a device to test for features.

    	Currently only tests for the presence of non-grayscale colors.

    	is_color: Possible values returned:
    		0: Definitely greyscale
    		1: Probably color (all colors were grey, but there
    		were images or shadings in a non grey colorspace).
    		2: Definitely color

    	threshold: The difference from grayscale that will be tolerated.
    	Typical values to use are either 0 (be exact) and 0.02 (allow an
    	imperceptible amount of slop).

    	options: A set of bitfield options, from the FZ_TEST_OPT set.

    	passthrough: A device to pass all calls through to, or NULL.
    	If set, then the test device can both test and pass through to
    	an underlying device (like, say, the display list device). This
    	means that a display list can be created and at the end we'll
    	know if it's colored or not.

    	In the absence of a passthrough device, the device will throw
    	an exception to stop page interpretation when color is found.
    """
    return _mupdf.ll_fz_new_test_device(is_color, threshold, options, passthrough)

def ll_fz_new_text():
    r"""
    Low-level wrapper for `::fz_new_text()`.
    Create a new empty fz_text object.

    Throws exception on failure to allocate.
    """
    return _mupdf.ll_fz_new_text()

def ll_fz_new_text_writer(format, path, options):
    r""" Low-level wrapper for `::fz_new_text_writer()`."""
    return _mupdf.ll_fz_new_text_writer(format, path, options)

def ll_fz_new_text_writer_with_output(format, out, options):
    r""" Low-level wrapper for `::fz_new_text_writer_with_output()`."""
    return _mupdf.ll_fz_new_text_writer_with_output(format, out, options)

def ll_fz_new_trace_device(out):
    r"""
    Low-level wrapper for `::fz_new_trace_device()`.
    Create a device to print a debug trace of all device calls.
    """
    return _mupdf.ll_fz_new_trace_device(out)

def ll_fz_new_tree_archive(tree):
    r"""
    Low-level wrapper for `::fz_new_tree_archive()`.
    Create an archive that holds named buffers.

    tree can either be a preformed tree with fz_buffers as values,
    or it can be NULL for an empty tree.
    """
    return _mupdf.ll_fz_new_tree_archive(tree)

def ll_fz_new_type3_font(name, matrix):
    r"""
    Low-level wrapper for `::fz_new_type3_font()`.
    Create a new (empty) type3 font.

    name: Name of font (or NULL).

    matrix: Font matrix.

    Returns a new font handle, or throws exception on
    allocation failure.
    """
    return _mupdf.ll_fz_new_type3_font(name, matrix)

def ll_fz_new_xhtml_document_from_document(old_doc, opts):
    r"""
    Low-level wrapper for `::fz_new_xhtml_document_from_document()`.
    Use text extraction to convert the input document into XHTML,
    then open the result as a new document that can be reflowed.
    """
    return _mupdf.ll_fz_new_xhtml_document_from_document(old_doc, opts)

def ll_fz_new_xmltext_device(out):
    r"""
    Low-level wrapper for `::fz_new_xmltext_device()`.
    Create a device to output raw information.
    """
    return _mupdf.ll_fz_new_xmltext_device(out)

def ll_fz_new_zip_writer(filename):
    r"""
    Low-level wrapper for `::fz_new_zip_writer()`.
    Create a new zip writer that writes to a given file.

    Open an archive using a seekable stream object rather than
    opening a file or directory on disk.
    """
    return _mupdf.ll_fz_new_zip_writer(filename)

def ll_fz_new_zip_writer_with_output(out):
    r"""
    Low-level wrapper for `::fz_new_zip_writer_with_output()`.
    Create a new zip writer that writes to a given output stream.

    Ownership of out passes in immediately upon calling this function.
    The caller should never drop the fz_output, even if this function throws
    an exception.
    """
    return _mupdf.ll_fz_new_zip_writer_with_output(out)

def ll_fz_next_page(doc, loc):
    r"""
    Low-level wrapper for `::fz_next_page()`.
    Function to get the location of the next page (allowing for the
    end of chapters etc). If at the end of the document, returns the
    current location.
    """
    return _mupdf.ll_fz_next_page(doc, loc)

def ll_fz_normalize_vector(p):
    r"""
    Low-level wrapper for `::fz_normalize_vector()`.
    Normalize a vector to length one.
    """
    return _mupdf.ll_fz_normalize_vector(p)

def ll_fz_open_a85d(chain):
    r"""
    Low-level wrapper for `::fz_open_a85d()`.
    a85d filter performs ASCII 85 Decoding of data read
    from the chained filter.
    """
    return _mupdf.ll_fz_open_a85d(chain)

def ll_fz_open_accelerated_document(filename, accel):
    r"""
    Low-level wrapper for `::fz_open_accelerated_document()`.
    Open a document file and read its basic structure so pages and
    objects can be located. MuPDF will try to repair broken
    documents (without actually changing the file contents).

    The returned fz_document is used when calling most other
    document related functions.

    filename: a path to a file as it would be given to open(2).
    """
    return _mupdf.ll_fz_open_accelerated_document(filename, accel)

def ll_fz_open_accelerated_document_with_stream(magic, stream, accel):
    r"""
    Low-level wrapper for `::fz_open_accelerated_document_with_stream()`.
    Open a document using the specified stream object rather than
    opening a file on disk.

    magic: a string used to detect document type; either a file name
    or mime-type.

    stream: a stream of the document contents.

    accel: NULL, or a stream of the 'accelerator' contents for this document.

    NOTE: The caller retains ownership of 'stream' and 'accel' - the document will
    take its own references if required.
    """
    return _mupdf.ll_fz_open_accelerated_document_with_stream(magic, stream, accel)

def ll_fz_open_accelerated_document_with_stream_and_dir(magic, stream, accel, dir):
    r"""
    Low-level wrapper for `::fz_open_accelerated_document_with_stream_and_dir()`.
    Open a document using the specified stream object rather than
    opening a file on disk.

    magic: a string used to detect document type; either a file name
    or mime-type.

    stream: a stream of the document contents.

    accel: NULL, or a stream of the 'accelerator' contents for this document.

    dir: NULL, or the 'directory context' for the stream contents.

    NOTE: The caller retains ownership of 'stream', 'accel' and 'dir' - the document will
    take its own references if required.
    """
    return _mupdf.ll_fz_open_accelerated_document_with_stream_and_dir(magic, stream, accel, dir)

def ll_fz_open_aesd(chain, key, keylen):
    r"""
    Low-level wrapper for `::fz_open_aesd()`.
    aesd filter performs AES decoding of data read from the chained
    filter using the supplied key.
    """
    return _mupdf.ll_fz_open_aesd(chain, key, keylen)

def ll_fz_open_ahxd(chain):
    r"""
    Low-level wrapper for `::fz_open_ahxd()`.
    ahxd filter performs ASCII Hex decoding of data read
    from the chained filter.
    """
    return _mupdf.ll_fz_open_ahxd(chain)

def ll_fz_open_arc4(chain, key, keylen):
    r"""
    Low-level wrapper for `::fz_open_arc4()`.
    arc4 filter performs RC4 decoding of data read from the chained
    filter using the supplied key.
    """
    return _mupdf.ll_fz_open_arc4(chain, key, keylen)

def ll_fz_open_archive(filename):
    r"""
    Low-level wrapper for `::fz_open_archive()`.
    Open a zip or tar archive

    Open a file and identify its archive type based on the archive
    signature contained inside.

    filename: a path to a file as it would be given to open(2).
    """
    return _mupdf.ll_fz_open_archive(filename)

def ll_fz_open_archive_entry(arch, name):
    r"""
    Low-level wrapper for `::fz_open_archive_entry()`.
    Opens an archive entry as a stream.

    name: Entry name to look for, this must be an exact match to
    the entry name in the archive.

    Throws an exception if a matching entry cannot be found.
    """
    return _mupdf.ll_fz_open_archive_entry(arch, name)

def ll_fz_open_archive_with_stream(file):
    r"""
    Low-level wrapper for `::fz_open_archive_with_stream()`.
    Open zip or tar archive stream.

    Open an archive using a seekable stream object rather than
    opening a file or directory on disk.
    """
    return _mupdf.ll_fz_open_archive_with_stream(file)

def ll_fz_open_buffer(buf):
    r"""
    Low-level wrapper for `::fz_open_buffer()`.
    Open a buffer as a stream.

    buf: The buffer to open. Ownership of the buffer is NOT passed
    in (this function takes its own reference).

    Returns pointer to newly created stream. May throw exceptions on
    failure to allocate.
    """
    return _mupdf.ll_fz_open_buffer(buf)

def ll_fz_open_cfb_archive(filename):
    r"""
    Low-level wrapper for `::fz_open_cfb_archive()`.
    Open a cfb file as an archive.

    An exception is thrown if the file is not recognised as a cfb.

    filename: a path to an archive file as it would be given to
    open(2).
    """
    return _mupdf.ll_fz_open_cfb_archive(filename)

def ll_fz_open_cfb_archive_with_stream(file):
    r"""
    Low-level wrapper for `::fz_open_cfb_archive_with_stream()`.
    Open a cfb file as an archive.

    Open an archive using a seekable stream object rather than
    opening a file or directory on disk.

    An exception is thrown if the file is not recognised as a chm.
    """
    return _mupdf.ll_fz_open_cfb_archive_with_stream(file)

def ll_fz_open_compressed_buffer(arg_1):
    r"""
    Low-level wrapper for `::fz_open_compressed_buffer()`.
    Open a stream to read the decompressed version of a buffer.
    """
    return _mupdf.ll_fz_open_compressed_buffer(arg_1)

def ll_fz_open_concat(max, pad):
    r"""
    Low-level wrapper for `::fz_open_concat()`.
    Concat filter concatenates several streams into one.
    """
    return _mupdf.ll_fz_open_concat(max, pad)

def ll_fz_open_dctd(chain, color_transform, invert_cmyk, l2factor, jpegtables):
    r"""
    Low-level wrapper for `::fz_open_dctd()`.
    dctd filter performs DCT (JPEG) decoding of data read
    from the chained filter.

    color_transform implements the PDF color_transform option
    	use -1 for default behavior
    	use 0 to disable YUV-RGB / YCCK-CMYK transforms
    	use 1 to enable YUV-RGB / YCCK-CMYK transforms

    invert_cmyk implements the necessary inversion for Photoshop CMYK images
    	use 0 if embedded in PDF
    	use 1 if not embedded in PDF

    For subsampling on decode, set l2factor to the log2 of the
    reduction required (therefore 0 = full size decode).

    jpegtables is an optional stream from which the JPEG tables
    can be read. Use NULL if not required.
    """
    return _mupdf.ll_fz_open_dctd(chain, color_transform, invert_cmyk, l2factor, jpegtables)

def ll_fz_open_directory(path):
    r"""
    Low-level wrapper for `::fz_open_directory()`.
    Open a directory as if it was an archive.

    A special case where a directory is opened as if it was an
    archive.

    Note that for directories it is not possible to retrieve the
    number of entries or list the entries. It is however possible
    to check if the archive has a particular entry.

    path: a path to a directory as it would be given to opendir(3).
    """
    return _mupdf.ll_fz_open_directory(path)

def ll_fz_open_document(filename):
    r"""
    Low-level wrapper for `::fz_open_document()`.
    Open a document file and read its basic structure so pages and
    objects can be located. MuPDF will try to repair broken
    documents (without actually changing the file contents).

    The returned fz_document is used when calling most other
    document related functions.

    filename: a path to a file as it would be given to open(2).
    """
    return _mupdf.ll_fz_open_document(filename)

def ll_fz_open_document_with_buffer(magic, buffer):
    r"""
    Low-level wrapper for `::fz_open_document_with_buffer()`.
    Open a document using a buffer rather than opening a file on disk.
    """
    return _mupdf.ll_fz_open_document_with_buffer(magic, buffer)

def ll_fz_open_document_with_stream(magic, stream):
    r"""
    Low-level wrapper for `::fz_open_document_with_stream()`.
    Open a document using the specified stream object rather than
    opening a file on disk.

    magic: a string used to detect document type; either a file name
    or mime-type.

    stream: a stream representing the contents of the document file.

    NOTE: The caller retains ownership of 'stream' - the document will take its
    own reference if required.
    """
    return _mupdf.ll_fz_open_document_with_stream(magic, stream)

def ll_fz_open_document_with_stream_and_dir(magic, stream, dir):
    r"""
    Low-level wrapper for `::fz_open_document_with_stream_and_dir()`.
    Open a document using the specified stream object rather than
    opening a file on disk.

    magic: a string used to detect document type; either a file name
    or mime-type.

    stream: a stream representing the contents of the document file.

    dir: a 'directory context' for those filetypes that need it.

    NOTE: The caller retains ownership of 'stream' and 'dir' - the document will
    take its own references if required.
    """
    return _mupdf.ll_fz_open_document_with_stream_and_dir(magic, stream, dir)

def ll_fz_open_endstream_filter(chain, len, offset):
    r"""
    Low-level wrapper for `::fz_open_endstream_filter()`.
    The endstream filter reads a PDF substream, and starts to look
    for an 'endstream' token after the specified length.
    """
    return _mupdf.ll_fz_open_endstream_filter(chain, len, offset)

def ll_fz_open_faxd(chain, k, end_of_line, encoded_byte_align, columns, rows, end_of_block, black_is_1):
    r"""
    Low-level wrapper for `::fz_open_faxd()`.
    faxd filter performs FAX decoding of data read from
    the chained filter.

    k: see fax specification (fax default is 0).

    end_of_line: whether we expect end of line markers (fax default
    is 0).

    encoded_byte_align: whether we align to bytes after each line
    (fax default is 0).

    columns: how many columns in the image (fax default is 1728).

    rows: 0 for unspecified or the number of rows of data to expect.

    end_of_block: whether we expect end of block markers (fax
    default is 1).

    black_is_1: determines the polarity of the image (fax default is
    0).
    """
    return _mupdf.ll_fz_open_faxd(chain, k, end_of_line, encoded_byte_align, columns, rows, end_of_block, black_is_1)

def ll_fz_open_file(filename):
    r"""
    Low-level wrapper for `::fz_open_file()`.
    Open the named file and wrap it in a stream.

    filename: Path to a file. On non-Windows machines the filename
    should be exactly as it would be passed to fopen(2). On Windows
    machines, the path should be UTF-8 encoded so that non-ASCII
    characters can be represented. Other platforms do the encoding
    as standard anyway (and in most cases, particularly for MacOS
    and Linux, the encoding they use is UTF-8 anyway).
    """
    return _mupdf.ll_fz_open_file(filename)

def ll_fz_open_file_ptr_no_close(file):
    r"""
    Low-level wrapper for `::fz_open_file_ptr_no_close()`.
    Create a stream from a FILE * that will not be closed
    when the stream is dropped.
    """
    return _mupdf.ll_fz_open_file_ptr_no_close(file)

def ll_fz_open_flated(chain, window_bits):
    r"""
    Low-level wrapper for `::fz_open_flated()`.
    flated filter performs LZ77 decoding (inflating) of data read
    from the chained filter.

    window_bits: How large a decompression window to use. Typically
    15. A negative number, -n, means to use n bits, but to expect
    raw data with no header.
    """
    return _mupdf.ll_fz_open_flated(chain, window_bits)

def ll_fz_open_image_decomp_stream(arg_1, arg_2, l2factor):
    r"""
     Low-level wrapper for `::fz_open_image_decomp_stream()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_fz_open_image_decomp_stream(::fz_stream *arg_0, ::fz_compression_params *arg_1)` => `(fz_stream *, int l2factor)`

    	Open a stream to read the decompressed version of another stream
    	with optional log2 subsampling.
    """
    return _mupdf.ll_fz_open_image_decomp_stream(arg_1, arg_2, l2factor)

def ll_fz_open_image_decomp_stream_from_buffer(arg_1, l2factor):
    r"""
     Low-level wrapper for `::fz_open_image_decomp_stream_from_buffer()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_fz_open_image_decomp_stream_from_buffer(::fz_compressed_buffer *arg_0)` => `(fz_stream *, int l2factor)`

    	Open a stream to read the decompressed version of a buffer,
    	with optional log2 subsampling.

    	l2factor = NULL for no subsampling, or a pointer to an integer
    	containing the maximum log2 subsample factor acceptable (0 =
    	none, 1 = halve dimensions, 2 = quarter dimensions etc). If
    	non-NULL, then *l2factor will be updated on exit with the actual
    	log2 subsample factor achieved.
    """
    return _mupdf.ll_fz_open_image_decomp_stream_from_buffer(arg_1, l2factor)

def ll_fz_open_jbig2d(chain, globals, embedded):
    r"""
    Low-level wrapper for `::fz_open_jbig2d()`.
    Open a filter that performs jbig2 decompression on the chained
    stream, using the optional globals record.
    """
    return _mupdf.ll_fz_open_jbig2d(chain, globals, embedded)

def ll_fz_open_leecher(chain, buf):
    r"""
    Low-level wrapper for `::fz_open_leecher()`.
    Attach a filter to a stream that will store any
    characters read from the stream into the supplied buffer.

    chain: The underlying stream to leech from.

    buf: The buffer into which the read data should be appended.
    The buffer will be resized as required.

    Returns pointer to newly created stream. May throw exceptions on
    failure to allocate.
    """
    return _mupdf.ll_fz_open_leecher(chain, buf)

def ll_fz_open_libarchive_archive(filename):
    r"""
    Low-level wrapper for `::fz_open_libarchive_archive()`.
    Open an archive using libarchive.

    An exception is thrown if the file is not supported by libarchive.

    filename: a path to an archive file as it would be given to
    open(2).
    """
    return _mupdf.ll_fz_open_libarchive_archive(filename)

def ll_fz_open_libarchive_archive_with_stream(file):
    r"""
    Low-level wrapper for `::fz_open_libarchive_archive_with_stream()`.
    Open an archive using libarchive.

    Open an archive using a seekable stream object rather than
    opening a file or directory on disk.

    An exception is thrown if the stream is not supported by libarchive.
    """
    return _mupdf.ll_fz_open_libarchive_archive_with_stream(file)

def ll_fz_open_libarchived(chain):
    r"""
    Low-level wrapper for `::fz_open_libarchived()`.
    libarchived filter performs generic compressed decoding of data
    in any format understood by libarchive from the chained filter.

    This will throw an exception if libarchive is not built in, or
    if the compression format is not recognised.
    """
    return _mupdf.ll_fz_open_libarchived(chain)

def ll_fz_open_lzwd(chain, early_change, min_bits, reverse_bits, old_tiff):
    r"""
    Low-level wrapper for `::fz_open_lzwd()`.
    lzwd filter performs LZW decoding of data read from the chained
    filter.

    early_change: (Default 1) specifies whether to change codes 1
    bit early.

    min_bits: (Default 9) specifies the minimum number of bits to
    use.

    reverse_bits: (Default 0) allows for compatibility with gif and
    old style tiffs (1).

    old_tiff: (Default 0) allows for different handling of the clear
    code, as found in old style tiffs.
    """
    return _mupdf.ll_fz_open_lzwd(chain, early_change, min_bits, reverse_bits, old_tiff)

def ll_fz_open_memory(data, len):
    r"""
    Low-level wrapper for `::fz_open_memory()`.
    Open a block of memory as a stream.

    data: Pointer to start of data block. Ownership of the data
    block is NOT passed in.

    len: Number of bytes in data block.

    Returns pointer to newly created stream. May throw exceptions on
    failure to allocate.
    """
    return _mupdf.ll_fz_open_memory(data, len)

def ll_fz_open_null_filter(chain, len, offset):
    r"""
    Low-level wrapper for `::fz_open_null_filter()`.
    The null filter reads a specified amount of data from the
    substream.
    """
    return _mupdf.ll_fz_open_null_filter(chain, len, offset)

def ll_fz_open_predict(chain, predictor, columns, colors, bpc):
    r"""
    Low-level wrapper for `::fz_open_predict()`.
    predict filter performs pixel prediction on data read from
    the chained filter.

    predictor: 1 = copy, 2 = tiff, other = inline PNG predictor

    columns: width of image in pixels

    colors: number of components.

    bpc: bits per component (typically 8)
    """
    return _mupdf.ll_fz_open_predict(chain, predictor, columns, colors, bpc)

def ll_fz_open_range_filter(chain, ranges, nranges):
    r"""
    Low-level wrapper for `::fz_open_range_filter()`.
    The range filter copies data from specified ranges of the
    chained stream.
    """
    return _mupdf.ll_fz_open_range_filter(chain, ranges, nranges)

def ll_fz_open_reflowed_document(underdoc, opts):
    r""" Low-level wrapper for `::fz_open_reflowed_document()`."""
    return _mupdf.ll_fz_open_reflowed_document(underdoc, opts)

def ll_fz_open_rld(chain):
    r"""
    Low-level wrapper for `::fz_open_rld()`.
    rld filter performs Run Length Decoding of data read
    from the chained filter.
    """
    return _mupdf.ll_fz_open_rld(chain)

def ll_fz_open_sgilog16(chain, w):
    r"""
    Low-level wrapper for `::fz_open_sgilog16()`.
    SGI Log 16bit (greyscale) decode from the chained filter.
    Decodes lines of w pixels to 8bpp greyscale.
    """
    return _mupdf.ll_fz_open_sgilog16(chain, w)

def ll_fz_open_sgilog24(chain, w):
    r"""
    Low-level wrapper for `::fz_open_sgilog24()`.
    SGI Log 24bit (LUV) decode from the chained filter.
    Decodes lines of w pixels to 8bpc rgb.
    """
    return _mupdf.ll_fz_open_sgilog24(chain, w)

def ll_fz_open_sgilog32(chain, w):
    r"""
    Low-level wrapper for `::fz_open_sgilog32()`.
    SGI Log 32bit (LUV) decode from the chained filter.
    Decodes lines of w pixels to 8bpc rgb.
    """
    return _mupdf.ll_fz_open_sgilog32(chain, w)

def ll_fz_open_tar_archive(filename):
    r"""
    Low-level wrapper for `::fz_open_tar_archive()`.
    Open a tar archive file.

    An exception is thrown if the file is not a tar archive as
    indicated by the presence of a tar signature.

    filename: a path to a tar archive file as it would be given to
    open(2).
    """
    return _mupdf.ll_fz_open_tar_archive(filename)

def ll_fz_open_tar_archive_with_stream(file):
    r"""
    Low-level wrapper for `::fz_open_tar_archive_with_stream()`.
    Open a tar archive stream.

    Open an archive using a seekable stream object rather than
    opening a file or directory on disk.

    An exception is thrown if the stream is not a tar archive as
    indicated by the presence of a tar signature.

    """
    return _mupdf.ll_fz_open_tar_archive_with_stream(file)

def ll_fz_open_thunder(chain, w):
    r"""
    Low-level wrapper for `::fz_open_thunder()`.
    4bit greyscale Thunderscan decoding from the chained filter.
    Decodes lines of w pixels to 8bpp greyscale.
    """
    return _mupdf.ll_fz_open_thunder(chain, w)

def ll_fz_open_zip_archive(path):
    r"""
    Low-level wrapper for `::fz_open_zip_archive()`.
    Open a zip archive file.

    An exception is thrown if the file is not a zip archive as
    indicated by the presence of a zip signature.

    filename: a path to a zip archive file as it would be given to
    open(2).
    """
    return _mupdf.ll_fz_open_zip_archive(path)

def ll_fz_open_zip_archive_with_stream(file):
    r"""
    Low-level wrapper for `::fz_open_zip_archive_with_stream()`.
    Open a zip archive stream.

    Open an archive using a seekable stream object rather than
    opening a file or directory on disk.

    An exception is thrown if the stream is not a zip archive as
    indicated by the presence of a zip signature.

    """
    return _mupdf.ll_fz_open_zip_archive_with_stream(file)

def ll_fz_opt_from_list(opt, optlist):
    r"""
    Low-level wrapper for `::fz_opt_from_list()`.
    Return the index of a (case-insensitive) option within an optlist.

    For instance for optlist = "Foo|Bar|Baz", and  opt = "bar",
    this would return 1.

    If the optlist ends with "|*" then that is a catch all case and
    matches all options allowing the caller to process it itself.
    fz_optarg will be set to point to the option, and the return
    value will be the index of the '*' option within that list.

    If an optlist entry ends with ':' (e.g. "Foo:") then that option
    may have suboptions appended to it (for example "JPG:80") and
    fz_optarg will be set to point at "80". Otherwise fz_optarg will
    be set to NULL.

    In the event of no-match found, prints an error and returns -1.
    """
    return _mupdf.ll_fz_opt_from_list(opt, optlist)

def ll_fz_option_eq(a, b):
    r"""
    Low-level wrapper for `::fz_option_eq()`.
    Check to see if an option, a, from a string matches a reference
    option, b.

    (i.e. a could be 'foo' or 'foo,bar...' etc, but b can only be
    'foo'.)
    """
    return _mupdf.ll_fz_option_eq(a, b)

def ll_fz_outline_glyph(font, gid, ctm):
    r"""
    Low-level wrapper for `::fz_outline_glyph()`.
    Look a glyph up from a font, and return the outline of the
    glyph using the given transform.

    The caller owns the returned path, and so is responsible for
    ensuring that it eventually gets dropped.
    """
    return _mupdf.ll_fz_outline_glyph(font, gid, ctm)

def ll_fz_outline_iterator_delete(iter):
    r"""
    Low-level wrapper for `::fz_outline_iterator_delete()`.
    Delete the current item.

    This implicitly moves us to the 'next' item, and the return code is as for fz_outline_iterator_next.
    """
    return _mupdf.ll_fz_outline_iterator_delete(iter)

def ll_fz_outline_iterator_down(iter):
    r""" Low-level wrapper for `::fz_outline_iterator_down()`."""
    return _mupdf.ll_fz_outline_iterator_down(iter)

def ll_fz_outline_iterator_from_outline(outline):
    r""" Low-level wrapper for `::fz_outline_iterator_from_outline()`."""
    return _mupdf.ll_fz_outline_iterator_from_outline(outline)

def ll_fz_outline_iterator_insert(iter, item):
    r"""
    Low-level wrapper for `::fz_outline_iterator_insert()`.
    Call to insert a new item BEFORE the current point.

    Ownership of pointers are retained by the caller. The item data will be copied.

    After an insert, we do not change where we are pointing.
    The return code is the same as for next, it indicates the current iterator position.
    """
    return _mupdf.ll_fz_outline_iterator_insert(iter, item)

def ll_fz_outline_iterator_item(iter):
    r"""
    Low-level wrapper for `::fz_outline_iterator_item()`.
    Call to get the current outline item.

    Can return NULL. The item is only valid until the next call.
    """
    return _mupdf.ll_fz_outline_iterator_item(iter)

def ll_fz_outline_iterator_next(iter):
    r"""
    Low-level wrapper for `::fz_outline_iterator_next()`.
    Calls to move the iterator position.

    A negative return value means we could not move as requested. Otherwise:
    0 = the final position has a valid item.
    1 = not a valid item, but we can insert an item here.
    """
    return _mupdf.ll_fz_outline_iterator_next(iter)

def ll_fz_outline_iterator_prev(iter):
    r""" Low-level wrapper for `::fz_outline_iterator_prev()`."""
    return _mupdf.ll_fz_outline_iterator_prev(iter)

def ll_fz_outline_iterator_up(iter):
    r""" Low-level wrapper for `::fz_outline_iterator_up()`."""
    return _mupdf.ll_fz_outline_iterator_up(iter)

def ll_fz_outline_iterator_update(iter, item):
    r"""
    Low-level wrapper for `::fz_outline_iterator_update()`.
    Update the current item properties according to the given item.
    """
    return _mupdf.ll_fz_outline_iterator_update(iter, item)

def ll_fz_output_accelerator(doc, accel):
    r"""
    Low-level wrapper for `::fz_output_accelerator()`.
    Output accelerator data for the document to a given output
    stream.
    """
    return _mupdf.ll_fz_output_accelerator(doc, accel)

def ll_fz_output_supports_stream(out):
    r"""
    Low-level wrapper for `::fz_output_supports_stream()`.
    Query whether a given fz_output supports fz_stream_from_output.
    """
    return _mupdf.ll_fz_output_supports_stream(out)

def ll_fz_output_xml(out, item, level):
    r"""
    Low-level wrapper for `::fz_output_xml()`.
    Pretty-print an XML tree to given output.
    """
    return _mupdf.ll_fz_output_xml(out, item, level)

def ll_fz_pack_path(pack, path):
    r"""
    Low-level wrapper for `::fz_pack_path()`.
    Pack a path into the given block.
    To minimise the size of paths, this function allows them to be
    packed into a buffer with other information. Paths can be used
    interchangeably regardless of how they are packed.

    pack: Pointer to a block of data to pack the path into. Should
    be aligned by the caller to the same alignment as required for
    a fz_path pointer.

    path: The path to pack.

    Returns the number of bytes within the block used. Callers can
    access the packed path data by casting the value of pack on
    entry to be a fz_path *.

    Throws exceptions on failure to allocate.

    Implementation details: Paths can be 'unpacked', 'flat', or
    'open'. Standard paths, as created are 'unpacked'. Paths
    will be packed as 'flat', unless they are too large
    (where large indicates that they exceed some private
    implementation defined limits, currently including having
    more than 256 coordinates or commands).

    Large paths are 'open' packed as a header into the given block,
    plus pointers to other data blocks.

    Users should not have to care about whether paths are 'open'
    or 'flat' packed. Simply pack a path (if required), and then
    forget about the details.
    """
    return _mupdf.ll_fz_pack_path(pack, path)

def ll_fz_packed_path_size(path):
    r"""
    Low-level wrapper for `::fz_packed_path_size()`.
    Return the number of bytes required to pack a path.
    """
    return _mupdf.ll_fz_packed_path_size(path)

def ll_fz_page_label(page, buf, size):
    r"""
    Low-level wrapper for `::fz_page_label()`.
    Get page label for a given page.
    """
    return _mupdf.ll_fz_page_label(page, buf, size)

def ll_fz_page_number_from_location(doc, loc):
    r"""
    Low-level wrapper for `::fz_page_number_from_location()`.
    Converts from chapter+page to page number. This may cause many
    chapters to be laid out in order to calculate the number of
    pages within those chapters.
    """
    return _mupdf.ll_fz_page_number_from_location(doc, loc)

def ll_fz_page_presentation(page, transition, duration):
    r"""
     Low-level wrapper for `::fz_page_presentation()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_fz_page_presentation(::fz_page *page, ::fz_transition *transition)` => `(fz_transition *, float duration)`

    	Get the presentation details for a given page.

    	transition: A pointer to a transition struct to fill out.

    	duration: A pointer to a place to set the page duration in
    	seconds. Will be set to 0 if no transition is specified for the
    	page.

    	Returns: a pointer to the transition structure, or NULL if there
    	is no transition specified for the page.
    """
    return _mupdf.ll_fz_page_presentation(page, transition, duration)

def ll_fz_page_separations(page):
    r"""
    Low-level wrapper for `::fz_page_separations()`.
    Get the separations details for a page.
    This will be NULL, unless the format specifically supports
    separations (such as PDF files). May be NULL even
    so, if there are no separations on a page.

    Returns a reference that must be dropped.
    """
    return _mupdf.ll_fz_page_separations(page)

def ll_fz_page_uses_overprint(page):
    r"""
    Low-level wrapper for `::fz_page_uses_overprint()`.
    Query if a given page requires overprint.
    """
    return _mupdf.ll_fz_page_uses_overprint(page)

def ll_fz_paint_shade(shade, override_cs, ctm, dest, color_params, bbox, eop, cache):
    r"""
     Low-level wrapper for `::fz_paint_shade()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_fz_paint_shade(::fz_shade *shade, ::fz_colorspace *override_cs, ::fz_matrix ctm, ::fz_pixmap *dest, ::fz_color_params color_params, ::fz_irect bbox, const ::fz_overprint *eop, ::fz_shade_color_cache **cache)` =>

    	Render a shade to a given pixmap.

    	shade: The shade to paint.

    	override_cs: NULL, or colorspace to override the shades
    	inbuilt colorspace.

    	ctm: The transform to apply.

    	dest: The pixmap to render into.

    	color_params: The color rendering settings

    	bbox: Pointer to a bounding box to limit the rendering
    	of the shade.

    	eop: NULL, or pointer to overprint bitmap.

    	cache: *cache is used to cache color information. If *cache is NULL it
    	is set to point to a new fz_shade_color_cache. If cache is NULL it is
    	ignored.
    """
    return _mupdf.ll_fz_paint_shade(shade, override_cs, ctm, dest, color_params, bbox, eop, cache)

def ll_fz_parse_draw_options(options, string):
    r"""
    Low-level wrapper for `::fz_parse_draw_options()`.
    Parse draw device options from a comma separated key-value string.
    """
    return _mupdf.ll_fz_parse_draw_options(options, string)

def ll_fz_parse_page_range(s, a, b, n):
    r"""
     Low-level wrapper for `::fz_parse_page_range()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_fz_parse_page_range(const char *s, int n)` => `(const char *, int a, int b)`
    """
    return _mupdf.ll_fz_parse_page_range(s, a, b, n)

def ll_fz_parse_pcl_options(opts, args):
    r"""
    Low-level wrapper for `::fz_parse_pcl_options()`.
    Parse PCL options.

    Currently defined options and values are as follows:

    	preset=X	Either "generic" or one of the presets as for fz_pcl_preset.
    	spacing=0	No vertical spacing capability
    	spacing=1	PCL 3 spacing (<ESC>*p+<n>Y)
    	spacing=2	PCL 4 spacing (<ESC>*b<n>Y)
    	spacing=3	PCL 5 spacing (<ESC>*b<n>Y and clear seed row)
    	mode2		Disable/Enable mode 2 graphics compression
    	mode3		Disable/Enable mode 3 graphics compression
    	eog_reset	End of graphics (<ESC>*rB) resets all parameters
    	has_duplex	Duplex supported (<ESC>&l<duplex>S)
    	has_papersize	Papersize setting supported (<ESC>&l<sizecode>A)
    	has_copies	Number of copies supported (<ESC>&l<copies>X)
    	is_ljet4pjl	Disable/Enable HP 4PJL model-specific output
    	is_oce9050	Disable/Enable Oce 9050 model-specific output
    """
    return _mupdf.ll_fz_parse_pcl_options(opts, args)

def ll_fz_parse_pclm_options(opts, args):
    r"""
    Low-level wrapper for `::fz_parse_pclm_options()`.
    Parse PCLm options.

    Currently defined options and values are as follows:

    	compression=none: No compression
    	compression=flate: Flate compression
    	strip-height=n: Strip height (default 16)
    """
    return _mupdf.ll_fz_parse_pclm_options(opts, args)

def ll_fz_parse_pdfocr_options(opts, args):
    r"""
    Low-level wrapper for `::fz_parse_pdfocr_options()`.
    Parse PDFOCR options.

    Currently defined options and values are as follows:

    	compression=none: No compression
    	compression=flate: Flate compression
    	strip-height=n: Strip height (default 16)
    	ocr-language=<lang>: OCR Language (default eng)
    	ocr-datadir=<datadir>: OCR data path (default rely on TESSDATA_PREFIX)
    """
    return _mupdf.ll_fz_parse_pdfocr_options(opts, args)

def ll_fz_parse_stext_options(opts, string):
    r"""
    Low-level wrapper for `::fz_parse_stext_options()`.
    Parse stext device options from a comma separated key-value
    string.
    """
    return _mupdf.ll_fz_parse_stext_options(opts, string)

def ll_fz_parse_xml(buf, preserve_white):
    r"""
    Low-level wrapper for `::fz_parse_xml()`.
    Parse the contents of buffer into a tree of xml nodes.

    preserve_white: whether to keep or delete all-whitespace nodes.
    """
    return _mupdf.ll_fz_parse_xml(buf, preserve_white)

def ll_fz_parse_xml_archive_entry(dir, filename, preserve_white):
    r"""
    Low-level wrapper for `::fz_parse_xml_archive_entry()`.
    Parse the contents of an archive entry into a tree of xml nodes.

    preserve_white: whether to keep or delete all-whitespace nodes.
    """
    return _mupdf.ll_fz_parse_xml_archive_entry(dir, filename, preserve_white)

def ll_fz_parse_xml_from_html5(buf):
    r"""
    Low-level wrapper for `::fz_parse_xml_from_html5()`.
    Parse the contents of a buffer into a tree of XML nodes,
    using the HTML5 parsing algorithm.
    """
    return _mupdf.ll_fz_parse_xml_from_html5(buf)

def ll_fz_parse_xml_stream(stream, preserve_white):
    r"""
    Low-level wrapper for `::fz_parse_xml_stream()`.
    Parse the contents of buffer into a tree of xml nodes.

    preserve_white: whether to keep or delete all-whitespace nodes.
    """
    return _mupdf.ll_fz_parse_xml_stream(stream, preserve_white)

def ll_fz_pcl_preset(opts, preset):
    r"""
    Low-level wrapper for `::fz_pcl_preset()`.
    Initialize PCL option struct for a given preset.

    Currently defined presets include:

    	generic	Generic PCL printer
    	ljet4	HP DeskJet
    	dj500	HP DeskJet 500
    	fs600	Kyocera FS-600
    	lj	HP LaserJet, HP LaserJet Plus
    	lj2	HP LaserJet IIp, HP LaserJet IId
    	lj3	HP LaserJet III
    	lj3d	HP LaserJet IIId
    	lj4	HP LaserJet 4
    	lj4pl	HP LaserJet 4 PL
    	lj4d	HP LaserJet 4d
    	lp2563b	HP 2563B line printer
    	oce9050	Oce 9050 Line printer
    """
    return _mupdf.ll_fz_pcl_preset(opts, preset)

def ll_fz_pdfocr_band_writer_set_progress(writer, progress_fn, progress_arg):
    r"""
    Low-level wrapper for `::fz_pdfocr_band_writer_set_progress()`.
    Set the progress callback for a pdfocr bandwriter.
    """
    return _mupdf.ll_fz_pdfocr_band_writer_set_progress(writer, progress_fn, progress_arg)

def ll_fz_pdfocr_writer_set_progress(writer, progress, arg_3):
    r""" Low-level wrapper for `::fz_pdfocr_writer_set_progress()`."""
    return _mupdf.ll_fz_pdfocr_writer_set_progress(writer, progress, arg_3)

def ll_fz_peek_byte(stm):
    r"""
    Low-level wrapper for `::fz_peek_byte()`.
    Peek at the next byte in a stream.

    stm: The stream to peek at.

    Returns -1 for EOF, or the next byte that will be read.
    """
    return _mupdf.ll_fz_peek_byte(stm)

def ll_fz_pixmap_alpha(pix):
    r"""
    Low-level wrapper for `::fz_pixmap_alpha()`.
    Return the number of alpha planes in a pixmap.

    Returns the number of alphas. Does not throw exceptions.
    """
    return _mupdf.ll_fz_pixmap_alpha(pix)

def ll_fz_pixmap_bbox(pix):
    r"""
    Low-level wrapper for `::fz_pixmap_bbox()`.
    Return the bounding box for a pixmap.
    """
    return _mupdf.ll_fz_pixmap_bbox(pix)

def ll_fz_pixmap_colorants(pix):
    r"""
    Low-level wrapper for `::fz_pixmap_colorants()`.
    Return the number of colorants in a pixmap.

    Returns the number of colorants (components, less any spots and
    alpha).
    """
    return _mupdf.ll_fz_pixmap_colorants(pix)

def ll_fz_pixmap_colorspace(pix):
    r"""
    Low-level wrapper for `::fz_pixmap_colorspace()`.
    Return the colorspace of a pixmap

    Returns colorspace.
    """
    return _mupdf.ll_fz_pixmap_colorspace(pix)

def ll_fz_pixmap_components(pix):
    r"""
    Low-level wrapper for `::fz_pixmap_components()`.
    Return the number of components in a pixmap.

    Returns the number of components (including spots and alpha).
    """
    return _mupdf.ll_fz_pixmap_components(pix)

def ll_fz_pixmap_height(pix):
    r"""
    Low-level wrapper for `::fz_pixmap_height()`.
    Return the height of the pixmap in pixels.
    """
    return _mupdf.ll_fz_pixmap_height(pix)

def ll_fz_pixmap_image_tile(cimg):
    r"""
    Low-level wrapper for `::fz_pixmap_image_tile()`.
    Retrieve the underlying fz_pixmap for an image.

    Returns a pointer to the underlying fz_pixmap for an image,
    or NULL if this image is not based upon an fz_pixmap.

    No reference is returned. Lifespan is limited to that of
    the image itself. If required, use fz_keep_pixmap to take
    a reference to keep it longer.
    """
    return _mupdf.ll_fz_pixmap_image_tile(cimg)

def ll_fz_pixmap_samples(pix):
    r"""
    Low-level wrapper for `::fz_pixmap_samples()`.
    Returns a pointer to the pixel data of a pixmap.

    Returns the pointer.
    """
    return _mupdf.ll_fz_pixmap_samples(pix)

def ll_fz_pixmap_samples_int(pixmap):
    r""" Low-level wrapper for `::fz_pixmap_samples_int()`."""
    return _mupdf.ll_fz_pixmap_samples_int(pixmap)

def ll_fz_pixmap_size(pix):
    r"""
    Low-level wrapper for `::fz_pixmap_size()`.
    Return sizeof fz_pixmap plus size of data, in bytes.
    """
    return _mupdf.ll_fz_pixmap_size(pix)

def ll_fz_pixmap_spots(pix):
    r"""
    Low-level wrapper for `::fz_pixmap_spots()`.
    Return the number of spots in a pixmap.

    Returns the number of spots (components, less colorants and
    alpha). Does not throw exceptions.
    """
    return _mupdf.ll_fz_pixmap_spots(pix)

def ll_fz_pixmap_stride(pix):
    r"""
    Low-level wrapper for `::fz_pixmap_stride()`.
    Return the number of bytes in a row in the pixmap.
    """
    return _mupdf.ll_fz_pixmap_stride(pix)

def ll_fz_pixmap_width(pix):
    r"""
    Low-level wrapper for `::fz_pixmap_width()`.
    Return the width of the pixmap in pixels.
    """
    return _mupdf.ll_fz_pixmap_width(pix)

def ll_fz_pixmap_x(pix):
    r"""
    Low-level wrapper for `::fz_pixmap_x()`.
    Return the x value of the pixmap in pixels.
    """
    return _mupdf.ll_fz_pixmap_x(pix)

def ll_fz_pixmap_y(pix):
    r"""
    Low-level wrapper for `::fz_pixmap_y()`.
    Return the y value of the pixmap in pixels.
    """
    return _mupdf.ll_fz_pixmap_y(pix)

def ll_fz_place_story(story, where, filled):
    r""" Low-level wrapper for `::fz_place_story()`."""
    return _mupdf.ll_fz_place_story(story, where, filled)

def ll_fz_place_story_flags(story, where, filled, flags):
    r""" Low-level wrapper for `::fz_place_story_flags()`."""
    return _mupdf.ll_fz_place_story_flags(story, where, filled, flags)

def ll_fz_pool_alloc(pool, size):
    r"""
    Low-level wrapper for `::fz_pool_alloc()`.
    Allocate a block of size bytes from the pool.
    """
    return _mupdf.ll_fz_pool_alloc(pool, size)

def ll_fz_pool_size(pool):
    r"""
    Low-level wrapper for `::fz_pool_size()`.
    The current size of the pool.

    The number of bytes of storage currently allocated to the pool.
    This is the total of the storage used for the blocks making
    up the pool, rather then total of the allocated blocks so far,
    so it will increase in 'lumps'.
    from the pool, then the pool size may still be X
    """
    return _mupdf.ll_fz_pool_size(pool)

def ll_fz_pool_strdup(pool, s):
    r"""
    Low-level wrapper for `::fz_pool_strdup()`.
    strdup equivalent allocating from the pool.
    """
    return _mupdf.ll_fz_pool_strdup(pool, s)

def ll_fz_pop_clip(dev):
    r""" Low-level wrapper for `::fz_pop_clip()`."""
    return _mupdf.ll_fz_pop_clip(dev)

def ll_fz_post_scale(m, sx, sy):
    r"""
    Low-level wrapper for `::fz_post_scale()`.
    Scale a matrix by postmultiplication.

    m: Pointer to the matrix to scale

    sx, sy: Scaling factors along the X- and Y-axes. A scaling
    factor of 1.0 will not cause any scaling along the relevant
    axis.

    Returns m (updated).
    """
    return _mupdf.ll_fz_post_scale(m, sx, sy)

def ll_fz_pre_rotate(m, degrees):
    r"""
    Low-level wrapper for `::fz_pre_rotate()`.
    Rotate a transformation by premultiplying.

    The premultiplied matrix is of the form
    [ cos(deg) sin(deg) -sin(deg) cos(deg) 0 0 ].

    m: Pointer to matrix to premultiply.

    degrees: Degrees of counter clockwise rotation. Values less
    than zero and greater than 360 are handled as expected.

    Returns m (updated).
    """
    return _mupdf.ll_fz_pre_rotate(m, degrees)

def ll_fz_pre_scale(m, sx, sy):
    r"""
    Low-level wrapper for `::fz_pre_scale()`.
    Scale a matrix by premultiplication.

    m: Pointer to the matrix to scale

    sx, sy: Scaling factors along the X- and Y-axes. A scaling
    factor of 1.0 will not cause any scaling along the relevant
    axis.

    Returns m (updated).
    """
    return _mupdf.ll_fz_pre_scale(m, sx, sy)

def ll_fz_pre_shear(m, sx, sy):
    r"""
    Low-level wrapper for `::fz_pre_shear()`.
    Premultiply a matrix with a shearing matrix.

    The shearing matrix is of the form [ 1 sy sx 1 0 0 ].

    m: pointer to matrix to premultiply

    sx, sy: Shearing factors. A shearing factor of 0.0 will not
    cause any shearing along the relevant axis.

    Returns m (updated).
    """
    return _mupdf.ll_fz_pre_shear(m, sx, sy)

def ll_fz_pre_translate(m, tx, ty):
    r"""
    Low-level wrapper for `::fz_pre_translate()`.
    Translate a matrix by premultiplication.

    m: The matrix to translate

    tx, ty: Translation distances along the X- and Y-axes. A
    translation of 0 will not cause any translation along the
    relevant axis.

    Returns m.
    """
    return _mupdf.ll_fz_pre_translate(m, tx, ty)

def ll_fz_prepare_t3_glyph(font, gid):
    r"""
    Low-level wrapper for `::fz_prepare_t3_glyph()`.
    Force a type3 font to cache the displaylist for a given glyph
    id.

    This caching can involve reading the underlying file, so must
    happen ahead of time, so we aren't suddenly forced to read the
    file while playing a displaylist back.
    """
    return _mupdf.ll_fz_prepare_t3_glyph(font, gid)

def ll_fz_previous_page(doc, loc):
    r"""
    Low-level wrapper for `::fz_previous_page()`.
    Function to get the location of the previous page (allowing for
    the end of chapters etc). If already at the start of the
    document, returns the current page.
    """
    return _mupdf.ll_fz_previous_page(doc, loc)

def ll_fz_print_stext_header_as_html(out):
    r""" Low-level wrapper for `::fz_print_stext_header_as_html()`."""
    return _mupdf.ll_fz_print_stext_header_as_html(out)

def ll_fz_print_stext_header_as_xhtml(out):
    r""" Low-level wrapper for `::fz_print_stext_header_as_xhtml()`."""
    return _mupdf.ll_fz_print_stext_header_as_xhtml(out)

def ll_fz_print_stext_page_as_html(out, page, id):
    r"""
    Low-level wrapper for `::fz_print_stext_page_as_html()`.
    Output structured text to a file in HTML (visual) format.
    """
    return _mupdf.ll_fz_print_stext_page_as_html(out, page, id)

def ll_fz_print_stext_page_as_json(out, page, scale):
    r"""
    Low-level wrapper for `::fz_print_stext_page_as_json()`.
    Output structured text to a file in JSON format.
    """
    return _mupdf.ll_fz_print_stext_page_as_json(out, page, scale)

def ll_fz_print_stext_page_as_text(out, page):
    r"""
    Low-level wrapper for `::fz_print_stext_page_as_text()`.
    Output structured text to a file in plain-text UTF-8 format.
    """
    return _mupdf.ll_fz_print_stext_page_as_text(out, page)

def ll_fz_print_stext_page_as_xhtml(out, page, id):
    r"""
    Low-level wrapper for `::fz_print_stext_page_as_xhtml()`.
    Output structured text to a file in XHTML (semantic) format.
    """
    return _mupdf.ll_fz_print_stext_page_as_xhtml(out, page, id)

def ll_fz_print_stext_page_as_xml(out, page, id):
    r"""
    Low-level wrapper for `::fz_print_stext_page_as_xml()`.
    Output structured text to a file in XML format.
    """
    return _mupdf.ll_fz_print_stext_page_as_xml(out, page, id)

def ll_fz_print_stext_trailer_as_html(out):
    r""" Low-level wrapper for `::fz_print_stext_trailer_as_html()`."""
    return _mupdf.ll_fz_print_stext_trailer_as_html(out)

def ll_fz_print_stext_trailer_as_xhtml(out):
    r""" Low-level wrapper for `::fz_print_stext_trailer_as_xhtml()`."""
    return _mupdf.ll_fz_print_stext_trailer_as_xhtml(out)

def ll_fz_process_opened_pages(doc, process_openend_page, state):
    r"""
    Low-level wrapper for `::fz_process_opened_pages()`.
    Iterates over all opened pages of the document, calling the
    provided callback for each page for processing. If the callback
    returns non-NULL then the iteration stops and that value is returned
    to the called of fz_process_opened_pages().

    The state pointer provided to fz_process_opened_pages() is
    passed on to the callback but is owned by the caller.

    Returns the first non-NULL value returned by the callback,
    or NULL if the callback returned NULL for all opened pages.
    """
    return _mupdf.ll_fz_process_opened_pages(doc, process_openend_page, state)

def ll_fz_process_shade(shade, ctm, scissor, prepare, process, process_arg):
    r"""
    Low-level wrapper for `::fz_process_shade()`.
    Process a shade, using supplied callback functions. This
    decomposes the shading to a mesh (even ones that are not
    natively meshes, such as linear or radial shadings), and
    processes triangles from those meshes.

    shade: The shade to process.

    ctm: The transform to use

    prepare: Callback function to 'prepare' each vertex.
    This function is passed an array of floats, and populates
    a fz_vertex structure.

    process: This function is passed 3 pointers to vertex
    structures, and actually performs the processing (typically
    filling the area between the vertexes).

    process_arg: An opaque argument passed through from caller
    to callback functions.
    """
    return _mupdf.ll_fz_process_shade(shade, ctm, scissor, prepare, process, process_arg)

def ll_fz_ptr_heap_insert(heap, v, HEAP_CMP):
    r""" Low-level wrapper for `::fz_ptr_heap_insert()`."""
    return _mupdf.ll_fz_ptr_heap_insert(heap, v, HEAP_CMP)

def ll_fz_ptr_heap_sort(heap, HEAP_CMP):
    r""" Low-level wrapper for `::fz_ptr_heap_sort()`."""
    return _mupdf.ll_fz_ptr_heap_sort(heap, HEAP_CMP)

def ll_fz_ptr_heap_uniq(heap, HEAP_CMP):
    r""" Low-level wrapper for `::fz_ptr_heap_uniq()`."""
    return _mupdf.ll_fz_ptr_heap_uniq(heap, HEAP_CMP)

def ll_fz_purge_glyph_cache():
    r"""
    Low-level wrapper for `::fz_purge_glyph_cache()`.
    Purge all the glyphs from the cache.
    """
    return _mupdf.ll_fz_purge_glyph_cache()

def ll_fz_quad_from_rect(r):
    r"""
    Low-level wrapper for `::fz_quad_from_rect()`.
    Convert a rect to a quad (losslessly).
    """
    return _mupdf.ll_fz_quad_from_rect(r)

def ll_fz_quadto(path, x0, y0, x1, y1):
    r"""
    Low-level wrapper for `::fz_quadto()`.
    Append a 'quadto' command to an open path. (For a
    quadratic bezier).

    path: The path to modify.

    x0, y0: The control coordinates for the quadratic curve.

    x1, y1: The end coordinates for the quadratic curve.

    Throws exceptions on failure to allocate, or attempting to
    modify a packed path.
    """
    return _mupdf.ll_fz_quadto(path, x0, y0, x1, y1)

def ll_fz_read(stm, data, len):
    r"""
    Low-level wrapper for `::fz_read()`.
    Read from a stream into a given data block.

    stm: The stream to read from.

    data: The data block to read into.

    len: The length of the data block (in bytes).

    Returns the number of bytes read. May throw exceptions.
    """
    return _mupdf.ll_fz_read(stm, data, len)

def ll_fz_read_all(stm, initial):
    r"""
    Low-level wrapper for `::fz_read_all()`.
    Read all of a stream into a buffer.

    stm: The stream to read from

    initial: Suggested initial size for the buffer.

    Returns a buffer created from reading from the stream. May throw
    exceptions on failure to allocate.
    """
    return _mupdf.ll_fz_read_all(stm, initial)

def ll_fz_read_archive_entry(arch, name):
    r"""
    Low-level wrapper for `::fz_read_archive_entry()`.
    Reads all bytes in an archive entry
    into a buffer.

    name: Entry name to look for, this must be an exact match to
    the entry name in the archive.

    Throws an exception if a matching entry cannot be found.
    """
    return _mupdf.ll_fz_read_archive_entry(arch, name)

def ll_fz_read_best(stm, initial, truncated, worst_case):
    r"""
     Low-level wrapper for `::fz_read_best()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_fz_read_best(::fz_stream *stm, size_t initial, size_t worst_case)` => `(fz_buffer *, int truncated)`

    	Attempt to read a stream into a buffer. If truncated
    	is NULL behaves as fz_read_all, sets a truncated flag in case of
    	error.

    	stm: The stream to read from.

    	initial: Suggested initial size for the buffer.

    	truncated: Flag to store success/failure indication in.

    	worst_case: 0 for unknown, otherwise an upper bound for the
    	size of the stream.

    	Returns a buffer created from reading from the stream.
    """
    return _mupdf.ll_fz_read_best(stm, initial, truncated, worst_case)

def ll_fz_read_bits(stm, n):
    r"""
    Low-level wrapper for `::fz_read_bits()`.
    Read the next n bits from a stream (assumed to
    be packed most significant bit first).

    stm: The stream to read from.

    n: The number of bits to read, between 1 and 8*sizeof(int)
    inclusive.

    Returns -1 for EOF, or the required number of bits.
    """
    return _mupdf.ll_fz_read_bits(stm, n)

def ll_fz_read_byte(stm):
    r"""
    Low-level wrapper for `::fz_read_byte()`.
    Read the next byte from a stream.

    stm: The stream t read from.

    Returns -1 for end of stream, or the next byte. May
    throw exceptions.
    """
    return _mupdf.ll_fz_read_byte(stm)

def ll_fz_read_file(filename):
    r"""
    Low-level wrapper for `::fz_read_file()`.
    Read all the contents of a file into a buffer.
    """
    return _mupdf.ll_fz_read_file(filename)

def ll_fz_read_float(stm):
    r""" Low-level wrapper for `::fz_read_float()`."""
    return _mupdf.ll_fz_read_float(stm)

def ll_fz_read_float_le(stm):
    r""" Low-level wrapper for `::fz_read_float_le()`."""
    return _mupdf.ll_fz_read_float_le(stm)

def ll_fz_read_int16(stm):
    r""" Low-level wrapper for `::fz_read_int16()`."""
    return _mupdf.ll_fz_read_int16(stm)

def ll_fz_read_int16_le(stm):
    r""" Low-level wrapper for `::fz_read_int16_le()`."""
    return _mupdf.ll_fz_read_int16_le(stm)

def ll_fz_read_int32(stm):
    r""" Low-level wrapper for `::fz_read_int32()`."""
    return _mupdf.ll_fz_read_int32(stm)

def ll_fz_read_int32_le(stm):
    r""" Low-level wrapper for `::fz_read_int32_le()`."""
    return _mupdf.ll_fz_read_int32_le(stm)

def ll_fz_read_int64(stm):
    r""" Low-level wrapper for `::fz_read_int64()`."""
    return _mupdf.ll_fz_read_int64(stm)

def ll_fz_read_int64_le(stm):
    r""" Low-level wrapper for `::fz_read_int64_le()`."""
    return _mupdf.ll_fz_read_int64_le(stm)

def ll_fz_read_line(stm, buf, max):
    r"""
    Low-level wrapper for `::fz_read_line()`.
    Read a line from stream into the buffer until either a
    terminating newline or EOF, which it replaces with a null byte
    ('').

    Returns buf on success, and NULL when end of file occurs while
    no characters have been read.
    """
    return _mupdf.ll_fz_read_line(stm, buf, max)

def ll_fz_read_rbits(stm, n):
    r"""
    Low-level wrapper for `::fz_read_rbits()`.
    Read the next n bits from a stream (assumed to
    be packed least significant bit first).

    stm: The stream to read from.

    n: The number of bits to read, between 1 and 8*sizeof(int)
    inclusive.

    Returns (unsigned int)-1 for EOF, or the required number of bits.
    """
    return _mupdf.ll_fz_read_rbits(stm, n)

def ll_fz_read_rune(_in):
    r"""
    Low-level wrapper for `::fz_read_rune()`.
    Read a utf-8 rune from a stream.

    In the event of encountering badly formatted utf-8 codes
    (such as a leading code with an unexpected number of following
    codes) no error/exception is given, but undefined values may be
    returned.
    """
    return _mupdf.ll_fz_read_rune(_in)

def ll_fz_read_string(stm, buffer, len):
    r"""
    Low-level wrapper for `::fz_read_string()`.
    Read a null terminated string from the stream into
    a buffer of a given length. The buffer will be null terminated.
    Throws on failure (including the failure to fit the entire
    string including the terminator into the buffer).
    """
    return _mupdf.ll_fz_read_string(stm, buffer, len)

def ll_fz_read_uint16(stm):
    r"""
    Low-level wrapper for `::fz_read_uint16()`.
    fz_read_[u]int(16|24|32|64)(_le)?

    Read a 16/32/64 bit signed/unsigned integer from stream,
    in big or little-endian byte orders.

    Throws an exception if EOF is encountered.
    """
    return _mupdf.ll_fz_read_uint16(stm)

def ll_fz_read_uint16_le(stm):
    r""" Low-level wrapper for `::fz_read_uint16_le()`."""
    return _mupdf.ll_fz_read_uint16_le(stm)

def ll_fz_read_uint24(stm):
    r""" Low-level wrapper for `::fz_read_uint24()`."""
    return _mupdf.ll_fz_read_uint24(stm)

def ll_fz_read_uint24_le(stm):
    r""" Low-level wrapper for `::fz_read_uint24_le()`."""
    return _mupdf.ll_fz_read_uint24_le(stm)

def ll_fz_read_uint32(stm):
    r""" Low-level wrapper for `::fz_read_uint32()`."""
    return _mupdf.ll_fz_read_uint32(stm)

def ll_fz_read_uint32_le(stm):
    r""" Low-level wrapper for `::fz_read_uint32_le()`."""
    return _mupdf.ll_fz_read_uint32_le(stm)

def ll_fz_read_uint64(stm):
    r""" Low-level wrapper for `::fz_read_uint64()`."""
    return _mupdf.ll_fz_read_uint64(stm)

def ll_fz_read_uint64_le(stm):
    r""" Low-level wrapper for `::fz_read_uint64_le()`."""
    return _mupdf.ll_fz_read_uint64_le(stm)

def ll_fz_read_utf16_be(stm):
    r""" Low-level wrapper for `::fz_read_utf16_be()`."""
    return _mupdf.ll_fz_read_utf16_be(stm)

def ll_fz_read_utf16_le(stm):
    r"""
    Low-level wrapper for `::fz_read_utf16_le()`.
    Read a utf-16 rune from a stream. (little endian and
    big endian respectively).

    In the event of encountering badly formatted utf-16 codes
    (mismatched surrogates) no error/exception is given, but
    undefined values may be returned.
    """
    return _mupdf.ll_fz_read_utf16_le(stm)

def ll_fz_realloc(p, size):
    r"""
    Low-level wrapper for `::fz_realloc()`.
    Reallocates a block of memory to given size. Existing contents
    up to min(old_size,new_size) are maintained. The rest of the
    block is uninitialised.

    fz_realloc(ctx, NULL, size) behaves like fz_malloc(ctx, size).

    fz_realloc(ctx, p, 0); behaves like fz_free(ctx, p).

    Throws exception in the event of failure to allocate.
    """
    return _mupdf.ll_fz_realloc(p, size)

def ll_fz_realloc_no_throw(p, size):
    r"""
    Low-level wrapper for `::fz_realloc_no_throw()`.
    fz_realloc equivalent that returns NULL rather than throwing
    exceptions.
    """
    return _mupdf.ll_fz_realloc_no_throw(p, size)

def ll_fz_realpath(path, resolved_path):
    r"""
    Low-level wrapper for `::fz_realpath()`.
    Resolve a path to an absolute file name.
    The resolved path buffer must be of at least PATH_MAX size.
    """
    return _mupdf.ll_fz_realpath(path, resolved_path)

def ll_fz_recognize_document(magic):
    r"""
    Low-level wrapper for `::fz_recognize_document()`.
    Given a magic find a document handler that can handle a
    document of this type.

    magic: Can be a filename extension (including initial period) or
    a mimetype.
    """
    return _mupdf.ll_fz_recognize_document(magic)

def ll_fz_recognize_document_content(filename):
    r"""
    Low-level wrapper for `::fz_recognize_document_content()`.
    Given a filename find a document handler that can handle a
    document of this type.

    filename: The filename of the document. This will be opened and sampled
    to check data.
    """
    return _mupdf.ll_fz_recognize_document_content(filename)

def ll_fz_recognize_document_stream_and_dir_content(stream, dir, magic):
    r"""
    Low-level wrapper for `::fz_recognize_document_stream_and_dir_content()`.
    Given a magic find a document handler that can handle a
    document of this type.

    stream: the file stream to sample. May be NULL if the document is
    a directory.

    dir: an fz_archive representing the directory from which the
    stream was opened (or NULL).

    magic: Can be a filename extension (including initial period) or
    a mimetype.
    """
    return _mupdf.ll_fz_recognize_document_stream_and_dir_content(stream, dir, magic)

def ll_fz_recognize_document_stream_content(stream, magic):
    r"""
    Low-level wrapper for `::fz_recognize_document_stream_content()`.
    Given a magic find a document handler that can handle a
    document of this type.

    stream: the file stream to sample. May be NULL if the document is
    a directory.

    magic: Can be a filename extension (including initial period) or
    a mimetype.
    """
    return _mupdf.ll_fz_recognize_document_stream_content(stream, magic)

def ll_fz_recognize_image_format(p):
    r"""
    Low-level wrapper for `::fz_recognize_image_format()`.
    Recognise image format strings in the first 8 bytes from image
    data.
    """
    return _mupdf.ll_fz_recognize_image_format(p)

def ll_fz_rect_from_irect(bbox):
    r"""
    Low-level wrapper for `::fz_rect_from_irect()`.
    Convert a bbox into a rect.

    For our purposes, a rect can represent all the values we meet in
    a bbox, so nothing can go wrong.

    rect: A place to store the generated rectangle.

    bbox: The bbox to convert.

    Returns rect (updated).
    """
    return _mupdf.ll_fz_rect_from_irect(bbox)

def ll_fz_rect_from_quad(q):
    r"""
    Low-level wrapper for `::fz_rect_from_quad()`.
    Convert a quad to the smallest rect that covers it.
    """
    return _mupdf.ll_fz_rect_from_quad(q)

def ll_fz_rectto(path, x0, y0, x1, y1):
    r"""
    Low-level wrapper for `::fz_rectto()`.
    Append a 'rectto' command to an open path.

    The rectangle is equivalent to:
    	moveto x0 y0
    	lineto x1 y0
    	lineto x1 y1
    	lineto x0 y1
    	closepath

    path: The path to modify.

    x0, y0: First corner of the rectangle.

    x1, y1: Second corner of the rectangle.

    Throws exceptions on failure to allocate, or attempting to
    modify a packed path.
    """
    return _mupdf.ll_fz_rectto(path, x0, y0, x1, y1)

def ll_fz_register_archive_handler(handler):
    r""" Low-level wrapper for `::fz_register_archive_handler()`."""
    return _mupdf.ll_fz_register_archive_handler(handler)

def ll_fz_register_document_handler(handler):
    r"""
    Low-level wrapper for `::fz_register_document_handler()`.
    Register a handler for a document type.

    handler: The handler to register.
    """
    return _mupdf.ll_fz_register_document_handler(handler)

def ll_fz_register_document_handlers():
    r"""
    Low-level wrapper for `::fz_register_document_handlers()`.
    Register handlers
    for all the standard document types supported in
    this build.
    """
    return _mupdf.ll_fz_register_document_handlers()

def ll_fz_remove_item(drop, key, type):
    r"""
    Low-level wrapper for `::fz_remove_item()`.
    Remove an item from the store.

    If an item indexed by the given key exists in the store, remove
    it.

    drop: The function used to free the value (to ensure we get a
    value of the correct type).

    key: The key used to find the item to remove.

    type: Functions used to manipulate the key.
    """
    return _mupdf.ll_fz_remove_item(drop, key, type)

def ll_fz_render_flags(dev, set, clear):
    r""" Low-level wrapper for `::fz_render_flags()`."""
    return _mupdf.ll_fz_render_flags(dev, set, clear)

def ll_fz_render_glyph_pixmap(font, gid, ctm, scissor, aa):
    r"""
    Low-level wrapper for `::fz_render_glyph_pixmap()`.
    Create a pixmap containing a rendered glyph.

    Lookup gid from font, clip it with scissor, and rendering it
    with aa bits of antialiasing into a new pixmap.

    The caller takes ownership of the pixmap and so must free it.

    Note: This function is no longer used for normal rendering
    operations, and is kept around just because we use it in the
    app. It should be considered "at risk" of removal from the API.
    """
    return _mupdf.ll_fz_render_glyph_pixmap(font, gid, ctm, scissor, aa)

def ll_fz_render_t3_glyph_direct(dev, font, gid, trm, gstate, def_cs):
    r"""
    Low-level wrapper for `::fz_render_t3_glyph_direct()`.
    Nasty PDF interpreter specific hernia, required to allow the
    interpreter to replay glyphs from a type3 font directly into
    the target device.

    This is only used in exceptional circumstances (such as type3
    glyphs that inherit current graphics state, or nested type3
    glyphs).
    """
    return _mupdf.ll_fz_render_t3_glyph_direct(dev, font, gid, trm, gstate, def_cs)

def ll_fz_rendering_intent_name(ri):
    r"""
    Low-level wrapper for `::fz_rendering_intent_name()`.
    Map from enumerated rendering intent to string.

    The returned string is static and therefore must not be freed.
    """
    return _mupdf.ll_fz_rendering_intent_name(ri)

def ll_fz_report_error():
    r""" Low-level wrapper for `::fz_report_error()`."""
    return _mupdf.ll_fz_report_error()

def ll_fz_reset_output(arg_1):
    r"""
    Low-level wrapper for `::fz_reset_output()`.
    Reset a closed output stream. Returns state to
    (broadly) that which it was in when opened. Not
    all outputs can be reset, so this may throw an
    exception.
    """
    return _mupdf.ll_fz_reset_output(arg_1)

def ll_fz_reset_story(story):
    r""" Low-level wrapper for `::fz_reset_story()`."""
    return _mupdf.ll_fz_reset_story(story)

def ll_fz_resize_buffer(buf, capacity):
    r"""
    Low-level wrapper for `::fz_resize_buffer()`.
    Ensure that a buffer has a given capacity,
    truncating data if required.

    capacity: The desired capacity for the buffer. If the current
    size of the buffer contents is smaller than capacity, it is
    truncated.
    """
    return _mupdf.ll_fz_resize_buffer(buf, capacity)

def ll_fz_resolve_link(doc, uri, xp, yp):
    r"""
     Low-level wrapper for `::fz_resolve_link()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_fz_resolve_link(::fz_document *doc, const char *uri)` => `(fz_location, float xp, float yp)`

    	Resolve an internal link to a page number.

    	xp, yp: Pointer to store coordinate of destination on the page.

    	Returns (-1,-1) if the URI cannot be resolved.
    """
    return _mupdf.ll_fz_resolve_link(doc, uri, xp, yp)

def ll_fz_resolve_link_dest(doc, uri):
    r"""
    Low-level wrapper for `::fz_resolve_link_dest()`.
    Resolve an internal link to a page number, location, and possible viewing parameters.

    Returns location (-1,-1) if the URI cannot be resolved.
    """
    return _mupdf.ll_fz_resolve_link_dest(doc, uri)

def ll_fz_rethrow():
    r""" Low-level wrapper for `::fz_rethrow()`."""
    return _mupdf.ll_fz_rethrow()

def ll_fz_rethrow_if(errcode):
    r"""
    Low-level wrapper for `::fz_rethrow_if()`.
    Within an fz_catch() block, rethrow the current exception
    if the errcode of the current exception matches.

    This assumes no intervening use of fz_try/fz_catch.
    """
    return _mupdf.ll_fz_rethrow_if(errcode)

def ll_fz_rethrow_unless(errcode):
    r""" Low-level wrapper for `::fz_rethrow_unless()`."""
    return _mupdf.ll_fz_rethrow_unless(errcode)

def ll_fz_rotate(degrees):
    r"""
    Low-level wrapper for `::fz_rotate()`.
    Create a rotation matrix.

    The returned matrix is of the form
    [ cos(deg) sin(deg) -sin(deg) cos(deg) 0 0 ].

    m: Pointer to place to store matrix

    degrees: Degrees of counter clockwise rotation. Values less
    than zero and greater than 360 are handled as expected.

    Returns m.
    """
    return _mupdf.ll_fz_rotate(degrees)

def ll_fz_round_rect(rect):
    r"""
    Low-level wrapper for `::fz_round_rect()`.
    Round rectangle coordinates.

    Coordinates in a bounding box are integers, so rounding of the
    rects coordinates takes place. The top left corner is rounded
    upwards and left while the bottom right corner is rounded
    downwards and to the right.

    This differs from fz_irect_from_rect, in that fz_irect_from_rect
    slavishly follows the numbers (i.e any slight over/under
    calculations can cause whole extra pixels to be added).
    fz_round_rect allows for a small amount of rounding error when
    calculating the bbox.
    """
    return _mupdf.ll_fz_round_rect(rect)

def ll_fz_run_display_list(list, dev, ctm, scissor, cookie):
    r"""
    Low-level wrapper for `::fz_run_display_list()`.
    (Re)-run a display list through a device.

    list: A display list, created by fz_new_display_list and
    populated with objects from a page by running fz_run_page on a
    device obtained from fz_new_list_device.

    ctm: Transform to apply to display list contents. May include
    for example scaling and rotation, see fz_scale, fz_rotate and
    fz_concat. Set to fz_identity if no transformation is desired.

    scissor: Only the part of the contents of the display list
    visible within this area will be considered when the list is
    run through the device. This does not imply for tile objects
    contained in the display list.

    cookie: Communication mechanism between caller and library
    running the page. Intended for multi-threaded applications,
    while single-threaded applications set cookie to NULL. The
    caller may abort an ongoing page run. Cookie also communicates
    progress information back to the caller. The fields inside
    cookie are continually updated while the page is being run.
    """
    return _mupdf.ll_fz_run_display_list(list, dev, ctm, scissor, cookie)

def ll_fz_run_document_structure(doc, dev, cookie):
    r"""
    Low-level wrapper for `::fz_run_document_structure()`.
    Run the document structure through a device.

    doc: Document in question.

    dev: Device obtained from fz_new_*_device.

    cookie: Communication mechanism between caller and library.
    Intended for multi-threaded applications, while
    single-threaded applications set cookie to NULL. The
    caller may abort an ongoing rendering of a page. Cookie also
    communicates progress information back to the caller. The
    fields inside cookie are continually updated while the page is
    rendering.
    """
    return _mupdf.ll_fz_run_document_structure(doc, dev, cookie)

def ll_fz_run_page(page, dev, transform, cookie):
    r"""
    Low-level wrapper for `::fz_run_page()`.
    Run a page through a device.

    page: Page obtained from fz_load_page.

    dev: Device obtained from fz_new_*_device.

    transform: Transform to apply to page. May include for example
    scaling and rotation, see fz_scale, fz_rotate and fz_concat.
    Set to fz_identity if no transformation is desired.

    cookie: Communication mechanism between caller and library
    rendering the page. Intended for multi-threaded applications,
    while single-threaded applications set cookie to NULL. The
    caller may abort an ongoing rendering of a page. Cookie also
    communicates progress information back to the caller. The
    fields inside cookie are continually updated while the page is
    rendering.
    """
    return _mupdf.ll_fz_run_page(page, dev, transform, cookie)

def ll_fz_run_page_annots(page, dev, transform, cookie):
    r"""
    Low-level wrapper for `::fz_run_page_annots()`.
    Run the annotations on a page through a device.
    """
    return _mupdf.ll_fz_run_page_annots(page, dev, transform, cookie)

def ll_fz_run_page_contents(page, dev, transform, cookie):
    r"""
    Low-level wrapper for `::fz_run_page_contents()`.
    Run a page through a device. Just the main
    page content, without the annotations, if any.

    page: Page obtained from fz_load_page.

    dev: Device obtained from fz_new_*_device.

    transform: Transform to apply to page. May include for example
    scaling and rotation, see fz_scale, fz_rotate and fz_concat.
    Set to fz_identity if no transformation is desired.

    cookie: Communication mechanism between caller and library
    rendering the page. Intended for multi-threaded applications,
    while single-threaded applications set cookie to NULL. The
    caller may abort an ongoing rendering of a page. Cookie also
    communicates progress information back to the caller. The
    fields inside cookie are continually updated while the page is
    rendering.
    """
    return _mupdf.ll_fz_run_page_contents(page, dev, transform, cookie)

def ll_fz_run_page_widgets(page, dev, transform, cookie):
    r"""
    Low-level wrapper for `::fz_run_page_widgets()`.
    Run the widgets on a page through a device.
    """
    return _mupdf.ll_fz_run_page_widgets(page, dev, transform, cookie)

def ll_fz_run_t3_glyph(font, gid, trm, dev):
    r"""
    Low-level wrapper for `::fz_run_t3_glyph()`.
    Run a glyph from a Type3 font to
    a given device.

    font: The font to find the glyph in.

    gid: The glyph to run.

    trm: The transform to apply.

    dev: The device to render onto.
    """
    return _mupdf.ll_fz_run_t3_glyph(font, gid, trm, dev)

def ll_fz_runeidx(str, p):
    r"""
    Low-level wrapper for `::fz_runeidx()`.
    Compute the index of a rune in a string.

    str: Pointer to beginning of a string.

    p: Pointer to a char in str.

    Returns the index of the rune pointed to by p in str.
    """
    return _mupdf.ll_fz_runeidx(str, p)

def ll_fz_runelen(rune):
    r"""
    Low-level wrapper for `::fz_runelen()`.
    Count how many chars are required to represent a rune.

    rune: The rune to encode.

    Returns the number of bytes required to represent this run in
    UTF8.
    """
    return _mupdf.ll_fz_runelen(rune)

def ll_fz_runeptr(str, idx):
    r"""
    Low-level wrapper for `::fz_runeptr()`.
    Obtain a pointer to the char representing the rune
    at a given index.

    str: Pointer to beginning of a string.

    idx: Index of a rune to return a char pointer to.

    Returns a pointer to the char where the desired rune starts,
    or NULL if the string ends before the index is reached.
    """
    return _mupdf.ll_fz_runeptr(str, idx)

def ll_fz_runetochar(str, rune):
    r"""
    Low-level wrapper for `::fz_runetochar()`.
    UTF8 encode a rune to a sequence of chars.

    str: Pointer to a place to put the UTF8 encoded character.

    rune: Pointer to a 'rune'.

    Returns the number of bytes the rune took to output.
    """
    return _mupdf.ll_fz_runetochar(str, rune)

def ll_fz_samples_get(pixmap, offset):
    r"""
     Low-level wrapper for `::fz_samples_get()`.
    Provides simple (but slow) access to pixmap data from Python and C#.
    """
    return _mupdf.ll_fz_samples_get(pixmap, offset)

def ll_fz_samples_set(pixmap, offset, value):
    r"""
     Low-level wrapper for `::fz_samples_set()`.
    Provides simple (but slow) write access to pixmap data from Python and
    C#.
    """
    return _mupdf.ll_fz_samples_set(pixmap, offset, value)

def ll_fz_save_accelerator(doc, accel):
    r"""
    Low-level wrapper for `::fz_save_accelerator()`.
    Save accelerator data for the document to a given file.
    """
    return _mupdf.ll_fz_save_accelerator(doc, accel)

def ll_fz_save_bitmap_as_pbm(bitmap, filename):
    r"""
    Low-level wrapper for `::fz_save_bitmap_as_pbm()`.
    Save a bitmap as a pbm.
    """
    return _mupdf.ll_fz_save_bitmap_as_pbm(bitmap, filename)

def ll_fz_save_bitmap_as_pcl(bitmap, filename, append, pcl):
    r"""
    Low-level wrapper for `::fz_save_bitmap_as_pcl()`.
    Save a bitmap as mono PCL.
    """
    return _mupdf.ll_fz_save_bitmap_as_pcl(bitmap, filename, append, pcl)

def ll_fz_save_bitmap_as_pkm(bitmap, filename):
    r"""
    Low-level wrapper for `::fz_save_bitmap_as_pkm()`.
    Save a CMYK bitmap as a pkm.
    """
    return _mupdf.ll_fz_save_bitmap_as_pkm(bitmap, filename)

def ll_fz_save_bitmap_as_pwg(bitmap, filename, append, pwg):
    r"""
    Low-level wrapper for `::fz_save_bitmap_as_pwg()`.
    Save a bitmap as a PWG.
    """
    return _mupdf.ll_fz_save_bitmap_as_pwg(bitmap, filename, append, pwg)

def ll_fz_save_buffer(buf, filename):
    r"""
    Low-level wrapper for `::fz_save_buffer()`.
    Save the contents of a buffer to a file.
    """
    return _mupdf.ll_fz_save_buffer(buf, filename)

def ll_fz_save_pixmap_as_jpeg(pixmap, filename, quality):
    r"""
    Low-level wrapper for `::fz_save_pixmap_as_jpeg()`.
    Save a pixmap as a JPEG.
    """
    return _mupdf.ll_fz_save_pixmap_as_jpeg(pixmap, filename, quality)

def ll_fz_save_pixmap_as_jpx(pixmap, filename, q):
    r"""
    Low-level wrapper for `::fz_save_pixmap_as_jpx()`.
    Save pixmap data as JP2K with no subsampling.

    quality = 100 = lossless
    otherwise for a factor of x compression use 100-x. (so 80 is 1:20 compression)
    """
    return _mupdf.ll_fz_save_pixmap_as_jpx(pixmap, filename, q)

def ll_fz_save_pixmap_as_pam(pixmap, filename):
    r"""
    Low-level wrapper for `::fz_save_pixmap_as_pam()`.
    Save a pixmap as a pnm (greyscale, rgb or cmyk, with or without
    alpha).
    """
    return _mupdf.ll_fz_save_pixmap_as_pam(pixmap, filename)

def ll_fz_save_pixmap_as_pbm(pixmap, filename):
    r"""
    Low-level wrapper for `::fz_save_pixmap_as_pbm()`.
    Save a pixmap as a pbm. (Performing halftoning).
    """
    return _mupdf.ll_fz_save_pixmap_as_pbm(pixmap, filename)

def ll_fz_save_pixmap_as_pcl(pixmap, filename, append, pcl):
    r"""
    Low-level wrapper for `::fz_save_pixmap_as_pcl()`.
    Save an (RGB) pixmap as color PCL.
    """
    return _mupdf.ll_fz_save_pixmap_as_pcl(pixmap, filename, append, pcl)

def ll_fz_save_pixmap_as_pclm(pixmap, filename, append, options):
    r"""
    Low-level wrapper for `::fz_save_pixmap_as_pclm()`.
    Save a (Greyscale or RGB) pixmap as pclm.
    """
    return _mupdf.ll_fz_save_pixmap_as_pclm(pixmap, filename, append, options)

def ll_fz_save_pixmap_as_pdfocr(pixmap, filename, append, options):
    r"""
    Low-level wrapper for `::fz_save_pixmap_as_pdfocr()`.
    Save a (Greyscale or RGB) pixmap as pdfocr.
    """
    return _mupdf.ll_fz_save_pixmap_as_pdfocr(pixmap, filename, append, options)

def ll_fz_save_pixmap_as_pkm(pixmap, filename):
    r"""
    Low-level wrapper for `::fz_save_pixmap_as_pkm()`.
    Save a CMYK pixmap as a pkm. (Performing halftoning).
    """
    return _mupdf.ll_fz_save_pixmap_as_pkm(pixmap, filename)

def ll_fz_save_pixmap_as_png(pixmap, filename):
    r"""
    Low-level wrapper for `::fz_save_pixmap_as_png()`.
    Save a (Greyscale or RGB) pixmap as a png.
    """
    return _mupdf.ll_fz_save_pixmap_as_png(pixmap, filename)

def ll_fz_save_pixmap_as_pnm(pixmap, filename):
    r"""
    Low-level wrapper for `::fz_save_pixmap_as_pnm()`.
    Save a pixmap as a pnm (greyscale or rgb, no alpha).
    """
    return _mupdf.ll_fz_save_pixmap_as_pnm(pixmap, filename)

def ll_fz_save_pixmap_as_ps(pixmap, filename, append):
    r"""
    Low-level wrapper for `::fz_save_pixmap_as_ps()`.
    Save a (gray, rgb, or cmyk, no alpha) pixmap out as postscript.
    """
    return _mupdf.ll_fz_save_pixmap_as_ps(pixmap, filename, append)

def ll_fz_save_pixmap_as_psd(pixmap, filename):
    r"""
    Low-level wrapper for `::fz_save_pixmap_as_psd()`.
    Save a pixmap as a PSD file.
    """
    return _mupdf.ll_fz_save_pixmap_as_psd(pixmap, filename)

def ll_fz_save_pixmap_as_pwg(pixmap, filename, append, pwg):
    r"""
    Low-level wrapper for `::fz_save_pixmap_as_pwg()`.
    Save a pixmap as a PWG.
    """
    return _mupdf.ll_fz_save_pixmap_as_pwg(pixmap, filename, append, pwg)

def ll_fz_scale(sx, sy):
    r"""
    Low-level wrapper for `::fz_scale()`.
    Create a scaling matrix.

    The returned matrix is of the form [ sx 0 0 sy 0 0 ].

    m: Pointer to the matrix to populate

    sx, sy: Scaling factors along the X- and Y-axes. A scaling
    factor of 1.0 will not cause any scaling along the relevant
    axis.

    Returns m.
    """
    return _mupdf.ll_fz_scale(sx, sy)

def ll_fz_scale_pixmap(src, x, y, w, h, clip):
    r""" Low-level wrapper for `::fz_scale_pixmap()`."""
    return _mupdf.ll_fz_scale_pixmap(src, x, y, w, h, clip)

def ll_fz_search_chapter_page_number(doc, chapter, page, needle, hit_mark, hit_bbox, hit_max):
    r"""
     Low-level wrapper for `::fz_search_chapter_page_number()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_fz_search_chapter_page_number(::fz_document *doc, int chapter, int page, const char *needle, ::fz_quad *hit_bbox, int hit_max)` => `(int, int hit_mark)`
    """
    return _mupdf.ll_fz_search_chapter_page_number(doc, chapter, page, needle, hit_mark, hit_bbox, hit_max)

def ll_fz_search_display_list(list, needle, hit_mark, hit_bbox, hit_max):
    r"""
     Low-level wrapper for `::fz_search_display_list()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_fz_search_display_list(::fz_display_list *list, const char *needle, ::fz_quad *hit_bbox, int hit_max)` => `(int, int hit_mark)`
    """
    return _mupdf.ll_fz_search_display_list(list, needle, hit_mark, hit_bbox, hit_max)

def ll_fz_search_page(page, needle, hit_mark, hit_bbox, hit_max):
    r"""
     Low-level wrapper for `::fz_search_page()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_fz_search_page(::fz_page *page, const char *needle, ::fz_quad *hit_bbox, int hit_max)` => `(int, int hit_mark)`

    	Search for the 'needle' text on the page.
    	Record the hits in the hit_bbox array and return the number of
    	hits. Will stop looking once it has filled hit_max rectangles.
    """
    return _mupdf.ll_fz_search_page(page, needle, hit_mark, hit_bbox, hit_max)

def ll_fz_search_page2(doc, number, needle, hit_max):
    r"""
     Low-level wrapper for `::fz_search_page2()`.
    C++ alternative to fz_search_page() that returns information in a std::vector.
    """
    return _mupdf.ll_fz_search_page2(doc, number, needle, hit_max)

def ll_fz_search_page_number(doc, number, needle, hit_mark, hit_bbox, hit_max):
    r"""
     Low-level wrapper for `::fz_search_page_number()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_fz_search_page_number(::fz_document *doc, int number, const char *needle, ::fz_quad *hit_bbox, int hit_max)` => `(int, int hit_mark)`
    """
    return _mupdf.ll_fz_search_page_number(doc, number, needle, hit_mark, hit_bbox, hit_max)

def ll_fz_search_stext_page(text, needle, hit_mark, hit_bbox, hit_max):
    r"""
     Low-level wrapper for `::fz_search_stext_page()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_fz_search_stext_page(::fz_stext_page *text, const char *needle, ::fz_quad *hit_bbox, int hit_max)` => `(int, int hit_mark)`

    	Search for occurrence of 'needle' in text page.

    	Return the number of hits and store hit quads in the passed in
    	array.

    	NOTE: This is an experimental interface and subject to change
    	without notice.
    """
    return _mupdf.ll_fz_search_stext_page(text, needle, hit_mark, hit_bbox, hit_max)

def ll_fz_seek(stm, offset, whence):
    r"""
    Low-level wrapper for `::fz_seek()`.
    Seek within a stream.

    stm: The stream to seek within.

    offset: The offset to seek to.

    whence: From where the offset is measured (see fseek).
    SEEK_SET - start of stream.
    SEEK_CUR - current position.
    SEEK_END - end of stream.

    """
    return _mupdf.ll_fz_seek(stm, offset, whence)

def ll_fz_seek_output(out, off, whence):
    r"""
    Low-level wrapper for `::fz_seek_output()`.
    Seek to the specified file position.
    See fseek for arguments.

    Throw an error on unseekable outputs.
    """
    return _mupdf.ll_fz_seek_output(out, off, whence)

def ll_fz_separation_current_behavior(sep, separation):
    r"""
    Low-level wrapper for `::fz_separation_current_behavior()`.
    Test for the current behavior of a separation.
    """
    return _mupdf.ll_fz_separation_current_behavior(sep, separation)

def ll_fz_separation_equivalent(seps, idx, dst_cs, dst_color, prf, color_params):
    r"""
     Low-level wrapper for `::fz_separation_equivalent()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_fz_separation_equivalent(const ::fz_separations *seps, int idx, ::fz_colorspace *dst_cs, ::fz_colorspace *prf, ::fz_color_params color_params)` => float dst_color

    	Get the equivalent separation color in a given colorspace.
    """
    return _mupdf.ll_fz_separation_equivalent(seps, idx, dst_cs, dst_color, prf, color_params)

def ll_fz_separation_name(sep, separation):
    r""" Low-level wrapper for `::fz_separation_name()`."""
    return _mupdf.ll_fz_separation_name(sep, separation)

def ll_fz_set_aa_level(bits):
    r"""
    Low-level wrapper for `::fz_set_aa_level()`.
    Set the number of bits of antialiasing we should
    use (for both text and graphics).

    bits: The number of bits of antialiasing to use (values are
    clamped to within the 0 to 8 range).
    """
    return _mupdf.ll_fz_set_aa_level(bits)

def ll_fz_set_compressed_image_buffer(cimg, buf):
    r""" Low-level wrapper for `::fz_set_compressed_image_buffer()`."""
    return _mupdf.ll_fz_set_compressed_image_buffer(cimg, buf)

def ll_fz_set_default_cmyk(default_cs, cs):
    r""" Low-level wrapper for `::fz_set_default_cmyk()`."""
    return _mupdf.ll_fz_set_default_cmyk(default_cs, cs)

def ll_fz_set_default_colorspaces(dev, default_cs):
    r""" Low-level wrapper for `::fz_set_default_colorspaces()`."""
    return _mupdf.ll_fz_set_default_colorspaces(dev, default_cs)

def ll_fz_set_default_gray(default_cs, cs):
    r"""
    Low-level wrapper for `::fz_set_default_gray()`.
    Set new defaults within the default colorspace structure.

    New references are taken to the new default, and references to
    the old defaults dropped.

    Never throws exceptions.
    """
    return _mupdf.ll_fz_set_default_gray(default_cs, cs)

def ll_fz_set_default_output_intent(default_cs, cs):
    r""" Low-level wrapper for `::fz_set_default_output_intent()`."""
    return _mupdf.ll_fz_set_default_output_intent(default_cs, cs)

def ll_fz_set_default_rgb(default_cs, cs):
    r""" Low-level wrapper for `::fz_set_default_rgb()`."""
    return _mupdf.ll_fz_set_default_rgb(default_cs, cs)

def ll_fz_set_error_callback(error_cb, user):
    r"""
    Low-level wrapper for `::fz_set_error_callback()`.
    Set the error callback. This will be called as part of the
    exception handling.

    The callback must not throw exceptions!
    """
    return _mupdf.ll_fz_set_error_callback(error_cb, user)

def ll_fz_set_font_bbox(font, xmin, ymin, xmax, ymax):
    r"""
    Low-level wrapper for `::fz_set_font_bbox()`.
    Set the font bbox.

    font: The font to set the bbox for.

    xmin, ymin, xmax, ymax: The bounding box.
    """
    return _mupdf.ll_fz_set_font_bbox(font, xmin, ymin, xmax, ymax)

def ll_fz_set_font_embedding(font, embed):
    r"""
    Low-level wrapper for `::fz_set_font_embedding()`.
    Control whether a given font should be embedded or not when writing.
    """
    return _mupdf.ll_fz_set_font_embedding(font, embed)

def ll_fz_set_graphics_aa_level(bits):
    r"""
    Low-level wrapper for `::fz_set_graphics_aa_level()`.
    Set the number of bits of antialiasing we
    should use for graphics.

    bits: The number of bits of antialiasing to use (values are
    clamped to within the 0 to 8 range).
    """
    return _mupdf.ll_fz_set_graphics_aa_level(bits)

def ll_fz_set_graphics_min_line_width(min_line_width):
    r"""
    Low-level wrapper for `::fz_set_graphics_min_line_width()`.
    Set the minimum line width to be
    used for stroked lines.

    min_line_width: The minimum line width to use (in pixels).
    """
    return _mupdf.ll_fz_set_graphics_min_line_width(min_line_width)

def ll_fz_set_link_rect(link, rect):
    r""" Low-level wrapper for `::fz_set_link_rect()`."""
    return _mupdf.ll_fz_set_link_rect(link, rect)

def ll_fz_set_link_uri(link, uri):
    r""" Low-level wrapper for `::fz_set_link_uri()`."""
    return _mupdf.ll_fz_set_link_uri(link, uri)

def ll_fz_set_metadata(doc, key, value):
    r""" Low-level wrapper for `::fz_set_metadata()`."""
    return _mupdf.ll_fz_set_metadata(doc, key, value)

def ll_fz_set_pixmap_image_tile(cimg, pix):
    r""" Low-level wrapper for `::fz_set_pixmap_image_tile()`."""
    return _mupdf.ll_fz_set_pixmap_image_tile(cimg, pix)

def ll_fz_set_pixmap_resolution(pix, xres, yres):
    r"""
    Low-level wrapper for `::fz_set_pixmap_resolution()`.
    Set the pixels per inch resolution of the pixmap.
    """
    return _mupdf.ll_fz_set_pixmap_resolution(pix, xres, yres)

def ll_fz_set_separation_behavior(sep, separation, behavior):
    r"""
    Low-level wrapper for `::fz_set_separation_behavior()`.
    Control the rendering of a given separation.
    """
    return _mupdf.ll_fz_set_separation_behavior(sep, separation, behavior)

def ll_fz_set_stddbg(out):
    r"""
    Low-level wrapper for `::fz_set_stddbg()`.
    Set the output stream to be used for fz_stddbg. Set to NULL to
    reset to default (stderr).
    """
    return _mupdf.ll_fz_set_stddbg(out)

def ll_fz_set_text_aa_level(bits):
    r"""
    Low-level wrapper for `::fz_set_text_aa_level()`.
    Set the number of bits of antialiasing we
    should use for text.

    bits: The number of bits of antialiasing to use (values are
    clamped to within the 0 to 8 range).
    """
    return _mupdf.ll_fz_set_text_aa_level(bits)

def ll_fz_set_use_document_css(use):
    r"""
    Low-level wrapper for `::fz_set_use_document_css()`.
    Toggle whether to respect document styles in HTML and EPUB.
    """
    return _mupdf.ll_fz_set_use_document_css(use)

def ll_fz_set_user_context(user):
    r"""
    Low-level wrapper for `::fz_set_user_context()`.
    Set the user field in the context.

    NULL initially, this field can be set to any opaque value
    required by the user. It is copied on clones.
    """
    return _mupdf.ll_fz_set_user_context(user)

def ll_fz_set_user_css(text):
    r"""
    Low-level wrapper for `::fz_set_user_css()`.
    Set the user stylesheet source text for use with HTML and EPUB.
    """
    return _mupdf.ll_fz_set_user_css(text)

def ll_fz_set_warning_callback(warning_cb, user):
    r"""
    Low-level wrapper for `::fz_set_warning_callback()`.
    Set the warning callback. This will be called as part of the
    exception handling.

    The callback must not throw exceptions!
    """
    return _mupdf.ll_fz_set_warning_callback(warning_cb, user)

def ll_fz_sha256_final(state, digest):
    r"""
    Low-level wrapper for `::fz_sha256_final()`.
    MD5 finalization. Ends an MD5 message-digest operation, writing
    the message digest and zeroizing the context.

    Never throws an exception.
    """
    return _mupdf.ll_fz_sha256_final(state, digest)

def ll_fz_sha256_init(state):
    r"""
    Low-level wrapper for `::fz_sha256_init()`.
    SHA256 initialization. Begins an SHA256 operation, initialising
    the supplied context.

    Never throws an exception.
    """
    return _mupdf.ll_fz_sha256_init(state)

def ll_fz_sha256_update(state, input, inlen):
    r"""
    Low-level wrapper for `::fz_sha256_update()`.
    SHA256 block update operation. Continues an SHA256 message-
    digest operation, processing another message block, and updating
    the context.

    Never throws an exception.
    """
    return _mupdf.ll_fz_sha256_update(state, input, inlen)

def ll_fz_sha384_final(state, digest):
    r"""
    Low-level wrapper for `::fz_sha384_final()`.
    SHA384 finalization. Ends an SHA384 message-digest operation,
    writing the message digest and zeroizing the context.

    Never throws an exception.
    """
    return _mupdf.ll_fz_sha384_final(state, digest)

def ll_fz_sha384_init(state):
    r"""
    Low-level wrapper for `::fz_sha384_init()`.
    SHA384 initialization. Begins an SHA384 operation, initialising
    the supplied context.

    Never throws an exception.
    """
    return _mupdf.ll_fz_sha384_init(state)

def ll_fz_sha384_update(state, input, inlen):
    r"""
    Low-level wrapper for `::fz_sha384_update()`.
    SHA384 block update operation. Continues an SHA384 message-
    digest operation, processing another message block, and updating
    the context.

    Never throws an exception.
    """
    return _mupdf.ll_fz_sha384_update(state, input, inlen)

def ll_fz_sha512_final(state, digest):
    r"""
    Low-level wrapper for `::fz_sha512_final()`.
    SHA512 finalization. Ends an SHA512 message-digest operation,
    writing the message digest and zeroizing the context.

    Never throws an exception.
    """
    return _mupdf.ll_fz_sha512_final(state, digest)

def ll_fz_sha512_init(state):
    r"""
    Low-level wrapper for `::fz_sha512_init()`.
    SHA512 initialization. Begins an SHA512 operation, initialising
    the supplied context.

    Never throws an exception.
    """
    return _mupdf.ll_fz_sha512_init(state)

def ll_fz_sha512_update(state, input, inlen):
    r"""
    Low-level wrapper for `::fz_sha512_update()`.
    SHA512 block update operation. Continues an SHA512 message-
    digest operation, processing another message block, and updating
    the context.

    Never throws an exception.
    """
    return _mupdf.ll_fz_sha512_update(state, input, inlen)

def ll_fz_shear(sx, sy):
    r"""
    Low-level wrapper for `::fz_shear()`.
    Create a shearing matrix.

    The returned matrix is of the form [ 1 sy sx 1 0 0 ].

    m: pointer to place to store returned matrix

    sx, sy: Shearing factors. A shearing factor of 0.0 will not
    cause any shearing along the relevant axis.

    Returns m.
    """
    return _mupdf.ll_fz_shear(sx, sy)

def ll_fz_show_glyph(text, font, trm, glyph, unicode, wmode, bidi_level, markup_dir, language):
    r"""
    Low-level wrapper for `::fz_show_glyph()`.
    Add a glyph/unicode value to a text object.

    text: Text object to add to.

    font: The font the glyph should be added in.

    trm: The transform to use for the glyph.

    glyph: The glyph id to add.

    unicode: The unicode character for the glyph.

    cid: The CJK CID value or raw character code.

    wmode: 1 for vertical mode, 0 for horizontal.

    bidi_level: The bidirectional level for this glyph.

    markup_dir: The direction of the text as specified in the
    markup.

    language: The language in use (if known, 0 otherwise)
    (e.g. FZ_LANG_zh_Hans).

    Throws exception on failure to allocate.
    """
    return _mupdf.ll_fz_show_glyph(text, font, trm, glyph, unicode, wmode, bidi_level, markup_dir, language)

def ll_fz_show_glyph_aux(text, font, trm, glyph, unicode, cid, wmode, bidi_level, markup_dir, lang):
    r""" Low-level wrapper for `::fz_show_glyph_aux()`."""
    return _mupdf.ll_fz_show_glyph_aux(text, font, trm, glyph, unicode, cid, wmode, bidi_level, markup_dir, lang)

def ll_fz_show_string(text, font, trm, s, wmode, bidi_level, markup_dir, language):
    r"""
    Low-level wrapper for `::fz_show_string()`.
    Add a UTF8 string to a text object.

    text: Text object to add to.

    font: The font the string should be added in.

    trm: The transform to use.

    s: The utf-8 string to add.

    wmode: 1 for vertical mode, 0 for horizontal.

    bidi_level: The bidirectional level for this glyph.

    markup_dir: The direction of the text as specified in the markup.

    language: The language in use (if known, 0 otherwise)
    	(e.g. FZ_LANG_zh_Hans).

    Returns the transform updated with the advance width of the
    string.
    """
    return _mupdf.ll_fz_show_string(text, font, trm, s, wmode, bidi_level, markup_dir, language)

def ll_fz_shrink_store(percent):
    r"""
    Low-level wrapper for `::fz_shrink_store()`.
    Evict items from the store until the total size of
    the objects in the store is reduced to a given percentage of its
    current size.

    percent: %age of current size to reduce the store to.

    Returns non zero if we managed to free enough memory, zero
    otherwise.
    """
    return _mupdf.ll_fz_shrink_store(percent)

def ll_fz_skip(stm, len):
    r"""
    Low-level wrapper for `::fz_skip()`.
    Read from a stream discarding data.

    stm: The stream to read from.

    len: The number of bytes to read.

    Returns the number of bytes read. May throw exceptions.
    """
    return _mupdf.ll_fz_skip(stm, len)

def ll_fz_skip_space(stm):
    r"""
    Low-level wrapper for `::fz_skip_space()`.
    Skip over whitespace (bytes <= 32) in a stream.
    """
    return _mupdf.ll_fz_skip_space(stm)

def ll_fz_skip_string(stm, str):
    r"""
    Low-level wrapper for `::fz_skip_string()`.
    Skip over a given string in a stream. Return 0 if successfully
    skipped, non-zero otherwise. As many characters will be skipped
    over as matched in the string.
    """
    return _mupdf.ll_fz_skip_string(stm, str)

def ll_fz_slice_buffer(buf, start, end):
    r"""
    Low-level wrapper for `::fz_slice_buffer()`.
    Create a new buffer with a (subset of) the data from the buffer.

    start: if >= 0, offset from start of buffer, if < 0 offset from end of buffer.

    end: if >= 0, offset from start of buffer, if < 0 offset from end of buffer.

    """
    return _mupdf.ll_fz_slice_buffer(buf, start, end)

def ll_fz_snap_selection(page, ap, bp, mode):
    r""" Low-level wrapper for `::fz_snap_selection()`."""
    return _mupdf.ll_fz_snap_selection(page, ap, bp, mode)

def ll_fz_start_throw_on_repair():
    r""" Low-level wrapper for `::fz_start_throw_on_repair()`."""
    return _mupdf.ll_fz_start_throw_on_repair()

def ll_fz_stat_ctime(path):
    r""" Low-level wrapper for `::fz_stat_ctime()`."""
    return _mupdf.ll_fz_stat_ctime(path)

def ll_fz_stat_mtime(path):
    r""" Low-level wrapper for `::fz_stat_mtime()`."""
    return _mupdf.ll_fz_stat_mtime(path)

def ll_fz_stddbg():
    r"""
    Low-level wrapper for `::fz_stddbg()`.
    Retrieve an fz_output for the default debugging stream. On
    Windows this will be OutputDebugString for non-console apps.
    Otherwise, it is always fz_stderr.

    Optionally may be fz_dropped when finished with.
    """
    return _mupdf.ll_fz_stddbg()

def ll_fz_stderr():
    r"""
    Low-level wrapper for `::fz_stderr()`.
    Retrieve an fz_output that directs to stdout.

    Optionally may be fz_dropped when finished with.
    """
    return _mupdf.ll_fz_stderr()

def ll_fz_stdout():
    r"""
    Low-level wrapper for `::fz_stdout()`.
    Retrieve an fz_output that directs to stdout.

    Optionally may be fz_dropped when finished with.
    """
    return _mupdf.ll_fz_stdout()

def ll_fz_store_item(key, val, itemsize, type):
    r"""
    Low-level wrapper for `::fz_store_item()`.
    Add an item to the store.

    Add an item into the store, returning NULL for success. If an
    item with the same key is found in the store, then our item will
    not be inserted, and the function will return a pointer to that
    value instead. This function takes its own reference to val, as
    required (i.e. the caller maintains ownership of its own
    reference).

    key: The key used to index the item.

    val: The value to store.

    itemsize: The size in bytes of the value (as counted towards the
    store size).

    type: Functions used to manipulate the key.
    """
    return _mupdf.ll_fz_store_item(key, val, itemsize, type)

def ll_fz_store_scavenge(size, phase):
    r"""
     Low-level wrapper for `::fz_store_scavenge()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_fz_store_scavenge(size_t size)` => `(int, int phase)`

    	Internal function used as part of the scavenging
    	allocator; when we fail to allocate memory, before returning a
    	failure to the caller, we try to scavenge space within the store
    	by evicting at least 'size' bytes. The allocator then retries.

    	size: The number of bytes we are trying to have free.

    	phase: What phase of the scavenge we are in. Updated on exit.

    	Returns non zero if we managed to free any memory.
    """
    return _mupdf.ll_fz_store_scavenge(size, phase)

def ll_fz_store_scavenge_external(size, phase):
    r"""
     Low-level wrapper for `::fz_store_scavenge_external()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_fz_store_scavenge_external(size_t size)` => `(int, int phase)`

    	External function for callers to use
    	to scavenge while trying allocations.

    	size: The number of bytes we are trying to have free.

    	phase: What phase of the scavenge we are in. Updated on exit.

    	Returns non zero if we managed to free any memory.
    """
    return _mupdf.ll_fz_store_scavenge_external(size, phase)

def ll_fz_story_document(story):
    r""" Low-level wrapper for `::fz_story_document()`."""
    return _mupdf.ll_fz_story_document(story)

def ll_fz_story_positions(story, cb, arg):
    r""" Low-level wrapper for `::fz_story_positions()`."""
    return _mupdf.ll_fz_story_positions(story, cb, arg)

def ll_fz_story_warnings(story):
    r""" Low-level wrapper for `::fz_story_warnings()`."""
    return _mupdf.ll_fz_story_warnings(story)

def ll_fz_strcasecmp(a, b):
    r"""
    Low-level wrapper for `::fz_strcasecmp()`.
    Case insensitive (ASCII only) string comparison.
    """
    return _mupdf.ll_fz_strcasecmp(a, b)

def ll_fz_strdup(s):
    r"""
    Low-level wrapper for `::fz_strdup()`.
    Portable strdup implementation, using fz allocators.
    """
    return _mupdf.ll_fz_strdup(s)

def ll_fz_stream_from_output(arg_1):
    r"""
    Low-level wrapper for `::fz_stream_from_output()`.
    Obtain the fz_output in the form of a fz_stream.

    This allows data to be read back from some forms of fz_output
    object. When finished reading, the fz_stream should be released
    by calling fz_drop_stream. Until the fz_stream is dropped, no
    further operations should be performed on the fz_output object.
    """
    return _mupdf.ll_fz_stream_from_output(arg_1)

def ll_fz_string_from_box_type(box):
    r""" Low-level wrapper for `::fz_string_from_box_type()`."""
    return _mupdf.ll_fz_string_from_box_type(box)

def ll_fz_string_from_buffer(buf):
    r"""
    Low-level wrapper for `::fz_string_from_buffer()`.
    Ensure that a buffer's data ends in a
    0 byte, and return a pointer to it.
    """
    return _mupdf.ll_fz_string_from_buffer(buf)

def ll_fz_string_from_text_language(str, lang):
    r"""
    Low-level wrapper for `::fz_string_from_text_language()`.
    Recover ISO 639 (639-{1,2,3,5}) language specification
    strings losslessly from a 15 bit fz_text_language code.

    No validation is carried out. See note above.
    """
    return _mupdf.ll_fz_string_from_text_language(str, lang)

def ll_fz_string_from_text_language2(lang):
    r"""
     Low-level wrapper for `::fz_string_from_text_language2()`.
    C++ alternative to fz_string_from_text_language() that returns information in a std::string.
    """
    return _mupdf.ll_fz_string_from_text_language2(lang)

def ll_fz_strlcat(dst, src, n):
    r"""
    Low-level wrapper for `::fz_strlcat()`.
    Concatenate 2 strings, with a maximum length.

    dst: pointer to first string in a buffer of n bytes.

    src: pointer to string to concatenate.

    n: Size (in bytes) of buffer that dst is in.

    Returns the real length that a concatenated dst + src would have
    been (not including terminator).
    """
    return _mupdf.ll_fz_strlcat(dst, src, n)

def ll_fz_strlcpy(dst, src, n):
    r"""
    Low-level wrapper for `::fz_strlcpy()`.
    Copy at most n-1 chars of a string into a destination
    buffer with null termination, returning the real length of the
    initial string (excluding terminator).

    dst: Destination buffer, at least n bytes long.

    src: C string (non-NULL).

    n: Size of dst buffer in bytes.

    Returns the length (excluding terminator) of src.
    """
    return _mupdf.ll_fz_strlcpy(dst, src, n)

def ll_fz_strncasecmp(a, b, n):
    r""" Low-level wrapper for `::fz_strncasecmp()`."""
    return _mupdf.ll_fz_strncasecmp(a, b, n)

def ll_fz_strnlen(s, maxlen):
    r"""
    Low-level wrapper for `::fz_strnlen()`.
    Return strlen(s), if that is less than maxlen, or maxlen if
    there is no null byte ('') among the first maxlen bytes.
    """
    return _mupdf.ll_fz_strnlen(s, maxlen)

def ll_fz_stroke_path(dev, path, stroke, ctm, colorspace, color, alpha, color_params):
    r""" Low-level wrapper for `::fz_stroke_path()`."""
    return _mupdf.ll_fz_stroke_path(dev, path, stroke, ctm, colorspace, color, alpha, color_params)

def ll_fz_stroke_text(dev, text, stroke, ctm, colorspace, color, alpha, color_params):
    r""" Low-level wrapper for `::fz_stroke_text()`."""
    return _mupdf.ll_fz_stroke_text(dev, text, stroke, ctm, colorspace, color, alpha, color_params)

def ll_fz_strsep(stringp, delim):
    r"""
     Low-level wrapper for `::fz_strsep()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_fz_strsep(const char *delim)` => `(char *, char *stringp)`

    	Given a pointer to a C string (or a pointer to NULL) break
    	it at the first occurrence of a delimiter char (from a given
    	set).

    	stringp: Pointer to a C string pointer (or NULL). Updated on
    	exit to point to the first char of the string after the
    	delimiter that was found. The string pointed to by stringp will
    	be corrupted by this call (as the found delimiter will be
    	overwritten by 0).

    	delim: A C string of acceptable delimiter characters.

    	Returns a pointer to a C string containing the chars of stringp
    	up to the first delimiter char (or the end of the string), or
    	NULL.
    """
    return _mupdf.ll_fz_strsep(stringp, delim)

def ll_fz_strtof(s, es):
    r"""
     Low-level wrapper for `::fz_strtof()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_fz_strtof(const char *s)` => `(float, char *es)`

    	Locale-independent decimal to binary conversion. On overflow
    	return (-)INFINITY and set errno to ERANGE. On underflow return
    	0 and set errno to ERANGE. Special inputs (case insensitive):
    	"NAN", "INF" or "INFINITY".
    """
    return _mupdf.ll_fz_strtof(s, es)

def ll_fz_structure_from_string(str):
    r""" Low-level wrapper for `::fz_structure_from_string()`."""
    return _mupdf.ll_fz_structure_from_string(str)

def ll_fz_structure_to_string(type):
    r""" Low-level wrapper for `::fz_structure_to_string()`."""
    return _mupdf.ll_fz_structure_to_string(type)

def ll_fz_subpixel_adjust(ctm, subpix_ctm, qe, qf):
    r"""
    Low-level wrapper for `::fz_subpixel_adjust()`.
    Perform subpixel quantisation and adjustment on a glyph matrix.

    ctm: On entry, the desired 'ideal' transformation for a glyph.
    On exit, adjusted to a (very similar) transformation quantised
    for subpixel caching.

    subpix_ctm: Initialised by the routine to the transform that
    should be used to render the glyph.

    qe, qf: which subpixel position we quantised to.

    Returns: the size of the glyph.

    Note: This is currently only exposed for use in our app. It
    should be considered "at risk" of removal from the API.
    """
    return _mupdf.ll_fz_subpixel_adjust(ctm, subpix_ctm, qe, qf)

def ll_fz_subsample_pixmap(tile, factor):
    r""" Low-level wrapper for `::fz_subsample_pixmap()`."""
    return _mupdf.ll_fz_subsample_pixmap(tile, factor)

def ll_fz_subset_cff_for_gids(orig, gids, num_gids, symbolic, cidfont):
    r"""
     Low-level wrapper for `::fz_subset_cff_for_gids()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_fz_subset_cff_for_gids(::fz_buffer *orig, int num_gids, int symbolic, int cidfont)` => `(fz_buffer *, int gids)`
    """
    return _mupdf.ll_fz_subset_cff_for_gids(orig, gids, num_gids, symbolic, cidfont)

def ll_fz_subset_ttf_for_gids(orig, gids, num_gids, symbolic, cidfont):
    r"""
     Low-level wrapper for `::fz_subset_ttf_for_gids()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_fz_subset_ttf_for_gids(::fz_buffer *orig, int num_gids, int symbolic, int cidfont)` => `(fz_buffer *, int gids)`
    """
    return _mupdf.ll_fz_subset_ttf_for_gids(orig, gids, num_gids, symbolic, cidfont)

def ll_fz_sync_bits(stm):
    r"""
    Low-level wrapper for `::fz_sync_bits()`.
    Called after reading bits to tell the stream
    that we are about to return to reading bytewise. Resyncs
    the stream to whole byte boundaries.
    """
    return _mupdf.ll_fz_sync_bits(stm)

def ll_fz_tell(stm):
    r"""
    Low-level wrapper for `::fz_tell()`.
    return the current reading position within a stream
    """
    return _mupdf.ll_fz_tell(stm)

def ll_fz_tell_output(out):
    r"""
    Low-level wrapper for `::fz_tell_output()`.
    Return the current file position.

    Throw an error on untellable outputs.
    """
    return _mupdf.ll_fz_tell_output(out)

def ll_fz_terminate_buffer(buf):
    r"""
    Low-level wrapper for `::fz_terminate_buffer()`.
    Zero-terminate buffer in order to use as a C string.

    This byte is invisible and does not affect the length of the
    buffer as returned by fz_buffer_storage. The zero byte is
    written *after* the data, and subsequent writes will overwrite
    the terminating byte.

    Subsequent changes to the size of the buffer (such as by
    fz_buffer_trim, fz_buffer_grow, fz_resize_buffer, etc) may
    invalidate this.
    """
    return _mupdf.ll_fz_terminate_buffer(buf)

def ll_fz_text_aa_level():
    r"""
    Low-level wrapper for `::fz_text_aa_level()`.
    Get the number of bits of antialiasing we are
    using for text. Between 0 and 8.
    """
    return _mupdf.ll_fz_text_aa_level()

def ll_fz_text_language_from_string(str):
    r"""
    Low-level wrapper for `::fz_text_language_from_string()`.
    Convert ISO 639 (639-{1,2,3,5}) language specification
    strings losslessly to a 15 bit fz_text_language code.

    No validation is carried out. Obviously invalid (out
    of spec) codes will be mapped to FZ_LANG_UNSET, but
    well-formed (but undefined) codes will be blithely
    accepted.
    """
    return _mupdf.ll_fz_text_language_from_string(str)

def ll_fz_tint_pixmap(pix, black, white):
    r"""
    Low-level wrapper for `::fz_tint_pixmap()`.
    Tint all the pixels in an RGB, BGR, or Gray pixmap.

    black: Map black to this hexadecimal RGB color.

    white: Map white to this hexadecimal RGB color.
    """
    return _mupdf.ll_fz_tint_pixmap(pix, black, white)

def ll_fz_tolower(c):
    r"""
    Low-level wrapper for `::fz_tolower()`.
    Unicode aware tolower and toupper functions.
    """
    return _mupdf.ll_fz_tolower(c)

def ll_fz_toupper(c):
    r""" Low-level wrapper for `::fz_toupper()`."""
    return _mupdf.ll_fz_toupper(c)

def ll_fz_transform_page(mediabox, resolution, rotate):
    r"""
    Low-level wrapper for `::fz_transform_page()`.
    Create transform matrix to draw page
    at a given resolution and rotation. Adjusts the scaling
    factors so that the page covers whole number of
    pixels and adjust the page origin to be at 0,0.
    """
    return _mupdf.ll_fz_transform_page(mediabox, resolution, rotate)

def ll_fz_transform_path(path, transform):
    r"""
    Low-level wrapper for `::fz_transform_path()`.
    Transform a path by a given
    matrix.

    path: The path to modify (must not be a packed path).

    transform: The transform to apply.

    Throws exceptions if the path is packed, or on failure
    to allocate.
    """
    return _mupdf.ll_fz_transform_path(path, transform)

def ll_fz_transform_point(point, m):
    r"""
    Low-level wrapper for `::fz_transform_point()`.
    Apply a transformation to a point.

    transform: Transformation matrix to apply. See fz_concat,
    fz_scale, fz_rotate and fz_translate for how to create a
    matrix.

    point: Pointer to point to update.

    Returns transform (unchanged).
    """
    return _mupdf.ll_fz_transform_point(point, m)

def ll_fz_transform_point_xy(x, y, m):
    r""" Low-level wrapper for `::fz_transform_point_xy()`."""
    return _mupdf.ll_fz_transform_point_xy(x, y, m)

def ll_fz_transform_quad(q, m):
    r"""
    Low-level wrapper for `::fz_transform_quad()`.
    Transform a quad by a matrix.
    """
    return _mupdf.ll_fz_transform_quad(q, m)

def ll_fz_transform_rect(rect, m):
    r"""
    Low-level wrapper for `::fz_transform_rect()`.
    Apply a transform to a rectangle.

    After the four corner points of the axis-aligned rectangle
    have been transformed it may not longer be axis-aligned. So a
    new axis-aligned rectangle is created covering at least the
    area of the transformed rectangle.

    transform: Transformation matrix to apply. See fz_concat,
    fz_scale and fz_rotate for how to create a matrix.

    rect: Rectangle to be transformed. The two special cases
    fz_empty_rect and fz_infinite_rect, may be used but are
    returned unchanged as expected.
    """
    return _mupdf.ll_fz_transform_rect(rect, m)

def ll_fz_transform_vector(vector, m):
    r"""
    Low-level wrapper for `::fz_transform_vector()`.
    Apply a transformation to a vector.

    transform: Transformation matrix to apply. See fz_concat,
    fz_scale and fz_rotate for how to create a matrix. Any
    translation will be ignored.

    vector: Pointer to vector to update.
    """
    return _mupdf.ll_fz_transform_vector(vector, m)

def ll_fz_translate(tx, ty):
    r"""
    Low-level wrapper for `::fz_translate()`.
    Create a translation matrix.

    The returned matrix is of the form [ 1 0 0 1 tx ty ].

    m: A place to store the created matrix.

    tx, ty: Translation distances along the X- and Y-axes. A
    translation of 0 will not cause any translation along the
    relevant axis.

    Returns m.
    """
    return _mupdf.ll_fz_translate(tx, ty)

def ll_fz_translate_irect(a, xoff, yoff):
    r""" Low-level wrapper for `::fz_translate_irect()`."""
    return _mupdf.ll_fz_translate_irect(a, xoff, yoff)

def ll_fz_translate_rect(a, xoff, yoff):
    r"""
    Low-level wrapper for `::fz_translate_rect()`.
    Translate bounding box.

    Translate a bbox by a given x and y offset. Allows for overflow.
    """
    return _mupdf.ll_fz_translate_rect(a, xoff, yoff)

def ll_fz_tree_archive_add_buffer(arch_, name, buf):
    r"""
    Low-level wrapper for `::fz_tree_archive_add_buffer()`.
    Add a named buffer to an existing tree archive.

    The tree will take a new reference to the buffer. Ownership
    is not transferred.
    """
    return _mupdf.ll_fz_tree_archive_add_buffer(arch_, name, buf)

def ll_fz_tree_archive_add_data(arch_, name, data, size):
    r"""
    Low-level wrapper for `::fz_tree_archive_add_data()`.
    Add a named block of data to an existing tree archive.

    The data will be copied into a buffer, and so the caller
    may free it as soon as this returns.
    """
    return _mupdf.ll_fz_tree_archive_add_data(arch_, name, data, size)

def ll_fz_tree_insert(root, key, value):
    r"""
    Low-level wrapper for `::fz_tree_insert()`.
    Insert a new key/value pair and rebalance the tree.
    Return the new root of the tree after inserting and rebalancing.
    May be called with a NULL root to create a new tree.

    No data is copied into the tree structure; key and value are
    merely kept as pointers.
    """
    return _mupdf.ll_fz_tree_insert(root, key, value)

def ll_fz_tree_lookup(node, key):
    r"""
    Low-level wrapper for `::fz_tree_lookup()`.
    Look for the value of a node in the tree with the given key.

    Simple pointer equivalence is used for key.

    Returns NULL for no match.
    """
    return _mupdf.ll_fz_tree_lookup(node, key)

def ll_fz_trim_buffer(buf):
    r"""
    Low-level wrapper for `::fz_trim_buffer()`.
    Trim wasted capacity from a buffer by resizing internal memory.
    """
    return _mupdf.ll_fz_trim_buffer(buf)

def ll_fz_trim_path(path):
    r"""
    Low-level wrapper for `::fz_trim_path()`.
    Minimise the internal storage used by a path.

    As paths are constructed, the internal buffers
    grow. To avoid repeated reallocations they
    grow with some spare space. Once a path has
    been fully constructed, this call allows the
    excess space to be trimmed.
    """
    return _mupdf.ll_fz_trim_path(path)

def ll_fz_truncate_output(arg_1):
    r"""
    Low-level wrapper for `::fz_truncate_output()`.
    Truncate the output at the current position.

    This allows output streams which have seeked back from the end
    of their storage to be truncated at the current point.
    """
    return _mupdf.ll_fz_truncate_output(arg_1)

def ll_fz_try_invert_matrix(inv, src):
    r"""
    Low-level wrapper for `::fz_try_invert_matrix()`.
    Attempt to create an inverse matrix.

    inverse: Place to store inverse matrix.

    matrix: Matrix to invert. A degenerate matrix, where the
    determinant is equal to zero, can not be inverted.

    Returns 1 if matrix is degenerate (singular), or 0 otherwise.
    """
    return _mupdf.ll_fz_try_invert_matrix(inv, src)

def ll_fz_try_open_archive_entry(arch, name):
    r"""
    Low-level wrapper for `::fz_try_open_archive_entry()`.
    Opens an archive entry as a stream.

    Returns NULL if a matching entry cannot be found, otherwise
    behaves exactly as fz_open_archive_entry.
    """
    return _mupdf.ll_fz_try_open_archive_entry(arch, name)

def ll_fz_try_open_archive_with_stream(file):
    r"""
    Low-level wrapper for `::fz_try_open_archive_with_stream()`.
    Open zip or tar archive stream.

    Does the same as fz_open_archive_with_stream, but will not throw
    an error in the event of failing to recognise the format. Will
    still throw errors in other cases though!
    """
    return _mupdf.ll_fz_try_open_archive_with_stream(file)

def ll_fz_try_open_file(name):
    r"""
    Low-level wrapper for `::fz_try_open_file()`.
    Open the named file and wrap it in a stream.

    Does the same as fz_open_file, but in the event the file
    does not open, it will return NULL rather than throw an
    exception.
    """
    return _mupdf.ll_fz_try_open_file(name)

def ll_fz_try_parse_xml_archive_entry(dir, filename, preserve_white):
    r"""
    Low-level wrapper for `::fz_try_parse_xml_archive_entry()`.
    Try and parse the contents of an archive entry into a tree of xml nodes.

    preserve_white: whether to keep or delete all-whitespace nodes.

    Will return NULL if the archive entry can't be found. Otherwise behaves
    the same as fz_parse_xml_archive_entry. May throw exceptions.
    """
    return _mupdf.ll_fz_try_parse_xml_archive_entry(dir, filename, preserve_white)

def ll_fz_try_read_archive_entry(arch, name):
    r"""
    Low-level wrapper for `::fz_try_read_archive_entry()`.
    Reads all bytes in an archive entry
    into a buffer.

    name: Entry name to look for, this must be an exact match to
    the entry name in the archive.

    Returns NULL if a matching entry cannot be found. Otherwise behaves
    the same as fz_read_archive_entry. Exceptions may be thrown.
    """
    return _mupdf.ll_fz_try_read_archive_entry(arch, name)

def ll_fz_try_read_file(filename):
    r"""
    Low-level wrapper for `::fz_try_read_file()`.
    Read all the contents of a file into a buffer.

    Returns NULL if the file does not exist, otherwise
    behaves exactly as fz_read_file.
    """
    return _mupdf.ll_fz_try_read_file(filename)

def ll_fz_tune_image_decode(image_decode, arg):
    r"""
    Low-level wrapper for `::fz_tune_image_decode()`.
    Set the tuning function to use for
    image decode.

    image_decode: Function to use.

    arg: Opaque argument to be passed to tuning function.
    """
    return _mupdf.ll_fz_tune_image_decode(image_decode, arg)

def ll_fz_tune_image_scale(image_scale, arg):
    r"""
    Low-level wrapper for `::fz_tune_image_scale()`.
    Set the tuning function to use for
    image scaling.

    image_scale: Function to use.

    arg: Opaque argument to be passed to tuning function.
    """
    return _mupdf.ll_fz_tune_image_scale(image_scale, arg)

def ll_fz_unicode_from_glyph_name(name):
    r""" Low-level wrapper for `::fz_unicode_from_glyph_name()`."""
    return _mupdf.ll_fz_unicode_from_glyph_name(name)

def ll_fz_unicode_from_glyph_name_strict(name):
    r""" Low-level wrapper for `::fz_unicode_from_glyph_name_strict()`."""
    return _mupdf.ll_fz_unicode_from_glyph_name_strict(name)

def ll_fz_union_rect(a, b):
    r"""
    Low-level wrapper for `::fz_union_rect()`.
    Compute union of two rectangles.

    Given two rectangles, update the first to be the smallest
    axis-aligned rectangle that encompasses both given rectangles.
    If either rectangle is infinite then the union is also infinite.
    If either rectangle is empty then the union is simply the
    non-empty rectangle. Should both rectangles be empty, then the
    union is also empty.
    """
    return _mupdf.ll_fz_union_rect(a, b)

def ll_fz_unlock(lock):
    r"""
    Low-level wrapper for `::fz_unlock()`.
    Unlock one of the user supplied mutexes.
    """
    return _mupdf.ll_fz_unlock(lock)

def ll_fz_unpack_stream(src, depth, w, h, n, indexed, pad, skip):
    r""" Low-level wrapper for `::fz_unpack_stream()`."""
    return _mupdf.ll_fz_unpack_stream(src, depth, w, h, n, indexed, pad, skip)

def ll_fz_unread_byte(stm):
    r"""
    Low-level wrapper for `::fz_unread_byte()`.
    Unread the single last byte successfully
    read from a stream. Do not call this without having
    successfully read a byte.

    stm: The stream to operate upon.
    """
    return _mupdf.ll_fz_unread_byte(stm)

def ll_fz_unshare_stroke_state(shared):
    r"""
    Low-level wrapper for `::fz_unshare_stroke_state()`.
    Given a reference to a (possibly) shared stroke_state structure,
    return a reference to an equivalent stroke_state structure
    that is guaranteed to be unshared (i.e. one that can
    safely be modified).

    shared: The reference to a (possibly) shared structure
    to unshare. Ownership of this reference is passed in
    to this function, even in the case of exceptions being
    thrown.

    Exceptions may be thrown in the event of failure to
    allocate if required.
    """
    return _mupdf.ll_fz_unshare_stroke_state(shared)

def ll_fz_unshare_stroke_state_with_dash_len(shared, len):
    r"""
    Low-level wrapper for `::fz_unshare_stroke_state_with_dash_len()`.
    Given a reference to a (possibly) shared stroke_state structure,
    return a reference to a stroke_state structure (with room for a
    given amount of dash data) that is guaranteed to be unshared
    (i.e. one that can safely be modified).

    shared: The reference to a (possibly) shared structure
    to unshare. Ownership of this reference is passed in
    to this function, even in the case of exceptions being
    thrown.

    Exceptions may be thrown in the event of failure to
    allocate if required.
    """
    return _mupdf.ll_fz_unshare_stroke_state_with_dash_len(shared, len)

def ll_fz_urldecode(url):
    r"""
    Low-level wrapper for `::fz_urldecode()`.
    Like fz_decode_uri_component but in-place.
    """
    return _mupdf.ll_fz_urldecode(url)

def ll_fz_use_document_css():
    r"""
    Low-level wrapper for `::fz_use_document_css()`.
    Return whether to respect document styles in HTML and EPUB.
    """
    return _mupdf.ll_fz_use_document_css()

def ll_fz_user_context():
    r"""
    Low-level wrapper for `::fz_user_context()`.
    Read the user field from the context.
    """
    return _mupdf.ll_fz_user_context()

def ll_fz_user_css():
    r"""
    Low-level wrapper for `::fz_user_css()`.
    Get the user stylesheet source text.
    """
    return _mupdf.ll_fz_user_css()

def ll_fz_utflen(s):
    r"""
    Low-level wrapper for `::fz_utflen()`.
    Count how many runes the UTF-8 encoded string
    consists of.

    s: The UTF-8 encoded, NUL-terminated text string.

    Returns the number of runes in the string.
    """
    return _mupdf.ll_fz_utflen(s)

def ll_fz_var_imp(arg_0):
    r""" Low-level wrapper for `::fz_var_imp()`."""
    return _mupdf.ll_fz_var_imp(arg_0)

def ll_fz_walk_path(path, walker, arg):
    r"""
    Low-level wrapper for `::fz_walk_path()`.
    Walk the segments of a path, calling the
    appropriate callback function from a given set for each
    segment of the path.

    path: The path to walk.

    walker: The set of callback functions to use. The first
    4 callback pointers in the set must be non-NULL. The
    subsequent ones can either be supplied, or can be left
    as NULL, in which case the top 4 functions will be
    called as appropriate to simulate them.

    arg: An opaque argument passed in to each callback.

    Exceptions will only be thrown if the underlying callback
    functions throw them.
    """
    return _mupdf.ll_fz_walk_path(path, walker, arg)

def ll_fz_warn(*args):
    r""" Low-level wrapper for `::fz_warn()`."""
    return _mupdf.ll_fz_warn(*args)

def ll_fz_warning_callback(user):
    r"""
     Low-level wrapper for `::fz_warning_callback()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_fz_warning_callback()` => `(fz_warning_cb *, void *user)`

    	Retrieve the currently set warning callback, or NULL if none
    	has been set. Optionally, if user is non-NULL, the user pointer
    	given when the warning callback was set is also passed back to
    	the caller.
    """
    return _mupdf.ll_fz_warning_callback(user)

def ll_fz_warp_pixmap(src, points, width, height):
    r""" Low-level wrapper for `::fz_warp_pixmap()`."""
    return _mupdf.ll_fz_warp_pixmap(src, points, width, height)

def ll_fz_windows_1250_from_unicode(u):
    r""" Low-level wrapper for `::fz_windows_1250_from_unicode()`."""
    return _mupdf.ll_fz_windows_1250_from_unicode(u)

def ll_fz_windows_1251_from_unicode(u):
    r""" Low-level wrapper for `::fz_windows_1251_from_unicode()`."""
    return _mupdf.ll_fz_windows_1251_from_unicode(u)

def ll_fz_windows_1252_from_unicode(u):
    r""" Low-level wrapper for `::fz_windows_1252_from_unicode()`."""
    return _mupdf.ll_fz_windows_1252_from_unicode(u)

def ll_fz_write_band(writer, stride, band_height, samples):
    r"""
    Low-level wrapper for `::fz_write_band()`.
    Cause a band writer to write the next band
    of data for an image.

    stride: The byte offset from the first byte of the data
    for a pixel to the first byte of the data for the same pixel
    on the row below.

    band_height: The number of lines in this band.

    samples: Pointer to first byte of the data.
    """
    return _mupdf.ll_fz_write_band(writer, stride, band_height, samples)

def ll_fz_write_base64(out, data, size, newline):
    r"""
    Low-level wrapper for `::fz_write_base64()`.
    Write a base64 encoded data block, optionally with periodic
    newlines.
    """
    return _mupdf.ll_fz_write_base64(out, data, size, newline)

def ll_fz_write_base64_buffer(out, data, newline):
    r"""
    Low-level wrapper for `::fz_write_base64_buffer()`.
    Write a base64 encoded fz_buffer, optionally with periodic
    newlines.
    """
    return _mupdf.ll_fz_write_base64_buffer(out, data, newline)

def ll_fz_write_bitmap_as_pbm(out, bitmap):
    r"""
    Low-level wrapper for `::fz_write_bitmap_as_pbm()`.
    Write a bitmap as a pbm.
    """
    return _mupdf.ll_fz_write_bitmap_as_pbm(out, bitmap)

def ll_fz_write_bitmap_as_pcl(out, bitmap, pcl):
    r"""
    Low-level wrapper for `::fz_write_bitmap_as_pcl()`.
    Write a bitmap as mono PCL.
    """
    return _mupdf.ll_fz_write_bitmap_as_pcl(out, bitmap, pcl)

def ll_fz_write_bitmap_as_pkm(out, bitmap):
    r"""
    Low-level wrapper for `::fz_write_bitmap_as_pkm()`.
    Write a CMYK bitmap as a pkm.
    """
    return _mupdf.ll_fz_write_bitmap_as_pkm(out, bitmap)

def ll_fz_write_bitmap_as_pwg(out, bitmap, pwg):
    r"""
    Low-level wrapper for `::fz_write_bitmap_as_pwg()`.
    Write a bitmap as a PWG.
    """
    return _mupdf.ll_fz_write_bitmap_as_pwg(out, bitmap, pwg)

def ll_fz_write_bitmap_as_pwg_page(out, bitmap, pwg):
    r"""
    Low-level wrapper for `::fz_write_bitmap_as_pwg_page()`.
    Write a bitmap as a PWG page.

    Caller should provide a file header by calling
    fz_write_pwg_file_header, but can then write several pages to
    the same file.
    """
    return _mupdf.ll_fz_write_bitmap_as_pwg_page(out, bitmap, pwg)

def ll_fz_write_bits(out, data, num_bits):
    r"""
    Low-level wrapper for `::fz_write_bits()`.
    Write num_bits of data to the end of the output stream, assumed to be packed
    most significant bits first.
    """
    return _mupdf.ll_fz_write_bits(out, data, num_bits)

def ll_fz_write_bits_sync(out):
    r"""
    Low-level wrapper for `::fz_write_bits_sync()`.
    Sync to byte boundary after writing bits.
    """
    return _mupdf.ll_fz_write_bits_sync(out)

def ll_fz_write_buffer(out, data):
    r""" Low-level wrapper for `::fz_write_buffer()`."""
    return _mupdf.ll_fz_write_buffer(out, data)

def ll_fz_write_byte(out, x):
    r""" Low-level wrapper for `::fz_write_byte()`."""
    return _mupdf.ll_fz_write_byte(out, x)

def ll_fz_write_char(out, x):
    r""" Low-level wrapper for `::fz_write_char()`."""
    return _mupdf.ll_fz_write_char(out, x)

def ll_fz_write_data(out, data, size):
    r"""
    Low-level wrapper for `::fz_write_data()`.
    Write data to output.

    data: Pointer to data to write.
    size: Size of data to write in bytes.
    """
    return _mupdf.ll_fz_write_data(out, data, size)

def ll_fz_write_document(wri, doc):
    r"""
    Low-level wrapper for `::fz_write_document()`.
    Convenience function to feed all the pages of a document to
    fz_begin_page/fz_run_page/fz_end_page.
    """
    return _mupdf.ll_fz_write_document(wri, doc)

def ll_fz_write_float_be(out, f):
    r""" Low-level wrapper for `::fz_write_float_be()`."""
    return _mupdf.ll_fz_write_float_be(out, f)

def ll_fz_write_float_le(out, f):
    r""" Low-level wrapper for `::fz_write_float_le()`."""
    return _mupdf.ll_fz_write_float_le(out, f)

def ll_fz_write_header(writer, w, h, n, alpha, xres, yres, pagenum, cs, seps):
    r"""
    Low-level wrapper for `::fz_write_header()`.
    Cause a band writer to write the header for
    a banded image with the given properties/dimensions etc. This
    also configures the bandwriter for the format of the data to be
    passed in future calls.

    w, h: Width and Height of the entire page.

    n: Number of components (including spots and alphas).

    alpha: Number of alpha components.

    xres, yres: X and Y resolutions in dpi.

    cs: Colorspace (NULL for bitmaps)

    seps: Separation details (or NULL).
    """
    return _mupdf.ll_fz_write_header(writer, w, h, n, alpha, xres, yres, pagenum, cs, seps)

def ll_fz_write_image_as_data_uri(out, image):
    r"""
    Low-level wrapper for `::fz_write_image_as_data_uri()`.
    Write image as a data URI (for HTML and SVG output).
    """
    return _mupdf.ll_fz_write_image_as_data_uri(out, image)

def ll_fz_write_int16_be(out, x):
    r""" Low-level wrapper for `::fz_write_int16_be()`."""
    return _mupdf.ll_fz_write_int16_be(out, x)

def ll_fz_write_int16_le(out, x):
    r""" Low-level wrapper for `::fz_write_int16_le()`."""
    return _mupdf.ll_fz_write_int16_le(out, x)

def ll_fz_write_int32_be(out, x):
    r"""
    Low-level wrapper for `::fz_write_int32_be()`.
    Write different sized data to an output stream.
    """
    return _mupdf.ll_fz_write_int32_be(out, x)

def ll_fz_write_int32_le(out, x):
    r""" Low-level wrapper for `::fz_write_int32_le()`."""
    return _mupdf.ll_fz_write_int32_le(out, x)

def ll_fz_write_pixmap_as_data_uri(out, pixmap):
    r""" Low-level wrapper for `::fz_write_pixmap_as_data_uri()`."""
    return _mupdf.ll_fz_write_pixmap_as_data_uri(out, pixmap)

def ll_fz_write_pixmap_as_jpeg(out, pix, quality, invert_cmyk):
    r"""
    Low-level wrapper for `::fz_write_pixmap_as_jpeg()`.
    Write a pixmap as a JPEG.
    """
    return _mupdf.ll_fz_write_pixmap_as_jpeg(out, pix, quality, invert_cmyk)

def ll_fz_write_pixmap_as_jpx(out, pix, quality):
    r"""
    Low-level wrapper for `::fz_write_pixmap_as_jpx()`.
    Pixmap data as JP2K with no subsampling.

    quality = 100 = lossless
    otherwise for a factor of x compression use 100-x. (so 80 is 1:20 compression)
    """
    return _mupdf.ll_fz_write_pixmap_as_jpx(out, pix, quality)

def ll_fz_write_pixmap_as_pam(out, pixmap):
    r"""
    Low-level wrapper for `::fz_write_pixmap_as_pam()`.
    Write a pixmap as a pnm (greyscale, rgb or cmyk, with or without
    alpha).
    """
    return _mupdf.ll_fz_write_pixmap_as_pam(out, pixmap)

def ll_fz_write_pixmap_as_pcl(out, pixmap, pcl):
    r"""
    Low-level wrapper for `::fz_write_pixmap_as_pcl()`.
    Write an (RGB) pixmap as color PCL.
    """
    return _mupdf.ll_fz_write_pixmap_as_pcl(out, pixmap, pcl)

def ll_fz_write_pixmap_as_pclm(out, pixmap, options):
    r"""
    Low-level wrapper for `::fz_write_pixmap_as_pclm()`.
    Write a (Greyscale or RGB) pixmap as pclm.
    """
    return _mupdf.ll_fz_write_pixmap_as_pclm(out, pixmap, options)

def ll_fz_write_pixmap_as_pdfocr(out, pixmap, options):
    r"""
    Low-level wrapper for `::fz_write_pixmap_as_pdfocr()`.
    Write a (Greyscale or RGB) pixmap as pdfocr.
    """
    return _mupdf.ll_fz_write_pixmap_as_pdfocr(out, pixmap, options)

def ll_fz_write_pixmap_as_png(out, pixmap):
    r"""
    Low-level wrapper for `::fz_write_pixmap_as_png()`.
    Write a (Greyscale or RGB) pixmap as a png.
    """
    return _mupdf.ll_fz_write_pixmap_as_png(out, pixmap)

def ll_fz_write_pixmap_as_pnm(out, pixmap):
    r"""
    Low-level wrapper for `::fz_write_pixmap_as_pnm()`.
    Write a pixmap as a pnm (greyscale or rgb, no alpha).
    """
    return _mupdf.ll_fz_write_pixmap_as_pnm(out, pixmap)

def ll_fz_write_pixmap_as_ps(out, pixmap):
    r"""
    Low-level wrapper for `::fz_write_pixmap_as_ps()`.
    Write a (gray, rgb, or cmyk, no alpha) pixmap out as postscript.
    """
    return _mupdf.ll_fz_write_pixmap_as_ps(out, pixmap)

def ll_fz_write_pixmap_as_psd(out, pixmap):
    r"""
    Low-level wrapper for `::fz_write_pixmap_as_psd()`.
    Write a pixmap as a PSD file.
    """
    return _mupdf.ll_fz_write_pixmap_as_psd(out, pixmap)

def ll_fz_write_pixmap_as_pwg(out, pixmap, pwg):
    r"""
    Low-level wrapper for `::fz_write_pixmap_as_pwg()`.
    Write a pixmap as a PWG.
    """
    return _mupdf.ll_fz_write_pixmap_as_pwg(out, pixmap, pwg)

def ll_fz_write_pixmap_as_pwg_page(out, pixmap, pwg):
    r"""
    Low-level wrapper for `::fz_write_pixmap_as_pwg_page()`.
    Write a pixmap as a PWG page.

    Caller should provide a file header by calling
    fz_write_pwg_file_header, but can then write several pages to
    the same file.
    """
    return _mupdf.ll_fz_write_pixmap_as_pwg_page(out, pixmap, pwg)

def ll_fz_write_ps_file_header(out):
    r"""
    Low-level wrapper for `::fz_write_ps_file_header()`.
    Write the file level header for ps band writer output.
    """
    return _mupdf.ll_fz_write_ps_file_header(out)

def ll_fz_write_ps_file_trailer(out, pages):
    r"""
    Low-level wrapper for `::fz_write_ps_file_trailer()`.
    Write the file level trailer for ps band writer output.
    """
    return _mupdf.ll_fz_write_ps_file_trailer(out, pages)

def ll_fz_write_pwg_file_header(out):
    r"""
    Low-level wrapper for `::fz_write_pwg_file_header()`.
    Output the file header to a pwg stream, ready for pages to follow it.
    """
    return _mupdf.ll_fz_write_pwg_file_header(out)

def ll_fz_write_rune(out, rune):
    r"""
    Low-level wrapper for `::fz_write_rune()`.
    Write a UTF-8 encoded unicode character.
    """
    return _mupdf.ll_fz_write_rune(out, rune)

def ll_fz_write_stabilized_story(writer, user_css, em, contentfn, contentfn_ref, rectfn, rectfn_ref, pagefn, pagefn_ref, dir):
    r""" Low-level wrapper for `::fz_write_stabilized_story()`."""
    return _mupdf.ll_fz_write_stabilized_story(writer, user_css, em, contentfn, contentfn_ref, rectfn, rectfn_ref, pagefn, pagefn_ref, dir)

def ll_fz_write_story(writer, story, rectfn, rectfn_ref, positionfn, positionfn_ref, pagefn, pagefn_ref):
    r""" Low-level wrapper for `::fz_write_story()`."""
    return _mupdf.ll_fz_write_story(writer, story, rectfn, rectfn_ref, positionfn, positionfn_ref, pagefn, pagefn_ref)

def ll_fz_write_string(out, s):
    r"""
    Low-level wrapper for `::fz_write_string()`.
    Write a string. Does not write zero terminator.
    """
    return _mupdf.ll_fz_write_string(out, s)

def ll_fz_write_uint16_be(out, x):
    r""" Low-level wrapper for `::fz_write_uint16_be()`."""
    return _mupdf.ll_fz_write_uint16_be(out, x)

def ll_fz_write_uint16_le(out, x):
    r""" Low-level wrapper for `::fz_write_uint16_le()`."""
    return _mupdf.ll_fz_write_uint16_le(out, x)

def ll_fz_write_uint32_be(out, x):
    r""" Low-level wrapper for `::fz_write_uint32_be()`."""
    return _mupdf.ll_fz_write_uint32_be(out, x)

def ll_fz_write_uint32_le(out, x):
    r""" Low-level wrapper for `::fz_write_uint32_le()`."""
    return _mupdf.ll_fz_write_uint32_le(out, x)

def ll_fz_write_zip_entry(zip, name, buf, compress):
    r"""
    Low-level wrapper for `::fz_write_zip_entry()`.
    Given a buffer of data, (optionally) compress it, and add it to
    the zip file with the given name.
    """
    return _mupdf.ll_fz_write_zip_entry(zip, name, buf, compress)

def ll_fz_xml_add_att(pool, node, key, val):
    r"""
    Low-level wrapper for `::fz_xml_add_att()`.
    Add an attribute to an XML node.
    """
    return _mupdf.ll_fz_xml_add_att(pool, node, key, val)

def ll_fz_xml_att(item, att):
    r"""
    Low-level wrapper for `::fz_xml_att()`.
    Return the value of an attribute of an XML node.
    NULL if the attribute doesn't exist.
    """
    return _mupdf.ll_fz_xml_att(item, att)

def ll_fz_xml_att_alt(item, one, two):
    r"""
    Low-level wrapper for `::fz_xml_att_alt()`.
    Return the value of an attribute of an XML node.
    If the first attribute doesn't exist, try the second.
    NULL if neither attribute exists.
    """
    return _mupdf.ll_fz_xml_att_alt(item, one, two)

def ll_fz_xml_att_eq(item, name, match):
    r"""
    Low-level wrapper for `::fz_xml_att_eq()`.
    Check for a matching attribute on an XML node.

    If the node has the requested attribute (name), and the value
    matches (match) then return 1. Otherwise, 0.
    """
    return _mupdf.ll_fz_xml_att_eq(item, name, match)

def ll_fz_xml_down(item):
    r"""
    Low-level wrapper for `::fz_xml_down()`.
    Return first child of XML node.
    """
    return _mupdf.ll_fz_xml_down(item)

def ll_fz_xml_find(item, tag):
    r"""
    Low-level wrapper for `::fz_xml_find()`.
    Search the siblings of XML nodes starting with item looking for
    the first with the given tag.

    Return NULL if none found.
    """
    return _mupdf.ll_fz_xml_find(item, tag)

def ll_fz_xml_find_dfs(item, tag, att, match):
    r"""
    Low-level wrapper for `::fz_xml_find_dfs()`.
    Perform a depth first search from item, returning the first
    child that matches the given tag (or any tag if tag is NULL),
    with the given attribute (if att is non NULL), that matches
    match (if match is non NULL).
    """
    return _mupdf.ll_fz_xml_find_dfs(item, tag, att, match)

def ll_fz_xml_find_dfs_top(item, tag, att, match, top):
    r"""
    Low-level wrapper for `::fz_xml_find_dfs_top()`.
    Perform a depth first search from item, returning the first
    child that matches the given tag (or any tag if tag is NULL),
    with the given attribute (if att is non NULL), that matches
    match (if match is non NULL). The search stops if it ever
    reaches the top of the tree, or the declared 'top' item.
    """
    return _mupdf.ll_fz_xml_find_dfs_top(item, tag, att, match, top)

def ll_fz_xml_find_down(item, tag):
    r"""
    Low-level wrapper for `::fz_xml_find_down()`.
    Search the siblings of XML nodes starting with the first child
    of item looking for the first with the given tag.

    Return NULL if none found.
    """
    return _mupdf.ll_fz_xml_find_down(item, tag)

def ll_fz_xml_find_down_match(item, tag, att, match):
    r"""
    Low-level wrapper for `::fz_xml_find_down_match()`.
    Search the siblings of XML nodes starting with the first child
    of item looking for the first with the given tag (or any tag if
    tag is NULL), and with a matching attribute.

    Return NULL if none found.
    """
    return _mupdf.ll_fz_xml_find_down_match(item, tag, att, match)

def ll_fz_xml_find_match(item, tag, att, match):
    r"""
    Low-level wrapper for `::fz_xml_find_match()`.
    Search the siblings of XML nodes starting with item looking for
    the first with the given tag (or any tag if tag is NULL), and
    with a matching attribute.

    Return NULL if none found.
    """
    return _mupdf.ll_fz_xml_find_match(item, tag, att, match)

def ll_fz_xml_find_next(item, tag):
    r"""
    Low-level wrapper for `::fz_xml_find_next()`.
    Search the siblings of XML nodes starting with the first sibling
    of item looking for the first with the given tag.

    Return NULL if none found.
    """
    return _mupdf.ll_fz_xml_find_next(item, tag)

def ll_fz_xml_find_next_dfs(item, tag, att, match):
    r"""
    Low-level wrapper for `::fz_xml_find_next_dfs()`.
    Perform a depth first search onwards from item, returning the first
    child that matches the given tag (or any tag if tag is NULL),
    with the given attribute (if att is non NULL), that matches
    match (if match is non NULL).
    """
    return _mupdf.ll_fz_xml_find_next_dfs(item, tag, att, match)

def ll_fz_xml_find_next_dfs_top(item, tag, att, match, top):
    r"""
    Low-level wrapper for `::fz_xml_find_next_dfs_top()`.
    Perform a depth first search onwards from item, returning the first
    child that matches the given tag (or any tag if tag is NULL),
    with the given attribute (if att is non NULL), that matches
    match (if match is non NULL). The search stops if it ever reaches
    the top of the tree, or the declared 'top' item.
    """
    return _mupdf.ll_fz_xml_find_next_dfs_top(item, tag, att, match, top)

def ll_fz_xml_find_next_match(item, tag, att, match):
    r"""
    Low-level wrapper for `::fz_xml_find_next_match()`.
    Search the siblings of XML nodes starting with the first sibling
    of item looking for the first with the given tag (or any tag if tag
    is NULL), and with a matching attribute.

    Return NULL if none found.
    """
    return _mupdf.ll_fz_xml_find_next_match(item, tag, att, match)

def ll_fz_xml_is_tag(item, name):
    r"""
    Low-level wrapper for `::fz_xml_is_tag()`.
    Return true if the tag name matches.
    """
    return _mupdf.ll_fz_xml_is_tag(item, name)

def ll_fz_xml_next(item):
    r"""
    Low-level wrapper for `::fz_xml_next()`.
    Return next sibling of XML node.
    """
    return _mupdf.ll_fz_xml_next(item)

def ll_fz_xml_prev(item):
    r"""
    Low-level wrapper for `::fz_xml_prev()`.
    Return previous sibling of XML node.
    """
    return _mupdf.ll_fz_xml_prev(item)

def ll_fz_xml_root(xml):
    r"""
    Low-level wrapper for `::fz_xml_root()`.
    Return the topmost XML node of a document.
    """
    return _mupdf.ll_fz_xml_root(xml)

def ll_fz_xml_tag(item):
    r"""
    Low-level wrapper for `::fz_xml_tag()`.
    Return tag of XML node. Return NULL for text nodes.
    """
    return _mupdf.ll_fz_xml_tag(item)

def ll_fz_xml_text(item):
    r"""
    Low-level wrapper for `::fz_xml_text()`.
    Return the text content of an XML node.
    Return NULL if the node is a tag.
    """
    return _mupdf.ll_fz_xml_text(item)

def ll_fz_xml_up(item):
    r"""
    Low-level wrapper for `::fz_xml_up()`.
    Return parent of XML node.
    """
    return _mupdf.ll_fz_xml_up(item)

def ll_pdf_abandon_operation(doc):
    r""" Low-level wrapper for `::pdf_abandon_operation()`."""
    return _mupdf.ll_pdf_abandon_operation(doc)

def ll_pdf_access_alert_event(evt):
    r""" Low-level wrapper for `::pdf_access_alert_event()`."""
    return _mupdf.ll_pdf_access_alert_event(evt)

def ll_pdf_access_exec_menu_item_event(evt):
    r""" Low-level wrapper for `::pdf_access_exec_menu_item_event()`."""
    return _mupdf.ll_pdf_access_exec_menu_item_event(evt)

def ll_pdf_access_launch_url_event(evt):
    r""" Low-level wrapper for `::pdf_access_launch_url_event()`."""
    return _mupdf.ll_pdf_access_launch_url_event(evt)

def ll_pdf_access_mail_doc_event(evt):
    r""" Low-level wrapper for `::pdf_access_mail_doc_event()`."""
    return _mupdf.ll_pdf_access_mail_doc_event(evt)

def ll_pdf_add_annot_border_dash_item(annot, length):
    r""" Low-level wrapper for `::pdf_add_annot_border_dash_item()`."""
    return _mupdf.ll_pdf_add_annot_border_dash_item(annot, length)

def ll_pdf_add_annot_ink_list(annot, n, stroke):
    r""" Low-level wrapper for `::pdf_add_annot_ink_list()`."""
    return _mupdf.ll_pdf_add_annot_ink_list(annot, n, stroke)

def ll_pdf_add_annot_ink_list_stroke(annot):
    r""" Low-level wrapper for `::pdf_add_annot_ink_list_stroke()`."""
    return _mupdf.ll_pdf_add_annot_ink_list_stroke(annot)

def ll_pdf_add_annot_ink_list_stroke_vertex(annot, p):
    r""" Low-level wrapper for `::pdf_add_annot_ink_list_stroke_vertex()`."""
    return _mupdf.ll_pdf_add_annot_ink_list_stroke_vertex(annot, p)

def ll_pdf_add_annot_quad_point(annot, quad):
    r""" Low-level wrapper for `::pdf_add_annot_quad_point()`."""
    return _mupdf.ll_pdf_add_annot_quad_point(annot, quad)

def ll_pdf_add_annot_vertex(annot, p):
    r""" Low-level wrapper for `::pdf_add_annot_vertex()`."""
    return _mupdf.ll_pdf_add_annot_vertex(annot, p)

def ll_pdf_add_cid_font(doc, font):
    r""" Low-level wrapper for `::pdf_add_cid_font()`."""
    return _mupdf.ll_pdf_add_cid_font(doc, font)

def ll_pdf_add_cjk_font(doc, font, script, wmode, serif):
    r""" Low-level wrapper for `::pdf_add_cjk_font()`."""
    return _mupdf.ll_pdf_add_cjk_font(doc, font, script, wmode, serif)

def ll_pdf_add_codespace(cmap, low, high, n):
    r""" Low-level wrapper for `::pdf_add_codespace()`."""
    return _mupdf.ll_pdf_add_codespace(cmap, low, high, n)

def ll_pdf_add_embedded_file(doc, filename, mimetype, contents, created, modifed, add_checksum):
    r""" Low-level wrapper for `::pdf_add_embedded_file()`."""
    return _mupdf.ll_pdf_add_embedded_file(doc, filename, mimetype, contents, created, modifed, add_checksum)

def ll_pdf_add_hmtx(font, lo, hi, w):
    r""" Low-level wrapper for `::pdf_add_hmtx()`."""
    return _mupdf.ll_pdf_add_hmtx(font, lo, hi, w)

def ll_pdf_add_image(doc, image):
    r""" Low-level wrapper for `::pdf_add_image()`."""
    return _mupdf.ll_pdf_add_image(doc, image)

def ll_pdf_add_journal_fragment(doc, parent, copy, copy_stream, newobj):
    r""" Low-level wrapper for `::pdf_add_journal_fragment()`."""
    return _mupdf.ll_pdf_add_journal_fragment(doc, parent, copy, copy_stream, newobj)

def ll_pdf_add_new_array(doc, initial):
    r""" Low-level wrapper for `::pdf_add_new_array()`."""
    return _mupdf.ll_pdf_add_new_array(doc, initial)

def ll_pdf_add_new_dict(doc, initial):
    r""" Low-level wrapper for `::pdf_add_new_dict()`."""
    return _mupdf.ll_pdf_add_new_dict(doc, initial)

def ll_pdf_add_object(doc, obj):
    r""" Low-level wrapper for `::pdf_add_object()`."""
    return _mupdf.ll_pdf_add_object(doc, obj)

def ll_pdf_add_object_drop(doc, obj):
    r""" Low-level wrapper for `::pdf_add_object_drop()`."""
    return _mupdf.ll_pdf_add_object_drop(doc, obj)

def ll_pdf_add_page(doc, mediabox, rotate, resources, contents):
    r""" Low-level wrapper for `::pdf_add_page()`."""
    return _mupdf.ll_pdf_add_page(doc, mediabox, rotate, resources, contents)

def ll_pdf_add_simple_font(doc, font, encoding):
    r""" Low-level wrapper for `::pdf_add_simple_font()`."""
    return _mupdf.ll_pdf_add_simple_font(doc, font, encoding)

def ll_pdf_add_stream(doc, buf, obj, compressed):
    r""" Low-level wrapper for `::pdf_add_stream()`."""
    return _mupdf.ll_pdf_add_stream(doc, buf, obj, compressed)

def ll_pdf_add_substitute_font(doc, font):
    r""" Low-level wrapper for `::pdf_add_substitute_font()`."""
    return _mupdf.ll_pdf_add_substitute_font(doc, font)

def ll_pdf_add_vmtx(font, lo, hi, x, y, w):
    r""" Low-level wrapper for `::pdf_add_vmtx()`."""
    return _mupdf.ll_pdf_add_vmtx(font, lo, hi, x, y, w)

def ll_pdf_annot_MK_BC(annot, n, color):
    r"""
     Low-level wrapper for `::pdf_annot_MK_BC()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_pdf_annot_MK_BC(::pdf_annot *annot, float color[4])` => int n
    """
    return _mupdf.ll_pdf_annot_MK_BC(annot, n, color)

def ll_pdf_annot_MK_BC_rgb(annot, rgb):
    r""" Low-level wrapper for `::pdf_annot_MK_BC_rgb()`."""
    return _mupdf.ll_pdf_annot_MK_BC_rgb(annot, rgb)

def ll_pdf_annot_MK_BG(annot, n, color):
    r"""
     Low-level wrapper for `::pdf_annot_MK_BG()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_pdf_annot_MK_BG(::pdf_annot *annot, float color[4])` => int n
    """
    return _mupdf.ll_pdf_annot_MK_BG(annot, n, color)

def ll_pdf_annot_MK_BG_rgb(annot, rgb):
    r""" Low-level wrapper for `::pdf_annot_MK_BG_rgb()`."""
    return _mupdf.ll_pdf_annot_MK_BG_rgb(annot, rgb)

def ll_pdf_annot_active(annot):
    r""" Low-level wrapper for `::pdf_annot_active()`."""
    return _mupdf.ll_pdf_annot_active(annot)

def ll_pdf_annot_ap(annot):
    r""" Low-level wrapper for `::pdf_annot_ap()`."""
    return _mupdf.ll_pdf_annot_ap(annot)

def ll_pdf_annot_author(annot):
    r""" Low-level wrapper for `::pdf_annot_author()`."""
    return _mupdf.ll_pdf_annot_author(annot)

def ll_pdf_annot_border(annot):
    r""" Low-level wrapper for `::pdf_annot_border()`."""
    return _mupdf.ll_pdf_annot_border(annot)

def ll_pdf_annot_border_dash_count(annot):
    r""" Low-level wrapper for `::pdf_annot_border_dash_count()`."""
    return _mupdf.ll_pdf_annot_border_dash_count(annot)

def ll_pdf_annot_border_dash_item(annot, i):
    r""" Low-level wrapper for `::pdf_annot_border_dash_item()`."""
    return _mupdf.ll_pdf_annot_border_dash_item(annot, i)

def ll_pdf_annot_border_effect(annot):
    r""" Low-level wrapper for `::pdf_annot_border_effect()`."""
    return _mupdf.ll_pdf_annot_border_effect(annot)

def ll_pdf_annot_border_effect_intensity(annot):
    r""" Low-level wrapper for `::pdf_annot_border_effect_intensity()`."""
    return _mupdf.ll_pdf_annot_border_effect_intensity(annot)

def ll_pdf_annot_border_style(annot):
    r""" Low-level wrapper for `::pdf_annot_border_style()`."""
    return _mupdf.ll_pdf_annot_border_style(annot)

def ll_pdf_annot_border_width(annot):
    r""" Low-level wrapper for `::pdf_annot_border_width()`."""
    return _mupdf.ll_pdf_annot_border_width(annot)

def ll_pdf_annot_color(annot, n, color):
    r"""
     Low-level wrapper for `::pdf_annot_color()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_pdf_annot_color(::pdf_annot *annot, float color[4])` => int n
    """
    return _mupdf.ll_pdf_annot_color(annot, n, color)

def ll_pdf_annot_contents(annot):
    r""" Low-level wrapper for `::pdf_annot_contents()`."""
    return _mupdf.ll_pdf_annot_contents(annot)

def ll_pdf_annot_creation_date(annot):
    r""" Low-level wrapper for `::pdf_annot_creation_date()`."""
    return _mupdf.ll_pdf_annot_creation_date(annot)

def ll_pdf_annot_default_appearance(annot, font, size, n, color):
    r"""
     Low-level wrapper for `::pdf_annot_default_appearance()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_pdf_annot_default_appearance(::pdf_annot *annot, float color[4])` => `(const char *font, float size, int n)`
    """
    return _mupdf.ll_pdf_annot_default_appearance(annot, font, size, n, color)

def ll_pdf_annot_ensure_local_xref(annot):
    r""" Low-level wrapper for `::pdf_annot_ensure_local_xref()`."""
    return _mupdf.ll_pdf_annot_ensure_local_xref(annot)

def ll_pdf_annot_event_blur(annot):
    r""" Low-level wrapper for `::pdf_annot_event_blur()`."""
    return _mupdf.ll_pdf_annot_event_blur(annot)

def ll_pdf_annot_event_down(annot):
    r""" Low-level wrapper for `::pdf_annot_event_down()`."""
    return _mupdf.ll_pdf_annot_event_down(annot)

def ll_pdf_annot_event_enter(annot):
    r""" Low-level wrapper for `::pdf_annot_event_enter()`."""
    return _mupdf.ll_pdf_annot_event_enter(annot)

def ll_pdf_annot_event_exit(annot):
    r""" Low-level wrapper for `::pdf_annot_event_exit()`."""
    return _mupdf.ll_pdf_annot_event_exit(annot)

def ll_pdf_annot_event_focus(annot):
    r""" Low-level wrapper for `::pdf_annot_event_focus()`."""
    return _mupdf.ll_pdf_annot_event_focus(annot)

def ll_pdf_annot_event_page_close(annot):
    r""" Low-level wrapper for `::pdf_annot_event_page_close()`."""
    return _mupdf.ll_pdf_annot_event_page_close(annot)

def ll_pdf_annot_event_page_invisible(annot):
    r""" Low-level wrapper for `::pdf_annot_event_page_invisible()`."""
    return _mupdf.ll_pdf_annot_event_page_invisible(annot)

def ll_pdf_annot_event_page_open(annot):
    r""" Low-level wrapper for `::pdf_annot_event_page_open()`."""
    return _mupdf.ll_pdf_annot_event_page_open(annot)

def ll_pdf_annot_event_page_visible(annot):
    r""" Low-level wrapper for `::pdf_annot_event_page_visible()`."""
    return _mupdf.ll_pdf_annot_event_page_visible(annot)

def ll_pdf_annot_event_up(annot):
    r""" Low-level wrapper for `::pdf_annot_event_up()`."""
    return _mupdf.ll_pdf_annot_event_up(annot)

def ll_pdf_annot_field_event_keystroke(doc, annot, evt):
    r""" Low-level wrapper for `::pdf_annot_field_event_keystroke()`."""
    return _mupdf.ll_pdf_annot_field_event_keystroke(doc, annot, evt)

def ll_pdf_annot_field_flags(annot):
    r""" Low-level wrapper for `::pdf_annot_field_flags()`."""
    return _mupdf.ll_pdf_annot_field_flags(annot)

def ll_pdf_annot_field_label(widget):
    r""" Low-level wrapper for `::pdf_annot_field_label()`."""
    return _mupdf.ll_pdf_annot_field_label(widget)

def ll_pdf_annot_field_value(annot):
    r""" Low-level wrapper for `::pdf_annot_field_value()`."""
    return _mupdf.ll_pdf_annot_field_value(annot)

def ll_pdf_annot_filespec(annot):
    r""" Low-level wrapper for `::pdf_annot_filespec()`."""
    return _mupdf.ll_pdf_annot_filespec(annot)

def ll_pdf_annot_flags(annot):
    r""" Low-level wrapper for `::pdf_annot_flags()`."""
    return _mupdf.ll_pdf_annot_flags(annot)

def ll_pdf_annot_has_author(annot):
    r""" Low-level wrapper for `::pdf_annot_has_author()`."""
    return _mupdf.ll_pdf_annot_has_author(annot)

def ll_pdf_annot_has_border(annot):
    r""" Low-level wrapper for `::pdf_annot_has_border()`."""
    return _mupdf.ll_pdf_annot_has_border(annot)

def ll_pdf_annot_has_border_effect(annot):
    r""" Low-level wrapper for `::pdf_annot_has_border_effect()`."""
    return _mupdf.ll_pdf_annot_has_border_effect(annot)

def ll_pdf_annot_has_filespec(annot):
    r""" Low-level wrapper for `::pdf_annot_has_filespec()`."""
    return _mupdf.ll_pdf_annot_has_filespec(annot)

def ll_pdf_annot_has_icon_name(annot):
    r""" Low-level wrapper for `::pdf_annot_has_icon_name()`."""
    return _mupdf.ll_pdf_annot_has_icon_name(annot)

def ll_pdf_annot_has_ink_list(annot):
    r""" Low-level wrapper for `::pdf_annot_has_ink_list()`."""
    return _mupdf.ll_pdf_annot_has_ink_list(annot)

def ll_pdf_annot_has_interior_color(annot):
    r""" Low-level wrapper for `::pdf_annot_has_interior_color()`."""
    return _mupdf.ll_pdf_annot_has_interior_color(annot)

def ll_pdf_annot_has_line(annot):
    r""" Low-level wrapper for `::pdf_annot_has_line()`."""
    return _mupdf.ll_pdf_annot_has_line(annot)

def ll_pdf_annot_has_line_ending_styles(annot):
    r""" Low-level wrapper for `::pdf_annot_has_line_ending_styles()`."""
    return _mupdf.ll_pdf_annot_has_line_ending_styles(annot)

def ll_pdf_annot_has_open(annot):
    r""" Low-level wrapper for `::pdf_annot_has_open()`."""
    return _mupdf.ll_pdf_annot_has_open(annot)

def ll_pdf_annot_has_quad_points(annot):
    r""" Low-level wrapper for `::pdf_annot_has_quad_points()`."""
    return _mupdf.ll_pdf_annot_has_quad_points(annot)

def ll_pdf_annot_has_quadding(annot):
    r""" Low-level wrapper for `::pdf_annot_has_quadding()`."""
    return _mupdf.ll_pdf_annot_has_quadding(annot)

def ll_pdf_annot_has_rect(annot):
    r""" Low-level wrapper for `::pdf_annot_has_rect()`."""
    return _mupdf.ll_pdf_annot_has_rect(annot)

def ll_pdf_annot_has_vertices(annot):
    r""" Low-level wrapper for `::pdf_annot_has_vertices()`."""
    return _mupdf.ll_pdf_annot_has_vertices(annot)

def ll_pdf_annot_hidden_for_editing(annot):
    r""" Low-level wrapper for `::pdf_annot_hidden_for_editing()`."""
    return _mupdf.ll_pdf_annot_hidden_for_editing(annot)

def ll_pdf_annot_hot(annot):
    r""" Low-level wrapper for `::pdf_annot_hot()`."""
    return _mupdf.ll_pdf_annot_hot(annot)

def ll_pdf_annot_icon_name(annot):
    r""" Low-level wrapper for `::pdf_annot_icon_name()`."""
    return _mupdf.ll_pdf_annot_icon_name(annot)

def ll_pdf_annot_ink_list_count(annot):
    r""" Low-level wrapper for `::pdf_annot_ink_list_count()`."""
    return _mupdf.ll_pdf_annot_ink_list_count(annot)

def ll_pdf_annot_ink_list_stroke_count(annot, i):
    r""" Low-level wrapper for `::pdf_annot_ink_list_stroke_count()`."""
    return _mupdf.ll_pdf_annot_ink_list_stroke_count(annot, i)

def ll_pdf_annot_ink_list_stroke_vertex(annot, i, k):
    r""" Low-level wrapper for `::pdf_annot_ink_list_stroke_vertex()`."""
    return _mupdf.ll_pdf_annot_ink_list_stroke_vertex(annot, i, k)

def ll_pdf_annot_interior_color(annot, n, color):
    r"""
     Low-level wrapper for `::pdf_annot_interior_color()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_pdf_annot_interior_color(::pdf_annot *annot, float color[4])` => int n
    """
    return _mupdf.ll_pdf_annot_interior_color(annot, n, color)

def ll_pdf_annot_is_open(annot):
    r""" Low-level wrapper for `::pdf_annot_is_open()`."""
    return _mupdf.ll_pdf_annot_is_open(annot)

def ll_pdf_annot_is_standard_stamp(annot):
    r""" Low-level wrapper for `::pdf_annot_is_standard_stamp()`."""
    return _mupdf.ll_pdf_annot_is_standard_stamp(annot)

def ll_pdf_annot_language(annot):
    r""" Low-level wrapper for `::pdf_annot_language()`."""
    return _mupdf.ll_pdf_annot_language(annot)

def ll_pdf_annot_line(annot, a, b):
    r""" Low-level wrapper for `::pdf_annot_line()`."""
    return _mupdf.ll_pdf_annot_line(annot, a, b)

def ll_pdf_annot_line_end_style(annot):
    r""" Low-level wrapper for `::pdf_annot_line_end_style()`."""
    return _mupdf.ll_pdf_annot_line_end_style(annot)

def ll_pdf_annot_line_ending_styles(annot, start_style, end_style):
    r"""
     Low-level wrapper for `::pdf_annot_line_ending_styles()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_pdf_annot_line_ending_styles(::pdf_annot *annot)` => `(enum pdf_line_ending start_style, enum pdf_line_ending end_style)`
    """
    return _mupdf.ll_pdf_annot_line_ending_styles(annot, start_style, end_style)

def ll_pdf_annot_line_start_style(annot):
    r""" Low-level wrapper for `::pdf_annot_line_start_style()`."""
    return _mupdf.ll_pdf_annot_line_start_style(annot)

def ll_pdf_annot_modification_date(annot):
    r""" Low-level wrapper for `::pdf_annot_modification_date()`."""
    return _mupdf.ll_pdf_annot_modification_date(annot)

def ll_pdf_annot_needs_resynthesis(annot):
    r""" Low-level wrapper for `::pdf_annot_needs_resynthesis()`."""
    return _mupdf.ll_pdf_annot_needs_resynthesis(annot)

def ll_pdf_annot_obj(annot):
    r""" Low-level wrapper for `::pdf_annot_obj()`."""
    return _mupdf.ll_pdf_annot_obj(annot)

def ll_pdf_annot_opacity(annot):
    r""" Low-level wrapper for `::pdf_annot_opacity()`."""
    return _mupdf.ll_pdf_annot_opacity(annot)

def ll_pdf_annot_page(annot):
    r""" Low-level wrapper for `::pdf_annot_page()`."""
    return _mupdf.ll_pdf_annot_page(annot)

def ll_pdf_annot_pop_and_discard_local_xref(annot):
    r""" Low-level wrapper for `::pdf_annot_pop_and_discard_local_xref()`."""
    return _mupdf.ll_pdf_annot_pop_and_discard_local_xref(annot)

def ll_pdf_annot_pop_local_xref(annot):
    r""" Low-level wrapper for `::pdf_annot_pop_local_xref()`."""
    return _mupdf.ll_pdf_annot_pop_local_xref(annot)

def ll_pdf_annot_popup(annot):
    r""" Low-level wrapper for `::pdf_annot_popup()`."""
    return _mupdf.ll_pdf_annot_popup(annot)

def ll_pdf_annot_push_local_xref(annot):
    r""" Low-level wrapper for `::pdf_annot_push_local_xref()`."""
    return _mupdf.ll_pdf_annot_push_local_xref(annot)

def ll_pdf_annot_quad_point(annot, i):
    r""" Low-level wrapper for `::pdf_annot_quad_point()`."""
    return _mupdf.ll_pdf_annot_quad_point(annot, i)

def ll_pdf_annot_quad_point_count(annot):
    r""" Low-level wrapper for `::pdf_annot_quad_point_count()`."""
    return _mupdf.ll_pdf_annot_quad_point_count(annot)

def ll_pdf_annot_quadding(annot):
    r""" Low-level wrapper for `::pdf_annot_quadding()`."""
    return _mupdf.ll_pdf_annot_quadding(annot)

def ll_pdf_annot_rect(annot):
    r""" Low-level wrapper for `::pdf_annot_rect()`."""
    return _mupdf.ll_pdf_annot_rect(annot)

def ll_pdf_annot_request_resynthesis(annot):
    r""" Low-level wrapper for `::pdf_annot_request_resynthesis()`."""
    return _mupdf.ll_pdf_annot_request_resynthesis(annot)

def ll_pdf_annot_request_synthesis(annot):
    r""" Low-level wrapper for `::pdf_annot_request_synthesis()`."""
    return _mupdf.ll_pdf_annot_request_synthesis(annot)

def ll_pdf_annot_transform(annot):
    r""" Low-level wrapper for `::pdf_annot_transform()`."""
    return _mupdf.ll_pdf_annot_transform(annot)

def ll_pdf_annot_type(annot):
    r""" Low-level wrapper for `::pdf_annot_type()`."""
    return _mupdf.ll_pdf_annot_type(annot)

def ll_pdf_annot_type_from_string(subtype):
    r""" Low-level wrapper for `::pdf_annot_type_from_string()`."""
    return _mupdf.ll_pdf_annot_type_from_string(subtype)

def ll_pdf_annot_vertex(annot, i):
    r""" Low-level wrapper for `::pdf_annot_vertex()`."""
    return _mupdf.ll_pdf_annot_vertex(annot, i)

def ll_pdf_annot_vertex_count(annot):
    r""" Low-level wrapper for `::pdf_annot_vertex_count()`."""
    return _mupdf.ll_pdf_annot_vertex_count(annot)

def ll_pdf_append_explicit_dest_to_uri(url, dest):
    r""" Low-level wrapper for `::pdf_append_explicit_dest_to_uri()`."""
    return _mupdf.ll_pdf_append_explicit_dest_to_uri(url, dest)

def ll_pdf_append_named_dest_to_uri(url, name):
    r""" Low-level wrapper for `::pdf_append_named_dest_to_uri()`."""
    return _mupdf.ll_pdf_append_named_dest_to_uri(url, name)

def ll_pdf_append_token(buf, tok, lex):
    r""" Low-level wrapper for `::pdf_append_token()`."""
    return _mupdf.ll_pdf_append_token(buf, tok, lex)

def ll_pdf_apply_redaction(annot, opts):
    r""" Low-level wrapper for `::pdf_apply_redaction()`."""
    return _mupdf.ll_pdf_apply_redaction(annot, opts)

def ll_pdf_array_contains(array, obj):
    r""" Low-level wrapper for `::pdf_array_contains()`."""
    return _mupdf.ll_pdf_array_contains(array, obj)

def ll_pdf_array_delete(array, index):
    r""" Low-level wrapper for `::pdf_array_delete()`."""
    return _mupdf.ll_pdf_array_delete(array, index)

def ll_pdf_array_find(array, obj):
    r""" Low-level wrapper for `::pdf_array_find()`."""
    return _mupdf.ll_pdf_array_find(array, obj)

def ll_pdf_array_get(array, i):
    r""" Low-level wrapper for `::pdf_array_get()`."""
    return _mupdf.ll_pdf_array_get(array, i)

def ll_pdf_array_get_bool(array, index):
    r""" Low-level wrapper for `::pdf_array_get_bool()`."""
    return _mupdf.ll_pdf_array_get_bool(array, index)

def ll_pdf_array_get_int(array, index):
    r""" Low-level wrapper for `::pdf_array_get_int()`."""
    return _mupdf.ll_pdf_array_get_int(array, index)

def ll_pdf_array_get_matrix(array, index):
    r""" Low-level wrapper for `::pdf_array_get_matrix()`."""
    return _mupdf.ll_pdf_array_get_matrix(array, index)

def ll_pdf_array_get_name(array, index):
    r""" Low-level wrapper for `::pdf_array_get_name()`."""
    return _mupdf.ll_pdf_array_get_name(array, index)

def ll_pdf_array_get_real(array, index):
    r""" Low-level wrapper for `::pdf_array_get_real()`."""
    return _mupdf.ll_pdf_array_get_real(array, index)

def ll_pdf_array_get_rect(array, index):
    r""" Low-level wrapper for `::pdf_array_get_rect()`."""
    return _mupdf.ll_pdf_array_get_rect(array, index)

def ll_pdf_array_get_string(array, index, sizep):
    r"""
     Low-level wrapper for `::pdf_array_get_string()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_pdf_array_get_string(::pdf_obj *array, int index)` => `(const char *, size_t sizep)`
    """
    return _mupdf.ll_pdf_array_get_string(array, index, sizep)

def ll_pdf_array_get_text_string(array, index):
    r""" Low-level wrapper for `::pdf_array_get_text_string()`."""
    return _mupdf.ll_pdf_array_get_text_string(array, index)

def ll_pdf_array_insert(array, obj, index):
    r""" Low-level wrapper for `::pdf_array_insert()`."""
    return _mupdf.ll_pdf_array_insert(array, obj, index)

def ll_pdf_array_insert_drop(array, obj, index):
    r""" Low-level wrapper for `::pdf_array_insert_drop()`."""
    return _mupdf.ll_pdf_array_insert_drop(array, obj, index)

def ll_pdf_array_len(array):
    r""" Low-level wrapper for `::pdf_array_len()`."""
    return _mupdf.ll_pdf_array_len(array)

def ll_pdf_array_push(array, obj):
    r""" Low-level wrapper for `::pdf_array_push()`."""
    return _mupdf.ll_pdf_array_push(array, obj)

def ll_pdf_array_push_array(array, initial):
    r""" Low-level wrapper for `::pdf_array_push_array()`."""
    return _mupdf.ll_pdf_array_push_array(array, initial)

def ll_pdf_array_push_bool(array, x):
    r""" Low-level wrapper for `::pdf_array_push_bool()`."""
    return _mupdf.ll_pdf_array_push_bool(array, x)

def ll_pdf_array_push_dict(array, initial):
    r""" Low-level wrapper for `::pdf_array_push_dict()`."""
    return _mupdf.ll_pdf_array_push_dict(array, initial)

def ll_pdf_array_push_drop(array, obj):
    r""" Low-level wrapper for `::pdf_array_push_drop()`."""
    return _mupdf.ll_pdf_array_push_drop(array, obj)

def ll_pdf_array_push_int(array, x):
    r""" Low-level wrapper for `::pdf_array_push_int()`."""
    return _mupdf.ll_pdf_array_push_int(array, x)

def ll_pdf_array_push_name(array, x):
    r""" Low-level wrapper for `::pdf_array_push_name()`."""
    return _mupdf.ll_pdf_array_push_name(array, x)

def ll_pdf_array_push_real(array, x):
    r""" Low-level wrapper for `::pdf_array_push_real()`."""
    return _mupdf.ll_pdf_array_push_real(array, x)

def ll_pdf_array_push_string(array, x, n):
    r""" Low-level wrapper for `::pdf_array_push_string()`."""
    return _mupdf.ll_pdf_array_push_string(array, x, n)

def ll_pdf_array_push_text_string(array, x):
    r""" Low-level wrapper for `::pdf_array_push_text_string()`."""
    return _mupdf.ll_pdf_array_push_text_string(array, x)

def ll_pdf_array_put(array, i, obj):
    r""" Low-level wrapper for `::pdf_array_put()`."""
    return _mupdf.ll_pdf_array_put(array, i, obj)

def ll_pdf_array_put_array(array, i, initial):
    r""" Low-level wrapper for `::pdf_array_put_array()`."""
    return _mupdf.ll_pdf_array_put_array(array, i, initial)

def ll_pdf_array_put_bool(array, i, x):
    r""" Low-level wrapper for `::pdf_array_put_bool()`."""
    return _mupdf.ll_pdf_array_put_bool(array, i, x)

def ll_pdf_array_put_dict(array, i, initial):
    r""" Low-level wrapper for `::pdf_array_put_dict()`."""
    return _mupdf.ll_pdf_array_put_dict(array, i, initial)

def ll_pdf_array_put_drop(array, i, obj):
    r""" Low-level wrapper for `::pdf_array_put_drop()`."""
    return _mupdf.ll_pdf_array_put_drop(array, i, obj)

def ll_pdf_array_put_int(array, i, x):
    r""" Low-level wrapper for `::pdf_array_put_int()`."""
    return _mupdf.ll_pdf_array_put_int(array, i, x)

def ll_pdf_array_put_name(array, i, x):
    r""" Low-level wrapper for `::pdf_array_put_name()`."""
    return _mupdf.ll_pdf_array_put_name(array, i, x)

def ll_pdf_array_put_real(array, i, x):
    r""" Low-level wrapper for `::pdf_array_put_real()`."""
    return _mupdf.ll_pdf_array_put_real(array, i, x)

def ll_pdf_array_put_string(array, i, x, n):
    r""" Low-level wrapper for `::pdf_array_put_string()`."""
    return _mupdf.ll_pdf_array_put_string(array, i, x, n)

def ll_pdf_array_put_text_string(array, i, x):
    r""" Low-level wrapper for `::pdf_array_put_text_string()`."""
    return _mupdf.ll_pdf_array_put_text_string(array, i, x)

def ll_pdf_authenticate_password(doc, pw):
    r""" Low-level wrapper for `::pdf_authenticate_password()`."""
    return _mupdf.ll_pdf_authenticate_password(doc, pw)

def ll_pdf_bake_document(doc, bake_annots, bake_widgets):
    r""" Low-level wrapper for `::pdf_bake_document()`."""
    return _mupdf.ll_pdf_bake_document(doc, bake_annots, bake_widgets)

def ll_pdf_begin_implicit_operation(doc):
    r""" Low-level wrapper for `::pdf_begin_implicit_operation()`."""
    return _mupdf.ll_pdf_begin_implicit_operation(doc)

def ll_pdf_begin_operation(doc, operation):
    r""" Low-level wrapper for `::pdf_begin_operation()`."""
    return _mupdf.ll_pdf_begin_operation(doc, operation)

def ll_pdf_bound_annot(annot):
    r""" Low-level wrapper for `::pdf_bound_annot()`."""
    return _mupdf.ll_pdf_bound_annot(annot)

def ll_pdf_bound_page(page, box):
    r""" Low-level wrapper for `::pdf_bound_page()`."""
    return _mupdf.ll_pdf_bound_page(page, box)

def ll_pdf_bound_widget(widget):
    r""" Low-level wrapper for `::pdf_bound_widget()`."""
    return _mupdf.ll_pdf_bound_widget(widget)

def ll_pdf_button_field_on_state(field):
    r""" Low-level wrapper for `::pdf_button_field_on_state()`."""
    return _mupdf.ll_pdf_button_field_on_state(field)

def ll_pdf_cache_object(doc, num):
    r"""
    Low-level wrapper for `::pdf_cache_object()`.
    Retrieve the pdf_xref_entry for a given object.

    This can cause xref reorganisations (solidifications etc) due to
    repairs, so all held pdf_xref_entries should be considered
    invalid after this call (other than the returned one).
    """
    return _mupdf.ll_pdf_cache_object(doc, num)

def ll_pdf_calculate_form(doc):
    r""" Low-level wrapper for `::pdf_calculate_form()`."""
    return _mupdf.ll_pdf_calculate_form(doc)

def ll_pdf_can_be_saved_incrementally(doc):
    r""" Low-level wrapper for `::pdf_can_be_saved_incrementally()`."""
    return _mupdf.ll_pdf_can_be_saved_incrementally(doc)

def ll_pdf_can_redo(doc):
    r""" Low-level wrapper for `::pdf_can_redo()`."""
    return _mupdf.ll_pdf_can_redo(doc)

def ll_pdf_can_undo(doc):
    r""" Low-level wrapper for `::pdf_can_undo()`."""
    return _mupdf.ll_pdf_can_undo(doc)

def ll_pdf_check_certificate(verifier, doc, signature):
    r""" Low-level wrapper for `::pdf_check_certificate()`."""
    return _mupdf.ll_pdf_check_certificate(verifier, doc, signature)

def ll_pdf_check_digest(verifier, doc, signature):
    r""" Low-level wrapper for `::pdf_check_digest()`."""
    return _mupdf.ll_pdf_check_digest(verifier, doc, signature)

def ll_pdf_check_widget_certificate(verifier, widget):
    r""" Low-level wrapper for `::pdf_check_widget_certificate()`."""
    return _mupdf.ll_pdf_check_widget_certificate(verifier, widget)

def ll_pdf_check_widget_digest(verifier, widget):
    r""" Low-level wrapper for `::pdf_check_widget_digest()`."""
    return _mupdf.ll_pdf_check_widget_digest(verifier, widget)

def ll_pdf_choice_field_option(field, exportval, i):
    r""" Low-level wrapper for `::pdf_choice_field_option()`."""
    return _mupdf.ll_pdf_choice_field_option(field, exportval, i)

def ll_pdf_choice_field_option_count(field):
    r""" Low-level wrapper for `::pdf_choice_field_option_count()`."""
    return _mupdf.ll_pdf_choice_field_option_count(field)

def ll_pdf_choice_widget_is_multiselect(tw):
    r""" Low-level wrapper for `::pdf_choice_widget_is_multiselect()`."""
    return _mupdf.ll_pdf_choice_widget_is_multiselect(tw)

def ll_pdf_choice_widget_options(tw, exportval, opts):
    r""" Low-level wrapper for `::pdf_choice_widget_options()`."""
    return _mupdf.ll_pdf_choice_widget_options(tw, exportval, opts)

def ll_pdf_choice_widget_options2(tw, exportval):
    r"""
     Low-level wrapper for `::pdf_choice_widget_options2()`.  Swig-friendly wrapper for pdf_choice_widget_options(), returns the
    options directly in a vector.
    """
    return _mupdf.ll_pdf_choice_widget_options2(tw, exportval)

def ll_pdf_choice_widget_set_value(tw, n, opts):
    r""" Low-level wrapper for `::pdf_choice_widget_set_value()`."""
    return _mupdf.ll_pdf_choice_widget_set_value(tw, n, opts)

def ll_pdf_choice_widget_value(tw, opts):
    r""" Low-level wrapper for `::pdf_choice_widget_value()`."""
    return _mupdf.ll_pdf_choice_widget_value(tw, opts)

def ll_pdf_clean_file(infile, outfile, password, opts, retainlen):
    r""" Low-level wrapper for `::pdf_clean_file()`."""
    return _mupdf.ll_pdf_clean_file(infile, outfile, password, opts, retainlen)

def ll_pdf_clean_font_name(fontname):
    r""" Low-level wrapper for `::pdf_clean_font_name()`."""
    return _mupdf.ll_pdf_clean_font_name(fontname)

def ll_pdf_clean_obj(obj):
    r""" Low-level wrapper for `::pdf_clean_obj()`."""
    return _mupdf.ll_pdf_clean_obj(obj)

def ll_pdf_clear_annot_border_dash(annot):
    r""" Low-level wrapper for `::pdf_clear_annot_border_dash()`."""
    return _mupdf.ll_pdf_clear_annot_border_dash(annot)

def ll_pdf_clear_annot_ink_list(annot):
    r""" Low-level wrapper for `::pdf_clear_annot_ink_list()`."""
    return _mupdf.ll_pdf_clear_annot_ink_list(annot)

def ll_pdf_clear_annot_quad_points(annot):
    r""" Low-level wrapper for `::pdf_clear_annot_quad_points()`."""
    return _mupdf.ll_pdf_clear_annot_quad_points(annot)

def ll_pdf_clear_annot_vertices(annot):
    r""" Low-level wrapper for `::pdf_clear_annot_vertices()`."""
    return _mupdf.ll_pdf_clear_annot_vertices(annot)

def ll_pdf_clear_signature(widget):
    r""" Low-level wrapper for `::pdf_clear_signature()`."""
    return _mupdf.ll_pdf_clear_signature(widget)

def ll_pdf_clear_xref(doc):
    r""" Low-level wrapper for `::pdf_clear_xref()`."""
    return _mupdf.ll_pdf_clear_xref(doc)

def ll_pdf_clear_xref_to_mark(doc):
    r""" Low-level wrapper for `::pdf_clear_xref_to_mark()`."""
    return _mupdf.ll_pdf_clear_xref_to_mark(doc)

def ll_pdf_close_processor(proc):
    r""" Low-level wrapper for `::pdf_close_processor()`."""
    return _mupdf.ll_pdf_close_processor(proc)

def ll_pdf_cmap_size(cmap):
    r""" Low-level wrapper for `::pdf_cmap_size()`."""
    return _mupdf.ll_pdf_cmap_size(cmap)

def ll_pdf_cmap_wmode(cmap):
    r""" Low-level wrapper for `::pdf_cmap_wmode()`."""
    return _mupdf.ll_pdf_cmap_wmode(cmap)

def ll_pdf_copy_array(array):
    r""" Low-level wrapper for `::pdf_copy_array()`."""
    return _mupdf.ll_pdf_copy_array(array)

def ll_pdf_copy_dict(dict):
    r""" Low-level wrapper for `::pdf_copy_dict()`."""
    return _mupdf.ll_pdf_copy_dict(dict)

def ll_pdf_count_layer_config_ui(doc):
    r""" Low-level wrapper for `::pdf_count_layer_config_ui()`."""
    return _mupdf.ll_pdf_count_layer_config_ui(doc)

def ll_pdf_count_layer_configs(doc):
    r""" Low-level wrapper for `::pdf_count_layer_configs()`."""
    return _mupdf.ll_pdf_count_layer_configs(doc)

def ll_pdf_count_layers(doc):
    r""" Low-level wrapper for `::pdf_count_layers()`."""
    return _mupdf.ll_pdf_count_layers(doc)

def ll_pdf_count_objects(doc):
    r""" Low-level wrapper for `::pdf_count_objects()`."""
    return _mupdf.ll_pdf_count_objects(doc)

def ll_pdf_count_pages(doc):
    r""" Low-level wrapper for `::pdf_count_pages()`."""
    return _mupdf.ll_pdf_count_pages(doc)

def ll_pdf_count_pages_imp(doc, chapter):
    r""" Low-level wrapper for `::pdf_count_pages_imp()`."""
    return _mupdf.ll_pdf_count_pages_imp(doc, chapter)

def ll_pdf_count_q_balance(doc, res, stm, prepend, append):
    r"""
     Low-level wrapper for `::pdf_count_q_balance()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_pdf_count_q_balance(::pdf_document *doc, ::pdf_obj *res, ::pdf_obj *stm)` => `(int prepend, int append)`
    """
    return _mupdf.ll_pdf_count_q_balance(doc, res, stm, prepend, append)

def ll_pdf_count_signatures(doc):
    r""" Low-level wrapper for `::pdf_count_signatures()`."""
    return _mupdf.ll_pdf_count_signatures(doc)

def ll_pdf_count_unsaved_versions(doc):
    r""" Low-level wrapper for `::pdf_count_unsaved_versions()`."""
    return _mupdf.ll_pdf_count_unsaved_versions(doc)

def ll_pdf_count_versions(doc):
    r""" Low-level wrapper for `::pdf_count_versions()`."""
    return _mupdf.ll_pdf_count_versions(doc)

def ll_pdf_create_annot(page, type):
    r""" Low-level wrapper for `::pdf_create_annot()`."""
    return _mupdf.ll_pdf_create_annot(page, type)

def ll_pdf_create_annot_raw(page, type):
    r""" Low-level wrapper for `::pdf_create_annot_raw()`."""
    return _mupdf.ll_pdf_create_annot_raw(page, type)

def ll_pdf_create_document():
    r""" Low-level wrapper for `::pdf_create_document()`."""
    return _mupdf.ll_pdf_create_document()

def ll_pdf_create_field_name(doc, prefix, buf, len):
    r""" Low-level wrapper for `::pdf_create_field_name()`."""
    return _mupdf.ll_pdf_create_field_name(doc, prefix, buf, len)

def ll_pdf_create_link(page, bbox, uri):
    r""" Low-level wrapper for `::pdf_create_link()`."""
    return _mupdf.ll_pdf_create_link(page, bbox, uri)

def ll_pdf_create_object(doc):
    r""" Low-level wrapper for `::pdf_create_object()`."""
    return _mupdf.ll_pdf_create_object(doc)

def ll_pdf_create_signature_widget(page, name):
    r""" Low-level wrapper for `::pdf_create_signature_widget()`."""
    return _mupdf.ll_pdf_create_signature_widget(page, name)

def ll_pdf_crypt_encrypt_metadata(crypt):
    r""" Low-level wrapper for `::pdf_crypt_encrypt_metadata()`."""
    return _mupdf.ll_pdf_crypt_encrypt_metadata(crypt)

def ll_pdf_crypt_key(crypt):
    r""" Low-level wrapper for `::pdf_crypt_key()`."""
    return _mupdf.ll_pdf_crypt_key(crypt)

def ll_pdf_crypt_length(crypt):
    r""" Low-level wrapper for `::pdf_crypt_length()`."""
    return _mupdf.ll_pdf_crypt_length(crypt)

def ll_pdf_crypt_method(crypt):
    r""" Low-level wrapper for `::pdf_crypt_method()`."""
    return _mupdf.ll_pdf_crypt_method(crypt)

def ll_pdf_crypt_obj(crypt, obj, num, gen):
    r""" Low-level wrapper for `::pdf_crypt_obj()`."""
    return _mupdf.ll_pdf_crypt_obj(crypt, obj, num, gen)

def ll_pdf_crypt_owner_encryption(crypt):
    r""" Low-level wrapper for `::pdf_crypt_owner_encryption()`."""
    return _mupdf.ll_pdf_crypt_owner_encryption(crypt)

def ll_pdf_crypt_owner_password(crypt):
    r""" Low-level wrapper for `::pdf_crypt_owner_password()`."""
    return _mupdf.ll_pdf_crypt_owner_password(crypt)

def ll_pdf_crypt_permissions(crypt):
    r""" Low-level wrapper for `::pdf_crypt_permissions()`."""
    return _mupdf.ll_pdf_crypt_permissions(crypt)

def ll_pdf_crypt_permissions_encryption(crypt):
    r""" Low-level wrapper for `::pdf_crypt_permissions_encryption()`."""
    return _mupdf.ll_pdf_crypt_permissions_encryption(crypt)

def ll_pdf_crypt_revision(crypt):
    r""" Low-level wrapper for `::pdf_crypt_revision()`."""
    return _mupdf.ll_pdf_crypt_revision(crypt)

def ll_pdf_crypt_stream_method(crypt):
    r""" Low-level wrapper for `::pdf_crypt_stream_method()`."""
    return _mupdf.ll_pdf_crypt_stream_method(crypt)

def ll_pdf_crypt_string_method(crypt):
    r""" Low-level wrapper for `::pdf_crypt_string_method()`."""
    return _mupdf.ll_pdf_crypt_string_method(crypt)

def ll_pdf_crypt_user_encryption(crypt):
    r""" Low-level wrapper for `::pdf_crypt_user_encryption()`."""
    return _mupdf.ll_pdf_crypt_user_encryption(crypt)

def ll_pdf_crypt_user_password(crypt):
    r""" Low-level wrapper for `::pdf_crypt_user_password()`."""
    return _mupdf.ll_pdf_crypt_user_password(crypt)

def ll_pdf_crypt_version(crypt):
    r""" Low-level wrapper for `::pdf_crypt_version()`."""
    return _mupdf.ll_pdf_crypt_version(crypt)

def ll_pdf_cycle(here, prev, obj):
    r""" Low-level wrapper for `::pdf_cycle()`."""
    return _mupdf.ll_pdf_cycle(here, prev, obj)

def ll_pdf_debug_doc_changes(doc):
    r""" Low-level wrapper for `::pdf_debug_doc_changes()`."""
    return _mupdf.ll_pdf_debug_doc_changes(doc)

def ll_pdf_debug_obj(obj):
    r""" Low-level wrapper for `::pdf_debug_obj()`."""
    return _mupdf.ll_pdf_debug_obj(obj)

def ll_pdf_debug_ref(obj):
    r""" Low-level wrapper for `::pdf_debug_ref()`."""
    return _mupdf.ll_pdf_debug_ref(obj)

def ll_pdf_decode_cmap(cmap, s, e, cpt):
    r"""
     Low-level wrapper for `::pdf_decode_cmap()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_pdf_decode_cmap(::pdf_cmap *cmap, unsigned char *s, unsigned char *e)` => `(int, unsigned int cpt)`
    """
    return _mupdf.ll_pdf_decode_cmap(cmap, s, e, cpt)

def ll_pdf_deep_copy_obj(obj):
    r""" Low-level wrapper for `::pdf_deep_copy_obj()`."""
    return _mupdf.ll_pdf_deep_copy_obj(obj)

def ll_pdf_delete_annot(page, annot):
    r""" Low-level wrapper for `::pdf_delete_annot()`."""
    return _mupdf.ll_pdf_delete_annot(page, annot)

def ll_pdf_delete_link(page, link):
    r""" Low-level wrapper for `::pdf_delete_link()`."""
    return _mupdf.ll_pdf_delete_link(page, link)

def ll_pdf_delete_object(doc, num):
    r""" Low-level wrapper for `::pdf_delete_object()`."""
    return _mupdf.ll_pdf_delete_object(doc, num)

def ll_pdf_delete_page(doc, number):
    r""" Low-level wrapper for `::pdf_delete_page()`."""
    return _mupdf.ll_pdf_delete_page(doc, number)

def ll_pdf_delete_page_labels(doc, index):
    r""" Low-level wrapper for `::pdf_delete_page_labels()`."""
    return _mupdf.ll_pdf_delete_page_labels(doc, index)

def ll_pdf_delete_page_range(doc, start, end):
    r""" Low-level wrapper for `::pdf_delete_page_range()`."""
    return _mupdf.ll_pdf_delete_page_range(doc, start, end)

def ll_pdf_deselect_layer_config_ui(doc, ui):
    r""" Low-level wrapper for `::pdf_deselect_layer_config_ui()`."""
    return _mupdf.ll_pdf_deselect_layer_config_ui(doc, ui)

def ll_pdf_deserialise_journal(doc, stm):
    r""" Low-level wrapper for `::pdf_deserialise_journal()`."""
    return _mupdf.ll_pdf_deserialise_journal(doc, stm)

def ll_pdf_dict_del(dict, key):
    r""" Low-level wrapper for `::pdf_dict_del()`."""
    return _mupdf.ll_pdf_dict_del(dict, key)

def ll_pdf_dict_dels(dict, key):
    r""" Low-level wrapper for `::pdf_dict_dels()`."""
    return _mupdf.ll_pdf_dict_dels(dict, key)

def ll_pdf_dict_get(dict, key):
    r""" Low-level wrapper for `::pdf_dict_get()`."""
    return _mupdf.ll_pdf_dict_get(dict, key)

def ll_pdf_dict_get_bool(dict, key):
    r""" Low-level wrapper for `::pdf_dict_get_bool()`."""
    return _mupdf.ll_pdf_dict_get_bool(dict, key)

def ll_pdf_dict_get_bool_default(dict, key, _def):
    r""" Low-level wrapper for `::pdf_dict_get_bool_default()`."""
    return _mupdf.ll_pdf_dict_get_bool_default(dict, key, _def)

def ll_pdf_dict_get_date(dict, key):
    r""" Low-level wrapper for `::pdf_dict_get_date()`."""
    return _mupdf.ll_pdf_dict_get_date(dict, key)

def ll_pdf_dict_get_inheritable(dict, key):
    r""" Low-level wrapper for `::pdf_dict_get_inheritable()`."""
    return _mupdf.ll_pdf_dict_get_inheritable(dict, key)

def ll_pdf_dict_get_inheritable_bool(dict, key):
    r""" Low-level wrapper for `::pdf_dict_get_inheritable_bool()`."""
    return _mupdf.ll_pdf_dict_get_inheritable_bool(dict, key)

def ll_pdf_dict_get_inheritable_date(dict, key):
    r""" Low-level wrapper for `::pdf_dict_get_inheritable_date()`."""
    return _mupdf.ll_pdf_dict_get_inheritable_date(dict, key)

def ll_pdf_dict_get_inheritable_int(dict, key):
    r""" Low-level wrapper for `::pdf_dict_get_inheritable_int()`."""
    return _mupdf.ll_pdf_dict_get_inheritable_int(dict, key)

def ll_pdf_dict_get_inheritable_int64(dict, key):
    r""" Low-level wrapper for `::pdf_dict_get_inheritable_int64()`."""
    return _mupdf.ll_pdf_dict_get_inheritable_int64(dict, key)

def ll_pdf_dict_get_inheritable_matrix(dict, key):
    r""" Low-level wrapper for `::pdf_dict_get_inheritable_matrix()`."""
    return _mupdf.ll_pdf_dict_get_inheritable_matrix(dict, key)

def ll_pdf_dict_get_inheritable_name(dict, key):
    r""" Low-level wrapper for `::pdf_dict_get_inheritable_name()`."""
    return _mupdf.ll_pdf_dict_get_inheritable_name(dict, key)

def ll_pdf_dict_get_inheritable_real(dict, key):
    r""" Low-level wrapper for `::pdf_dict_get_inheritable_real()`."""
    return _mupdf.ll_pdf_dict_get_inheritable_real(dict, key)

def ll_pdf_dict_get_inheritable_rect(dict, key):
    r""" Low-level wrapper for `::pdf_dict_get_inheritable_rect()`."""
    return _mupdf.ll_pdf_dict_get_inheritable_rect(dict, key)

def ll_pdf_dict_get_inheritable_string(dict, key, sizep):
    r"""
     Low-level wrapper for `::pdf_dict_get_inheritable_string()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_pdf_dict_get_inheritable_string(::pdf_obj *dict, ::pdf_obj *key)` => `(const char *, size_t sizep)`
    """
    return _mupdf.ll_pdf_dict_get_inheritable_string(dict, key, sizep)

def ll_pdf_dict_get_inheritable_text_string(dict, key):
    r""" Low-level wrapper for `::pdf_dict_get_inheritable_text_string()`."""
    return _mupdf.ll_pdf_dict_get_inheritable_text_string(dict, key)

def ll_pdf_dict_get_int(dict, key):
    r""" Low-level wrapper for `::pdf_dict_get_int()`."""
    return _mupdf.ll_pdf_dict_get_int(dict, key)

def ll_pdf_dict_get_int64(dict, key):
    r""" Low-level wrapper for `::pdf_dict_get_int64()`."""
    return _mupdf.ll_pdf_dict_get_int64(dict, key)

def ll_pdf_dict_get_int_default(dict, key, _def):
    r""" Low-level wrapper for `::pdf_dict_get_int_default()`."""
    return _mupdf.ll_pdf_dict_get_int_default(dict, key, _def)

def ll_pdf_dict_get_key(dict, idx):
    r""" Low-level wrapper for `::pdf_dict_get_key()`."""
    return _mupdf.ll_pdf_dict_get_key(dict, idx)

def ll_pdf_dict_get_matrix(dict, key):
    r""" Low-level wrapper for `::pdf_dict_get_matrix()`."""
    return _mupdf.ll_pdf_dict_get_matrix(dict, key)

def ll_pdf_dict_get_name(dict, key):
    r""" Low-level wrapper for `::pdf_dict_get_name()`."""
    return _mupdf.ll_pdf_dict_get_name(dict, key)

def ll_pdf_dict_get_put_drop(dict, key, val, old_val):
    r"""
     Low-level wrapper for `::pdf_dict_get_put_drop()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_pdf_dict_get_put_drop(::pdf_obj *dict, ::pdf_obj *key, ::pdf_obj *val, ::pdf_obj **old_val)` =>
    """
    return _mupdf.ll_pdf_dict_get_put_drop(dict, key, val, old_val)

def ll_pdf_dict_get_real(dict, key):
    r""" Low-level wrapper for `::pdf_dict_get_real()`."""
    return _mupdf.ll_pdf_dict_get_real(dict, key)

def ll_pdf_dict_get_real_default(dict, key, _def):
    r""" Low-level wrapper for `::pdf_dict_get_real_default()`."""
    return _mupdf.ll_pdf_dict_get_real_default(dict, key, _def)

def ll_pdf_dict_get_rect(dict, key):
    r""" Low-level wrapper for `::pdf_dict_get_rect()`."""
    return _mupdf.ll_pdf_dict_get_rect(dict, key)

def ll_pdf_dict_get_string(dict, key, sizep):
    r"""
     Low-level wrapper for `::pdf_dict_get_string()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_pdf_dict_get_string(::pdf_obj *dict, ::pdf_obj *key)` => `(const char *, size_t sizep)`
    """
    return _mupdf.ll_pdf_dict_get_string(dict, key, sizep)

def ll_pdf_dict_get_text_string(dict, key):
    r""" Low-level wrapper for `::pdf_dict_get_text_string()`."""
    return _mupdf.ll_pdf_dict_get_text_string(dict, key)

def ll_pdf_dict_get_val(dict, idx):
    r""" Low-level wrapper for `::pdf_dict_get_val()`."""
    return _mupdf.ll_pdf_dict_get_val(dict, idx)

def ll_pdf_dict_geta(dict, key, abbrev):
    r""" Low-level wrapper for `::pdf_dict_geta()`."""
    return _mupdf.ll_pdf_dict_geta(dict, key, abbrev)

def ll_pdf_dict_getp(dict, path):
    r""" Low-level wrapper for `::pdf_dict_getp()`."""
    return _mupdf.ll_pdf_dict_getp(dict, path)

def ll_pdf_dict_getp_inheritable(dict, path):
    r""" Low-level wrapper for `::pdf_dict_getp_inheritable()`."""
    return _mupdf.ll_pdf_dict_getp_inheritable(dict, path)

def ll_pdf_dict_gets(dict, key):
    r""" Low-level wrapper for `::pdf_dict_gets()`."""
    return _mupdf.ll_pdf_dict_gets(dict, key)

def ll_pdf_dict_gets_inheritable(dict, key):
    r""" Low-level wrapper for `::pdf_dict_gets_inheritable()`."""
    return _mupdf.ll_pdf_dict_gets_inheritable(dict, key)

def ll_pdf_dict_getsa(dict, key, abbrev):
    r""" Low-level wrapper for `::pdf_dict_getsa()`."""
    return _mupdf.ll_pdf_dict_getsa(dict, key, abbrev)

def ll_pdf_dict_len(dict):
    r""" Low-level wrapper for `::pdf_dict_len()`."""
    return _mupdf.ll_pdf_dict_len(dict)

def ll_pdf_dict_put(dict, key, val):
    r""" Low-level wrapper for `::pdf_dict_put()`."""
    return _mupdf.ll_pdf_dict_put(dict, key, val)

def ll_pdf_dict_put_array(dict, key, initial):
    r""" Low-level wrapper for `::pdf_dict_put_array()`."""
    return _mupdf.ll_pdf_dict_put_array(dict, key, initial)

def ll_pdf_dict_put_bool(dict, key, x):
    r""" Low-level wrapper for `::pdf_dict_put_bool()`."""
    return _mupdf.ll_pdf_dict_put_bool(dict, key, x)

def ll_pdf_dict_put_date(dict, key, time):
    r""" Low-level wrapper for `::pdf_dict_put_date()`."""
    return _mupdf.ll_pdf_dict_put_date(dict, key, time)

def ll_pdf_dict_put_dict(dict, key, initial):
    r""" Low-level wrapper for `::pdf_dict_put_dict()`."""
    return _mupdf.ll_pdf_dict_put_dict(dict, key, initial)

def ll_pdf_dict_put_drop(dict, key, val):
    r""" Low-level wrapper for `::pdf_dict_put_drop()`."""
    return _mupdf.ll_pdf_dict_put_drop(dict, key, val)

def ll_pdf_dict_put_int(dict, key, x):
    r""" Low-level wrapper for `::pdf_dict_put_int()`."""
    return _mupdf.ll_pdf_dict_put_int(dict, key, x)

def ll_pdf_dict_put_matrix(dict, key, x):
    r""" Low-level wrapper for `::pdf_dict_put_matrix()`."""
    return _mupdf.ll_pdf_dict_put_matrix(dict, key, x)

def ll_pdf_dict_put_name(dict, key, x):
    r""" Low-level wrapper for `::pdf_dict_put_name()`."""
    return _mupdf.ll_pdf_dict_put_name(dict, key, x)

def ll_pdf_dict_put_real(dict, key, x):
    r""" Low-level wrapper for `::pdf_dict_put_real()`."""
    return _mupdf.ll_pdf_dict_put_real(dict, key, x)

def ll_pdf_dict_put_rect(dict, key, x):
    r""" Low-level wrapper for `::pdf_dict_put_rect()`."""
    return _mupdf.ll_pdf_dict_put_rect(dict, key, x)

def ll_pdf_dict_put_string(dict, key, x, n):
    r""" Low-level wrapper for `::pdf_dict_put_string()`."""
    return _mupdf.ll_pdf_dict_put_string(dict, key, x, n)

def ll_pdf_dict_put_text_string(dict, key, x):
    r""" Low-level wrapper for `::pdf_dict_put_text_string()`."""
    return _mupdf.ll_pdf_dict_put_text_string(dict, key, x)

def ll_pdf_dict_put_val_null(obj, idx):
    r""" Low-level wrapper for `::pdf_dict_put_val_null()`."""
    return _mupdf.ll_pdf_dict_put_val_null(obj, idx)

def ll_pdf_dict_putp(dict, path, val):
    r""" Low-level wrapper for `::pdf_dict_putp()`."""
    return _mupdf.ll_pdf_dict_putp(dict, path, val)

def ll_pdf_dict_putp_drop(dict, path, val):
    r""" Low-level wrapper for `::pdf_dict_putp_drop()`."""
    return _mupdf.ll_pdf_dict_putp_drop(dict, path, val)

def ll_pdf_dict_puts(dict, key, val):
    r""" Low-level wrapper for `::pdf_dict_puts()`."""
    return _mupdf.ll_pdf_dict_puts(dict, key, val)

def ll_pdf_dict_puts_dict(dict, key, initial):
    r""" Low-level wrapper for `::pdf_dict_puts_dict()`."""
    return _mupdf.ll_pdf_dict_puts_dict(dict, key, initial)

def ll_pdf_dict_puts_drop(dict, key, val):
    r""" Low-level wrapper for `::pdf_dict_puts_drop()`."""
    return _mupdf.ll_pdf_dict_puts_drop(dict, key, val)

def ll_pdf_dirty_annot(annot):
    r""" Low-level wrapper for `::pdf_dirty_annot()`."""
    return _mupdf.ll_pdf_dirty_annot(annot)

def ll_pdf_dirty_obj(obj):
    r""" Low-level wrapper for `::pdf_dirty_obj()`."""
    return _mupdf.ll_pdf_dirty_obj(obj)

def ll_pdf_disable_js(doc):
    r""" Low-level wrapper for `::pdf_disable_js()`."""
    return _mupdf.ll_pdf_disable_js(doc)

def ll_pdf_discard_journal(journal):
    r""" Low-level wrapper for `::pdf_discard_journal()`."""
    return _mupdf.ll_pdf_discard_journal(journal)

def ll_pdf_doc_was_linearized(doc):
    r""" Low-level wrapper for `::pdf_doc_was_linearized()`."""
    return _mupdf.ll_pdf_doc_was_linearized(doc)

def ll_pdf_document_event_did_print(doc):
    r""" Low-level wrapper for `::pdf_document_event_did_print()`."""
    return _mupdf.ll_pdf_document_event_did_print(doc)

def ll_pdf_document_event_did_save(doc):
    r""" Low-level wrapper for `::pdf_document_event_did_save()`."""
    return _mupdf.ll_pdf_document_event_did_save(doc)

def ll_pdf_document_event_will_close(doc):
    r""" Low-level wrapper for `::pdf_document_event_will_close()`."""
    return _mupdf.ll_pdf_document_event_will_close(doc)

def ll_pdf_document_event_will_print(doc):
    r""" Low-level wrapper for `::pdf_document_event_will_print()`."""
    return _mupdf.ll_pdf_document_event_will_print(doc)

def ll_pdf_document_event_will_save(doc):
    r""" Low-level wrapper for `::pdf_document_event_will_save()`."""
    return _mupdf.ll_pdf_document_event_will_save(doc)

def ll_pdf_document_from_fz_document(ptr):
    r""" Low-level wrapper for `::pdf_document_from_fz_document()`."""
    return _mupdf.ll_pdf_document_from_fz_document(ptr)

def ll_pdf_document_language(doc):
    r""" Low-level wrapper for `::pdf_document_language()`."""
    return _mupdf.ll_pdf_document_language(doc)

def ll_pdf_document_output_intent(doc):
    r""" Low-level wrapper for `::pdf_document_output_intent()`."""
    return _mupdf.ll_pdf_document_output_intent(doc)

def ll_pdf_document_permissions(doc):
    r""" Low-level wrapper for `::pdf_document_permissions()`."""
    return _mupdf.ll_pdf_document_permissions(doc)

def ll_pdf_drop_annot(annot):
    r""" Low-level wrapper for `::pdf_drop_annot()`."""
    return _mupdf.ll_pdf_drop_annot(annot)

def ll_pdf_drop_cmap(cmap):
    r""" Low-level wrapper for `::pdf_drop_cmap()`."""
    return _mupdf.ll_pdf_drop_cmap(cmap)

def ll_pdf_drop_cmap_imp(cmap):
    r""" Low-level wrapper for `::pdf_drop_cmap_imp()`."""
    return _mupdf.ll_pdf_drop_cmap_imp(cmap)

def ll_pdf_drop_crypt(crypt):
    r""" Low-level wrapper for `::pdf_drop_crypt()`."""
    return _mupdf.ll_pdf_drop_crypt(crypt)

def ll_pdf_drop_document(doc):
    r""" Low-level wrapper for `::pdf_drop_document()`."""
    return _mupdf.ll_pdf_drop_document(doc)

def ll_pdf_drop_font(font):
    r""" Low-level wrapper for `::pdf_drop_font()`."""
    return _mupdf.ll_pdf_drop_font(font)

def ll_pdf_drop_function(func):
    r""" Low-level wrapper for `::pdf_drop_function()`."""
    return _mupdf.ll_pdf_drop_function(func)

def ll_pdf_drop_graft_map(map):
    r""" Low-level wrapper for `::pdf_drop_graft_map()`."""
    return _mupdf.ll_pdf_drop_graft_map(map)

def ll_pdf_drop_journal(journal):
    r""" Low-level wrapper for `::pdf_drop_journal()`."""
    return _mupdf.ll_pdf_drop_journal(journal)

def ll_pdf_drop_js(js):
    r""" Low-level wrapper for `::pdf_drop_js()`."""
    return _mupdf.ll_pdf_drop_js(js)

def ll_pdf_drop_local_xref(xref):
    r""" Low-level wrapper for `::pdf_drop_local_xref()`."""
    return _mupdf.ll_pdf_drop_local_xref(xref)

def ll_pdf_drop_local_xref_and_resources(doc):
    r""" Low-level wrapper for `::pdf_drop_local_xref_and_resources()`."""
    return _mupdf.ll_pdf_drop_local_xref_and_resources(doc)

def ll_pdf_drop_locked_fields(locked):
    r""" Low-level wrapper for `::pdf_drop_locked_fields()`."""
    return _mupdf.ll_pdf_drop_locked_fields(locked)

def ll_pdf_drop_mark_bits(marks):
    r""" Low-level wrapper for `::pdf_drop_mark_bits()`."""
    return _mupdf.ll_pdf_drop_mark_bits(marks)

def ll_pdf_drop_obj(obj):
    r""" Low-level wrapper for `::pdf_drop_obj()`."""
    return _mupdf.ll_pdf_drop_obj(obj)

def ll_pdf_drop_ocg(doc):
    r""" Low-level wrapper for `::pdf_drop_ocg()`."""
    return _mupdf.ll_pdf_drop_ocg(doc)

def ll_pdf_drop_page(page):
    r""" Low-level wrapper for `::pdf_drop_page()`."""
    return _mupdf.ll_pdf_drop_page(page)

def ll_pdf_drop_page_tree(doc):
    r""" Low-level wrapper for `::pdf_drop_page_tree()`."""
    return _mupdf.ll_pdf_drop_page_tree(doc)

def ll_pdf_drop_page_tree_internal(doc):
    r""" Low-level wrapper for `::pdf_drop_page_tree_internal()`."""
    return _mupdf.ll_pdf_drop_page_tree_internal(doc)

def ll_pdf_drop_pattern(pat):
    r""" Low-level wrapper for `::pdf_drop_pattern()`."""
    return _mupdf.ll_pdf_drop_pattern(pat)

def ll_pdf_drop_processor(proc):
    r""" Low-level wrapper for `::pdf_drop_processor()`."""
    return _mupdf.ll_pdf_drop_processor(proc)

def ll_pdf_drop_resource_tables(doc):
    r""" Low-level wrapper for `::pdf_drop_resource_tables()`."""
    return _mupdf.ll_pdf_drop_resource_tables(doc)

def ll_pdf_drop_signer(signer):
    r""" Low-level wrapper for `::pdf_drop_signer()`."""
    return _mupdf.ll_pdf_drop_signer(signer)

def ll_pdf_drop_singleton_obj(obj):
    r""" Low-level wrapper for `::pdf_drop_singleton_obj()`."""
    return _mupdf.ll_pdf_drop_singleton_obj(obj)

def ll_pdf_drop_verifier(verifier):
    r""" Low-level wrapper for `::pdf_drop_verifier()`."""
    return _mupdf.ll_pdf_drop_verifier(verifier)

def ll_pdf_drop_widget(widget):
    r""" Low-level wrapper for `::pdf_drop_widget()`."""
    return _mupdf.ll_pdf_drop_widget(widget)

def ll_pdf_edit_text_field_value(widget, value, change, selStart, selEnd, newvalue):
    r"""
     Low-level wrapper for `::pdf_edit_text_field_value()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_pdf_edit_text_field_value(::pdf_annot *widget, const char *value, const char *change)` => `(int, int selStart, int selEnd, char *newvalue)`
    """
    return _mupdf.ll_pdf_edit_text_field_value(widget, value, change, selStart, selEnd, newvalue)

def ll_pdf_empty_store(doc):
    r""" Low-level wrapper for `::pdf_empty_store()`."""
    return _mupdf.ll_pdf_empty_store(doc)

def ll_pdf_enable_journal(doc):
    r""" Low-level wrapper for `::pdf_enable_journal()`."""
    return _mupdf.ll_pdf_enable_journal(doc)

def ll_pdf_enable_js(doc):
    r""" Low-level wrapper for `::pdf_enable_js()`."""
    return _mupdf.ll_pdf_enable_js(doc)

def ll_pdf_enable_layer(doc, layer, enabled):
    r""" Low-level wrapper for `::pdf_enable_layer()`."""
    return _mupdf.ll_pdf_enable_layer(doc, layer, enabled)

def ll_pdf_encrypt_data(crypt, num, gen, fmt_str_out, arg, s, n):
    r""" Low-level wrapper for `::pdf_encrypt_data()`."""
    return _mupdf.ll_pdf_encrypt_data(crypt, num, gen, fmt_str_out, arg, s, n)

def ll_pdf_encrypted_len(crypt, num, gen, len):
    r""" Low-level wrapper for `::pdf_encrypted_len()`."""
    return _mupdf.ll_pdf_encrypted_len(crypt, num, gen, len)

def ll_pdf_end_hmtx(font):
    r""" Low-level wrapper for `::pdf_end_hmtx()`."""
    return _mupdf.ll_pdf_end_hmtx(font)

def ll_pdf_end_operation(doc):
    r""" Low-level wrapper for `::pdf_end_operation()`."""
    return _mupdf.ll_pdf_end_operation(doc)

def ll_pdf_end_vmtx(font):
    r""" Low-level wrapper for `::pdf_end_vmtx()`."""
    return _mupdf.ll_pdf_end_vmtx(font)

def ll_pdf_ensure_solid_xref(doc, num):
    r""" Low-level wrapper for `::pdf_ensure_solid_xref()`."""
    return _mupdf.ll_pdf_ensure_solid_xref(doc, num)

def ll_pdf_eval_function(func, _in, inlen, out, outlen):
    r"""
     Low-level wrapper for `::pdf_eval_function()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_pdf_eval_function(::pdf_function *func, const float *in, int inlen, int outlen)` => float out
    """
    return _mupdf.ll_pdf_eval_function(func, _in, inlen, out, outlen)

def ll_pdf_event_issue_alert(doc, evt):
    r""" Low-level wrapper for `::pdf_event_issue_alert()`."""
    return _mupdf.ll_pdf_event_issue_alert(doc, evt)

def ll_pdf_event_issue_exec_menu_item(doc, item):
    r""" Low-level wrapper for `::pdf_event_issue_exec_menu_item()`."""
    return _mupdf.ll_pdf_event_issue_exec_menu_item(doc, item)

def ll_pdf_event_issue_launch_url(doc, url, new_frame):
    r""" Low-level wrapper for `::pdf_event_issue_launch_url()`."""
    return _mupdf.ll_pdf_event_issue_launch_url(doc, url, new_frame)

def ll_pdf_event_issue_mail_doc(doc, evt):
    r""" Low-level wrapper for `::pdf_event_issue_mail_doc()`."""
    return _mupdf.ll_pdf_event_issue_mail_doc(doc, evt)

def ll_pdf_event_issue_print(doc):
    r""" Low-level wrapper for `::pdf_event_issue_print()`."""
    return _mupdf.ll_pdf_event_issue_print(doc)

def ll_pdf_field_border_style(field):
    r""" Low-level wrapper for `::pdf_field_border_style()`."""
    return _mupdf.ll_pdf_field_border_style(field)

def ll_pdf_field_display(field):
    r""" Low-level wrapper for `::pdf_field_display()`."""
    return _mupdf.ll_pdf_field_display(field)

def ll_pdf_field_event_calculate(doc, field):
    r""" Low-level wrapper for `::pdf_field_event_calculate()`."""
    return _mupdf.ll_pdf_field_event_calculate(doc, field)

def ll_pdf_field_event_format(doc, field):
    r""" Low-level wrapper for `::pdf_field_event_format()`."""
    return _mupdf.ll_pdf_field_event_format(doc, field)

def ll_pdf_field_event_keystroke(doc, field, evt):
    r""" Low-level wrapper for `::pdf_field_event_keystroke()`."""
    return _mupdf.ll_pdf_field_event_keystroke(doc, field, evt)

def ll_pdf_field_event_validate(doc, field, value, newvalue):
    r"""
     Low-level wrapper for `::pdf_field_event_validate()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_pdf_field_event_validate(::pdf_document *doc, ::pdf_obj *field, const char *value)` => `(int, char *newvalue)`
    """
    return _mupdf.ll_pdf_field_event_validate(doc, field, value, newvalue)

def ll_pdf_field_flags(field):
    r""" Low-level wrapper for `::pdf_field_flags()`."""
    return _mupdf.ll_pdf_field_flags(field)

def ll_pdf_field_label(field):
    r""" Low-level wrapper for `::pdf_field_label()`."""
    return _mupdf.ll_pdf_field_label(field)

def ll_pdf_field_reset(doc, field):
    r""" Low-level wrapper for `::pdf_field_reset()`."""
    return _mupdf.ll_pdf_field_reset(doc, field)

def ll_pdf_field_set_border_style(field, text):
    r""" Low-level wrapper for `::pdf_field_set_border_style()`."""
    return _mupdf.ll_pdf_field_set_border_style(field, text)

def ll_pdf_field_set_button_caption(field, text):
    r""" Low-level wrapper for `::pdf_field_set_button_caption()`."""
    return _mupdf.ll_pdf_field_set_button_caption(field, text)

def ll_pdf_field_set_display(field, d):
    r""" Low-level wrapper for `::pdf_field_set_display()`."""
    return _mupdf.ll_pdf_field_set_display(field, d)

def ll_pdf_field_set_fill_color(field, col):
    r""" Low-level wrapper for `::pdf_field_set_fill_color()`."""
    return _mupdf.ll_pdf_field_set_fill_color(field, col)

def ll_pdf_field_set_text_color(field, col):
    r""" Low-level wrapper for `::pdf_field_set_text_color()`."""
    return _mupdf.ll_pdf_field_set_text_color(field, col)

def ll_pdf_field_type(field):
    r""" Low-level wrapper for `::pdf_field_type()`."""
    return _mupdf.ll_pdf_field_type(field)

def ll_pdf_field_type_string(field):
    r""" Low-level wrapper for `::pdf_field_type_string()`."""
    return _mupdf.ll_pdf_field_type_string(field)

def ll_pdf_field_value(field):
    r""" Low-level wrapper for `::pdf_field_value()`."""
    return _mupdf.ll_pdf_field_value(field)

def ll_pdf_filter_annot_contents(doc, annot, options):
    r""" Low-level wrapper for `::pdf_filter_annot_contents()`."""
    return _mupdf.ll_pdf_filter_annot_contents(doc, annot, options)

def ll_pdf_filter_page_contents(doc, page, options):
    r""" Low-level wrapper for `::pdf_filter_page_contents()`."""
    return _mupdf.ll_pdf_filter_page_contents(doc, page, options)

def ll_pdf_filter_xobject_instance(old_xobj, page_res, ctm, options, cycle_up):
    r""" Low-level wrapper for `::pdf_filter_xobject_instance()`."""
    return _mupdf.ll_pdf_filter_xobject_instance(old_xobj, page_res, ctm, options, cycle_up)

def ll_pdf_find_font_resource(doc, type, encoding, item, key):
    r""" Low-level wrapper for `::pdf_find_font_resource()`."""
    return _mupdf.ll_pdf_find_font_resource(doc, type, encoding, item, key)

def ll_pdf_find_item(drop, key):
    r""" Low-level wrapper for `::pdf_find_item()`."""
    return _mupdf.ll_pdf_find_item(drop, key)

def ll_pdf_find_locked_fields(doc, version):
    r""" Low-level wrapper for `::pdf_find_locked_fields()`."""
    return _mupdf.ll_pdf_find_locked_fields(doc, version)

def ll_pdf_find_locked_fields_for_sig(doc, sig):
    r""" Low-level wrapper for `::pdf_find_locked_fields_for_sig()`."""
    return _mupdf.ll_pdf_find_locked_fields_for_sig(doc, sig)

def ll_pdf_find_version_for_obj(doc, obj):
    r""" Low-level wrapper for `::pdf_find_version_for_obj()`."""
    return _mupdf.ll_pdf_find_version_for_obj(doc, obj)

def ll_pdf_first_annot(page):
    r""" Low-level wrapper for `::pdf_first_annot()`."""
    return _mupdf.ll_pdf_first_annot(page)

def ll_pdf_first_widget(page):
    r""" Low-level wrapper for `::pdf_first_widget()`."""
    return _mupdf.ll_pdf_first_widget(page)

def ll_pdf_flatten_inheritable_page_items(page):
    r""" Low-level wrapper for `::pdf_flatten_inheritable_page_items()`."""
    return _mupdf.ll_pdf_flatten_inheritable_page_items(page)

def ll_pdf_font_cid_to_gid(fontdesc, cid):
    r""" Low-level wrapper for `::pdf_font_cid_to_gid()`."""
    return _mupdf.ll_pdf_font_cid_to_gid(fontdesc, cid)

def ll_pdf_font_writing_supported(font):
    r""" Low-level wrapper for `::pdf_font_writing_supported()`."""
    return _mupdf.ll_pdf_font_writing_supported(font)

def ll_pdf_forget_xref(doc):
    r""" Low-level wrapper for `::pdf_forget_xref()`."""
    return _mupdf.ll_pdf_forget_xref(doc)

def ll_pdf_format_date(time, s, n):
    r""" Low-level wrapper for `::pdf_format_date()`."""
    return _mupdf.ll_pdf_format_date(time, s, n)

def ll_pdf_format_write_options(buffer, buffer_len, opts):
    r""" Low-level wrapper for `::pdf_format_write_options()`."""
    return _mupdf.ll_pdf_format_write_options(buffer, buffer_len, opts)

def ll_pdf_function_size(func):
    r""" Low-level wrapper for `::pdf_function_size()`."""
    return _mupdf.ll_pdf_function_size(func)

def ll_pdf_get_bound_document(obj):
    r""" Low-level wrapper for `::pdf_get_bound_document()`."""
    return _mupdf.ll_pdf_get_bound_document(obj)

def ll_pdf_get_doc_event_callback_data(doc):
    r""" Low-level wrapper for `::pdf_get_doc_event_callback_data()`."""
    return _mupdf.ll_pdf_get_doc_event_callback_data(doc)

def ll_pdf_get_embedded_file_params(fs, out):
    r""" Low-level wrapper for `::pdf_get_embedded_file_params()`."""
    return _mupdf.ll_pdf_get_embedded_file_params(fs, out)

def ll_pdf_get_incremental_xref_entry(doc, i):
    r""" Low-level wrapper for `::pdf_get_incremental_xref_entry()`."""
    return _mupdf.ll_pdf_get_incremental_xref_entry(doc, i)

def ll_pdf_get_indirect_document(obj):
    r""" Low-level wrapper for `::pdf_get_indirect_document()`."""
    return _mupdf.ll_pdf_get_indirect_document(obj)

def ll_pdf_get_populating_xref_entry(doc, i):
    r""" Low-level wrapper for `::pdf_get_populating_xref_entry()`."""
    return _mupdf.ll_pdf_get_populating_xref_entry(doc, i)

def ll_pdf_get_widget_editing_state(widget):
    r""" Low-level wrapper for `::pdf_get_widget_editing_state()`."""
    return _mupdf.ll_pdf_get_widget_editing_state(widget)

def ll_pdf_get_xref_entry(doc, i):
    r""" Low-level wrapper for `::pdf_get_xref_entry()`."""
    return _mupdf.ll_pdf_get_xref_entry(doc, i)

def ll_pdf_get_xref_entry_no_change(doc, i):
    r""" Low-level wrapper for `::pdf_get_xref_entry_no_change()`."""
    return _mupdf.ll_pdf_get_xref_entry_no_change(doc, i)

def ll_pdf_get_xref_entry_no_null(doc, i):
    r""" Low-level wrapper for `::pdf_get_xref_entry_no_null()`."""
    return _mupdf.ll_pdf_get_xref_entry_no_null(doc, i)

def ll_pdf_graft_mapped_object(map, obj):
    r""" Low-level wrapper for `::pdf_graft_mapped_object()`."""
    return _mupdf.ll_pdf_graft_mapped_object(map, obj)

def ll_pdf_graft_mapped_page(map, page_to, src, page_from):
    r""" Low-level wrapper for `::pdf_graft_mapped_page()`."""
    return _mupdf.ll_pdf_graft_mapped_page(map, page_to, src, page_from)

def ll_pdf_graft_object(dst, obj):
    r""" Low-level wrapper for `::pdf_graft_object()`."""
    return _mupdf.ll_pdf_graft_object(dst, obj)

def ll_pdf_graft_page(dst, page_to, src, page_from):
    r""" Low-level wrapper for `::pdf_graft_page()`."""
    return _mupdf.ll_pdf_graft_page(dst, page_to, src, page_from)

def ll_pdf_has_permission(doc, p):
    r""" Low-level wrapper for `::pdf_has_permission()`."""
    return _mupdf.ll_pdf_has_permission(doc, p)

def ll_pdf_has_unsaved_changes(doc):
    r""" Low-level wrapper for `::pdf_has_unsaved_changes()`."""
    return _mupdf.ll_pdf_has_unsaved_changes(doc)

def ll_pdf_has_unsaved_sigs(doc):
    r""" Low-level wrapper for `::pdf_has_unsaved_sigs()`."""
    return _mupdf.ll_pdf_has_unsaved_sigs(doc)

def ll_pdf_insert_font_resource(doc, key, obj):
    r""" Low-level wrapper for `::pdf_insert_font_resource()`."""
    return _mupdf.ll_pdf_insert_font_resource(doc, key, obj)

def ll_pdf_insert_page(doc, at, page):
    r""" Low-level wrapper for `::pdf_insert_page()`."""
    return _mupdf.ll_pdf_insert_page(doc, at, page)

def ll_pdf_invalidate_xfa(doc):
    r""" Low-level wrapper for `::pdf_invalidate_xfa()`."""
    return _mupdf.ll_pdf_invalidate_xfa(doc)

def ll_pdf_is_array(obj):
    r""" Low-level wrapper for `::pdf_is_array()`."""
    return _mupdf.ll_pdf_is_array(obj)

def ll_pdf_is_bool(obj):
    r""" Low-level wrapper for `::pdf_is_bool()`."""
    return _mupdf.ll_pdf_is_bool(obj)

def ll_pdf_is_dict(obj):
    r""" Low-level wrapper for `::pdf_is_dict()`."""
    return _mupdf.ll_pdf_is_dict(obj)

def ll_pdf_is_embedded_file(fs):
    r""" Low-level wrapper for `::pdf_is_embedded_file()`."""
    return _mupdf.ll_pdf_is_embedded_file(fs)

def ll_pdf_is_field_locked(locked, name):
    r""" Low-level wrapper for `::pdf_is_field_locked()`."""
    return _mupdf.ll_pdf_is_field_locked(locked, name)

def ll_pdf_is_indirect(obj):
    r""" Low-level wrapper for `::pdf_is_indirect()`."""
    return _mupdf.ll_pdf_is_indirect(obj)

def ll_pdf_is_int(obj):
    r""" Low-level wrapper for `::pdf_is_int()`."""
    return _mupdf.ll_pdf_is_int(obj)

def ll_pdf_is_jpx_image(dict):
    r""" Low-level wrapper for `::pdf_is_jpx_image()`."""
    return _mupdf.ll_pdf_is_jpx_image(dict)

def ll_pdf_is_local_object(doc, obj):
    r""" Low-level wrapper for `::pdf_is_local_object()`."""
    return _mupdf.ll_pdf_is_local_object(doc, obj)

def ll_pdf_is_name(obj):
    r""" Low-level wrapper for `::pdf_is_name()`."""
    return _mupdf.ll_pdf_is_name(obj)

def ll_pdf_is_null(obj):
    r""" Low-level wrapper for `::pdf_is_null()`."""
    return _mupdf.ll_pdf_is_null(obj)

def ll_pdf_is_number(obj):
    r""" Low-level wrapper for `::pdf_is_number()`."""
    return _mupdf.ll_pdf_is_number(obj)

def ll_pdf_is_ocg_hidden(doc, rdb, usage, ocg):
    r""" Low-level wrapper for `::pdf_is_ocg_hidden()`."""
    return _mupdf.ll_pdf_is_ocg_hidden(doc, rdb, usage, ocg)

def ll_pdf_is_real(obj):
    r""" Low-level wrapper for `::pdf_is_real()`."""
    return _mupdf.ll_pdf_is_real(obj)

def ll_pdf_is_stream(obj):
    r""" Low-level wrapper for `::pdf_is_stream()`."""
    return _mupdf.ll_pdf_is_stream(obj)

def ll_pdf_is_string(obj):
    r""" Low-level wrapper for `::pdf_is_string()`."""
    return _mupdf.ll_pdf_is_string(obj)

def ll_pdf_is_tint_colorspace(cs):
    r""" Low-level wrapper for `::pdf_is_tint_colorspace()`."""
    return _mupdf.ll_pdf_is_tint_colorspace(cs)

def ll_pdf_js_event_init(js, target, value, willCommit):
    r""" Low-level wrapper for `::pdf_js_event_init()`."""
    return _mupdf.ll_pdf_js_event_init(js, target, value, willCommit)

def ll_pdf_js_event_init_keystroke(js, target, evt):
    r""" Low-level wrapper for `::pdf_js_event_init_keystroke()`."""
    return _mupdf.ll_pdf_js_event_init_keystroke(js, target, evt)

def ll_pdf_js_event_result(js):
    r""" Low-level wrapper for `::pdf_js_event_result()`."""
    return _mupdf.ll_pdf_js_event_result(js)

def ll_pdf_js_event_result_keystroke(js, evt):
    r""" Low-level wrapper for `::pdf_js_event_result_keystroke()`."""
    return _mupdf.ll_pdf_js_event_result_keystroke(js, evt)

def ll_pdf_js_event_result_validate(js, newvalue):
    r"""
     Low-level wrapper for `::pdf_js_event_result_validate()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_pdf_js_event_result_validate(::pdf_js *js)` => `(int, char *newvalue)`
    """
    return _mupdf.ll_pdf_js_event_result_validate(js, newvalue)

def ll_pdf_js_event_value(js):
    r""" Low-level wrapper for `::pdf_js_event_value()`."""
    return _mupdf.ll_pdf_js_event_value(js)

def ll_pdf_js_execute(js, name, code, result):
    r"""
     Low-level wrapper for `::pdf_js_execute()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_pdf_js_execute(::pdf_js *js, const char *name, const char *code)` => char *result
    """
    return _mupdf.ll_pdf_js_execute(js, name, code, result)

def ll_pdf_js_get_console(doc):
    r""" Low-level wrapper for `::pdf_js_get_console()`."""
    return _mupdf.ll_pdf_js_get_console(doc)

def ll_pdf_js_set_console(doc, console, user):
    r""" Low-level wrapper for `::pdf_js_set_console()`."""
    return _mupdf.ll_pdf_js_set_console(doc, console, user)

def ll_pdf_js_supported(doc):
    r""" Low-level wrapper for `::pdf_js_supported()`."""
    return _mupdf.ll_pdf_js_supported(doc)

def ll_pdf_keep_annot(annot):
    r""" Low-level wrapper for `::pdf_keep_annot()`."""
    return _mupdf.ll_pdf_keep_annot(annot)

def ll_pdf_keep_cmap(cmap):
    r""" Low-level wrapper for `::pdf_keep_cmap()`."""
    return _mupdf.ll_pdf_keep_cmap(cmap)

def ll_pdf_keep_document(doc):
    r""" Low-level wrapper for `::pdf_keep_document()`."""
    return _mupdf.ll_pdf_keep_document(doc)

def ll_pdf_keep_font(fontdesc):
    r""" Low-level wrapper for `::pdf_keep_font()`."""
    return _mupdf.ll_pdf_keep_font(fontdesc)

def ll_pdf_keep_function(func):
    r""" Low-level wrapper for `::pdf_keep_function()`."""
    return _mupdf.ll_pdf_keep_function(func)

def ll_pdf_keep_graft_map(map):
    r""" Low-level wrapper for `::pdf_keep_graft_map()`."""
    return _mupdf.ll_pdf_keep_graft_map(map)

def ll_pdf_keep_obj(obj):
    r""" Low-level wrapper for `::pdf_keep_obj()`."""
    return _mupdf.ll_pdf_keep_obj(obj)

def ll_pdf_keep_page(page):
    r""" Low-level wrapper for `::pdf_keep_page()`."""
    return _mupdf.ll_pdf_keep_page(page)

def ll_pdf_keep_pattern(pat):
    r""" Low-level wrapper for `::pdf_keep_pattern()`."""
    return _mupdf.ll_pdf_keep_pattern(pat)

def ll_pdf_keep_processor(proc):
    r""" Low-level wrapper for `::pdf_keep_processor()`."""
    return _mupdf.ll_pdf_keep_processor(proc)

def ll_pdf_keep_widget(widget):
    r""" Low-level wrapper for `::pdf_keep_widget()`."""
    return _mupdf.ll_pdf_keep_widget(widget)

def ll_pdf_layer_config_info(doc, config_num, info):
    r""" Low-level wrapper for `::pdf_layer_config_info()`."""
    return _mupdf.ll_pdf_layer_config_info(doc, config_num, info)

def ll_pdf_layer_config_ui_info(doc, ui, info):
    r""" Low-level wrapper for `::pdf_layer_config_ui_info()`."""
    return _mupdf.ll_pdf_layer_config_ui_info(doc, ui, info)

def ll_pdf_layer_is_enabled(doc, layer):
    r""" Low-level wrapper for `::pdf_layer_is_enabled()`."""
    return _mupdf.ll_pdf_layer_is_enabled(doc, layer)

def ll_pdf_layer_name(doc, layer):
    r""" Low-level wrapper for `::pdf_layer_name()`."""
    return _mupdf.ll_pdf_layer_name(doc, layer)

def ll_pdf_layout_fit_text(font, lang, str, bounds):
    r""" Low-level wrapper for `::pdf_layout_fit_text()`."""
    return _mupdf.ll_pdf_layout_fit_text(font, lang, str, bounds)

def ll_pdf_layout_text_widget(annot):
    r""" Low-level wrapper for `::pdf_layout_text_widget()`."""
    return _mupdf.ll_pdf_layout_text_widget(annot)

def ll_pdf_lex(f, lexbuf):
    r""" Low-level wrapper for `::pdf_lex()`."""
    return _mupdf.ll_pdf_lex(f, lexbuf)

def ll_pdf_lex_no_string(f, lexbuf):
    r""" Low-level wrapper for `::pdf_lex_no_string()`."""
    return _mupdf.ll_pdf_lex_no_string(f, lexbuf)

def ll_pdf_lexbuf_fin(lexbuf):
    r""" Low-level wrapper for `::pdf_lexbuf_fin()`."""
    return _mupdf.ll_pdf_lexbuf_fin(lexbuf)

def ll_pdf_lexbuf_grow(lexbuf):
    r""" Low-level wrapper for `::pdf_lexbuf_grow()`."""
    return _mupdf.ll_pdf_lexbuf_grow(lexbuf)

def ll_pdf_lexbuf_init(lexbuf, size):
    r""" Low-level wrapper for `::pdf_lexbuf_init()`."""
    return _mupdf.ll_pdf_lexbuf_init(lexbuf, size)

def ll_pdf_line_ending_from_name(end):
    r""" Low-level wrapper for `::pdf_line_ending_from_name()`."""
    return _mupdf.ll_pdf_line_ending_from_name(end)

def ll_pdf_line_ending_from_string(end):
    r""" Low-level wrapper for `::pdf_line_ending_from_string()`."""
    return _mupdf.ll_pdf_line_ending_from_string(end)

def ll_pdf_load_builtin_cmap(name):
    r""" Low-level wrapper for `::pdf_load_builtin_cmap()`."""
    return _mupdf.ll_pdf_load_builtin_cmap(name)

def ll_pdf_load_cmap(file):
    r""" Low-level wrapper for `::pdf_load_cmap()`."""
    return _mupdf.ll_pdf_load_cmap(file)

def ll_pdf_load_colorspace(obj):
    r""" Low-level wrapper for `::pdf_load_colorspace()`."""
    return _mupdf.ll_pdf_load_colorspace(obj)

def ll_pdf_load_compressed_inline_image(doc, dict, length, cstm, indexed, image):
    r""" Low-level wrapper for `::pdf_load_compressed_inline_image()`."""
    return _mupdf.ll_pdf_load_compressed_inline_image(doc, dict, length, cstm, indexed, image)

def ll_pdf_load_compressed_stream(doc, num, worst_case):
    r""" Low-level wrapper for `::pdf_load_compressed_stream()`."""
    return _mupdf.ll_pdf_load_compressed_stream(doc, num, worst_case)

def ll_pdf_load_default_colorspaces(doc, page):
    r""" Low-level wrapper for `::pdf_load_default_colorspaces()`."""
    return _mupdf.ll_pdf_load_default_colorspaces(doc, page)

def ll_pdf_load_embedded_cmap(doc, ref):
    r""" Low-level wrapper for `::pdf_load_embedded_cmap()`."""
    return _mupdf.ll_pdf_load_embedded_cmap(doc, ref)

def ll_pdf_load_embedded_file_contents(fs):
    r""" Low-level wrapper for `::pdf_load_embedded_file_contents()`."""
    return _mupdf.ll_pdf_load_embedded_file_contents(fs)

def ll_pdf_load_encoding(estrings, encoding):
    r"""
     Low-level wrapper for `::pdf_load_encoding()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_pdf_load_encoding(const char *encoding)` => const char *estrings
    """
    return _mupdf.ll_pdf_load_encoding(estrings, encoding)

def ll_pdf_load_field_name(field):
    r""" Low-level wrapper for `::pdf_load_field_name()`."""
    return _mupdf.ll_pdf_load_field_name(field)

def ll_pdf_load_field_name2(field):
    r""" Alternative to `ll_pdf_load_field_name()` that returns a std::string."""
    return _mupdf.ll_pdf_load_field_name2(field)

def ll_pdf_load_font(doc, rdb, obj):
    r""" Low-level wrapper for `::pdf_load_font()`."""
    return _mupdf.ll_pdf_load_font(doc, rdb, obj)

def ll_pdf_load_function(ref, _in, out):
    r""" Low-level wrapper for `::pdf_load_function()`."""
    return _mupdf.ll_pdf_load_function(ref, _in, out)

def ll_pdf_load_hail_mary_font(doc):
    r""" Low-level wrapper for `::pdf_load_hail_mary_font()`."""
    return _mupdf.ll_pdf_load_hail_mary_font(doc)

def ll_pdf_load_image(doc, obj):
    r""" Low-level wrapper for `::pdf_load_image()`."""
    return _mupdf.ll_pdf_load_image(doc, obj)

def ll_pdf_load_inline_image(doc, rdb, dict, file):
    r""" Low-level wrapper for `::pdf_load_inline_image()`."""
    return _mupdf.ll_pdf_load_inline_image(doc, rdb, dict, file)

def ll_pdf_load_journal(doc, filename):
    r""" Low-level wrapper for `::pdf_load_journal()`."""
    return _mupdf.ll_pdf_load_journal(doc, filename)

def ll_pdf_load_link_annots(arg_1, arg_2, annots, pagenum, page_ctm):
    r""" Low-level wrapper for `::pdf_load_link_annots()`."""
    return _mupdf.ll_pdf_load_link_annots(arg_1, arg_2, annots, pagenum, page_ctm)

def ll_pdf_load_links(page):
    r""" Low-level wrapper for `::pdf_load_links()`."""
    return _mupdf.ll_pdf_load_links(page)

def ll_pdf_load_name_tree(doc, which):
    r""" Low-level wrapper for `::pdf_load_name_tree()`."""
    return _mupdf.ll_pdf_load_name_tree(doc, which)

def ll_pdf_load_object(doc, num):
    r"""
    Low-level wrapper for `::pdf_load_object()`.
    Load a given object.

    This can cause xref reorganisations (solidifications etc) due to
    repairs, so all held pdf_xref_entries should be considered
    invalid after this call (other than the returned one).
    """
    return _mupdf.ll_pdf_load_object(doc, num)

def ll_pdf_load_outline(doc):
    r""" Low-level wrapper for `::pdf_load_outline()`."""
    return _mupdf.ll_pdf_load_outline(doc)

def ll_pdf_load_page(doc, number):
    r""" Low-level wrapper for `::pdf_load_page()`."""
    return _mupdf.ll_pdf_load_page(doc, number)

def ll_pdf_load_page_imp(doc, chapter, number):
    r""" Low-level wrapper for `::pdf_load_page_imp()`."""
    return _mupdf.ll_pdf_load_page_imp(doc, chapter, number)

def ll_pdf_load_page_tree(doc):
    r""" Low-level wrapper for `::pdf_load_page_tree()`."""
    return _mupdf.ll_pdf_load_page_tree(doc)

def ll_pdf_load_pattern(doc, obj):
    r""" Low-level wrapper for `::pdf_load_pattern()`."""
    return _mupdf.ll_pdf_load_pattern(doc, obj)

def ll_pdf_load_raw_stream(ref):
    r""" Low-level wrapper for `::pdf_load_raw_stream()`."""
    return _mupdf.ll_pdf_load_raw_stream(ref)

def ll_pdf_load_raw_stream_number(doc, num):
    r""" Low-level wrapper for `::pdf_load_raw_stream_number()`."""
    return _mupdf.ll_pdf_load_raw_stream_number(doc, num)

def ll_pdf_load_shading(doc, obj):
    r""" Low-level wrapper for `::pdf_load_shading()`."""
    return _mupdf.ll_pdf_load_shading(doc, obj)

def ll_pdf_load_stream(ref):
    r""" Low-level wrapper for `::pdf_load_stream()`."""
    return _mupdf.ll_pdf_load_stream(ref)

def ll_pdf_load_stream_number(doc, num):
    r""" Low-level wrapper for `::pdf_load_stream_number()`."""
    return _mupdf.ll_pdf_load_stream_number(doc, num)

def ll_pdf_load_stream_or_string_as_utf8(src):
    r""" Low-level wrapper for `::pdf_load_stream_or_string_as_utf8()`."""
    return _mupdf.ll_pdf_load_stream_or_string_as_utf8(src)

def ll_pdf_load_system_cmap(name):
    r""" Low-level wrapper for `::pdf_load_system_cmap()`."""
    return _mupdf.ll_pdf_load_system_cmap(name)

def ll_pdf_load_to_unicode(doc, font, strings, collection, cmapstm):
    r"""
     Low-level wrapper for `::pdf_load_to_unicode()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_pdf_load_to_unicode(::pdf_document *doc, ::pdf_font_desc *font, char *collection, ::pdf_obj *cmapstm)` => const char *strings
    """
    return _mupdf.ll_pdf_load_to_unicode(doc, font, strings, collection, cmapstm)

def ll_pdf_load_type3_font(doc, rdb, obj):
    r""" Low-level wrapper for `::pdf_load_type3_font()`."""
    return _mupdf.ll_pdf_load_type3_font(doc, rdb, obj)

def ll_pdf_load_type3_glyphs(doc, fontdesc):
    r""" Low-level wrapper for `::pdf_load_type3_glyphs()`."""
    return _mupdf.ll_pdf_load_type3_glyphs(doc, fontdesc)

def ll_pdf_load_unencrypted_object(doc, num):
    r""" Low-level wrapper for `::pdf_load_unencrypted_object()`."""
    return _mupdf.ll_pdf_load_unencrypted_object(doc, num)

def ll_pdf_lookup_cmap(cmap, cpt):
    r""" Low-level wrapper for `::pdf_lookup_cmap()`."""
    return _mupdf.ll_pdf_lookup_cmap(cmap, cpt)

def ll_pdf_lookup_cmap_full(cmap, cpt, out):
    r"""
     Low-level wrapper for `::pdf_lookup_cmap_full()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_pdf_lookup_cmap_full(::pdf_cmap *cmap, unsigned int cpt)` => `(int, int out)`
    """
    return _mupdf.ll_pdf_lookup_cmap_full(cmap, cpt, out)

def ll_pdf_lookup_dest(doc, needle):
    r""" Low-level wrapper for `::pdf_lookup_dest()`."""
    return _mupdf.ll_pdf_lookup_dest(doc, needle)

def ll_pdf_lookup_field(form, name):
    r""" Low-level wrapper for `::pdf_lookup_field()`."""
    return _mupdf.ll_pdf_lookup_field(form, name)

def ll_pdf_lookup_hmtx(font, cid):
    r""" Low-level wrapper for `::pdf_lookup_hmtx()`."""
    return _mupdf.ll_pdf_lookup_hmtx(font, cid)

def ll_pdf_lookup_metadata(doc, key, ptr, size):
    r""" Low-level wrapper for `::pdf_lookup_metadata()`."""
    return _mupdf.ll_pdf_lookup_metadata(doc, key, ptr, size)

def ll_pdf_lookup_metadata2(doc, key):
    r"""
     Low-level wrapper for `::pdf_lookup_metadata2()`.
    C++ alternative to `pdf_lookup_metadata()` that returns a `std::string`
    or calls `fz_throw()` if not found.
    """
    return _mupdf.ll_pdf_lookup_metadata2(doc, key)

def ll_pdf_lookup_name(doc, which, needle):
    r""" Low-level wrapper for `::pdf_lookup_name()`."""
    return _mupdf.ll_pdf_lookup_name(doc, which, needle)

def ll_pdf_lookup_number(root, needle):
    r""" Low-level wrapper for `::pdf_lookup_number()`."""
    return _mupdf.ll_pdf_lookup_number(root, needle)

def ll_pdf_lookup_page_loc(doc, needle, parentp, indexp):
    r"""
     Low-level wrapper for `::pdf_lookup_page_loc()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_pdf_lookup_page_loc(::pdf_document *doc, int needle, ::pdf_obj **parentp)` => `(pdf_obj *, int indexp)`
    """
    return _mupdf.ll_pdf_lookup_page_loc(doc, needle, parentp, indexp)

def ll_pdf_lookup_page_number(doc, pageobj):
    r""" Low-level wrapper for `::pdf_lookup_page_number()`."""
    return _mupdf.ll_pdf_lookup_page_number(doc, pageobj)

def ll_pdf_lookup_page_obj(doc, needle):
    r""" Low-level wrapper for `::pdf_lookup_page_obj()`."""
    return _mupdf.ll_pdf_lookup_page_obj(doc, needle)

def ll_pdf_lookup_substitute_font(mono, serif, bold, italic, len):
    r"""
     Low-level wrapper for `::pdf_lookup_substitute_font()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_pdf_lookup_substitute_font(int mono, int serif, int bold, int italic)` => `(const unsigned char *, int len)`
    """
    return _mupdf.ll_pdf_lookup_substitute_font(mono, serif, bold, italic, len)

def ll_pdf_lookup_vmtx(font, cid):
    r""" Low-level wrapper for `::pdf_lookup_vmtx()`."""
    return _mupdf.ll_pdf_lookup_vmtx(font, cid)

def ll_pdf_map_one_to_many(cmap, one, many, len):
    r"""
     Low-level wrapper for `::pdf_map_one_to_many()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_pdf_map_one_to_many(::pdf_cmap *cmap, unsigned int one, size_t len)` => int many
    """
    return _mupdf.ll_pdf_map_one_to_many(cmap, one, many, len)

def ll_pdf_map_range_to_range(cmap, srclo, srchi, dstlo):
    r""" Low-level wrapper for `::pdf_map_range_to_range()`."""
    return _mupdf.ll_pdf_map_range_to_range(cmap, srclo, srchi, dstlo)

def ll_pdf_mark_bits_reset(marks):
    r""" Low-level wrapper for `::pdf_mark_bits_reset()`."""
    return _mupdf.ll_pdf_mark_bits_reset(marks)

def ll_pdf_mark_bits_set(marks, obj):
    r""" Low-level wrapper for `::pdf_mark_bits_set()`."""
    return _mupdf.ll_pdf_mark_bits_set(marks, obj)

def ll_pdf_mark_list_check(list, obj):
    r""" Low-level wrapper for `::pdf_mark_list_check()`."""
    return _mupdf.ll_pdf_mark_list_check(list, obj)

def ll_pdf_mark_list_free(list):
    r""" Low-level wrapper for `::pdf_mark_list_free()`."""
    return _mupdf.ll_pdf_mark_list_free(list)

def ll_pdf_mark_list_init(list):
    r""" Low-level wrapper for `::pdf_mark_list_init()`."""
    return _mupdf.ll_pdf_mark_list_init(list)

def ll_pdf_mark_list_pop(list):
    r""" Low-level wrapper for `::pdf_mark_list_pop()`."""
    return _mupdf.ll_pdf_mark_list_pop(list)

def ll_pdf_mark_list_push(list, obj):
    r""" Low-level wrapper for `::pdf_mark_list_push()`."""
    return _mupdf.ll_pdf_mark_list_push(list, obj)

def ll_pdf_mark_obj(obj):
    r""" Low-level wrapper for `::pdf_mark_obj()`."""
    return _mupdf.ll_pdf_mark_obj(obj)

def ll_pdf_mark_xref(doc):
    r""" Low-level wrapper for `::pdf_mark_xref()`."""
    return _mupdf.ll_pdf_mark_xref(doc)

def ll_pdf_metadata(doc):
    r""" Low-level wrapper for `::pdf_metadata()`."""
    return _mupdf.ll_pdf_metadata(doc)

def ll_pdf_minimize_document(doc):
    r""" Low-level wrapper for `::pdf_minimize_document()`."""
    return _mupdf.ll_pdf_minimize_document(doc)

def ll_pdf_name_eq(a, b):
    r""" Low-level wrapper for `::pdf_name_eq()`."""
    return _mupdf.ll_pdf_name_eq(a, b)

def ll_pdf_name_from_line_ending(end):
    r""" Low-level wrapper for `::pdf_name_from_line_ending()`."""
    return _mupdf.ll_pdf_name_from_line_ending(end)

def ll_pdf_needs_password(doc):
    r""" Low-level wrapper for `::pdf_needs_password()`."""
    return _mupdf.ll_pdf_needs_password(doc)

def ll_pdf_new_action_from_link(doc, uri):
    r""" Low-level wrapper for `::pdf_new_action_from_link()`."""
    return _mupdf.ll_pdf_new_action_from_link(doc, uri)

def ll_pdf_new_array(doc, initialcap):
    r""" Low-level wrapper for `::pdf_new_array()`."""
    return _mupdf.ll_pdf_new_array(doc, initialcap)

def ll_pdf_new_buffer_processor(buffer, ahxencode, newlines):
    r""" Low-level wrapper for `::pdf_new_buffer_processor()`."""
    return _mupdf.ll_pdf_new_buffer_processor(buffer, ahxencode, newlines)

def ll_pdf_new_cmap():
    r""" Low-level wrapper for `::pdf_new_cmap()`."""
    return _mupdf.ll_pdf_new_cmap()

def ll_pdf_new_color_filter(doc, chain, struct_parents, transform, options, copts):
    r""" Low-level wrapper for `::pdf_new_color_filter()`."""
    return _mupdf.ll_pdf_new_color_filter(doc, chain, struct_parents, transform, options, copts)

def ll_pdf_new_crypt(enc, id):
    r""" Low-level wrapper for `::pdf_new_crypt()`."""
    return _mupdf.ll_pdf_new_crypt(enc, id)

def ll_pdf_new_date(doc, time):
    r""" Low-level wrapper for `::pdf_new_date()`."""
    return _mupdf.ll_pdf_new_date(doc, time)

def ll_pdf_new_dest_from_link(doc, uri, is_remote):
    r""" Low-level wrapper for `::pdf_new_dest_from_link()`."""
    return _mupdf.ll_pdf_new_dest_from_link(doc, uri, is_remote)

def ll_pdf_new_dict(doc, initialcap):
    r""" Low-level wrapper for `::pdf_new_dict()`."""
    return _mupdf.ll_pdf_new_dict(doc, initialcap)

def ll_pdf_new_display_list_from_annot(annot):
    r""" Low-level wrapper for `::pdf_new_display_list_from_annot()`."""
    return _mupdf.ll_pdf_new_display_list_from_annot(annot)

def ll_pdf_new_encrypt(opwd_utf8, upwd_utf8, id, permissions, algorithm):
    r""" Low-level wrapper for `::pdf_new_encrypt()`."""
    return _mupdf.ll_pdf_new_encrypt(opwd_utf8, upwd_utf8, id, permissions, algorithm)

def ll_pdf_new_font_desc():
    r""" Low-level wrapper for `::pdf_new_font_desc()`."""
    return _mupdf.ll_pdf_new_font_desc()

def ll_pdf_new_graft_map(dst):
    r""" Low-level wrapper for `::pdf_new_graft_map()`."""
    return _mupdf.ll_pdf_new_graft_map(dst)

def ll_pdf_new_identity_cmap(wmode, bytes):
    r""" Low-level wrapper for `::pdf_new_identity_cmap()`."""
    return _mupdf.ll_pdf_new_identity_cmap(wmode, bytes)

def ll_pdf_new_indirect(doc, num, gen):
    r""" Low-level wrapper for `::pdf_new_indirect()`."""
    return _mupdf.ll_pdf_new_indirect(doc, num, gen)

def ll_pdf_new_int(i):
    r""" Low-level wrapper for `::pdf_new_int()`."""
    return _mupdf.ll_pdf_new_int(i)

def ll_pdf_new_link(page, rect, uri, obj):
    r""" Low-level wrapper for `::pdf_new_link()`."""
    return _mupdf.ll_pdf_new_link(page, rect, uri, obj)

def ll_pdf_new_local_xref(doc):
    r""" Low-level wrapper for `::pdf_new_local_xref()`."""
    return _mupdf.ll_pdf_new_local_xref(doc)

def ll_pdf_new_mark_bits(doc):
    r""" Low-level wrapper for `::pdf_new_mark_bits()`."""
    return _mupdf.ll_pdf_new_mark_bits(doc)

def ll_pdf_new_matrix(doc, mtx):
    r""" Low-level wrapper for `::pdf_new_matrix()`."""
    return _mupdf.ll_pdf_new_matrix(doc, mtx)

def ll_pdf_new_name(str):
    r""" Low-level wrapper for `::pdf_new_name()`."""
    return _mupdf.ll_pdf_new_name(str)

def ll_pdf_new_outline_iterator(doc):
    r""" Low-level wrapper for `::pdf_new_outline_iterator()`."""
    return _mupdf.ll_pdf_new_outline_iterator(doc)

def ll_pdf_new_output_processor(out, ahxencode, newlines):
    r""" Low-level wrapper for `::pdf_new_output_processor()`."""
    return _mupdf.ll_pdf_new_output_processor(out, ahxencode, newlines)

def ll_pdf_new_pdf_device(doc, topctm, resources, contents):
    r""" Low-level wrapper for `::pdf_new_pdf_device()`."""
    return _mupdf.ll_pdf_new_pdf_device(doc, topctm, resources, contents)

def ll_pdf_new_pixmap_from_annot(annot, ctm, cs, seps, alpha):
    r""" Low-level wrapper for `::pdf_new_pixmap_from_annot()`."""
    return _mupdf.ll_pdf_new_pixmap_from_annot(annot, ctm, cs, seps, alpha)

def ll_pdf_new_pixmap_from_page_contents_with_separations_and_usage(page, ctm, cs, seps, alpha, usage, box):
    r""" Low-level wrapper for `::pdf_new_pixmap_from_page_contents_with_separations_and_usage()`."""
    return _mupdf.ll_pdf_new_pixmap_from_page_contents_with_separations_and_usage(page, ctm, cs, seps, alpha, usage, box)

def ll_pdf_new_pixmap_from_page_contents_with_usage(page, ctm, cs, alpha, usage, box):
    r""" Low-level wrapper for `::pdf_new_pixmap_from_page_contents_with_usage()`."""
    return _mupdf.ll_pdf_new_pixmap_from_page_contents_with_usage(page, ctm, cs, alpha, usage, box)

def ll_pdf_new_pixmap_from_page_with_separations_and_usage(page, ctm, cs, seps, alpha, usage, box):
    r""" Low-level wrapper for `::pdf_new_pixmap_from_page_with_separations_and_usage()`."""
    return _mupdf.ll_pdf_new_pixmap_from_page_with_separations_and_usage(page, ctm, cs, seps, alpha, usage, box)

def ll_pdf_new_pixmap_from_page_with_usage(page, ctm, cs, alpha, usage, box):
    r""" Low-level wrapper for `::pdf_new_pixmap_from_page_with_usage()`."""
    return _mupdf.ll_pdf_new_pixmap_from_page_with_usage(page, ctm, cs, alpha, usage, box)

def ll_pdf_new_processor(size):
    r""" Low-level wrapper for `::pdf_new_processor()`."""
    return _mupdf.ll_pdf_new_processor(size)

def ll_pdf_new_real(f):
    r""" Low-level wrapper for `::pdf_new_real()`."""
    return _mupdf.ll_pdf_new_real(f)

def ll_pdf_new_rect(doc, rect):
    r""" Low-level wrapper for `::pdf_new_rect()`."""
    return _mupdf.ll_pdf_new_rect(doc, rect)

def ll_pdf_new_run_processor(doc, dev, ctm, struct_parent, usage, gstate, default_cs, cookie):
    r""" Low-level wrapper for `::pdf_new_run_processor()`."""
    return _mupdf.ll_pdf_new_run_processor(doc, dev, ctm, struct_parent, usage, gstate, default_cs, cookie)

def ll_pdf_new_sanitize_filter(doc, chain, struct_parents, transform, options, sopts):
    r""" Low-level wrapper for `::pdf_new_sanitize_filter()`."""
    return _mupdf.ll_pdf_new_sanitize_filter(doc, chain, struct_parents, transform, options, sopts)

def ll_pdf_new_stext_page_from_annot(annot, options):
    r""" Low-level wrapper for `::pdf_new_stext_page_from_annot()`."""
    return _mupdf.ll_pdf_new_stext_page_from_annot(annot, options)

def ll_pdf_new_string(str, len):
    r""" Low-level wrapper for `::pdf_new_string()`."""
    return _mupdf.ll_pdf_new_string(str, len)

def ll_pdf_new_text_string(s):
    r""" Low-level wrapper for `::pdf_new_text_string()`."""
    return _mupdf.ll_pdf_new_text_string(s)

def ll_pdf_new_uri_from_explicit_dest(dest):
    r""" Low-level wrapper for `::pdf_new_uri_from_explicit_dest()`."""
    return _mupdf.ll_pdf_new_uri_from_explicit_dest(dest)

def ll_pdf_new_uri_from_path_and_explicit_dest(path, dest):
    r""" Low-level wrapper for `::pdf_new_uri_from_path_and_explicit_dest()`."""
    return _mupdf.ll_pdf_new_uri_from_path_and_explicit_dest(path, dest)

def ll_pdf_new_uri_from_path_and_named_dest(path, name):
    r""" Low-level wrapper for `::pdf_new_uri_from_path_and_named_dest()`."""
    return _mupdf.ll_pdf_new_uri_from_path_and_named_dest(path, name)

def ll_pdf_new_utf8_from_pdf_stream_obj(src):
    r""" Low-level wrapper for `::pdf_new_utf8_from_pdf_stream_obj()`."""
    return _mupdf.ll_pdf_new_utf8_from_pdf_stream_obj(src)

def ll_pdf_new_utf8_from_pdf_string(srcptr, srclen):
    r""" Low-level wrapper for `::pdf_new_utf8_from_pdf_string()`."""
    return _mupdf.ll_pdf_new_utf8_from_pdf_string(srcptr, srclen)

def ll_pdf_new_utf8_from_pdf_string_obj(src):
    r""" Low-level wrapper for `::pdf_new_utf8_from_pdf_string_obj()`."""
    return _mupdf.ll_pdf_new_utf8_from_pdf_string_obj(src)

def ll_pdf_new_xobject(doc, bbox, matrix, res, buffer):
    r""" Low-level wrapper for `::pdf_new_xobject()`."""
    return _mupdf.ll_pdf_new_xobject(doc, bbox, matrix, res, buffer)

def ll_pdf_next_annot(annot):
    r""" Low-level wrapper for `::pdf_next_annot()`."""
    return _mupdf.ll_pdf_next_annot(annot)

def ll_pdf_next_widget(previous):
    r""" Low-level wrapper for `::pdf_next_widget()`."""
    return _mupdf.ll_pdf_next_widget(previous)

def ll_pdf_obj_is_dirty(obj):
    r""" Low-level wrapper for `::pdf_obj_is_dirty()`."""
    return _mupdf.ll_pdf_obj_is_dirty(obj)

def ll_pdf_obj_is_incremental(obj):
    r""" Low-level wrapper for `::pdf_obj_is_incremental()`."""
    return _mupdf.ll_pdf_obj_is_incremental(obj)

def ll_pdf_obj_marked(obj):
    r""" Low-level wrapper for `::pdf_obj_marked()`."""
    return _mupdf.ll_pdf_obj_marked(obj)

def ll_pdf_obj_memo(obj, bit, memo):
    r"""
     Low-level wrapper for `::pdf_obj_memo()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_pdf_obj_memo(::pdf_obj *obj, int bit)` => `(int, int memo)`
    """
    return _mupdf.ll_pdf_obj_memo(obj, bit, memo)

def ll_pdf_obj_num_is_stream(doc, num):
    r""" Low-level wrapper for `::pdf_obj_num_is_stream()`."""
    return _mupdf.ll_pdf_obj_num_is_stream(doc, num)

def ll_pdf_obj_parent_num(obj):
    r""" Low-level wrapper for `::pdf_obj_parent_num()`."""
    return _mupdf.ll_pdf_obj_parent_num(obj)

def ll_pdf_obj_refs(ref):
    r""" Low-level wrapper for `::pdf_obj_refs()`."""
    return _mupdf.ll_pdf_obj_refs(ref)

def ll_pdf_objcmp(a, b):
    r""" Low-level wrapper for `::pdf_objcmp()`."""
    return _mupdf.ll_pdf_objcmp(a, b)

def ll_pdf_objcmp_deep(a, b):
    r""" Low-level wrapper for `::pdf_objcmp_deep()`."""
    return _mupdf.ll_pdf_objcmp_deep(a, b)

def ll_pdf_objcmp_resolve(a, b):
    r""" Low-level wrapper for `::pdf_objcmp_resolve()`."""
    return _mupdf.ll_pdf_objcmp_resolve(a, b)

def ll_pdf_open_contents_stream(doc, obj):
    r""" Low-level wrapper for `::pdf_open_contents_stream()`."""
    return _mupdf.ll_pdf_open_contents_stream(doc, obj)

def ll_pdf_open_crypt(chain, crypt, num, gen):
    r""" Low-level wrapper for `::pdf_open_crypt()`."""
    return _mupdf.ll_pdf_open_crypt(chain, crypt, num, gen)

def ll_pdf_open_crypt_with_filter(chain, crypt, name, num, gen):
    r""" Low-level wrapper for `::pdf_open_crypt_with_filter()`."""
    return _mupdf.ll_pdf_open_crypt_with_filter(chain, crypt, name, num, gen)

def ll_pdf_open_document(filename):
    r""" Low-level wrapper for `::pdf_open_document()`."""
    return _mupdf.ll_pdf_open_document(filename)

def ll_pdf_open_document_with_stream(file):
    r""" Low-level wrapper for `::pdf_open_document_with_stream()`."""
    return _mupdf.ll_pdf_open_document_with_stream(file)

def ll_pdf_open_inline_stream(doc, stmobj, length, chain, params):
    r""" Low-level wrapper for `::pdf_open_inline_stream()`."""
    return _mupdf.ll_pdf_open_inline_stream(doc, stmobj, length, chain, params)

def ll_pdf_open_raw_stream(ref):
    r""" Low-level wrapper for `::pdf_open_raw_stream()`."""
    return _mupdf.ll_pdf_open_raw_stream(ref)

def ll_pdf_open_raw_stream_number(doc, num):
    r""" Low-level wrapper for `::pdf_open_raw_stream_number()`."""
    return _mupdf.ll_pdf_open_raw_stream_number(doc, num)

def ll_pdf_open_stream(ref):
    r""" Low-level wrapper for `::pdf_open_stream()`."""
    return _mupdf.ll_pdf_open_stream(ref)

def ll_pdf_open_stream_number(doc, num):
    r""" Low-level wrapper for `::pdf_open_stream_number()`."""
    return _mupdf.ll_pdf_open_stream_number(doc, num)

def ll_pdf_open_stream_with_offset(doc, num, dict, stm_ofs):
    r""" Low-level wrapper for `::pdf_open_stream_with_offset()`."""
    return _mupdf.ll_pdf_open_stream_with_offset(doc, num, dict, stm_ofs)

def ll_pdf_page_contents(page):
    r""" Low-level wrapper for `::pdf_page_contents()`."""
    return _mupdf.ll_pdf_page_contents(page)

def ll_pdf_page_event_close(page):
    r""" Low-level wrapper for `::pdf_page_event_close()`."""
    return _mupdf.ll_pdf_page_event_close(page)

def ll_pdf_page_event_open(page):
    r""" Low-level wrapper for `::pdf_page_event_open()`."""
    return _mupdf.ll_pdf_page_event_open(page)

def ll_pdf_page_from_fz_page(ptr):
    r""" Low-level wrapper for `::pdf_page_from_fz_page()`."""
    return _mupdf.ll_pdf_page_from_fz_page(ptr)

def ll_pdf_page_group(page):
    r""" Low-level wrapper for `::pdf_page_group()`."""
    return _mupdf.ll_pdf_page_group(page)

def ll_pdf_page_has_transparency(page):
    r""" Low-level wrapper for `::pdf_page_has_transparency()`."""
    return _mupdf.ll_pdf_page_has_transparency(page)

def ll_pdf_page_label(doc, page, buf, size):
    r""" Low-level wrapper for `::pdf_page_label()`."""
    return _mupdf.ll_pdf_page_label(doc, page, buf, size)

def ll_pdf_page_label_imp(doc, chapter, page, buf, size):
    r""" Low-level wrapper for `::pdf_page_label_imp()`."""
    return _mupdf.ll_pdf_page_label_imp(doc, chapter, page, buf, size)

def ll_pdf_page_obj_transform(pageobj, outbox, outctm):
    r""" Low-level wrapper for `::pdf_page_obj_transform()`."""
    return _mupdf.ll_pdf_page_obj_transform(pageobj, outbox, outctm)

def ll_pdf_page_obj_transform_box(pageobj, outbox, out, box):
    r""" Low-level wrapper for `::pdf_page_obj_transform_box()`."""
    return _mupdf.ll_pdf_page_obj_transform_box(pageobj, outbox, out, box)

def ll_pdf_page_presentation(page, transition, duration):
    r"""
     Low-level wrapper for `::pdf_page_presentation()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_pdf_page_presentation(::pdf_page *page, ::fz_transition *transition)` => `(fz_transition *, float duration)`
    """
    return _mupdf.ll_pdf_page_presentation(page, transition, duration)

def ll_pdf_page_resources(page):
    r""" Low-level wrapper for `::pdf_page_resources()`."""
    return _mupdf.ll_pdf_page_resources(page)

def ll_pdf_page_separations(page):
    r""" Low-level wrapper for `::pdf_page_separations()`."""
    return _mupdf.ll_pdf_page_separations(page)

def ll_pdf_page_transform(page, mediabox, ctm):
    r""" Low-level wrapper for `::pdf_page_transform()`."""
    return _mupdf.ll_pdf_page_transform(page, mediabox, ctm)

def ll_pdf_page_transform_box(page, mediabox, ctm, box):
    r""" Low-level wrapper for `::pdf_page_transform_box()`."""
    return _mupdf.ll_pdf_page_transform_box(page, mediabox, ctm, box)

def ll_pdf_page_write(doc, mediabox, presources, pcontents):
    r"""
     Low-level wrapper for `::pdf_page_write()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_pdf_page_write(::pdf_document *doc, ::fz_rect mediabox, ::pdf_obj **presources, ::fz_buffer **pcontents)` => `(fz_device *)`
    """
    return _mupdf.ll_pdf_page_write(doc, mediabox, presources, pcontents)

def ll_pdf_parse_array(doc, f, buf):
    r""" Low-level wrapper for `::pdf_parse_array()`."""
    return _mupdf.ll_pdf_parse_array(doc, f, buf)

def ll_pdf_parse_date(s):
    r""" Low-level wrapper for `::pdf_parse_date()`."""
    return _mupdf.ll_pdf_parse_date(s)

def ll_pdf_parse_default_appearance(da, font, size, n, color):
    r"""
     Low-level wrapper for `::pdf_parse_default_appearance()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_pdf_parse_default_appearance(const char *da, float color[4])` => `(const char *font, float size, int n)`
    """
    return _mupdf.ll_pdf_parse_default_appearance(da, font, size, n, color)

def ll_pdf_parse_dict(doc, f, buf):
    r""" Low-level wrapper for `::pdf_parse_dict()`."""
    return _mupdf.ll_pdf_parse_dict(doc, f, buf)

def ll_pdf_parse_ind_obj(doc, f, num, gen, stm_ofs, try_repair):
    r"""
     Low-level wrapper for `::pdf_parse_ind_obj()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_pdf_parse_ind_obj(::pdf_document *doc, ::fz_stream *f)` => `(pdf_obj *, int num, int gen, int64_t stm_ofs, int try_repair)`
    """
    return _mupdf.ll_pdf_parse_ind_obj(doc, f, num, gen, stm_ofs, try_repair)

def ll_pdf_parse_journal_obj(doc, stm, onum, ostm, newobj):
    r"""
     Low-level wrapper for `::pdf_parse_journal_obj()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_pdf_parse_journal_obj(::pdf_document *doc, ::fz_stream *stm, ::fz_buffer **ostm)` => `(pdf_obj *, int onum, int newobj)`
    """
    return _mupdf.ll_pdf_parse_journal_obj(doc, stm, onum, ostm, newobj)

def ll_pdf_parse_stm_obj(doc, f, buf):
    r""" Low-level wrapper for `::pdf_parse_stm_obj()`."""
    return _mupdf.ll_pdf_parse_stm_obj(doc, f, buf)

def ll_pdf_parse_write_options(opts, args):
    r""" Low-level wrapper for `::pdf_parse_write_options()`."""
    return _mupdf.ll_pdf_parse_write_options(opts, args)

def ll_pdf_pin_document(obj):
    r""" Low-level wrapper for `::pdf_pin_document()`."""
    return _mupdf.ll_pdf_pin_document(obj)

def ll_pdf_preview_signature_as_display_list(w, h, lang, signer, appearance_flags, graphic, reason, location):
    r""" Low-level wrapper for `::pdf_preview_signature_as_display_list()`."""
    return _mupdf.ll_pdf_preview_signature_as_display_list(w, h, lang, signer, appearance_flags, graphic, reason, location)

def ll_pdf_preview_signature_as_pixmap(w, h, lang, signer, appearance_flags, graphic, reason, location):
    r""" Low-level wrapper for `::pdf_preview_signature_as_pixmap()`."""
    return _mupdf.ll_pdf_preview_signature_as_pixmap(w, h, lang, signer, appearance_flags, graphic, reason, location)

def ll_pdf_print_crypt(out, crypt):
    r""" Low-level wrapper for `::pdf_print_crypt()`."""
    return _mupdf.ll_pdf_print_crypt(out, crypt)

def ll_pdf_print_default_appearance(buf, nbuf, font, size, n, color):
    r""" Low-level wrapper for `::pdf_print_default_appearance()`."""
    return _mupdf.ll_pdf_print_default_appearance(buf, nbuf, font, size, n, color)

def ll_pdf_print_encrypted_obj(out, obj, tight, ascii, crypt, num, gen, sep):
    r"""
     Low-level wrapper for `::pdf_print_encrypted_obj()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_pdf_print_encrypted_obj(::fz_output *out, ::pdf_obj *obj, int tight, int ascii, ::pdf_crypt *crypt, int num, int gen)` => int sep
    """
    return _mupdf.ll_pdf_print_encrypted_obj(out, obj, tight, ascii, crypt, num, gen, sep)

def ll_pdf_print_font(out, fontdesc):
    r""" Low-level wrapper for `::pdf_print_font()`."""
    return _mupdf.ll_pdf_print_font(out, fontdesc)

def ll_pdf_print_obj(out, obj, tight, ascii):
    r""" Low-level wrapper for `::pdf_print_obj()`."""
    return _mupdf.ll_pdf_print_obj(out, obj, tight, ascii)

def ll_pdf_process_annot(proc, annot, cookie):
    r""" Low-level wrapper for `::pdf_process_annot()`."""
    return _mupdf.ll_pdf_process_annot(proc, annot, cookie)

def ll_pdf_process_contents(proc, doc, res, stm, cookie, out_res):
    r"""
     Low-level wrapper for `::pdf_process_contents()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_pdf_process_contents(::pdf_processor *proc, ::pdf_document *doc, ::pdf_obj *res, ::pdf_obj *stm, ::fz_cookie *cookie, ::pdf_obj **out_res)` =>
    """
    return _mupdf.ll_pdf_process_contents(proc, doc, res, stm, cookie, out_res)

def ll_pdf_process_glyph(proc, doc, resources, contents):
    r""" Low-level wrapper for `::pdf_process_glyph()`."""
    return _mupdf.ll_pdf_process_glyph(proc, doc, resources, contents)

def ll_pdf_process_raw_contents(proc, doc, rdb, stmobj, cookie):
    r""" Low-level wrapper for `::pdf_process_raw_contents()`."""
    return _mupdf.ll_pdf_process_raw_contents(proc, doc, rdb, stmobj, cookie)

def ll_pdf_processor_pop_resources(proc):
    r""" Low-level wrapper for `::pdf_processor_pop_resources()`."""
    return _mupdf.ll_pdf_processor_pop_resources(proc)

def ll_pdf_processor_push_resources(proc, res):
    r""" Low-level wrapper for `::pdf_processor_push_resources()`."""
    return _mupdf.ll_pdf_processor_push_resources(proc, res)

def ll_pdf_progressive_advance(doc, pagenum):
    r""" Low-level wrapper for `::pdf_progressive_advance()`."""
    return _mupdf.ll_pdf_progressive_advance(doc, pagenum)

def ll_pdf_purge_local_font_resources(doc):
    r""" Low-level wrapper for `::pdf_purge_local_font_resources()`."""
    return _mupdf.ll_pdf_purge_local_font_resources(doc)

def ll_pdf_purge_locals_from_store(doc):
    r""" Low-level wrapper for `::pdf_purge_locals_from_store()`."""
    return _mupdf.ll_pdf_purge_locals_from_store(doc)

def ll_pdf_read_journal(doc, stm):
    r""" Low-level wrapper for `::pdf_read_journal()`."""
    return _mupdf.ll_pdf_read_journal(doc, stm)

def ll_pdf_read_ocg(doc):
    r""" Low-level wrapper for `::pdf_read_ocg()`."""
    return _mupdf.ll_pdf_read_ocg(doc)

def ll_pdf_rearrange_pages(doc, count, pages):
    r""" Low-level wrapper for `::pdf_rearrange_pages()`."""
    return _mupdf.ll_pdf_rearrange_pages(doc, count, pages)

def ll_pdf_rearrange_pages2(doc, pages):
    r""" Low-level wrapper for `::pdf_rearrange_pages2()`.  Swig-friendly wrapper for pdf_rearrange_pages()."""
    return _mupdf.ll_pdf_rearrange_pages2(doc, pages)

def ll_pdf_recolor_shade(shade, reshade, opaque):
    r"""
    Low-level wrapper for `::pdf_recolor_shade()`.
    Recolor a shade.
    """
    return _mupdf.ll_pdf_recolor_shade(shade, reshade, opaque)

def ll_pdf_redact_page(doc, page, opts):
    r""" Low-level wrapper for `::pdf_redact_page()`."""
    return _mupdf.ll_pdf_redact_page(doc, page, opts)

def ll_pdf_redo(doc):
    r""" Low-level wrapper for `::pdf_redo()`."""
    return _mupdf.ll_pdf_redo(doc)

def ll_pdf_remove_item(drop, key):
    r""" Low-level wrapper for `::pdf_remove_item()`."""
    return _mupdf.ll_pdf_remove_item(drop, key)

def ll_pdf_repair_obj(doc, buf, stmofsp, stmlenp, encrypt, id, page, tmpofs, root):
    r"""
     Low-level wrapper for `::pdf_repair_obj()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_pdf_repair_obj(::pdf_document *doc, ::pdf_lexbuf *buf, ::pdf_obj **encrypt, ::pdf_obj **id, ::pdf_obj **page, ::pdf_obj **root)` => `(int, int64_t stmofsp, int64_t stmlenp, int64_t tmpofs)`
    """
    return _mupdf.ll_pdf_repair_obj(doc, buf, stmofsp, stmlenp, encrypt, id, page, tmpofs, root)

def ll_pdf_repair_obj_stms(doc):
    r""" Low-level wrapper for `::pdf_repair_obj_stms()`."""
    return _mupdf.ll_pdf_repair_obj_stms(doc)

def ll_pdf_repair_trailer(doc):
    r""" Low-level wrapper for `::pdf_repair_trailer()`."""
    return _mupdf.ll_pdf_repair_trailer(doc)

def ll_pdf_repair_xref(doc):
    r""" Low-level wrapper for `::pdf_repair_xref()`."""
    return _mupdf.ll_pdf_repair_xref(doc)

def ll_pdf_replace_xref(doc, entries, n):
    r""" Low-level wrapper for `::pdf_replace_xref()`."""
    return _mupdf.ll_pdf_replace_xref(doc, entries, n)

def ll_pdf_reset_form(doc, fields, exclude):
    r""" Low-level wrapper for `::pdf_reset_form()`."""
    return _mupdf.ll_pdf_reset_form(doc, fields, exclude)

def ll_pdf_reset_processor(proc):
    r""" Low-level wrapper for `::pdf_reset_processor()`."""
    return _mupdf.ll_pdf_reset_processor(proc)

def ll_pdf_resolve_indirect(ref):
    r"""
    Low-level wrapper for `::pdf_resolve_indirect()`.
    Resolve an indirect object (or chain of objects).

    This can cause xref reorganisations (solidifications etc) due to
    repairs, so all held pdf_xref_entries should be considered
    invalid after this call (other than the returned one).
    """
    return _mupdf.ll_pdf_resolve_indirect(ref)

def ll_pdf_resolve_indirect_chain(ref):
    r""" Low-level wrapper for `::pdf_resolve_indirect_chain()`."""
    return _mupdf.ll_pdf_resolve_indirect_chain(ref)

def ll_pdf_resolve_link(doc, uri, xp, yp):
    r"""
     Low-level wrapper for `::pdf_resolve_link()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_pdf_resolve_link(::pdf_document *doc, const char *uri)` => `(int, float xp, float yp)`
    """
    return _mupdf.ll_pdf_resolve_link(doc, uri, xp, yp)

def ll_pdf_resolve_link_dest(doc, uri):
    r""" Low-level wrapper for `::pdf_resolve_link_dest()`."""
    return _mupdf.ll_pdf_resolve_link_dest(doc, uri)

def ll_pdf_rewrite_images(doc, opts):
    r""" Low-level wrapper for `::pdf_rewrite_images()`."""
    return _mupdf.ll_pdf_rewrite_images(doc, opts)

def ll_pdf_run_annot(annot, dev, ctm, cookie):
    r""" Low-level wrapper for `::pdf_run_annot()`."""
    return _mupdf.ll_pdf_run_annot(annot, dev, ctm, cookie)

def ll_pdf_run_document_structure(doc, dev, cookie):
    r""" Low-level wrapper for `::pdf_run_document_structure()`."""
    return _mupdf.ll_pdf_run_document_structure(doc, dev, cookie)

def ll_pdf_run_glyph(doc, resources, contents, dev, ctm, gstate, default_cs):
    r""" Low-level wrapper for `::pdf_run_glyph()`."""
    return _mupdf.ll_pdf_run_glyph(doc, resources, contents, dev, ctm, gstate, default_cs)

def ll_pdf_run_page(page, dev, ctm, cookie):
    r""" Low-level wrapper for `::pdf_run_page()`."""
    return _mupdf.ll_pdf_run_page(page, dev, ctm, cookie)

def ll_pdf_run_page_annots(page, dev, ctm, cookie):
    r""" Low-level wrapper for `::pdf_run_page_annots()`."""
    return _mupdf.ll_pdf_run_page_annots(page, dev, ctm, cookie)

def ll_pdf_run_page_annots_with_usage(page, dev, ctm, usage, cookie):
    r""" Low-level wrapper for `::pdf_run_page_annots_with_usage()`."""
    return _mupdf.ll_pdf_run_page_annots_with_usage(page, dev, ctm, usage, cookie)

def ll_pdf_run_page_contents(page, dev, ctm, cookie):
    r""" Low-level wrapper for `::pdf_run_page_contents()`."""
    return _mupdf.ll_pdf_run_page_contents(page, dev, ctm, cookie)

def ll_pdf_run_page_contents_with_usage(page, dev, ctm, usage, cookie):
    r""" Low-level wrapper for `::pdf_run_page_contents_with_usage()`."""
    return _mupdf.ll_pdf_run_page_contents_with_usage(page, dev, ctm, usage, cookie)

def ll_pdf_run_page_widgets(page, dev, ctm, cookie):
    r""" Low-level wrapper for `::pdf_run_page_widgets()`."""
    return _mupdf.ll_pdf_run_page_widgets(page, dev, ctm, cookie)

def ll_pdf_run_page_widgets_with_usage(page, dev, ctm, usage, cookie):
    r""" Low-level wrapper for `::pdf_run_page_widgets_with_usage()`."""
    return _mupdf.ll_pdf_run_page_widgets_with_usage(page, dev, ctm, usage, cookie)

def ll_pdf_run_page_with_usage(page, dev, ctm, usage, cookie):
    r""" Low-level wrapper for `::pdf_run_page_with_usage()`."""
    return _mupdf.ll_pdf_run_page_with_usage(page, dev, ctm, usage, cookie)

def ll_pdf_sample_shade_function(shade, n, funcs, func, t0, t1):
    r"""
     Low-level wrapper for `::pdf_sample_shade_function()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_pdf_sample_shade_function(float shade[256][33], int n, int funcs, ::pdf_function **func, float t0, float t1)` =>
    """
    return _mupdf.ll_pdf_sample_shade_function(shade, n, funcs, func, t0, t1)

def ll_pdf_save_document(doc, filename, opts):
    r""" Low-level wrapper for `::pdf_save_document()`."""
    return _mupdf.ll_pdf_save_document(doc, filename, opts)

def ll_pdf_save_journal(doc, filename):
    r""" Low-level wrapper for `::pdf_save_journal()`."""
    return _mupdf.ll_pdf_save_journal(doc, filename)

def ll_pdf_save_snapshot(doc, filename):
    r""" Low-level wrapper for `::pdf_save_snapshot()`."""
    return _mupdf.ll_pdf_save_snapshot(doc, filename)

def ll_pdf_select_layer_config(doc, config_num):
    r""" Low-level wrapper for `::pdf_select_layer_config()`."""
    return _mupdf.ll_pdf_select_layer_config(doc, config_num)

def ll_pdf_select_layer_config_ui(doc, ui):
    r""" Low-level wrapper for `::pdf_select_layer_config_ui()`."""
    return _mupdf.ll_pdf_select_layer_config_ui(doc, ui)

def ll_pdf_serialise_journal(doc, out):
    r""" Low-level wrapper for `::pdf_serialise_journal()`."""
    return _mupdf.ll_pdf_serialise_journal(doc, out)

def ll_pdf_set_annot_active(annot, active):
    r""" Low-level wrapper for `::pdf_set_annot_active()`."""
    return _mupdf.ll_pdf_set_annot_active(annot, active)

def ll_pdf_set_annot_appearance(annot, appearance, state, ctm, bbox, res, contents):
    r""" Low-level wrapper for `::pdf_set_annot_appearance()`."""
    return _mupdf.ll_pdf_set_annot_appearance(annot, appearance, state, ctm, bbox, res, contents)

def ll_pdf_set_annot_appearance_from_display_list(annot, appearance, state, ctm, list):
    r""" Low-level wrapper for `::pdf_set_annot_appearance_from_display_list()`."""
    return _mupdf.ll_pdf_set_annot_appearance_from_display_list(annot, appearance, state, ctm, list)

def ll_pdf_set_annot_author(annot, author):
    r""" Low-level wrapper for `::pdf_set_annot_author()`."""
    return _mupdf.ll_pdf_set_annot_author(annot, author)

def ll_pdf_set_annot_border(annot, width):
    r""" Low-level wrapper for `::pdf_set_annot_border()`."""
    return _mupdf.ll_pdf_set_annot_border(annot, width)

def ll_pdf_set_annot_border_effect(annot, effect):
    r""" Low-level wrapper for `::pdf_set_annot_border_effect()`."""
    return _mupdf.ll_pdf_set_annot_border_effect(annot, effect)

def ll_pdf_set_annot_border_effect_intensity(annot, intensity):
    r""" Low-level wrapper for `::pdf_set_annot_border_effect_intensity()`."""
    return _mupdf.ll_pdf_set_annot_border_effect_intensity(annot, intensity)

def ll_pdf_set_annot_border_style(annot, style):
    r""" Low-level wrapper for `::pdf_set_annot_border_style()`."""
    return _mupdf.ll_pdf_set_annot_border_style(annot, style)

def ll_pdf_set_annot_border_width(annot, width):
    r""" Low-level wrapper for `::pdf_set_annot_border_width()`."""
    return _mupdf.ll_pdf_set_annot_border_width(annot, width)

def ll_pdf_set_annot_color(annot, n, color):
    r""" Low-level wrapper for `::pdf_set_annot_color()`."""
    return _mupdf.ll_pdf_set_annot_color(annot, n, color)

def ll_pdf_set_annot_contents(annot, text):
    r""" Low-level wrapper for `::pdf_set_annot_contents()`."""
    return _mupdf.ll_pdf_set_annot_contents(annot, text)

def ll_pdf_set_annot_creation_date(annot, time):
    r""" Low-level wrapper for `::pdf_set_annot_creation_date()`."""
    return _mupdf.ll_pdf_set_annot_creation_date(annot, time)

def ll_pdf_set_annot_default_appearance(annot, font, size, n, color):
    r""" Low-level wrapper for `::pdf_set_annot_default_appearance()`."""
    return _mupdf.ll_pdf_set_annot_default_appearance(annot, font, size, n, color)

def ll_pdf_set_annot_field_value(doc, widget, text, ignore_trigger_events):
    r""" Low-level wrapper for `::pdf_set_annot_field_value()`."""
    return _mupdf.ll_pdf_set_annot_field_value(doc, widget, text, ignore_trigger_events)

def ll_pdf_set_annot_filespec(annot, obj):
    r""" Low-level wrapper for `::pdf_set_annot_filespec()`."""
    return _mupdf.ll_pdf_set_annot_filespec(annot, obj)

def ll_pdf_set_annot_flags(annot, flags):
    r""" Low-level wrapper for `::pdf_set_annot_flags()`."""
    return _mupdf.ll_pdf_set_annot_flags(annot, flags)

def ll_pdf_set_annot_hidden_for_editing(annot, hidden):
    r""" Low-level wrapper for `::pdf_set_annot_hidden_for_editing()`."""
    return _mupdf.ll_pdf_set_annot_hidden_for_editing(annot, hidden)

def ll_pdf_set_annot_hot(annot, hot):
    r""" Low-level wrapper for `::pdf_set_annot_hot()`."""
    return _mupdf.ll_pdf_set_annot_hot(annot, hot)

def ll_pdf_set_annot_icon_name(annot, name):
    r""" Low-level wrapper for `::pdf_set_annot_icon_name()`."""
    return _mupdf.ll_pdf_set_annot_icon_name(annot, name)

def ll_pdf_set_annot_ink_list(annot, n, count, v):
    r""" Low-level wrapper for `::pdf_set_annot_ink_list()`."""
    return _mupdf.ll_pdf_set_annot_ink_list(annot, n, count, v)

def ll_pdf_set_annot_interior_color(annot, n, color):
    r""" Low-level wrapper for `::pdf_set_annot_interior_color()`."""
    return _mupdf.ll_pdf_set_annot_interior_color(annot, n, color)

def ll_pdf_set_annot_is_open(annot, is_open):
    r""" Low-level wrapper for `::pdf_set_annot_is_open()`."""
    return _mupdf.ll_pdf_set_annot_is_open(annot, is_open)

def ll_pdf_set_annot_language(annot, lang):
    r""" Low-level wrapper for `::pdf_set_annot_language()`."""
    return _mupdf.ll_pdf_set_annot_language(annot, lang)

def ll_pdf_set_annot_line(annot, a, b):
    r""" Low-level wrapper for `::pdf_set_annot_line()`."""
    return _mupdf.ll_pdf_set_annot_line(annot, a, b)

def ll_pdf_set_annot_line_end_style(annot, e):
    r""" Low-level wrapper for `::pdf_set_annot_line_end_style()`."""
    return _mupdf.ll_pdf_set_annot_line_end_style(annot, e)

def ll_pdf_set_annot_line_ending_styles(annot, start_style, end_style):
    r""" Low-level wrapper for `::pdf_set_annot_line_ending_styles()`."""
    return _mupdf.ll_pdf_set_annot_line_ending_styles(annot, start_style, end_style)

def ll_pdf_set_annot_line_start_style(annot, s):
    r""" Low-level wrapper for `::pdf_set_annot_line_start_style()`."""
    return _mupdf.ll_pdf_set_annot_line_start_style(annot, s)

def ll_pdf_set_annot_modification_date(annot, time):
    r""" Low-level wrapper for `::pdf_set_annot_modification_date()`."""
    return _mupdf.ll_pdf_set_annot_modification_date(annot, time)

def ll_pdf_set_annot_opacity(annot, opacity):
    r""" Low-level wrapper for `::pdf_set_annot_opacity()`."""
    return _mupdf.ll_pdf_set_annot_opacity(annot, opacity)

def ll_pdf_set_annot_popup(annot, rect):
    r""" Low-level wrapper for `::pdf_set_annot_popup()`."""
    return _mupdf.ll_pdf_set_annot_popup(annot, rect)

def ll_pdf_set_annot_quad_points(annot, n, qv):
    r""" Low-level wrapper for `::pdf_set_annot_quad_points()`."""
    return _mupdf.ll_pdf_set_annot_quad_points(annot, n, qv)

def ll_pdf_set_annot_quadding(annot, q):
    r""" Low-level wrapper for `::pdf_set_annot_quadding()`."""
    return _mupdf.ll_pdf_set_annot_quadding(annot, q)

def ll_pdf_set_annot_rect(annot, rect):
    r""" Low-level wrapper for `::pdf_set_annot_rect()`."""
    return _mupdf.ll_pdf_set_annot_rect(annot, rect)

def ll_pdf_set_annot_resynthesised(annot):
    r""" Low-level wrapper for `::pdf_set_annot_resynthesised()`."""
    return _mupdf.ll_pdf_set_annot_resynthesised(annot)

def ll_pdf_set_annot_stamp_image(annot, image):
    r""" Low-level wrapper for `::pdf_set_annot_stamp_image()`."""
    return _mupdf.ll_pdf_set_annot_stamp_image(annot, image)

def ll_pdf_set_annot_vertex(annot, i, p):
    r""" Low-level wrapper for `::pdf_set_annot_vertex()`."""
    return _mupdf.ll_pdf_set_annot_vertex(annot, i, p)

def ll_pdf_set_annot_vertices(annot, n, v):
    r""" Low-level wrapper for `::pdf_set_annot_vertices()`."""
    return _mupdf.ll_pdf_set_annot_vertices(annot, n, v)

def ll_pdf_set_choice_field_value(widget, value):
    r""" Low-level wrapper for `::pdf_set_choice_field_value()`."""
    return _mupdf.ll_pdf_set_choice_field_value(widget, value)

def ll_pdf_set_cmap_wmode(cmap, wmode):
    r""" Low-level wrapper for `::pdf_set_cmap_wmode()`."""
    return _mupdf.ll_pdf_set_cmap_wmode(cmap, wmode)

def ll_pdf_set_default_hmtx(font, w):
    r""" Low-level wrapper for `::pdf_set_default_hmtx()`."""
    return _mupdf.ll_pdf_set_default_hmtx(font, w)

def ll_pdf_set_default_vmtx(font, y, w):
    r""" Low-level wrapper for `::pdf_set_default_vmtx()`."""
    return _mupdf.ll_pdf_set_default_vmtx(font, y, w)

def ll_pdf_set_doc_event_callback(doc, event_cb, free_event_data_cb, data):
    r""" Low-level wrapper for `::pdf_set_doc_event_callback()`."""
    return _mupdf.ll_pdf_set_doc_event_callback(doc, event_cb, free_event_data_cb, data)

def ll_pdf_set_document_language(doc, lang):
    r""" Low-level wrapper for `::pdf_set_document_language()`."""
    return _mupdf.ll_pdf_set_document_language(doc, lang)

def ll_pdf_set_field_value(doc, field, text, ignore_trigger_events):
    r""" Low-level wrapper for `::pdf_set_field_value()`."""
    return _mupdf.ll_pdf_set_field_value(doc, field, text, ignore_trigger_events)

def ll_pdf_set_font_wmode(font, wmode):
    r""" Low-level wrapper for `::pdf_set_font_wmode()`."""
    return _mupdf.ll_pdf_set_font_wmode(font, wmode)

def ll_pdf_set_int(obj, i):
    r""" Low-level wrapper for `::pdf_set_int()`."""
    return _mupdf.ll_pdf_set_int(obj, i)

def ll_pdf_set_layer_config_as_default(doc):
    r""" Low-level wrapper for `::pdf_set_layer_config_as_default()`."""
    return _mupdf.ll_pdf_set_layer_config_as_default(doc)

def ll_pdf_set_obj_memo(obj, bit, memo):
    r""" Low-level wrapper for `::pdf_set_obj_memo()`."""
    return _mupdf.ll_pdf_set_obj_memo(obj, bit, memo)

def ll_pdf_set_obj_parent(obj, num):
    r""" Low-level wrapper for `::pdf_set_obj_parent()`."""
    return _mupdf.ll_pdf_set_obj_parent(obj, num)

def ll_pdf_set_page_box(page, box, rect):
    r""" Low-level wrapper for `::pdf_set_page_box()`."""
    return _mupdf.ll_pdf_set_page_box(page, box, rect)

def ll_pdf_set_page_labels(doc, index, style, prefix, start):
    r""" Low-level wrapper for `::pdf_set_page_labels()`."""
    return _mupdf.ll_pdf_set_page_labels(doc, index, style, prefix, start)

def ll_pdf_set_populating_xref_trailer(doc, trailer):
    r""" Low-level wrapper for `::pdf_set_populating_xref_trailer()`."""
    return _mupdf.ll_pdf_set_populating_xref_trailer(doc, trailer)

def ll_pdf_set_str_len(obj, newlen):
    r""" Low-level wrapper for `::pdf_set_str_len()`."""
    return _mupdf.ll_pdf_set_str_len(obj, newlen)

def ll_pdf_set_text_field_value(widget, value):
    r""" Low-level wrapper for `::pdf_set_text_field_value()`."""
    return _mupdf.ll_pdf_set_text_field_value(widget, value)

def ll_pdf_set_usecmap(cmap, usecmap):
    r""" Low-level wrapper for `::pdf_set_usecmap()`."""
    return _mupdf.ll_pdf_set_usecmap(cmap, usecmap)

def ll_pdf_set_widget_editing_state(widget, editing):
    r""" Low-level wrapper for `::pdf_set_widget_editing_state()`."""
    return _mupdf.ll_pdf_set_widget_editing_state(widget, editing)

def ll_pdf_sign_signature(widget, signer, appearance_flags, graphic, reason, location):
    r""" Low-level wrapper for `::pdf_sign_signature()`."""
    return _mupdf.ll_pdf_sign_signature(widget, signer, appearance_flags, graphic, reason, location)

def ll_pdf_sign_signature_with_appearance(widget, signer, date, disp_list):
    r""" Low-level wrapper for `::pdf_sign_signature_with_appearance()`."""
    return _mupdf.ll_pdf_sign_signature_with_appearance(widget, signer, date, disp_list)

def ll_pdf_signature_appearance_signed(rect, lang, img, left_text, right_text, include_logo):
    r""" Low-level wrapper for `::pdf_signature_appearance_signed()`."""
    return _mupdf.ll_pdf_signature_appearance_signed(rect, lang, img, left_text, right_text, include_logo)

def ll_pdf_signature_appearance_unsigned(rect, lang):
    r""" Low-level wrapper for `::pdf_signature_appearance_unsigned()`."""
    return _mupdf.ll_pdf_signature_appearance_unsigned(rect, lang)

def ll_pdf_signature_byte_range(doc, signature, byte_range):
    r""" Low-level wrapper for `::pdf_signature_byte_range()`."""
    return _mupdf.ll_pdf_signature_byte_range(doc, signature, byte_range)

def ll_pdf_signature_contents(doc, signature, contents):
    r"""
     Low-level wrapper for `::pdf_signature_contents()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_pdf_signature_contents(::pdf_document *doc, ::pdf_obj *signature)` => `(size_t, char *contents)`
    """
    return _mupdf.ll_pdf_signature_contents(doc, signature, contents)

def ll_pdf_signature_drop_distinguished_name(name):
    r""" Low-level wrapper for `::pdf_signature_drop_distinguished_name()`."""
    return _mupdf.ll_pdf_signature_drop_distinguished_name(name)

def ll_pdf_signature_error_description(err):
    r""" Low-level wrapper for `::pdf_signature_error_description()`."""
    return _mupdf.ll_pdf_signature_error_description(err)

def ll_pdf_signature_format_distinguished_name(name):
    r""" Low-level wrapper for `::pdf_signature_format_distinguished_name()`."""
    return _mupdf.ll_pdf_signature_format_distinguished_name(name)

def ll_pdf_signature_get_signatory(verifier, doc, signature):
    r""" Low-level wrapper for `::pdf_signature_get_signatory()`."""
    return _mupdf.ll_pdf_signature_get_signatory(verifier, doc, signature)

def ll_pdf_signature_get_widget_signatory(verifier, widget):
    r""" Low-level wrapper for `::pdf_signature_get_widget_signatory()`."""
    return _mupdf.ll_pdf_signature_get_widget_signatory(verifier, widget)

def ll_pdf_signature_hash_bytes(doc, signature):
    r""" Low-level wrapper for `::pdf_signature_hash_bytes()`."""
    return _mupdf.ll_pdf_signature_hash_bytes(doc, signature)

def ll_pdf_signature_incremental_change_since_signing(doc, signature):
    r""" Low-level wrapper for `::pdf_signature_incremental_change_since_signing()`."""
    return _mupdf.ll_pdf_signature_incremental_change_since_signing(doc, signature)

def ll_pdf_signature_info(name, dn, reason, location, date, include_labels):
    r""" Low-level wrapper for `::pdf_signature_info()`."""
    return _mupdf.ll_pdf_signature_info(name, dn, reason, location, date, include_labels)

def ll_pdf_signature_is_signed(doc, field):
    r""" Low-level wrapper for `::pdf_signature_is_signed()`."""
    return _mupdf.ll_pdf_signature_is_signed(doc, field)

def ll_pdf_signature_set_value(doc, field, signer, stime):
    r""" Low-level wrapper for `::pdf_signature_set_value()`."""
    return _mupdf.ll_pdf_signature_set_value(doc, field, signer, stime)

def ll_pdf_sort_cmap(cmap):
    r""" Low-level wrapper for `::pdf_sort_cmap()`."""
    return _mupdf.ll_pdf_sort_cmap(cmap)

def ll_pdf_sort_dict(dict):
    r""" Low-level wrapper for `::pdf_sort_dict()`."""
    return _mupdf.ll_pdf_sort_dict(dict)

def ll_pdf_specifics(doc):
    r""" Low-level wrapper for `::pdf_specifics()`."""
    return _mupdf.ll_pdf_specifics(doc)

def ll_pdf_sprint_obj(buf, cap, len, obj, tight, ascii):
    r"""
     Low-level wrapper for `::pdf_sprint_obj()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_pdf_sprint_obj(char *buf, size_t cap, ::pdf_obj *obj, int tight, int ascii)` => `(char *, size_t len)`
    """
    return _mupdf.ll_pdf_sprint_obj(buf, cap, len, obj, tight, ascii)

def ll_pdf_store_item(key, val, itemsize):
    r""" Low-level wrapper for `::pdf_store_item()`."""
    return _mupdf.ll_pdf_store_item(key, val, itemsize)

def ll_pdf_string_from_annot_type(type):
    r""" Low-level wrapper for `::pdf_string_from_annot_type()`."""
    return _mupdf.ll_pdf_string_from_annot_type(type)

def ll_pdf_string_from_line_ending(end):
    r""" Low-level wrapper for `::pdf_string_from_line_ending()`."""
    return _mupdf.ll_pdf_string_from_line_ending(end)

def ll_pdf_structure_type(role_map, tag):
    r""" Low-level wrapper for `::pdf_structure_type()`."""
    return _mupdf.ll_pdf_structure_type(role_map, tag)

def ll_pdf_subset_fonts(doc, pages_len, pages):
    r""" Low-level wrapper for `::pdf_subset_fonts()`."""
    return _mupdf.ll_pdf_subset_fonts(doc, pages_len, pages)

def ll_pdf_subset_fonts2(doc, pages):
    r""" Low-level wrapper for `::pdf_subset_fonts2()`.  Swig-friendly wrapper for pdf_subset_fonts()."""
    return _mupdf.ll_pdf_subset_fonts2(doc, pages)

def ll_pdf_text_widget_format(tw):
    r""" Low-level wrapper for `::pdf_text_widget_format()`."""
    return _mupdf.ll_pdf_text_widget_format(tw)

def ll_pdf_text_widget_max_len(tw):
    r""" Low-level wrapper for `::pdf_text_widget_max_len()`."""
    return _mupdf.ll_pdf_text_widget_max_len(tw)

def ll_pdf_to_bool(obj):
    r""" Low-level wrapper for `::pdf_to_bool()`."""
    return _mupdf.ll_pdf_to_bool(obj)

def ll_pdf_to_bool_default(obj, _def):
    r""" Low-level wrapper for `::pdf_to_bool_default()`."""
    return _mupdf.ll_pdf_to_bool_default(obj, _def)

def ll_pdf_to_date(time):
    r""" Low-level wrapper for `::pdf_to_date()`."""
    return _mupdf.ll_pdf_to_date(time)

def ll_pdf_to_gen(obj):
    r""" Low-level wrapper for `::pdf_to_gen()`."""
    return _mupdf.ll_pdf_to_gen(obj)

def ll_pdf_to_int(obj):
    r""" Low-level wrapper for `::pdf_to_int()`."""
    return _mupdf.ll_pdf_to_int(obj)

def ll_pdf_to_int64(obj):
    r""" Low-level wrapper for `::pdf_to_int64()`."""
    return _mupdf.ll_pdf_to_int64(obj)

def ll_pdf_to_int_default(obj, _def):
    r""" Low-level wrapper for `::pdf_to_int_default()`."""
    return _mupdf.ll_pdf_to_int_default(obj, _def)

def ll_pdf_to_matrix(array):
    r""" Low-level wrapper for `::pdf_to_matrix()`."""
    return _mupdf.ll_pdf_to_matrix(array)

def ll_pdf_to_name(obj):
    r""" Low-level wrapper for `::pdf_to_name()`."""
    return _mupdf.ll_pdf_to_name(obj)

def ll_pdf_to_num(obj):
    r""" Low-level wrapper for `::pdf_to_num()`."""
    return _mupdf.ll_pdf_to_num(obj)

def ll_pdf_to_quad(array, offset):
    r""" Low-level wrapper for `::pdf_to_quad()`."""
    return _mupdf.ll_pdf_to_quad(array, offset)

def ll_pdf_to_real(obj):
    r""" Low-level wrapper for `::pdf_to_real()`."""
    return _mupdf.ll_pdf_to_real(obj)

def ll_pdf_to_real_default(obj, _def):
    r""" Low-level wrapper for `::pdf_to_real_default()`."""
    return _mupdf.ll_pdf_to_real_default(obj, _def)

def ll_pdf_to_rect(array):
    r""" Low-level wrapper for `::pdf_to_rect()`."""
    return _mupdf.ll_pdf_to_rect(array)

def ll_pdf_to_str_buf(obj):
    r""" Low-level wrapper for `::pdf_to_str_buf()`."""
    return _mupdf.ll_pdf_to_str_buf(obj)

def ll_pdf_to_str_len(obj):
    r""" Low-level wrapper for `::pdf_to_str_len()`."""
    return _mupdf.ll_pdf_to_str_len(obj)

def ll_pdf_to_string(obj, sizep):
    r"""
     Low-level wrapper for `::pdf_to_string()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_pdf_to_string(::pdf_obj *obj)` => `(const char *, size_t sizep)`
    """
    return _mupdf.ll_pdf_to_string(obj, sizep)

def ll_pdf_to_text_string(obj):
    r""" Low-level wrapper for `::pdf_to_text_string()`."""
    return _mupdf.ll_pdf_to_text_string(obj)

def ll_pdf_toggle_layer_config_ui(doc, ui):
    r""" Low-level wrapper for `::pdf_toggle_layer_config_ui()`."""
    return _mupdf.ll_pdf_toggle_layer_config_ui(doc, ui)

def ll_pdf_toggle_widget(widget):
    r""" Low-level wrapper for `::pdf_toggle_widget()`."""
    return _mupdf.ll_pdf_toggle_widget(widget)

def ll_pdf_tos_get_text(tos):
    r""" Low-level wrapper for `::pdf_tos_get_text()`."""
    return _mupdf.ll_pdf_tos_get_text(tos)

def ll_pdf_tos_make_trm(tos, text, fontdesc, cid, trm):
    r""" Low-level wrapper for `::pdf_tos_make_trm()`."""
    return _mupdf.ll_pdf_tos_make_trm(tos, text, fontdesc, cid, trm)

def ll_pdf_tos_move_after_char(tos):
    r""" Low-level wrapper for `::pdf_tos_move_after_char()`."""
    return _mupdf.ll_pdf_tos_move_after_char(tos)

def ll_pdf_tos_newline(tos, leading):
    r""" Low-level wrapper for `::pdf_tos_newline()`."""
    return _mupdf.ll_pdf_tos_newline(tos, leading)

def ll_pdf_tos_reset(tos, render):
    r""" Low-level wrapper for `::pdf_tos_reset()`."""
    return _mupdf.ll_pdf_tos_reset(tos, render)

def ll_pdf_tos_restore(tos, save):
    r""" Low-level wrapper for `::pdf_tos_restore()`."""
    return _mupdf.ll_pdf_tos_restore(tos, save)

def ll_pdf_tos_save(tos, save):
    r""" Low-level wrapper for `::pdf_tos_save()`."""
    return _mupdf.ll_pdf_tos_save(tos, save)

def ll_pdf_tos_set_matrix(tos, a, b, c, d, e, f):
    r""" Low-level wrapper for `::pdf_tos_set_matrix()`."""
    return _mupdf.ll_pdf_tos_set_matrix(tos, a, b, c, d, e, f)

def ll_pdf_tos_translate(tos, tx, ty):
    r""" Low-level wrapper for `::pdf_tos_translate()`."""
    return _mupdf.ll_pdf_tos_translate(tos, tx, ty)

def ll_pdf_trailer(doc):
    r""" Low-level wrapper for `::pdf_trailer()`."""
    return _mupdf.ll_pdf_trailer(doc)

def ll_pdf_undo(doc):
    r""" Low-level wrapper for `::pdf_undo()`."""
    return _mupdf.ll_pdf_undo(doc)

def ll_pdf_undoredo_state(doc, steps):
    r"""
     Low-level wrapper for `::pdf_undoredo_state()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_pdf_undoredo_state(::pdf_document *doc)` => `(int, int steps)`
    """
    return _mupdf.ll_pdf_undoredo_state(doc, steps)

def ll_pdf_undoredo_step(doc, step):
    r""" Low-level wrapper for `::pdf_undoredo_step()`."""
    return _mupdf.ll_pdf_undoredo_step(doc, step)

def ll_pdf_unmark_obj(obj):
    r""" Low-level wrapper for `::pdf_unmark_obj()`."""
    return _mupdf.ll_pdf_unmark_obj(obj)

def ll_pdf_update_annot(annot):
    r""" Low-level wrapper for `::pdf_update_annot()`."""
    return _mupdf.ll_pdf_update_annot(annot)

def ll_pdf_update_default_colorspaces(old_cs, res):
    r""" Low-level wrapper for `::pdf_update_default_colorspaces()`."""
    return _mupdf.ll_pdf_update_default_colorspaces(old_cs, res)

def ll_pdf_update_object(doc, num, obj):
    r""" Low-level wrapper for `::pdf_update_object()`."""
    return _mupdf.ll_pdf_update_object(doc, num, obj)

def ll_pdf_update_page(page):
    r""" Low-level wrapper for `::pdf_update_page()`."""
    return _mupdf.ll_pdf_update_page(page)

def ll_pdf_update_stream(doc, ref, buf, compressed):
    r""" Low-level wrapper for `::pdf_update_stream()`."""
    return _mupdf.ll_pdf_update_stream(doc, ref, buf, compressed)

def ll_pdf_update_widget(widget):
    r""" Low-level wrapper for `::pdf_update_widget()`."""
    return _mupdf.ll_pdf_update_widget(widget)

def ll_pdf_update_xobject(doc, xobj, bbox, mat, res, buffer):
    r""" Low-level wrapper for `::pdf_update_xobject()`."""
    return _mupdf.ll_pdf_update_xobject(doc, xobj, bbox, mat, res, buffer)

def ll_pdf_validate_change_history(doc):
    r""" Low-level wrapper for `::pdf_validate_change_history()`."""
    return _mupdf.ll_pdf_validate_change_history(doc)

def ll_pdf_validate_changes(doc, version):
    r""" Low-level wrapper for `::pdf_validate_changes()`."""
    return _mupdf.ll_pdf_validate_changes(doc, version)

def ll_pdf_validate_signature(widget):
    r""" Low-level wrapper for `::pdf_validate_signature()`."""
    return _mupdf.ll_pdf_validate_signature(widget)

def ll_pdf_verify_embedded_file_checksum(fs):
    r""" Low-level wrapper for `::pdf_verify_embedded_file_checksum()`."""
    return _mupdf.ll_pdf_verify_embedded_file_checksum(fs)

def ll_pdf_version(doc):
    r""" Low-level wrapper for `::pdf_version()`."""
    return _mupdf.ll_pdf_version(doc)

def ll_pdf_walk_tree(tree, kid_name, arrive, leave, arg, names, values):
    r"""
     Low-level wrapper for `::pdf_walk_tree()`.

    This function has out-params. Python/C# wrappers look like:
    	`ll_pdf_walk_tree(::pdf_obj *tree, ::pdf_obj *kid_name, void (*arrive)(::fz_context *, ::pdf_obj *, void *, ::pdf_obj **), void (*leave)(::fz_context *, ::pdf_obj *, void *), void *arg, ::pdf_obj **names, ::pdf_obj **values)` => `()`
    """
    return _mupdf.ll_pdf_walk_tree(tree, kid_name, arrive, leave, arg, names, values)

def ll_pdf_was_pure_xfa(doc):
    r""" Low-level wrapper for `::pdf_was_pure_xfa()`."""
    return _mupdf.ll_pdf_was_pure_xfa(doc)

def ll_pdf_was_repaired(doc):
    r""" Low-level wrapper for `::pdf_was_repaired()`."""
    return _mupdf.ll_pdf_was_repaired(doc)

def ll_pdf_widget_is_readonly(widget):
    r""" Low-level wrapper for `::pdf_widget_is_readonly()`."""
    return _mupdf.ll_pdf_widget_is_readonly(widget)

def ll_pdf_widget_is_signed(widget):
    r""" Low-level wrapper for `::pdf_widget_is_signed()`."""
    return _mupdf.ll_pdf_widget_is_signed(widget)

def ll_pdf_widget_type(widget):
    r""" Low-level wrapper for `::pdf_widget_type()`."""
    return _mupdf.ll_pdf_widget_type(widget)

def ll_pdf_write_digest(out, byte_range, field, digest_offset, digest_length, signer):
    r""" Low-level wrapper for `::pdf_write_digest()`."""
    return _mupdf.ll_pdf_write_digest(out, byte_range, field, digest_offset, digest_length, signer)

def ll_pdf_write_document(doc, out, opts):
    r""" Low-level wrapper for `::pdf_write_document()`."""
    return _mupdf.ll_pdf_write_document(doc, out, opts)

def ll_pdf_write_journal(doc, out):
    r""" Low-level wrapper for `::pdf_write_journal()`."""
    return _mupdf.ll_pdf_write_journal(doc, out)

def ll_pdf_write_snapshot(doc, out):
    r""" Low-level wrapper for `::pdf_write_snapshot()`."""
    return _mupdf.ll_pdf_write_snapshot(doc, out)

def ll_pdf_xobject_bbox(xobj):
    r""" Low-level wrapper for `::pdf_xobject_bbox()`."""
    return _mupdf.ll_pdf_xobject_bbox(xobj)

def ll_pdf_xobject_colorspace(xobj):
    r""" Low-level wrapper for `::pdf_xobject_colorspace()`."""
    return _mupdf.ll_pdf_xobject_colorspace(xobj)

def ll_pdf_xobject_isolated(xobj):
    r""" Low-level wrapper for `::pdf_xobject_isolated()`."""
    return _mupdf.ll_pdf_xobject_isolated(xobj)

def ll_pdf_xobject_knockout(xobj):
    r""" Low-level wrapper for `::pdf_xobject_knockout()`."""
    return _mupdf.ll_pdf_xobject_knockout(xobj)

def ll_pdf_xobject_matrix(xobj):
    r""" Low-level wrapper for `::pdf_xobject_matrix()`."""
    return _mupdf.ll_pdf_xobject_matrix(xobj)

def ll_pdf_xobject_resources(xobj):
    r""" Low-level wrapper for `::pdf_xobject_resources()`."""
    return _mupdf.ll_pdf_xobject_resources(xobj)

def ll_pdf_xobject_transparency(xobj):
    r""" Low-level wrapper for `::pdf_xobject_transparency()`."""
    return _mupdf.ll_pdf_xobject_transparency(xobj)

def ll_pdf_xref_ensure_incremental_object(doc, num):
    r""" Low-level wrapper for `::pdf_xref_ensure_incremental_object()`."""
    return _mupdf.ll_pdf_xref_ensure_incremental_object(doc, num)

def ll_pdf_xref_ensure_local_object(doc, num):
    r""" Low-level wrapper for `::pdf_xref_ensure_local_object()`."""
    return _mupdf.ll_pdf_xref_ensure_local_object(doc, num)

def ll_pdf_xref_entry_map(doc, fn, arg):
    r""" Low-level wrapper for `::pdf_xref_entry_map()`."""
    return _mupdf.ll_pdf_xref_entry_map(doc, fn, arg)

def ll_pdf_xref_is_incremental(doc, num):
    r""" Low-level wrapper for `::pdf_xref_is_incremental()`."""
    return _mupdf.ll_pdf_xref_is_incremental(doc, num)

def ll_pdf_xref_len(doc):
    r""" Low-level wrapper for `::pdf_xref_len()`."""
    return _mupdf.ll_pdf_xref_len(doc)

def ll_pdf_xref_obj_is_unsaved_signature(doc, obj):
    r""" Low-level wrapper for `::pdf_xref_obj_is_unsaved_signature()`."""
    return _mupdf.ll_pdf_xref_obj_is_unsaved_signature(doc, obj)

def ll_pdf_xref_remove_unsaved_signature(doc, field):
    r""" Low-level wrapper for `::pdf_xref_remove_unsaved_signature()`."""
    return _mupdf.ll_pdf_xref_remove_unsaved_signature(doc, field)

def ll_pdf_xref_store_unsaved_signature(doc, field, signer):
    r""" Low-level wrapper for `::pdf_xref_store_unsaved_signature()`."""
    return _mupdf.ll_pdf_xref_store_unsaved_signature(doc, field, signer)

def to_string_fz_aa_context(s):
    r""" Returns string containing a fz_aa_context's members, labelled and inside (...), using operator<<."""
    return _mupdf.to_string_fz_aa_context(s)

def to_string_fz_color_params(s):
    r""" Returns string containing a fz_color_params's members, labelled and inside (...), using operator<<."""
    return _mupdf.to_string_fz_color_params(s)

def to_string_fz_cookie(s):
    r""" Returns string containing a fz_cookie's members, labelled and inside (...), using operator<<."""
    return _mupdf.to_string_fz_cookie(s)

def to_string_fz_draw_options(s):
    r""" Returns string containing a fz_draw_options's members, labelled and inside (...), using operator<<."""
    return _mupdf.to_string_fz_draw_options(s)

def to_string_fz_install_load_system_font_funcs_args(s):
    r""" Returns string containing a fz_install_load_system_font_funcs_args's members, labelled and inside (...), using operator<<."""
    return _mupdf.to_string_fz_install_load_system_font_funcs_args(s)

def to_string_fz_irect(s):
    r""" Returns string containing a fz_irect's members, labelled and inside (...), using operator<<."""
    return _mupdf.to_string_fz_irect(s)

def to_string_fz_location(s):
    r""" Returns string containing a fz_location's members, labelled and inside (...), using operator<<."""
    return _mupdf.to_string_fz_location(s)

def to_string_fz_matrix(s):
    r""" Returns string containing a fz_matrix's members, labelled and inside (...), using operator<<."""
    return _mupdf.to_string_fz_matrix(s)

def to_string_fz_md5(s):
    r""" Returns string containing a fz_md5's members, labelled and inside (...), using operator<<."""
    return _mupdf.to_string_fz_md5(s)

def to_string_fz_outline_item(s):
    r""" Returns string containing a fz_outline_item's members, labelled and inside (...), using operator<<."""
    return _mupdf.to_string_fz_outline_item(s)

def to_string_fz_pdfocr_options(s):
    r""" Returns string containing a fz_pdfocr_options's members, labelled and inside (...), using operator<<."""
    return _mupdf.to_string_fz_pdfocr_options(s)

def to_string_fz_point(s):
    r""" Returns string containing a fz_point's members, labelled and inside (...), using operator<<."""
    return _mupdf.to_string_fz_point(s)

def to_string_fz_pwg_options(s):
    r""" Returns string containing a fz_pwg_options's members, labelled and inside (...), using operator<<."""
    return _mupdf.to_string_fz_pwg_options(s)

def to_string_fz_quad(s):
    r""" Returns string containing a fz_quad's members, labelled and inside (...), using operator<<."""
    return _mupdf.to_string_fz_quad(s)

def to_string_fz_rect(s):
    r""" Returns string containing a fz_rect's members, labelled and inside (...), using operator<<."""
    return _mupdf.to_string_fz_rect(s)

def to_string_fz_stext_options(s):
    r""" Returns string containing a fz_stext_options's members, labelled and inside (...), using operator<<."""
    return _mupdf.to_string_fz_stext_options(s)

def to_string_fz_story_element_position(s):
    r""" Returns string containing a fz_story_element_position's members, labelled and inside (...), using operator<<."""
    return _mupdf.to_string_fz_story_element_position(s)

def to_string_fz_transition(s):
    r""" Returns string containing a fz_transition's members, labelled and inside (...), using operator<<."""
    return _mupdf.to_string_fz_transition(s)

def to_string_pdf_clean_options(s):
    r""" Returns string containing a pdf_clean_options's members, labelled and inside (...), using operator<<."""
    return _mupdf.to_string_pdf_clean_options(s)

def to_string_pdf_filter_factory(s):
    r""" Returns string containing a pdf_filter_factory's members, labelled and inside (...), using operator<<."""
    return _mupdf.to_string_pdf_filter_factory(s)

def to_string_pdf_filter_options(s):
    r""" Returns string containing a pdf_filter_options's members, labelled and inside (...), using operator<<."""
    return _mupdf.to_string_pdf_filter_options(s)

def to_string_pdf_image_rewriter_options(s):
    r""" Returns string containing a pdf_image_rewriter_options's members, labelled and inside (...), using operator<<."""
    return _mupdf.to_string_pdf_image_rewriter_options(s)

def to_string_pdf_layer_config(s):
    r""" Returns string containing a pdf_layer_config's members, labelled and inside (...), using operator<<."""
    return _mupdf.to_string_pdf_layer_config(s)

def to_string_pdf_layer_config_ui(s):
    r""" Returns string containing a pdf_layer_config_ui's members, labelled and inside (...), using operator<<."""
    return _mupdf.to_string_pdf_layer_config_ui(s)

def to_string_pdf_redact_options(s):
    r""" Returns string containing a pdf_redact_options's members, labelled and inside (...), using operator<<."""
    return _mupdf.to_string_pdf_redact_options(s)

def to_string_pdf_sanitize_filter_options(s):
    r""" Returns string containing a pdf_sanitize_filter_options's members, labelled and inside (...), using operator<<."""
    return _mupdf.to_string_pdf_sanitize_filter_options(s)

def to_string_pdf_write_options(s):
    r""" Returns string containing a pdf_write_options's members, labelled and inside (...), using operator<<."""
    return _mupdf.to_string_pdf_write_options(s)

def to_string(*args):
    r"""
    *Overload 1:*
     Returns string containing a fz_aa_context's members, labelled and inside (...), using operator<<.
    (Convenience overload).

    |

    *Overload 2:*
     Returns string containing a fz_color_params's members, labelled and inside (...), using operator<<.
    (Convenience overload).

    |

    *Overload 3:*
     Returns string containing a fz_cookie's members, labelled and inside (...), using operator<<.
    (Convenience overload).

    |

    *Overload 4:*
     Returns string containing a fz_draw_options's members, labelled and inside (...), using operator<<.
    (Convenience overload).

    |

    *Overload 5:*
     Returns string containing a fz_install_load_system_font_funcs_args's members, labelled and inside (...), using operator<<.
    (Convenience overload).

    |

    *Overload 6:*
     Returns string containing a fz_irect's members, labelled and inside (...), using operator<<.
    (Convenience overload).

    |

    *Overload 7:*
     Returns string containing a fz_location's members, labelled and inside (...), using operator<<.
    (Convenience overload).

    |

    *Overload 8:*
     Returns string containing a fz_matrix's members, labelled and inside (...), using operator<<.
    (Convenience overload).

    |

    *Overload 9:*
     Returns string containing a fz_md5's members, labelled and inside (...), using operator<<.
    (Convenience overload).

    |

    *Overload 10:*
     Returns string containing a fz_outline_item's members, labelled and inside (...), using operator<<.
    (Convenience overload).

    |

    *Overload 11:*
     Returns string containing a fz_pdfocr_options's members, labelled and inside (...), using operator<<.
    (Convenience overload).

    |

    *Overload 12:*
     Returns string containing a fz_point's members, labelled and inside (...), using operator<<.
    (Convenience overload).

    |

    *Overload 13:*
     Returns string containing a fz_pwg_options's members, labelled and inside (...), using operator<<.
    (Convenience overload).

    |

    *Overload 14:*
     Returns string containing a fz_quad's members, labelled and inside (...), using operator<<.
    (Convenience overload).

    |

    *Overload 15:*
     Returns string containing a fz_rect's members, labelled and inside (...), using operator<<.
    (Convenience overload).

    |

    *Overload 16:*
     Returns string containing a fz_stext_options's members, labelled and inside (...), using operator<<.
    (Convenience overload).

    |

    *Overload 17:*
     Returns string containing a fz_story_element_position's members, labelled and inside (...), using operator<<.
    (Convenience overload).

    |

    *Overload 18:*
     Returns string containing a fz_transition's members, labelled and inside (...), using operator<<.
    (Convenience overload).

    |

    *Overload 19:*
     Returns string containing a pdf_clean_options's members, labelled and inside (...), using operator<<.
    (Convenience overload).

    |

    *Overload 20:*
     Returns string containing a pdf_filter_factory's members, labelled and inside (...), using operator<<.
    (Convenience overload).

    |

    *Overload 21:*
     Returns string containing a pdf_filter_options's members, labelled and inside (...), using operator<<.
    (Convenience overload).

    |

    *Overload 22:*
     Returns string containing a pdf_image_rewriter_options's members, labelled and inside (...), using operator<<.
    (Convenience overload).

    |

    *Overload 23:*
     Returns string containing a pdf_layer_config's members, labelled and inside (...), using operator<<.
    (Convenience overload).

    |

    *Overload 24:*
     Returns string containing a pdf_layer_config_ui's members, labelled and inside (...), using operator<<.
    (Convenience overload).

    |

    *Overload 25:*
     Returns string containing a pdf_redact_options's members, labelled and inside (...), using operator<<.
    (Convenience overload).

    |

    *Overload 26:*
     Returns string containing a pdf_sanitize_filter_options's members, labelled and inside (...), using operator<<.
    (Convenience overload).

    |

    *Overload 27:*
     Returns string containing a pdf_write_options's members, labelled and inside (...), using operator<<.
    (Convenience overload).
    """
    return _mupdf.to_string(*args)

def reinit_singlethreaded():
    r"""
     Reinitializes the MuPDF context for single-threaded use, which
    is slightly faster when calling code is single threaded.

    This should be called before any other use of MuPDF.
    """
    return _mupdf.reinit_singlethreaded()
class FzAaContext(object):
    r""" Wrapper class for struct `fz_aa_context`."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        We use default copy constructor and operator=.  Default constructor, sets each member to default value.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::fz_aa_context`.

        |

        *Overload 3:*
        Constructor using raw copy of pre-existing `::fz_aa_context`.
        """
        _mupdf.FzAaContext_swiginit(self, _mupdf.new_FzAaContext(*args))

    def internal(self, *args):
        r"""
        *Overload 1:*
        Access as underlying struct.

        |

        *Overload 2:*
        Access as underlying struct.
        """
        return _mupdf.FzAaContext_internal(self, *args)
    __swig_destroy__ = _mupdf.delete_FzAaContext
    hscale = property(_mupdf.FzAaContext_hscale_get, _mupdf.FzAaContext_hscale_set)
    vscale = property(_mupdf.FzAaContext_vscale_get, _mupdf.FzAaContext_vscale_set)
    scale = property(_mupdf.FzAaContext_scale_get, _mupdf.FzAaContext_scale_set)
    bits = property(_mupdf.FzAaContext_bits_get, _mupdf.FzAaContext_bits_set)
    text_bits = property(_mupdf.FzAaContext_text_bits_get, _mupdf.FzAaContext_text_bits_set)
    min_line_width = property(_mupdf.FzAaContext_min_line_width_get, _mupdf.FzAaContext_min_line_width_set)
    s_num_instances = property(_mupdf.FzAaContext_s_num_instances_get, _mupdf.FzAaContext_s_num_instances_set)

    def to_string(self):
        r""" Returns string containing our members, labelled and inside (...), using operator<<."""
        return _mupdf.FzAaContext_to_string(self)

    def __eq__(self, rhs):
        r""" Comparison method."""
        return _mupdf.FzAaContext___eq__(self, rhs)

    def __ne__(self, rhs):
        r""" Comparison method."""
        return _mupdf.FzAaContext___ne__(self, rhs)

# Register FzAaContext in _mupdf:
_mupdf.FzAaContext_swigregister(FzAaContext)
metadata_keys = cvar.metadata_keys

class FzAes(object):
    r"""
    Wrapper class for struct `fz_aes`. Not copyable or assignable.
    Structure definitions are public to enable stack
    based allocation. Do not access the members directly.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def fz_aes_crypt_cbc(self, mode, length, iv, input, output):
        r"""
        Class-aware wrapper for `::fz_aes_crypt_cbc()`.
        	AES block processing. Encrypts or Decrypts (according to mode,
        	which must match what was initially set up) length bytes (which
        	must be a multiple of 16), using (and modifying) the insertion
        	vector iv, reading from input, and writing to output.

        	Never throws an exception.
        """
        return _mupdf.FzAes_fz_aes_crypt_cbc(self, mode, length, iv, input, output)

    def fz_aes_setkey_dec(self, key, keysize):
        r"""
        Class-aware wrapper for `::fz_aes_setkey_dec()`.
        	AES decryption intialisation. Fills in the supplied context
        	and prepares for decryption using the given key.

        	Returns non-zero for error (key size other than 128/192/256).

        	Never throws an exception.
        """
        return _mupdf.FzAes_fz_aes_setkey_dec(self, key, keysize)

    def fz_aes_setkey_enc(self, key, keysize):
        r"""
        Class-aware wrapper for `::fz_aes_setkey_enc()`.
        	AES encryption intialisation. Fills in the supplied context
        	and prepares for encryption using the given key.

        	Returns non-zero for error (key size other than 128/192/256).

        	Never throws an exception.
        """
        return _mupdf.FzAes_fz_aes_setkey_enc(self, key, keysize)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::fz_aes`.
        """
        _mupdf.FzAes_swiginit(self, _mupdf.new_FzAes(*args))
    __swig_destroy__ = _mupdf.delete_FzAes

    def m_internal_value(self):
        r""" Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.FzAes_m_internal_value(self)
    m_internal = property(_mupdf.FzAes_m_internal_get, _mupdf.FzAes_m_internal_set, doc=r""" Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.FzAes_s_num_instances_get, _mupdf.FzAes_s_num_instances_set)

# Register FzAes in _mupdf:
_mupdf.FzAes_swigregister(FzAes)
class FzAllocContext(object):
    r"""
    Wrapper class for struct `fz_alloc_context`. Not copyable or assignable.
    Allocator structure; holds callbacks and private data pointer.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::fz_alloc_context`.
        """
        _mupdf.FzAllocContext_swiginit(self, _mupdf.new_FzAllocContext(*args))
    __swig_destroy__ = _mupdf.delete_FzAllocContext

    def m_internal_value(self):
        r""" Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.FzAllocContext_m_internal_value(self)
    m_internal = property(_mupdf.FzAllocContext_m_internal_get, _mupdf.FzAllocContext_m_internal_set, doc=r""" Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.FzAllocContext_s_num_instances_get, _mupdf.FzAllocContext_s_num_instances_set)

# Register FzAllocContext in _mupdf:
_mupdf.FzAllocContext_swigregister(FzAllocContext)
class FzArc4(object):
    r"""
    Wrapper class for struct `fz_arc4`. Not copyable or assignable.
    Structure definition is public to enable stack
    based allocation. Do not access the members directly.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def fz_arc4_encrypt(self, dest, src, len):
        r"""
        Class-aware wrapper for `::fz_arc4_encrypt()`.
        	RC4 block encrypt operation; encrypt src into dst (both of
        	length len) updating the RC4 state as we go.

        	Never throws an exception.
        """
        return _mupdf.FzArc4_fz_arc4_encrypt(self, dest, src, len)

    def fz_arc4_final(self):
        r"""
        Class-aware wrapper for `::fz_arc4_final()`.
        	RC4 finalization. Zero the context.

        	Never throws an exception.
        """
        return _mupdf.FzArc4_fz_arc4_final(self)

    def fz_arc4_init(self, key, len):
        r"""
        Class-aware wrapper for `::fz_arc4_init()`.
        	RC4 initialization. Begins an RC4 operation, writing a new
        	context.

        	Never throws an exception.
        """
        return _mupdf.FzArc4_fz_arc4_init(self, key, len)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::fz_arc4`.
        """
        _mupdf.FzArc4_swiginit(self, _mupdf.new_FzArc4(*args))
    __swig_destroy__ = _mupdf.delete_FzArc4

    def m_internal_value(self):
        r""" Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.FzArc4_m_internal_value(self)
    m_internal = property(_mupdf.FzArc4_m_internal_get, _mupdf.FzArc4_m_internal_set, doc=r""" Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.FzArc4_s_num_instances_get, _mupdf.FzArc4_s_num_instances_set)

# Register FzArc4 in _mupdf:
_mupdf.FzArc4_swigregister(FzArc4)
class FzArchive(object):
    r"""
    Wrapper class for struct `fz_archive`.
    fz_archive:

    fz_archive provides methods for accessing "archive" files.
    An archive file is a conceptual entity that contains multiple
    files, which can be counted, enumerated, and read.

    Implementations of fz_archive based upon directories, zip
    and tar files are included.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def fz_archive_format(self):
        r"""
        Class-aware wrapper for `::fz_archive_format()`.
        	Return a pointer to a string describing the format of the
        	archive.

        	The lifetime of the string is unspecified (in current
        	implementations the string will persist until the archive
        	is closed, but this is not guaranteed).
        """
        return _mupdf.FzArchive_fz_archive_format(self)

    def fz_count_archive_entries(self):
        r"""
        Class-aware wrapper for `::fz_count_archive_entries()`.
        	Number of entries in archive.

        	Will always return a value >= 0.

        	May throw an exception if this type of archive cannot count the
        	entries (such as a directory).
        """
        return _mupdf.FzArchive_fz_count_archive_entries(self)

    def fz_has_archive_entry(self, name):
        r"""
        Class-aware wrapper for `::fz_has_archive_entry()`.
        	Check if entry by given name exists.

        	If named entry does not exist 0 will be returned, if it does
        	exist 1 is returned.

        	name: Entry name to look for, this must be an exact match to
        	the entry name in the archive.
        """
        return _mupdf.FzArchive_fz_has_archive_entry(self, name)

    def fz_list_archive_entry(self, idx):
        r"""
        Class-aware wrapper for `::fz_list_archive_entry()`.
        	Get listed name of entry position idx.

        	idx: Must be a value >= 0 < return value from
        	fz_count_archive_entries. If not in range NULL will be
        	returned.

        	May throw an exception if this type of archive cannot list the
        	entries (such as a directory).
        """
        return _mupdf.FzArchive_fz_list_archive_entry(self, idx)

    def fz_mount_multi_archive(self, sub, path):
        r"""
        Class-aware wrapper for `::fz_mount_multi_archive()`.
        	Add an archive to the set of archives handled by a multi
        	archive.

        	If path is NULL, then the archive contents will appear at the
        	top level, otherwise, the archives contents will appear prefixed
        	by path.
        """
        return _mupdf.FzArchive_fz_mount_multi_archive(self, sub, path)

    def fz_open_archive_entry(self, name):
        r"""
        Class-aware wrapper for `::fz_open_archive_entry()`.
        	Opens an archive entry as a stream.

        	name: Entry name to look for, this must be an exact match to
        	the entry name in the archive.

        	Throws an exception if a matching entry cannot be found.
        """
        return _mupdf.FzArchive_fz_open_archive_entry(self, name)

    def fz_parse_xml_archive_entry(self, filename, preserve_white):
        r"""
        Class-aware wrapper for `::fz_parse_xml_archive_entry()`.
        	Parse the contents of an archive entry into a tree of xml nodes.

        	preserve_white: whether to keep or delete all-whitespace nodes.
        """
        return _mupdf.FzArchive_fz_parse_xml_archive_entry(self, filename, preserve_white)

    def fz_read_archive_entry(self, name):
        r"""
        Class-aware wrapper for `::fz_read_archive_entry()`.
        	Reads all bytes in an archive entry
        	into a buffer.

        	name: Entry name to look for, this must be an exact match to
        	the entry name in the archive.

        	Throws an exception if a matching entry cannot be found.
        """
        return _mupdf.FzArchive_fz_read_archive_entry(self, name)

    def fz_tree_archive_add_buffer(self, name, buf):
        r"""
        Class-aware wrapper for `::fz_tree_archive_add_buffer()`.
        	Add a named buffer to an existing tree archive.

        	The tree will take a new reference to the buffer. Ownership
        	is not transferred.
        """
        return _mupdf.FzArchive_fz_tree_archive_add_buffer(self, name, buf)

    def fz_tree_archive_add_data(self, name, data, size):
        r"""
        Class-aware wrapper for `::fz_tree_archive_add_data()`.
        	Add a named block of data to an existing tree archive.

        	The data will be copied into a buffer, and so the caller
        	may free it as soon as this returns.
        """
        return _mupdf.FzArchive_fz_tree_archive_add_data(self, name, data, size)

    def fz_try_open_archive_entry(self, name):
        r"""
        Class-aware wrapper for `::fz_try_open_archive_entry()`.
        	Opens an archive entry as a stream.

        	Returns NULL if a matching entry cannot be found, otherwise
        	behaves exactly as fz_open_archive_entry.
        """
        return _mupdf.FzArchive_fz_try_open_archive_entry(self, name)

    def fz_try_parse_xml_archive_entry(self, filename, preserve_white):
        r"""
        Class-aware wrapper for `::fz_try_parse_xml_archive_entry()`.
        	Try and parse the contents of an archive entry into a tree of xml nodes.

        	preserve_white: whether to keep or delete all-whitespace nodes.

        	Will return NULL if the archive entry can't be found. Otherwise behaves
        	the same as fz_parse_xml_archive_entry. May throw exceptions.
        """
        return _mupdf.FzArchive_fz_try_parse_xml_archive_entry(self, filename, preserve_white)

    def fz_try_read_archive_entry(self, name):
        r"""
        Class-aware wrapper for `::fz_try_read_archive_entry()`.
        	Reads all bytes in an archive entry
        	into a buffer.

        	name: Entry name to look for, this must be an exact match to
        	the entry name in the archive.

        	Returns NULL if a matching entry cannot be found. Otherwise behaves
        	the same as fz_read_archive_entry. Exceptions may be thrown.
        """
        return _mupdf.FzArchive_fz_try_read_archive_entry(self, name)

    def __init__(self, *args):
        r"""
        *Overload 1:*
         == Constructors.  Constructor using `fz_new_archive_of_size()`.

        |

        *Overload 2:*
         Constructor using `fz_new_multi_archive()`.
        		Create a new multi archive (initially empty).


        |

        *Overload 3:*
         Constructor using `fz_new_tree_archive()`.
        		Create an archive that holds named buffers.

        		tree can either be a preformed tree with fz_buffers as values,
        		or it can be NULL for an empty tree.


        |

        *Overload 4:*
         Copy constructor using `fz_keep_archive()`.

        |

        *Overload 5:*
         Constructor using raw copy of pre-existing `::fz_archive`.
        """
        _mupdf.FzArchive_swiginit(self, _mupdf.new_FzArchive(*args))
    __swig_destroy__ = _mupdf.delete_FzArchive

    def m_internal_value(self):
        r""" Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.FzArchive_m_internal_value(self)
    m_internal = property(_mupdf.FzArchive_m_internal_get, _mupdf.FzArchive_m_internal_set, doc=r""" Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.FzArchive_s_num_instances_get, _mupdf.FzArchive_s_num_instances_set)

# Register FzArchive in _mupdf:
_mupdf.FzArchive_swigregister(FzArchive)
class FzArchiveHandler(object):
    r""" Wrapper class for struct `fz_archive_handler`. Not copyable or assignable."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def fz_register_archive_handler(self):
        r""" Class-aware wrapper for `::fz_register_archive_handler()`."""
        return _mupdf.FzArchiveHandler_fz_register_archive_handler(self)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::fz_archive_handler`.
        """
        _mupdf.FzArchiveHandler_swiginit(self, _mupdf.new_FzArchiveHandler(*args))
    __swig_destroy__ = _mupdf.delete_FzArchiveHandler

    def m_internal_value(self):
        r""" Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.FzArchiveHandler_m_internal_value(self)
    m_internal = property(_mupdf.FzArchiveHandler_m_internal_get, _mupdf.FzArchiveHandler_m_internal_set, doc=r""" Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.FzArchiveHandler_s_num_instances_get, _mupdf.FzArchiveHandler_s_num_instances_set)

# Register FzArchiveHandler in _mupdf:
_mupdf.FzArchiveHandler_swigregister(FzArchiveHandler)
class FzArchiveHandlerContext(object):
    r""" Wrapper class for struct `fz_archive_handler_context`. Not copyable or assignable."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::fz_archive_handler_context`.
        """
        _mupdf.FzArchiveHandlerContext_swiginit(self, _mupdf.new_FzArchiveHandlerContext(*args))
    __swig_destroy__ = _mupdf.delete_FzArchiveHandlerContext

    def m_internal_value(self):
        r""" Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.FzArchiveHandlerContext_m_internal_value(self)
    m_internal = property(_mupdf.FzArchiveHandlerContext_m_internal_get, _mupdf.FzArchiveHandlerContext_m_internal_set, doc=r""" Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.FzArchiveHandlerContext_s_num_instances_get, _mupdf.FzArchiveHandlerContext_s_num_instances_set)

# Register FzArchiveHandlerContext in _mupdf:
_mupdf.FzArchiveHandlerContext_swigregister(FzArchiveHandlerContext)
class FzBandWriter(object):
    r"""
    Wrapper class for struct `fz_band_writer`. Not copyable or assignable.
    fz_band_writer
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    MONO = _mupdf.FzBandWriter_MONO
    COLOR = _mupdf.FzBandWriter_COLOR
    PNG = _mupdf.FzBandWriter_PNG
    PNM = _mupdf.FzBandWriter_PNM
    PAM = _mupdf.FzBandWriter_PAM
    PBM = _mupdf.FzBandWriter_PBM
    PKM = _mupdf.FzBandWriter_PKM
    PS = _mupdf.FzBandWriter_PS
    PSD = _mupdf.FzBandWriter_PSD

    def fz_close_band_writer(self):
        r"""
        Class-aware wrapper for `::fz_close_band_writer()`.
        	Finishes up the output and closes the band writer. After this
        	call no more headers or bands may be written.
        """
        return _mupdf.FzBandWriter_fz_close_band_writer(self)

    def fz_pdfocr_band_writer_set_progress(self, progress_fn, progress_arg):
        r"""
        Class-aware wrapper for `::fz_pdfocr_band_writer_set_progress()`.
        	Set the progress callback for a pdfocr bandwriter.
        """
        return _mupdf.FzBandWriter_fz_pdfocr_band_writer_set_progress(self, progress_fn, progress_arg)

    def fz_write_band(self, stride, band_height, samples):
        r"""
        Class-aware wrapper for `::fz_write_band()`.
        	Cause a band writer to write the next band
        	of data for an image.

        	stride: The byte offset from the first byte of the data
        	for a pixel to the first byte of the data for the same pixel
        	on the row below.

        	band_height: The number of lines in this band.

        	samples: Pointer to first byte of the data.
        """
        return _mupdf.FzBandWriter_fz_write_band(self, stride, band_height, samples)

    def fz_write_header(self, w, h, n, alpha, xres, yres, pagenum, cs, seps):
        r"""
        Class-aware wrapper for `::fz_write_header()`.
        	Cause a band writer to write the header for
        	a banded image with the given properties/dimensions etc. This
        	also configures the bandwriter for the format of the data to be
        	passed in future calls.

        	w, h: Width and Height of the entire page.

        	n: Number of components (including spots and alphas).

        	alpha: Number of alpha components.

        	xres, yres: X and Y resolutions in dpi.

        	cs: Colorspace (NULL for bitmaps)

        	seps: Separation details (or NULL).
        """
        return _mupdf.FzBandWriter_fz_write_header(self, w, h, n, alpha, xres, yres, pagenum, cs, seps)

    def __init__(self, *args):
        r"""
        *Overload 1:*
         == Constructors.  Constructor using `fz_new_band_writer_of_size()`.

        |

        *Overload 2:*
         Constructor using `fz_new_color_pcl_band_writer()`.
        		Create a new band writer, outputing color pcl.
        	 Constructor using `fz_new_mono_pcl_band_writer()`.
        		Create a new band writer, outputing monochrome pcl.


        |

        *Overload 3:*
         Constructor using `fz_new_mono_pwg_band_writer()`.
        		Create a new monochrome pwg band writer.


        |

        *Overload 4:*
         Constructor using `fz_new_pam_band_writer()`.
        		Create a band writer targetting pnm (greyscale, rgb or cmyk,
        		with or without alpha).
        	 Constructor using `fz_new_pbm_band_writer()`.
        		Create a new band writer, targetting pbm.
        	 Constructor using `fz_new_pclm_band_writer()`.
        		Create a new band writer, outputing pclm


        |

        *Overload 5:*
         Constructor using `fz_new_pdfocr_band_writer()`.
        		Create a new band writer, outputing pdfocr.

        		Ownership of output stays with the caller, the band writer
        		borrows the reference. The caller must keep the output around
        		for the duration of the band writer, and then close/drop as
        		appropriate.


        |

        *Overload 6:*
         Constructor using `fz_new_pkm_band_writer()`.
        		Create a new pkm band writer for CMYK pixmaps.
        	 Constructor using `fz_new_png_band_writer()`.
        		Create a new png band writer (greyscale or RGB, with or without
        		alpha).


        |

        *Overload 7:*
         Constructor using `fz_new_pnm_band_writer()`.
        		Create a band writer targetting pnm (greyscale or rgb, no
        		alpha).
        	 Constructor using `fz_new_ps_band_writer()`.
        		Create a postscript band writer for gray, rgb, or cmyk, no
        		alpha.
        	 Constructor using `fz_new_psd_band_writer()`.
        		Open a PSD band writer.
        	 Constructor using `fz_new_pwg_band_writer()`.
        		Create a new color pwg band writer.
        	 Constructor using fz_new_mono_pcl_band_writer() or fz_new_color_pcl_band_writer().

        |

        *Overload 8:*
         Constructor using fz_new_p*_band_writer().

        |

        *Overload 9:*
         Constructor using fz_new_mono_pwg_band_writer() or fz_new_pwg_band_writer().

        |

        *Overload 10:*
         Default constructor, sets `m_internal` to null.

        |

        *Overload 11:*
         Constructor using raw copy of pre-existing `::fz_band_writer`.
        """
        _mupdf.FzBandWriter_swiginit(self, _mupdf.new_FzBandWriter(*args))
    __swig_destroy__ = _mupdf.delete_FzBandWriter

    def m_internal_value(self):
        r""" Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.FzBandWriter_m_internal_value(self)
    m_internal = property(_mupdf.FzBandWriter_m_internal_get, _mupdf.FzBandWriter_m_internal_set, doc=r""" Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.FzBandWriter_s_num_instances_get, _mupdf.FzBandWriter_s_num_instances_set)

# Register FzBandWriter in _mupdf:
_mupdf.FzBandWriter_swigregister(FzBandWriter)
class FzBitmap(object):
    r"""
    Wrapper class for struct `fz_bitmap`.
    Bitmaps have 1 bit per component. Only used for creating
    halftoned versions of contone buffers, and saving out. Samples
    are stored msb first, akin to pbms.

    The internals of this struct are considered implementation
    details and subject to change. Where possible, accessor
    functions should be used in preference.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def fz_bitmap_details(self, w, h, n, stride):
        r"""
        Class-aware wrapper for `::fz_bitmap_details()`.

        This method has out-params. Python/C# wrappers look like:
        	`fz_bitmap_details()` => `(int w, int h, int n, int stride)`

        	Retrieve details of a given bitmap.

        	bitmap: The bitmap to query.

        	w: Pointer to storage to retrieve width (or NULL).

        	h: Pointer to storage to retrieve height (or NULL).

        	n: Pointer to storage to retrieve number of color components (or
        	NULL).

        	stride: Pointer to storage to retrieve bitmap stride (or NULL).
        """
        return _mupdf.FzBitmap_fz_bitmap_details(self, w, h, n, stride)

    def fz_clear_bitmap(self):
        r"""
        Class-aware wrapper for `::fz_clear_bitmap()`.
        	Set the entire bitmap to 0.

        	Never throws exceptions.
        """
        return _mupdf.FzBitmap_fz_clear_bitmap(self)

    def fz_invert_bitmap(self):
        r"""
        Class-aware wrapper for `::fz_invert_bitmap()`.
        	Invert bitmap.

        	Never throws exceptions.
        """
        return _mupdf.FzBitmap_fz_invert_bitmap(self)

    def fz_save_bitmap_as_pbm(self, filename):
        r"""
        Class-aware wrapper for `::fz_save_bitmap_as_pbm()`.
        	Save a bitmap as a pbm.
        """
        return _mupdf.FzBitmap_fz_save_bitmap_as_pbm(self, filename)

    def fz_save_bitmap_as_pcl(self, filename, append, pcl):
        r"""
        Class-aware wrapper for `::fz_save_bitmap_as_pcl()`.
        	Save a bitmap as mono PCL.
        """
        return _mupdf.FzBitmap_fz_save_bitmap_as_pcl(self, filename, append, pcl)

    def fz_save_bitmap_as_pkm(self, filename):
        r"""
        Class-aware wrapper for `::fz_save_bitmap_as_pkm()`.
        	Save a CMYK bitmap as a pkm.
        """
        return _mupdf.FzBitmap_fz_save_bitmap_as_pkm(self, filename)

    def fz_save_bitmap_as_pwg(self, filename, append, pwg):
        r"""
        Class-aware wrapper for `::fz_save_bitmap_as_pwg()`.
        	Save a bitmap as a PWG.
        """
        return _mupdf.FzBitmap_fz_save_bitmap_as_pwg(self, filename, append, pwg)

    def __init__(self, *args):
        r"""
        *Overload 1:*
         == Constructors.  Constructor using `fz_new_bitmap()`.
        		Create a new bitmap.

        		w, h: Width and Height for the bitmap

        		n: Number of color components (assumed to be a divisor of 8)

        		xres, yres: X and Y resolutions (in pixels per inch).

        		Returns pointer to created bitmap structure. The bitmap
        		data is uninitialised.


        |

        *Overload 2:*
         Constructor using `fz_new_bitmap_from_pixmap()`.
        		Make a bitmap from a pixmap and a halftone.

        		pix: The pixmap to generate from. Currently must be a single
        		color component with no alpha.

        		ht: The halftone to use. NULL implies the default halftone.

        		Returns the resultant bitmap. Throws exceptions in the case of
        		failure to allocate.


        |

        *Overload 3:*
         Constructor using `fz_new_bitmap_from_pixmap_band()`.
        		Make a bitmap from a pixmap and a
        		halftone, allowing for the position of the pixmap within an
        		overall banded rendering.

        		pix: The pixmap to generate from. Currently must be a single
        		color component with no alpha.

        		ht: The halftone to use. NULL implies the default halftone.

        		band_start: Vertical offset within the overall banded rendering
        		(in pixels)

        		Returns the resultant bitmap. Throws exceptions in the case of
        		failure to allocate.


        |

        *Overload 4:*
         Copy constructor using `fz_keep_bitmap()`.

        |

        *Overload 5:*
         Default constructor, sets `m_internal` to null.

        |

        *Overload 6:*
         Constructor using raw copy of pre-existing `::fz_bitmap`.
        """
        _mupdf.FzBitmap_swiginit(self, _mupdf.new_FzBitmap(*args))

    def refs(self):
        return _mupdf.FzBitmap_refs(self)

    def w(self):
        return _mupdf.FzBitmap_w(self)

    def h(self):
        return _mupdf.FzBitmap_h(self)

    def stride(self):
        return _mupdf.FzBitmap_stride(self)

    def n(self):
        return _mupdf.FzBitmap_n(self)

    def xres(self):
        return _mupdf.FzBitmap_xres(self)

    def yres(self):
        return _mupdf.FzBitmap_yres(self)

    def samples(self):
        return _mupdf.FzBitmap_samples(self)
    __swig_destroy__ = _mupdf.delete_FzBitmap

    def m_internal_value(self):
        r""" Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.FzBitmap_m_internal_value(self)
    m_internal = property(_mupdf.FzBitmap_m_internal_get, _mupdf.FzBitmap_m_internal_set, doc=r""" Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.FzBitmap_s_num_instances_get, _mupdf.FzBitmap_s_num_instances_set)

# Register FzBitmap in _mupdf:
_mupdf.FzBitmap_swigregister(FzBitmap)
class FzBuffer(object):
    r"""
    Wrapper class for struct `fz_buffer`.
    fz_buffer is a wrapper around a dynamically allocated array of
    bytes.

    Buffers have a capacity (the number of bytes storage immediately
    available) and a current size.

    The contents of the structure are considered implementation
    details and are subject to change. Users should use the accessor
    functions in preference.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def fz_new_buffer_from_copied_data(data, size):
        r"""
        Class-aware wrapper for `::fz_new_buffer_from_copied_data()`.
        	Create a new buffer containing a copy of the passed data.
        """
        return _mupdf.FzBuffer_fz_new_buffer_from_copied_data(data, size)

    @staticmethod
    def fz_new_buffer_from_image_as_pnm(image, color_params):
        r""" Class-aware wrapper for `::fz_new_buffer_from_image_as_pnm()`."""
        return _mupdf.FzBuffer_fz_new_buffer_from_image_as_pnm(image, color_params)

    @staticmethod
    def fz_new_buffer_from_image_as_pam(image, color_params):
        r""" Class-aware wrapper for `::fz_new_buffer_from_image_as_pam()`."""
        return _mupdf.FzBuffer_fz_new_buffer_from_image_as_pam(image, color_params)

    @staticmethod
    def fz_new_buffer_from_image_as_psd(image, color_params):
        r""" Class-aware wrapper for `::fz_new_buffer_from_image_as_psd()`."""
        return _mupdf.FzBuffer_fz_new_buffer_from_image_as_psd(image, color_params)

    @staticmethod
    def fz_new_buffer_from_pixmap_as_pnm(pixmap, color_params):
        r""" Class-aware wrapper for `::fz_new_buffer_from_pixmap_as_pnm()`."""
        return _mupdf.FzBuffer_fz_new_buffer_from_pixmap_as_pnm(pixmap, color_params)

    @staticmethod
    def fz_new_buffer_from_pixmap_as_pam(pixmap, color_params):
        r""" Class-aware wrapper for `::fz_new_buffer_from_pixmap_as_pam()`."""
        return _mupdf.FzBuffer_fz_new_buffer_from_pixmap_as_pam(pixmap, color_params)

    @staticmethod
    def fz_new_buffer_from_pixmap_as_psd(pix, color_params):
        r""" Class-aware wrapper for `::fz_new_buffer_from_pixmap_as_psd()`."""
        return _mupdf.FzBuffer_fz_new_buffer_from_pixmap_as_psd(pix, color_params)

    def fz_append_base64(self, data, size, newline):
        r"""
        Class-aware wrapper for `::fz_append_base64()`.
        	Write a base64 encoded data block, optionally with periodic newlines.
        """
        return _mupdf.FzBuffer_fz_append_base64(self, data, size, newline)

    def fz_append_base64_buffer(self, data, newline):
        r"""
        Class-aware wrapper for `::fz_append_base64_buffer()`.
        	Append a base64 encoded fz_buffer, optionally with periodic newlines.
        """
        return _mupdf.FzBuffer_fz_append_base64_buffer(self, data, newline)

    def fz_append_bits(self, value, count):
        r""" Class-aware wrapper for `::fz_append_bits()`."""
        return _mupdf.FzBuffer_fz_append_bits(self, value, count)

    def fz_append_bits_pad(self):
        r""" Class-aware wrapper for `::fz_append_bits_pad()`."""
        return _mupdf.FzBuffer_fz_append_bits_pad(self)

    def fz_append_buffer(self, source):
        r"""
        Class-aware wrapper for `::fz_append_buffer()`.
        	Append the contents of the source buffer onto the end of the
        	destination buffer, extending automatically as required.

        	Ownership of buffers does not change.
        """
        return _mupdf.FzBuffer_fz_append_buffer(self, source)

    def fz_append_byte(self, c):
        r""" Class-aware wrapper for `::fz_append_byte()`."""
        return _mupdf.FzBuffer_fz_append_byte(self, c)

    def fz_append_data(self, data, len):
        r"""
        Class-aware wrapper for `::fz_append_data()`.
        	fz_append_*: Append data to a buffer.

        	The buffer will automatically grow as required.
        """
        return _mupdf.FzBuffer_fz_append_data(self, data, len)

    def fz_append_image_as_data_uri(self, image):
        r""" Class-aware wrapper for `::fz_append_image_as_data_uri()`."""
        return _mupdf.FzBuffer_fz_append_image_as_data_uri(self, image)

    def fz_append_int16_be(self, x):
        r""" Class-aware wrapper for `::fz_append_int16_be()`."""
        return _mupdf.FzBuffer_fz_append_int16_be(self, x)

    def fz_append_int16_le(self, x):
        r""" Class-aware wrapper for `::fz_append_int16_le()`."""
        return _mupdf.FzBuffer_fz_append_int16_le(self, x)

    def fz_append_int32_be(self, x):
        r""" Class-aware wrapper for `::fz_append_int32_be()`."""
        return _mupdf.FzBuffer_fz_append_int32_be(self, x)

    def fz_append_int32_le(self, x):
        r""" Class-aware wrapper for `::fz_append_int32_le()`."""
        return _mupdf.FzBuffer_fz_append_int32_le(self, x)

    def fz_append_pdf_string(self, text):
        r"""
        Class-aware wrapper for `::fz_append_pdf_string()`.
        	fz_append_pdf_string: Append a string with PDF syntax quotes and
        	escapes.

        	The buffer will automatically grow as required.
        """
        return _mupdf.FzBuffer_fz_append_pdf_string(self, text)

    def fz_append_pixmap_as_data_uri(self, pixmap):
        r""" Class-aware wrapper for `::fz_append_pixmap_as_data_uri()`."""
        return _mupdf.FzBuffer_fz_append_pixmap_as_data_uri(self, pixmap)

    def fz_append_rune(self, c):
        r""" Class-aware wrapper for `::fz_append_rune()`."""
        return _mupdf.FzBuffer_fz_append_rune(self, c)

    def fz_append_string(self, data):
        r""" Class-aware wrapper for `::fz_append_string()`."""
        return _mupdf.FzBuffer_fz_append_string(self, data)

    def fz_buffer_extract(self, data):
        r"""
        Class-aware wrapper for `::fz_buffer_extract()`.

        This method has out-params. Python/C# wrappers look like:
        	`fz_buffer_extract()` => `(size_t, unsigned char *data)`

        	Take ownership of buffer contents.

        	Performs the same task as fz_buffer_storage, but ownership of
        	the data buffer returns with this call. The buffer is left
        	empty.

        	Note: Bad things may happen if this is called on a buffer with
        	multiple references that is being used from multiple threads.

        	data: Pointer to place to retrieve data pointer.

        	Returns length of stream.
        """
        return _mupdf.FzBuffer_fz_buffer_extract(self, data)

    def fz_buffer_storage(self, datap):
        r"""
        Class-aware wrapper for `::fz_buffer_storage()`.

        This method has out-params. Python/C# wrappers look like:
        	`fz_buffer_storage()` => `(size_t, unsigned char *datap)`

        	Retrieve internal memory of buffer.

        	datap: Output parameter that will be pointed to the data.

        	Returns the current size of the data in bytes.
        """
        return _mupdf.FzBuffer_fz_buffer_storage(self, datap)

    def fz_clear_buffer(self):
        r"""
        Class-aware wrapper for `::fz_clear_buffer()`.
        	Empties the buffer. Storage is not freed, but is held ready
        	to be reused as the buffer is refilled.

        	Never throws exceptions.
        """
        return _mupdf.FzBuffer_fz_clear_buffer(self)

    def fz_clone_buffer(self):
        r"""
        Class-aware wrapper for `::fz_clone_buffer()`.
        	Make a new buffer, containing a copy of the data used in
        	the original.
        """
        return _mupdf.FzBuffer_fz_clone_buffer(self)

    def fz_grow_buffer(self):
        r"""
        Class-aware wrapper for `::fz_grow_buffer()`.
        	Make some space within a buffer (i.e. ensure that
        	capacity > size).
        """
        return _mupdf.FzBuffer_fz_grow_buffer(self)

    def fz_load_jbig2_globals(self):
        r"""
        Class-aware wrapper for `::fz_load_jbig2_globals()`.
        	Create a jbig2 globals record from a buffer.

        	Immutable once created.
        """
        return _mupdf.FzBuffer_fz_load_jbig2_globals(self)

    def fz_md5_buffer(self, digest):
        r"""
        Class-aware wrapper for `::fz_md5_buffer()`.
        	Create an MD5 digest from buffer contents.

        	Never throws exceptions.
        """
        return _mupdf.FzBuffer_fz_md5_buffer(self, digest)

    def fz_new_display_list_from_svg(self, base_uri, dir, w, h):
        r"""
        Class-aware wrapper for `::fz_new_display_list_from_svg()`.

        This method has out-params. Python/C# wrappers look like:
        	`fz_new_display_list_from_svg(const char *base_uri, ::fz_archive *dir)` => `(fz_display_list *, float w, float h)`

        	Parse an SVG document into a display-list.
        """
        return _mupdf.FzBuffer_fz_new_display_list_from_svg(self, base_uri, dir, w, h)

    def fz_new_image_from_buffer(self):
        r"""
        Class-aware wrapper for `::fz_new_image_from_buffer()`.
        	Create a new image from a
        	buffer of data, inferring its type from the format
        	of the data.
        """
        return _mupdf.FzBuffer_fz_new_image_from_buffer(self)

    def fz_new_image_from_svg(self, base_uri, dir):
        r"""
        Class-aware wrapper for `::fz_new_image_from_svg()`.
        	Create a scalable image from an SVG document.
        """
        return _mupdf.FzBuffer_fz_new_image_from_svg(self, base_uri, dir)

    def fz_open_buffer(self):
        r"""
        Class-aware wrapper for `::fz_open_buffer()`.
        	Open a buffer as a stream.

        	buf: The buffer to open. Ownership of the buffer is NOT passed
        	in (this function takes its own reference).

        	Returns pointer to newly created stream. May throw exceptions on
        	failure to allocate.
        """
        return _mupdf.FzBuffer_fz_open_buffer(self)

    def fz_parse_xml(self, preserve_white):
        r"""
        Class-aware wrapper for `::fz_parse_xml()`.
        	Parse the contents of buffer into a tree of xml nodes.

        	preserve_white: whether to keep or delete all-whitespace nodes.
        """
        return _mupdf.FzBuffer_fz_parse_xml(self, preserve_white)

    def fz_parse_xml_from_html5(self):
        r"""
        Class-aware wrapper for `::fz_parse_xml_from_html5()`.
        	Parse the contents of a buffer into a tree of XML nodes,
        	using the HTML5 parsing algorithm.
        """
        return _mupdf.FzBuffer_fz_parse_xml_from_html5(self)

    def fz_resize_buffer(self, capacity):
        r"""
        Class-aware wrapper for `::fz_resize_buffer()`.
        	Ensure that a buffer has a given capacity,
        	truncating data if required.

        	capacity: The desired capacity for the buffer. If the current
        	size of the buffer contents is smaller than capacity, it is
        	truncated.
        """
        return _mupdf.FzBuffer_fz_resize_buffer(self, capacity)

    def fz_save_buffer(self, filename):
        r"""
        Class-aware wrapper for `::fz_save_buffer()`.
        	Save the contents of a buffer to a file.
        """
        return _mupdf.FzBuffer_fz_save_buffer(self, filename)

    def fz_slice_buffer(self, start, end):
        r"""
        Class-aware wrapper for `::fz_slice_buffer()`.
        	Create a new buffer with a (subset of) the data from the buffer.

        	start: if >= 0, offset from start of buffer, if < 0 offset from end of buffer.

        	end: if >= 0, offset from start of buffer, if < 0 offset from end of buffer.

        """
        return _mupdf.FzBuffer_fz_slice_buffer(self, start, end)

    def fz_string_from_buffer(self):
        r"""
        Class-aware wrapper for `::fz_string_from_buffer()`.
        	Ensure that a buffer's data ends in a
        	0 byte, and return a pointer to it.
        """
        return _mupdf.FzBuffer_fz_string_from_buffer(self)

    def fz_subset_cff_for_gids(self, gids, num_gids, symbolic, cidfont):
        r"""
        Class-aware wrapper for `::fz_subset_cff_for_gids()`.

        This method has out-params. Python/C# wrappers look like:
        	`fz_subset_cff_for_gids(int num_gids, int symbolic, int cidfont)` => `(fz_buffer *, int gids)`
        """
        return _mupdf.FzBuffer_fz_subset_cff_for_gids(self, gids, num_gids, symbolic, cidfont)

    def fz_subset_ttf_for_gids(self, gids, num_gids, symbolic, cidfont):
        r"""
        Class-aware wrapper for `::fz_subset_ttf_for_gids()`.

        This method has out-params. Python/C# wrappers look like:
        	`fz_subset_ttf_for_gids(int num_gids, int symbolic, int cidfont)` => `(fz_buffer *, int gids)`
        """
        return _mupdf.FzBuffer_fz_subset_ttf_for_gids(self, gids, num_gids, symbolic, cidfont)

    def fz_terminate_buffer(self):
        r"""
        Class-aware wrapper for `::fz_terminate_buffer()`.
        	Zero-terminate buffer in order to use as a C string.

        	This byte is invisible and does not affect the length of the
        	buffer as returned by fz_buffer_storage. The zero byte is
        	written *after* the data, and subsequent writes will overwrite
        	the terminating byte.

        	Subsequent changes to the size of the buffer (such as by
        	fz_buffer_trim, fz_buffer_grow, fz_resize_buffer, etc) may
        	invalidate this.
        """
        return _mupdf.FzBuffer_fz_terminate_buffer(self)

    def fz_trim_buffer(self):
        r"""
        Class-aware wrapper for `::fz_trim_buffer()`.
        	Trim wasted capacity from a buffer by resizing internal memory.
        """
        return _mupdf.FzBuffer_fz_trim_buffer(self)

    def pdf_append_token(self, tok, lex):
        r""" Class-aware wrapper for `::pdf_append_token()`."""
        return _mupdf.FzBuffer_pdf_append_token(self, tok, lex)

    def pdf_new_buffer_processor(self, ahxencode, newlines):
        r""" Class-aware wrapper for `::pdf_new_buffer_processor()`."""
        return _mupdf.FzBuffer_pdf_new_buffer_processor(self, ahxencode, newlines)

    def __init__(self, *args):
        r"""
        *Overload 1:*
         == Constructors.  Constructor using `fz_new_buffer()`.

        |

        *Overload 2:*
         Constructor using `fz_new_buffer_from_base64()`.
        		Create a new buffer with data decoded from a base64 input string.


        |

        *Overload 3:*
         Constructor using `fz_new_buffer_from_data()`.
        		Create a new buffer with existing data.

        		data: Pointer to existing data.
        		size: Size of existing data.

        		Takes ownership of data. Does not make a copy. Calls fz_free on
        		the data when the buffer is deallocated. Do not use 'data' after
        		passing to this function.

        		Returns pointer to new buffer. Throws exception on allocation
        		failure.


        |

        *Overload 4:*
         Constructor using `fz_new_buffer_from_display_list()`.

        |

        *Overload 5:*
         Constructor using `fz_new_buffer_from_image_as_jpeg()`.

        |

        *Overload 6:*
         Constructor using `fz_new_buffer_from_image_as_jpx()`.

        |

        *Overload 7:*
         Constructor using `fz_new_buffer_from_image_as_png()`.
        		Reencode a given image as a PNG into a buffer.

        		Ownership of the buffer is returned.


        |

        *Overload 8:*
         Constructor using `fz_new_buffer_from_page()`.

        |

        *Overload 9:*
         Constructor using `fz_new_buffer_from_page_number()`.

        |

        *Overload 10:*
         Constructor using `fz_new_buffer_from_page_with_format()`.
        		Returns an fz_buffer containing a page after conversion to specified format.

        		page: The page to convert.
        		format, options: Passed to fz_new_document_writer_with_output() internally.
        		transform, cookie: Passed to fz_run_page() internally.


        |

        *Overload 11:*
         Constructor using `fz_new_buffer_from_pixmap_as_jpeg()`.

        |

        *Overload 12:*
         Constructor using `fz_new_buffer_from_pixmap_as_jpx()`.

        |

        *Overload 13:*
         Constructor using `fz_new_buffer_from_pixmap_as_png()`.
        		Reencode a given pixmap as a PNG into a buffer.

        		Ownership of the buffer is returned.


        |

        *Overload 14:*
         Constructor using `fz_new_buffer_from_shared_data()`.
        		Like fz_new_buffer, but does not take ownership.


        |

        *Overload 15:*
         Constructor using `fz_new_buffer_from_stext_page()`.
        		Convert structured text into plain text.


        |

        *Overload 16:*
         Constructor using `fz_read_file()`.
        		Read all the contents of a file into a buffer.


        |

        *Overload 17:*
         Copy constructor using `fz_keep_buffer()`.

        |

        *Overload 18:*
         Constructor using raw copy of pre-existing `::fz_buffer`.

        |

        *Overload 19:*
         Constructor using raw copy of pre-existing `::fz_buffer`.
        """
        _mupdf.FzBuffer_swiginit(self, _mupdf.new_FzBuffer(*args))
    __swig_destroy__ = _mupdf.delete_FzBuffer

    def m_internal_value(self):
        r""" Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.FzBuffer_m_internal_value(self)
    m_internal = property(_mupdf.FzBuffer_m_internal_get, _mupdf.FzBuffer_m_internal_set, doc=r""" Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.FzBuffer_s_num_instances_get, _mupdf.FzBuffer_s_num_instances_set)

# Register FzBuffer in _mupdf:
_mupdf.FzBuffer_swigregister(FzBuffer)
class FzColorParams(object):
    r""" Wrapper class for struct `fz_color_params`."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Equivalent to fz_default_color_params.

        |

        *Overload 2:*
        We use default copy constructor and operator=.  Constructor using raw copy of pre-existing `::fz_color_params`.

        |

        *Overload 3:*
        Constructor using raw copy of pre-existing `::fz_color_params`.
        """
        _mupdf.FzColorParams_swiginit(self, _mupdf.new_FzColorParams(*args))

    def internal(self, *args):
        r"""
        *Overload 1:*
        Access as underlying struct.

        |

        *Overload 2:*
        Access as underlying struct.
        """
        return _mupdf.FzColorParams_internal(self, *args)
    __swig_destroy__ = _mupdf.delete_FzColorParams
    ri = property(_mupdf.FzColorParams_ri_get, _mupdf.FzColorParams_ri_set)
    bp = property(_mupdf.FzColorParams_bp_get, _mupdf.FzColorParams_bp_set)
    op = property(_mupdf.FzColorParams_op_get, _mupdf.FzColorParams_op_set)
    opm = property(_mupdf.FzColorParams_opm_get, _mupdf.FzColorParams_opm_set)
    s_num_instances = property(_mupdf.FzColorParams_s_num_instances_get, _mupdf.FzColorParams_s_num_instances_set)

    def to_string(self):
        r""" Returns string containing our members, labelled and inside (...), using operator<<."""
        return _mupdf.FzColorParams_to_string(self)

    def __eq__(self, rhs):
        r""" Comparison method."""
        return _mupdf.FzColorParams___eq__(self, rhs)

    def __ne__(self, rhs):
        r""" Comparison method."""
        return _mupdf.FzColorParams___ne__(self, rhs)

# Register FzColorParams in _mupdf:
_mupdf.FzColorParams_swigregister(FzColorParams)
class FzColorspace(object):
    r"""
    Wrapper class for struct `fz_colorspace`.
    Describes a given colorspace.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    Fixed_GRAY = _mupdf.FzColorspace_Fixed_GRAY
    Fixed_RGB = _mupdf.FzColorspace_Fixed_RGB
    Fixed_BGR = _mupdf.FzColorspace_Fixed_BGR
    Fixed_CMYK = _mupdf.FzColorspace_Fixed_CMYK
    Fixed_LAB = _mupdf.FzColorspace_Fixed_LAB

    def fz_base_colorspace(self):
        r"""
        Class-aware wrapper for `::fz_base_colorspace()`.
        	Get the 'base' colorspace for a colorspace.

        	For indexed colorspaces, this is the colorspace the index
        	decodes into. For all other colorspaces, it is the colorspace
        	itself.

        	The returned colorspace is 'borrowed' (i.e. no additional
        	references are taken or dropped).
        """
        return _mupdf.FzColorspace_fz_base_colorspace(self)

    def fz_clamp_color(self, _in, out):
        r"""
        Class-aware wrapper for `::fz_clamp_color()`.

        This method has out-params. Python/C# wrappers look like:
        	`fz_clamp_color(const float *in)` => float out

        	Clamp the samples in a color to the correct ranges for a
        	given colorspace.
        """
        return _mupdf.FzColorspace_fz_clamp_color(self, _in, out)

    def fz_colorspace_colorant(self, n):
        r"""
        Class-aware wrapper for `::fz_colorspace_colorant()`.
        	Retrieve a the name for a colorant.

        	Returns a pointer with the same lifespan as the colorspace.
        """
        return _mupdf.FzColorspace_fz_colorspace_colorant(self, n)

    def fz_colorspace_device_n_has_cmyk(self):
        r"""
        Class-aware wrapper for `::fz_colorspace_device_n_has_cmyk()`.
        	True if DeviceN color space has cyan magenta yellow or black as
        	one of its colorants.
        """
        return _mupdf.FzColorspace_fz_colorspace_device_n_has_cmyk(self)

    def fz_colorspace_device_n_has_only_cmyk(self):
        r"""
        Class-aware wrapper for `::fz_colorspace_device_n_has_only_cmyk()`.
        	True if DeviceN color space has only colorants from the CMYK set.
        """
        return _mupdf.FzColorspace_fz_colorspace_device_n_has_only_cmyk(self)

    def fz_colorspace_is_cmyk(self):
        r""" Class-aware wrapper for `::fz_colorspace_is_cmyk()`."""
        return _mupdf.FzColorspace_fz_colorspace_is_cmyk(self)

    def fz_colorspace_is_device(self):
        r""" Class-aware wrapper for `::fz_colorspace_is_device()`."""
        return _mupdf.FzColorspace_fz_colorspace_is_device(self)

    def fz_colorspace_is_device_cmyk(self):
        r""" Class-aware wrapper for `::fz_colorspace_is_device_cmyk()`."""
        return _mupdf.FzColorspace_fz_colorspace_is_device_cmyk(self)

    def fz_colorspace_is_device_gray(self):
        r""" Class-aware wrapper for `::fz_colorspace_is_device_gray()`."""
        return _mupdf.FzColorspace_fz_colorspace_is_device_gray(self)

    def fz_colorspace_is_device_n(self):
        r""" Class-aware wrapper for `::fz_colorspace_is_device_n()`."""
        return _mupdf.FzColorspace_fz_colorspace_is_device_n(self)

    def fz_colorspace_is_gray(self):
        r"""
        Class-aware wrapper for `::fz_colorspace_is_gray()`.
        	Tests for particular types of colorspaces
        """
        return _mupdf.FzColorspace_fz_colorspace_is_gray(self)

    def fz_colorspace_is_indexed(self):
        r""" Class-aware wrapper for `::fz_colorspace_is_indexed()`."""
        return _mupdf.FzColorspace_fz_colorspace_is_indexed(self)

    def fz_colorspace_is_lab(self):
        r""" Class-aware wrapper for `::fz_colorspace_is_lab()`."""
        return _mupdf.FzColorspace_fz_colorspace_is_lab(self)

    def fz_colorspace_is_lab_icc(self):
        r""" Class-aware wrapper for `::fz_colorspace_is_lab_icc()`."""
        return _mupdf.FzColorspace_fz_colorspace_is_lab_icc(self)

    def fz_colorspace_is_rgb(self):
        r""" Class-aware wrapper for `::fz_colorspace_is_rgb()`."""
        return _mupdf.FzColorspace_fz_colorspace_is_rgb(self)

    def fz_colorspace_is_subtractive(self):
        r"""
        Class-aware wrapper for `::fz_colorspace_is_subtractive()`.
        	True for CMYK, Separation and DeviceN colorspaces.
        """
        return _mupdf.FzColorspace_fz_colorspace_is_subtractive(self)

    def fz_colorspace_n(self):
        r"""
        Class-aware wrapper for `::fz_colorspace_n()`.
        	Query the number of colorants in a colorspace.
        """
        return _mupdf.FzColorspace_fz_colorspace_n(self)

    def fz_colorspace_name(self):
        r"""
        Class-aware wrapper for `::fz_colorspace_name()`.
        	Query the name of a colorspace.

        	The returned string has the same lifespan as the colorspace
        	does. Caller should not free it.
        """
        return _mupdf.FzColorspace_fz_colorspace_name(self)

    def fz_colorspace_name_colorant(self, n, name):
        r"""
        Class-aware wrapper for `::fz_colorspace_name_colorant()`.
        	Assign a name for a given colorant in a colorspace.

        	Used while initially setting up a colorspace. The string is
        	copied into local storage, so need not be retained by the
        	caller.
        """
        return _mupdf.FzColorspace_fz_colorspace_name_colorant(self, n, name)

    def fz_colorspace_type(self):
        r"""
        Class-aware wrapper for `::fz_colorspace_type()`.
        	Query the type of colorspace.
        """
        return _mupdf.FzColorspace_fz_colorspace_type(self)

    def fz_convert_color(self, sv, ds, dv, _is, params):
        r"""
        Class-aware wrapper for `::fz_convert_color()`.

        This method has out-params. Python/C# wrappers look like:
        	`fz_convert_color(const float *sv, ::fz_colorspace *ds, ::fz_colorspace *is, ::fz_color_params params)` => float dv

        	Convert color values sv from colorspace ss into colorvalues dv
        	for colorspace ds, via an optional intervening space is,
        	respecting the given color_params.
        """
        return _mupdf.FzColorspace_fz_convert_color(self, sv, ds, dv, _is, params)

    def fz_convert_separation_colors(self, src_color, dst_seps, dst_cs, dst_color, color_params):
        r"""
        Class-aware wrapper for `::fz_convert_separation_colors()`.

        This method has out-params. Python/C# wrappers look like:
        	`fz_convert_separation_colors(const float *src_color, ::fz_separations *dst_seps, ::fz_colorspace *dst_cs, ::fz_color_params color_params)` => float dst_color

        	Convert a color given in terms of one colorspace,
        	to a color in terms of another colorspace/separations.
        """
        return _mupdf.FzColorspace_fz_convert_separation_colors(self, src_color, dst_seps, dst_cs, dst_color, color_params)

    def fz_is_valid_blend_colorspace(self):
        r"""
        Class-aware wrapper for `::fz_is_valid_blend_colorspace()`.
        	Check to see that a colorspace is appropriate to be used as
        	a blending space (i.e. only grey, rgb or cmyk).
        """
        return _mupdf.FzColorspace_fz_is_valid_blend_colorspace(self)

    def fz_new_indexed_colorspace(self, high, lookup):
        r"""
        Class-aware wrapper for `::fz_new_indexed_colorspace()`.
        	Create an indexed colorspace.

        	The supplied lookup table is high palette entries long. Each
        	entry is n bytes long, where n is given by the number of
        	colorants in the base colorspace, one byte per colorant.

        	Ownership of lookup is passed it; it will be freed on
        	destruction, so must be heap allocated.

        	The colorspace will keep an additional reference to the base
        	colorspace that will be dropped on destruction.

        	The returned reference should be dropped when it is finished
        	with.

        	Colorspaces are immutable once created.
        """
        return _mupdf.FzColorspace_fz_new_indexed_colorspace(self, high, lookup)

    def fz_new_pixmap(self, w, h, seps, alpha):
        r"""
        Class-aware wrapper for `::fz_new_pixmap()`.
        	Create a new pixmap, with its origin at (0,0)

        	cs: The colorspace to use for the pixmap, or NULL for an alpha
        	plane/mask.

        	w: The width of the pixmap (in pixels)

        	h: The height of the pixmap (in pixels)

        	seps: Details of separations.

        	alpha: 0 for no alpha, 1 for alpha.

        	Returns a pointer to the new pixmap. Throws exception on failure
        	to allocate.
        """
        return _mupdf.FzColorspace_fz_new_pixmap(self, w, h, seps, alpha)

    def fz_new_pixmap_with_bbox(self, bbox, seps, alpha):
        r"""
        Class-aware wrapper for `::fz_new_pixmap_with_bbox()`.
        	Create a pixmap of a given size, location and pixel format.

        	The bounding box specifies the size of the created pixmap and
        	where it will be located. The colorspace determines the number
        	of components per pixel. Alpha is always present. Pixmaps are
        	reference counted, so drop references using fz_drop_pixmap.

        	colorspace: Colorspace format used for the created pixmap. The
        	pixmap will keep a reference to the colorspace.

        	bbox: Bounding box specifying location/size of created pixmap.

        	seps: Details of separations.

        	alpha: 0 for no alpha, 1 for alpha.

        	Returns a pointer to the new pixmap. Throws exception on failure
        	to allocate.
        """
        return _mupdf.FzColorspace_fz_new_pixmap_with_bbox(self, bbox, seps, alpha)

    def fz_new_pixmap_with_bbox_and_data(self, rect, seps, alpha, samples):
        r"""
        Class-aware wrapper for `::fz_new_pixmap_with_bbox_and_data()`.
        	Create a pixmap of a given size, location and pixel format,
        	using the supplied data block.

        	The bounding box specifies the size of the created pixmap and
        	where it will be located. The colorspace determines the number
        	of components per pixel. Alpha is always present. Pixmaps are
        	reference counted, so drop references using fz_drop_pixmap.

        	colorspace: Colorspace format used for the created pixmap. The
        	pixmap will keep a reference to the colorspace.

        	rect: Bounding box specifying location/size of created pixmap.

        	seps: Details of separations.

        	alpha: Number of alpha planes (0 or 1).

        	samples: The data block to keep the samples in.

        	Returns a pointer to the new pixmap. Throws exception on failure
        	to allocate.
        """
        return _mupdf.FzColorspace_fz_new_pixmap_with_bbox_and_data(self, rect, seps, alpha, samples)

    def fz_new_pixmap_with_data(self, w, h, seps, alpha, stride, samples):
        r"""
        Class-aware wrapper for `::fz_new_pixmap_with_data()`.
        	Create a new pixmap, with its origin at
        	(0,0) using the supplied data block.

        	cs: The colorspace to use for the pixmap, or NULL for an alpha
        	plane/mask.

        	w: The width of the pixmap (in pixels)

        	h: The height of the pixmap (in pixels)

        	seps: Details of separations.

        	alpha: 0 for no alpha, 1 for alpha.

        	stride: The byte offset from the pixel data in a row to the
        	pixel data in the next row.

        	samples: The data block to keep the samples in.

        	Returns a pointer to the new pixmap. Throws exception on failure to
        	allocate.
        """
        return _mupdf.FzColorspace_fz_new_pixmap_with_data(self, w, h, seps, alpha, stride, samples)

    def pdf_is_tint_colorspace(self):
        r""" Class-aware wrapper for `::pdf_is_tint_colorspace()`."""
        return _mupdf.FzColorspace_pdf_is_tint_colorspace(self)

    def __init__(self, *args):
        r"""
        *Overload 1:*
         == Constructors.  Constructor using `fz_new_cal_gray_colorspace()`.
        		Create a calibrated gray colorspace.

        		The returned reference should be dropped when it is finished
        		with.

        		Colorspaces are immutable once created.


        |

        *Overload 2:*
         Constructor using `fz_new_cal_rgb_colorspace()`.
        		Create a calibrated rgb colorspace.

        		The returned reference should be dropped when it is finished
        		with.

        		Colorspaces are immutable once created.


        |

        *Overload 3:*
         Constructor using `fz_new_colorspace()`.
        		Creates a new colorspace instance and returns a reference.

        		No internal checking is done that the colorspace type (e.g.
        		CMYK) matches with the flags (e.g. FZ_COLORSPACE_HAS_CMYK) or
        		colorant count (n) or name.

        		The reference should be dropped when it is finished with.

        		Colorspaces are immutable once created (with the exception of
        		setting up colorant names for separation spaces).


        |

        *Overload 4:*
         Constructor using `fz_new_icc_colorspace()`.
        		Create a colorspace from an ICC profile supplied in buf.

        		Limited checking is done to ensure that the colorspace type is
        		appropriate for the supplied ICC profile.

        		An additional reference is taken to buf, which will be dropped
        		on destruction. Ownership is NOT passed in.

        		The returned reference should be dropped when it is finished
        		with.

        		Colorspaces are immutable once created.


        |

        *Overload 5:*
         Constructor using `fz_new_indexed_colorspace()`.
        		Create an indexed colorspace.

        		The supplied lookup table is high palette entries long. Each
        		entry is n bytes long, where n is given by the number of
        		colorants in the base colorspace, one byte per colorant.

        		Ownership of lookup is passed it; it will be freed on
        		destruction, so must be heap allocated.

        		The colorspace will keep an additional reference to the base
        		colorspace that will be dropped on destruction.

        		The returned reference should be dropped when it is finished
        		with.

        		Colorspaces are immutable once created.


        |

        *Overload 6:*
         Construct using one of: fz_device_gray(), fz_device_rgb(), fz_device_bgr(), fz_device_cmyk(), fz_device_lab().

        |

        *Overload 7:*
         Copy constructor using `fz_keep_colorspace()`.

        |

        *Overload 8:*
         Default constructor, sets `m_internal` to null.

        |

        *Overload 9:*
         Constructor using raw copy of pre-existing `::fz_colorspace`.
        """
        _mupdf.FzColorspace_swiginit(self, _mupdf.new_FzColorspace(*args))
    __swig_destroy__ = _mupdf.delete_FzColorspace

    def m_internal_value(self):
        r""" Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.FzColorspace_m_internal_value(self)
    m_internal = property(_mupdf.FzColorspace_m_internal_get, _mupdf.FzColorspace_m_internal_set, doc=r""" Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.FzColorspace_s_num_instances_get, _mupdf.FzColorspace_s_num_instances_set)

# Register FzColorspace in _mupdf:
_mupdf.FzColorspace_swigregister(FzColorspace)
class FzColorspaceContext(object):
    r""" Wrapper class for struct `fz_colorspace_context`. Not copyable or assignable."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::fz_colorspace_context`.
        """
        _mupdf.FzColorspaceContext_swiginit(self, _mupdf.new_FzColorspaceContext(*args))
    __swig_destroy__ = _mupdf.delete_FzColorspaceContext

    def m_internal_value(self):
        r""" Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.FzColorspaceContext_m_internal_value(self)
    m_internal = property(_mupdf.FzColorspaceContext_m_internal_get, _mupdf.FzColorspaceContext_m_internal_set, doc=r""" Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.FzColorspaceContext_s_num_instances_get, _mupdf.FzColorspaceContext_s_num_instances_set)

# Register FzColorspaceContext in _mupdf:
_mupdf.FzColorspaceContext_swigregister(FzColorspaceContext)
class FzCompressedBuffer(object):
    r"""
    Wrapper class for struct `fz_compressed_buffer`.
    Buffers of compressed data; typically for the source data
    for images.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def fz_compressed_buffer_size(self):
        r"""
        Class-aware wrapper for `::fz_compressed_buffer_size()`.
        	Return the storage size used for a buffer and its data.
        	Used in implementing store handling.

        	Never throws exceptions.
        """
        return _mupdf.FzCompressedBuffer_fz_compressed_buffer_size(self)

    def fz_open_compressed_buffer(self):
        r"""
        Class-aware wrapper for `::fz_open_compressed_buffer()`.
        	Open a stream to read the decompressed version of a buffer.
        """
        return _mupdf.FzCompressedBuffer_fz_open_compressed_buffer(self)

    def fz_open_image_decomp_stream_from_buffer(self, l2factor):
        r"""
        Class-aware wrapper for `::fz_open_image_decomp_stream_from_buffer()`.

        This method has out-params. Python/C# wrappers look like:
        	`fz_open_image_decomp_stream_from_buffer()` => `(fz_stream *, int l2factor)`

        	Open a stream to read the decompressed version of a buffer,
        	with optional log2 subsampling.

        	l2factor = NULL for no subsampling, or a pointer to an integer
        	containing the maximum log2 subsample factor acceptable (0 =
        	none, 1 = halve dimensions, 2 = quarter dimensions etc). If
        	non-NULL, then *l2factor will be updated on exit with the actual
        	log2 subsample factor achieved.
        """
        return _mupdf.FzCompressedBuffer_fz_open_image_decomp_stream_from_buffer(self, l2factor)

    def get_buffer(self):
        r""" Returns wrapper class for fz_buffer *m_internal.buffer."""
        return _mupdf.FzCompressedBuffer_get_buffer(self)

    def __init__(self, *args):
        r"""
        *Overload 1:*
         == Constructors.  Constructor using `fz_new_compressed_buffer()`.
        		Create a new, UNKNOWN format, compressed_buffer.


        |

        *Overload 2:*
         Copy constructor using `fz_keep_compressed_buffer()`.

        |

        *Overload 3:*
         Constructor using raw copy of pre-existing `::fz_compressed_buffer`.
        """
        _mupdf.FzCompressedBuffer_swiginit(self, _mupdf.new_FzCompressedBuffer(*args))
    __swig_destroy__ = _mupdf.delete_FzCompressedBuffer

    def m_internal_value(self):
        r""" Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.FzCompressedBuffer_m_internal_value(self)
    m_internal = property(_mupdf.FzCompressedBuffer_m_internal_get, _mupdf.FzCompressedBuffer_m_internal_set, doc=r""" Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.FzCompressedBuffer_s_num_instances_get, _mupdf.FzCompressedBuffer_s_num_instances_set)

# Register FzCompressedBuffer in _mupdf:
_mupdf.FzCompressedBuffer_swigregister(FzCompressedBuffer)
class FzCompressedImage(object):
    r""" Wrapper class for struct `fz_compressed_image`. Not copyable or assignable."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def fz_set_compressed_image_buffer(self, buf):
        r""" Class-aware wrapper for `::fz_set_compressed_image_buffer()`."""
        return _mupdf.FzCompressedImage_fz_set_compressed_image_buffer(self, buf)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::fz_compressed_image`.
        """
        _mupdf.FzCompressedImage_swiginit(self, _mupdf.new_FzCompressedImage(*args))
    __swig_destroy__ = _mupdf.delete_FzCompressedImage

    def m_internal_value(self):
        r""" Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.FzCompressedImage_m_internal_value(self)
    m_internal = property(_mupdf.FzCompressedImage_m_internal_get, _mupdf.FzCompressedImage_m_internal_set, doc=r""" Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.FzCompressedImage_s_num_instances_get, _mupdf.FzCompressedImage_s_num_instances_set)

# Register FzCompressedImage in _mupdf:
_mupdf.FzCompressedImage_swigregister(FzCompressedImage)
class FzCompressionParams(object):
    r"""
    Wrapper class for struct `fz_compression_params`. Not copyable or assignable.
    Compression parameters used for buffers of compressed data;
    typically for the source data for images.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::fz_compression_params`.
        """
        _mupdf.FzCompressionParams_swiginit(self, _mupdf.new_FzCompressionParams(*args))
    __swig_destroy__ = _mupdf.delete_FzCompressionParams

    def m_internal_value(self):
        r""" Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.FzCompressionParams_m_internal_value(self)
    m_internal = property(_mupdf.FzCompressionParams_m_internal_get, _mupdf.FzCompressionParams_m_internal_set, doc=r""" Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.FzCompressionParams_s_num_instances_get, _mupdf.FzCompressionParams_s_num_instances_set)

# Register FzCompressionParams in _mupdf:
_mupdf.FzCompressionParams_swigregister(FzCompressionParams)
class FzContext(object):
    r""" Wrapper class for struct `fz_context`. Not copyable or assignable."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        == Constructors.  Constructor using `fz_new_context_imp()`.

        |

        *Overload 2:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 3:*
        Constructor using raw copy of pre-existing `::fz_context`.
        """
        _mupdf.FzContext_swiginit(self, _mupdf.new_FzContext(*args))
    __swig_destroy__ = _mupdf.delete_FzContext

    def m_internal_value(self):
        r""" Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.FzContext_m_internal_value(self)
    m_internal = property(_mupdf.FzContext_m_internal_get, _mupdf.FzContext_m_internal_set, doc=r""" Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.FzContext_s_num_instances_get, _mupdf.FzContext_s_num_instances_set)

# Register FzContext in _mupdf:
_mupdf.FzContext_swigregister(FzContext)
class FzCookie(object):
    r"""
    Wrapper class for struct `fz_cookie`. Not copyable or assignable.
    Provide two-way communication between application and library.
    Intended for multi-threaded applications where one thread is
    rendering pages and another thread wants to read progress
    feedback or abort a job that takes a long time to finish. The
    communication is unsynchronized without locking.

    abort: The application should set this field to 0 before
    calling fz_run_page to render a page. At any point when the
    page is being rendered the application my set this field to 1
    which will cause the rendering to finish soon. This field is
    checked periodically when the page is rendered, but exactly
    when is not known, therefore there is no upper bound on
    exactly when the rendering will abort. If the application
    did not provide a set of locks to fz_new_context, it must also
    await the completion of fz_run_page before issuing another
    call to fz_run_page. Note that once the application has set
    this field to 1 after it called fz_run_page it may not change
    the value again.

    progress: Communicates rendering progress back to the
    application and is read only. Increments as a page is being
    rendered. The value starts out at 0 and is limited to less
    than or equal to progress_max, unless progress_max is -1.

    progress_max: Communicates the known upper bound of rendering
    back to the application and is read only. The maximum value
    that the progress field may take. If there is no known upper
    bound on how long the rendering may take this value is -1 and
    progress is not limited. Note that the value of progress_max
    may change from -1 to a positive value once an upper bound is
    known, so take this into consideration when comparing the
    value of progress to that of progress_max.

    errors: count of errors during current rendering.

    incomplete: Initially should be set to 0. Will be set to
    non-zero if a TRYLATER error is thrown during rendering.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r""" Default constructor sets all fields to default values."""
        _mupdf.FzCookie_swiginit(self, _mupdf.new_FzCookie())

    def set_abort(self):
        r""" Sets m_internal.abort to 1."""
        return _mupdf.FzCookie_set_abort(self)

    def increment_errors(self, delta):
        r""" Increments m_internal.errors by <delta>."""
        return _mupdf.FzCookie_increment_errors(self, delta)

    def abort(self):
        return _mupdf.FzCookie_abort(self)

    def progress(self):
        return _mupdf.FzCookie_progress(self)

    def progress_max(self):
        return _mupdf.FzCookie_progress_max(self)

    def errors(self):
        return _mupdf.FzCookie_errors(self)

    def incomplete(self):
        return _mupdf.FzCookie_incomplete(self)
    __swig_destroy__ = _mupdf.delete_FzCookie
    m_internal = property(_mupdf.FzCookie_m_internal_get, _mupdf.FzCookie_m_internal_set)
    s_num_instances = property(_mupdf.FzCookie_s_num_instances_get, _mupdf.FzCookie_s_num_instances_set, doc=r""" Wrapped data is held by value.""")

    def to_string(self):
        r""" Returns string containing our members, labelled and inside (...), using operator<<."""
        return _mupdf.FzCookie_to_string(self)

    def __eq__(self, rhs):
        r""" Comparison method."""
        return _mupdf.FzCookie___eq__(self, rhs)

    def __ne__(self, rhs):
        r""" Comparison method."""
        return _mupdf.FzCookie___ne__(self, rhs)

# Register FzCookie in _mupdf:
_mupdf.FzCookie_swigregister(FzCookie)
class FzDefaultColorspaces(object):
    r"""
    Wrapper class for struct `fz_default_colorspaces`.
    Structure to hold default colorspaces.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def fz_clone_default_colorspaces(self):
        r"""
        Class-aware wrapper for `::fz_clone_default_colorspaces()`.
        	Returns a reference to a newly cloned default colorspaces
        	structure.

        	The new clone may safely be altered without fear of race
        	conditions as the caller is the only reference holder.
        """
        return _mupdf.FzDefaultColorspaces_fz_clone_default_colorspaces(self)

    def fz_default_cmyk(self):
        r""" Class-aware wrapper for `::fz_default_cmyk()`."""
        return _mupdf.FzDefaultColorspaces_fz_default_cmyk(self)

    def fz_default_gray(self):
        r"""
        Class-aware wrapper for `::fz_default_gray()`.
        	Retrieve default colorspaces (typically page local).

        	If default_cs is non NULL, the default is retrieved from there,
        	otherwise the global default is retrieved.

        	These return borrowed references that should not be dropped,
        	unless they are kept first.
        """
        return _mupdf.FzDefaultColorspaces_fz_default_gray(self)

    def fz_default_output_intent(self):
        r""" Class-aware wrapper for `::fz_default_output_intent()`."""
        return _mupdf.FzDefaultColorspaces_fz_default_output_intent(self)

    def fz_default_rgb(self):
        r""" Class-aware wrapper for `::fz_default_rgb()`."""
        return _mupdf.FzDefaultColorspaces_fz_default_rgb(self)

    def fz_set_default_cmyk(self, cs):
        r""" Class-aware wrapper for `::fz_set_default_cmyk()`."""
        return _mupdf.FzDefaultColorspaces_fz_set_default_cmyk(self, cs)

    def fz_set_default_gray(self, cs):
        r"""
        Class-aware wrapper for `::fz_set_default_gray()`.
        	Set new defaults within the default colorspace structure.

        	New references are taken to the new default, and references to
        	the old defaults dropped.

        	Never throws exceptions.
        """
        return _mupdf.FzDefaultColorspaces_fz_set_default_gray(self, cs)

    def fz_set_default_output_intent(self, cs):
        r""" Class-aware wrapper for `::fz_set_default_output_intent()`."""
        return _mupdf.FzDefaultColorspaces_fz_set_default_output_intent(self, cs)

    def fz_set_default_rgb(self, cs):
        r""" Class-aware wrapper for `::fz_set_default_rgb()`."""
        return _mupdf.FzDefaultColorspaces_fz_set_default_rgb(self, cs)

    def pdf_update_default_colorspaces(self, res):
        r""" Class-aware wrapper for `::pdf_update_default_colorspaces()`."""
        return _mupdf.FzDefaultColorspaces_pdf_update_default_colorspaces(self, res)

    def __init__(self, *args):
        r"""
        *Overload 1:*
         == Constructors.  Constructor using `fz_new_default_colorspaces()`.
        		Create a new default colorspace structure with values inherited
        		from the context, and return a reference to it.

        		These can be overridden using fz_set_default_xxxx.

        		These should not be overridden while more than one caller has
        		the reference for fear of race conditions.

        		The caller should drop this reference once finished with it.


        |

        *Overload 2:*
         Copy constructor using `fz_keep_default_colorspaces()`.

        |

        *Overload 3:*
         Constructor using raw copy of pre-existing `::fz_default_colorspaces`.
        """
        _mupdf.FzDefaultColorspaces_swiginit(self, _mupdf.new_FzDefaultColorspaces(*args))
    __swig_destroy__ = _mupdf.delete_FzDefaultColorspaces

    def m_internal_value(self):
        r""" Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.FzDefaultColorspaces_m_internal_value(self)
    m_internal = property(_mupdf.FzDefaultColorspaces_m_internal_get, _mupdf.FzDefaultColorspaces_m_internal_set, doc=r""" Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.FzDefaultColorspaces_s_num_instances_get, _mupdf.FzDefaultColorspaces_s_num_instances_set)

# Register FzDefaultColorspaces in _mupdf:
_mupdf.FzDefaultColorspaces_swigregister(FzDefaultColorspaces)
class FzDevice(object):
    r"""
    Wrapper class for struct `fz_device`.
    The different format handlers (pdf, xps etc) interpret pages to
    a device. These devices can then process the stream of calls
    they receive in various ways:
    	The trace device outputs debugging information for the calls.
    	The draw device will render them.
    	The list device stores them in a list to play back later.
    	The text device performs text extraction and searching.
    	The bbox device calculates the bounding box for the page.
    Other devices can (and will) be written in the future.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def fz_new_xmltext_device(out):
        r"""
        Class-aware wrapper for `::fz_new_xmltext_device()`.
        	Create a device to output raw information.
        """
        return _mupdf.FzDevice_fz_new_xmltext_device(out)

    @staticmethod
    def fz_new_draw_device_type3(transform, dest):
        r""" Class-aware wrapper for `::fz_new_draw_device_type3()`."""
        return _mupdf.FzDevice_fz_new_draw_device_type3(transform, dest)

    def fz_begin_group(self, area, cs, isolated, knockout, blendmode, alpha):
        r""" Class-aware wrapper for `::fz_begin_group()`."""
        return _mupdf.FzDevice_fz_begin_group(self, area, cs, isolated, knockout, blendmode, alpha)

    def fz_begin_layer(self, layer_name):
        r""" Class-aware wrapper for `::fz_begin_layer()`."""
        return _mupdf.FzDevice_fz_begin_layer(self, layer_name)

    def fz_begin_mask(self, area, luminosity, colorspace, bc, color_params):
        r""" Class-aware wrapper for `::fz_begin_mask()`."""
        return _mupdf.FzDevice_fz_begin_mask(self, area, luminosity, colorspace, bc, color_params)

    def fz_begin_metatext(self, meta, text):
        r""" Class-aware wrapper for `::fz_begin_metatext()`."""
        return _mupdf.FzDevice_fz_begin_metatext(self, meta, text)

    def fz_begin_structure(self, standard, raw, idx):
        r""" Class-aware wrapper for `::fz_begin_structure()`."""
        return _mupdf.FzDevice_fz_begin_structure(self, standard, raw, idx)

    def fz_begin_tile(self, area, view, xstep, ystep, ctm):
        r""" Class-aware wrapper for `::fz_begin_tile()`."""
        return _mupdf.FzDevice_fz_begin_tile(self, area, view, xstep, ystep, ctm)

    def fz_begin_tile_id(self, area, view, xstep, ystep, ctm, id):
        r""" Class-aware wrapper for `::fz_begin_tile_id()`."""
        return _mupdf.FzDevice_fz_begin_tile_id(self, area, view, xstep, ystep, ctm, id)

    def fz_clip_image_mask(self, image, ctm, scissor):
        r""" Class-aware wrapper for `::fz_clip_image_mask()`."""
        return _mupdf.FzDevice_fz_clip_image_mask(self, image, ctm, scissor)

    def fz_clip_path(self, path, even_odd, ctm, scissor):
        r""" Class-aware wrapper for `::fz_clip_path()`."""
        return _mupdf.FzDevice_fz_clip_path(self, path, even_odd, ctm, scissor)

    def fz_clip_stroke_path(self, path, stroke, ctm, scissor):
        r""" Class-aware wrapper for `::fz_clip_stroke_path()`."""
        return _mupdf.FzDevice_fz_clip_stroke_path(self, path, stroke, ctm, scissor)

    def fz_clip_stroke_text(self, text, stroke, ctm, scissor):
        r""" Class-aware wrapper for `::fz_clip_stroke_text()`."""
        return _mupdf.FzDevice_fz_clip_stroke_text(self, text, stroke, ctm, scissor)

    def fz_clip_text(self, text, ctm, scissor):
        r""" Class-aware wrapper for `::fz_clip_text()`."""
        return _mupdf.FzDevice_fz_clip_text(self, text, ctm, scissor)

    def fz_close_device(self):
        r"""
        Class-aware wrapper for `::fz_close_device()`.
        	Signal the end of input, and flush any buffered output.
        	This is NOT called implicitly on fz_drop_device. This
        	may throw exceptions.
        """
        return _mupdf.FzDevice_fz_close_device(self)

    def fz_device_current_scissor(self):
        r"""
        Class-aware wrapper for `::fz_device_current_scissor()`.
        	Find current scissor region as tracked by the device.
        """
        return _mupdf.FzDevice_fz_device_current_scissor(self)

    def fz_disable_device_hints(self, hints):
        r"""
        Class-aware wrapper for `::fz_disable_device_hints()`.
        	Disable (clear) hint bits within the hint bitfield for a device.
        """
        return _mupdf.FzDevice_fz_disable_device_hints(self, hints)

    def fz_enable_device_hints(self, hints):
        r"""
        Class-aware wrapper for `::fz_enable_device_hints()`.
        	Enable (set) hint bits within the hint bitfield for a device.
        """
        return _mupdf.FzDevice_fz_enable_device_hints(self, hints)

    def fz_end_group(self):
        r""" Class-aware wrapper for `::fz_end_group()`."""
        return _mupdf.FzDevice_fz_end_group(self)

    def fz_end_layer(self):
        r""" Class-aware wrapper for `::fz_end_layer()`."""
        return _mupdf.FzDevice_fz_end_layer(self)

    def fz_end_mask(self):
        r""" Class-aware wrapper for `::fz_end_mask()`."""
        return _mupdf.FzDevice_fz_end_mask(self)

    def fz_end_mask_tr(self, fn):
        r""" Class-aware wrapper for `::fz_end_mask_tr()`."""
        return _mupdf.FzDevice_fz_end_mask_tr(self, fn)

    def fz_end_metatext(self):
        r""" Class-aware wrapper for `::fz_end_metatext()`."""
        return _mupdf.FzDevice_fz_end_metatext(self)

    def fz_end_structure(self):
        r""" Class-aware wrapper for `::fz_end_structure()`."""
        return _mupdf.FzDevice_fz_end_structure(self)

    def fz_end_tile(self):
        r""" Class-aware wrapper for `::fz_end_tile()`."""
        return _mupdf.FzDevice_fz_end_tile(self)

    def fz_fill_image(self, image, ctm, alpha, color_params):
        r""" Class-aware wrapper for `::fz_fill_image()`."""
        return _mupdf.FzDevice_fz_fill_image(self, image, ctm, alpha, color_params)

    def fz_fill_image_mask(self, image, ctm, colorspace, color, alpha, color_params):
        r""" Class-aware wrapper for `::fz_fill_image_mask()`."""
        return _mupdf.FzDevice_fz_fill_image_mask(self, image, ctm, colorspace, color, alpha, color_params)

    def fz_fill_path(self, path, even_odd, ctm, colorspace, color, alpha, color_params):
        r"""
        Class-aware wrapper for `::fz_fill_path()`.
        	Device calls; graphics primitives and containers.
        """
        return _mupdf.FzDevice_fz_fill_path(self, path, even_odd, ctm, colorspace, color, alpha, color_params)

    def fz_fill_shade(self, shade, ctm, alpha, color_params):
        r""" Class-aware wrapper for `::fz_fill_shade()`."""
        return _mupdf.FzDevice_fz_fill_shade(self, shade, ctm, alpha, color_params)

    def fz_fill_text(self, text, ctm, colorspace, color, alpha, color_params):
        r""" Class-aware wrapper for `::fz_fill_text()`."""
        return _mupdf.FzDevice_fz_fill_text(self, text, ctm, colorspace, color, alpha, color_params)

    def fz_ignore_text(self, text, ctm):
        r""" Class-aware wrapper for `::fz_ignore_text()`."""
        return _mupdf.FzDevice_fz_ignore_text(self, text, ctm)

    def fz_new_ocr_device(self, ctm, mediabox, with_list, language, datadir, progress, progress_arg):
        r"""
        Class-aware wrapper for `::fz_new_ocr_device()`.
        	Create a device to OCR the text on the page.

        	Renders the page internally to a bitmap that is then OCRd. Text
        	is then forwarded onto the target device.

        	target: The target device to receive the OCRd text.

        	ctm: The transform to apply to the mediabox to get the size for
        	the rendered page image. Also used to calculate the resolution
        	for the page image. In general, this will be the same as the CTM
        	that you pass to fz_run_page (or fz_run_display_list) to feed
        	this device.

        	mediabox: The mediabox (in points). Combined with the CTM to get
        	the bounds of the pixmap used internally for the rendered page
        	image.

        	with_list: If with_list is false, then all non-text operations
        	are forwarded instantly to the target device. This results in
        	the target device seeing all NON-text operations, followed by
        	all the text operations (derived from OCR).

        	If with_list is true, then all the marking operations are
        	collated into a display list which is then replayed to the
        	target device at the end.

        	language: NULL (for "eng"), or a pointer to a string to describe
        	the languages/scripts that should be used for OCR (e.g.
        	"eng,ara").

        	datadir: NULL (for ""), or a pointer to a path string otherwise
        	provided to Tesseract in the TESSDATA_PREFIX environment variable.

        	progress: NULL, or function to be called periodically to indicate
        	progress. Return 0 to continue, or 1 to cancel. progress_arg is
        	returned as the void *. The int is a value between 0 and 100 to
        	indicate progress.

        	progress_arg: A void * value to be parrotted back to the progress
        	function.
        """
        return _mupdf.FzDevice_fz_new_ocr_device(self, ctm, mediabox, with_list, language, datadir, progress, progress_arg)

    def fz_pop_clip(self):
        r""" Class-aware wrapper for `::fz_pop_clip()`."""
        return _mupdf.FzDevice_fz_pop_clip(self)

    def fz_render_flags(self, set, clear):
        r""" Class-aware wrapper for `::fz_render_flags()`."""
        return _mupdf.FzDevice_fz_render_flags(self, set, clear)

    def fz_render_t3_glyph_direct(self, font, gid, trm, gstate, def_cs):
        r"""
        Class-aware wrapper for `::fz_render_t3_glyph_direct()`.
        	Nasty PDF interpreter specific hernia, required to allow the
        	interpreter to replay glyphs from a type3 font directly into
        	the target device.

        	This is only used in exceptional circumstances (such as type3
        	glyphs that inherit current graphics state, or nested type3
        	glyphs).
        """
        return _mupdf.FzDevice_fz_render_t3_glyph_direct(self, font, gid, trm, gstate, def_cs)

    def fz_set_default_colorspaces(self, default_cs):
        r""" Class-aware wrapper for `::fz_set_default_colorspaces()`."""
        return _mupdf.FzDevice_fz_set_default_colorspaces(self, default_cs)

    def fz_stroke_path(self, path, stroke, ctm, colorspace, color, alpha, color_params):
        r""" Class-aware wrapper for `::fz_stroke_path()`."""
        return _mupdf.FzDevice_fz_stroke_path(self, path, stroke, ctm, colorspace, color, alpha, color_params)

    def fz_stroke_text(self, text, stroke, ctm, colorspace, color, alpha, color_params):
        r""" Class-aware wrapper for `::fz_stroke_text()`."""
        return _mupdf.FzDevice_fz_stroke_text(self, text, stroke, ctm, colorspace, color, alpha, color_params)

    def __init__(self, *args):
        r"""
        *Overload 1:*
         == Constructors.  Constructor using `fz_new_bbox_device()`.
        		Create a device to compute the bounding
        		box of all marks on a page.

        		The returned bounding box will be the union of all bounding
        		boxes of all objects on a page.


        |

        *Overload 2:*
         Constructor using `fz_new_device_of_size()`.
        		Devices are created by calls to device implementations, for
        		instance: foo_new_device(). These will be implemented by calling
        		fz_new_derived_device(ctx, foo_device) where foo_device is a
        		structure "derived from" fz_device, for instance
        		typedef struct { fz_device base;  ...extras...} foo_device;


        |

        *Overload 3:*
         Constructor using `fz_new_draw_device()`.
        		Create a device to draw on a pixmap.

        		dest: Target pixmap for the draw device. See fz_new_pixmap*
        		for how to obtain a pixmap. The pixmap is not cleared by the
        		draw device, see fz_clear_pixmap* for how to clear it prior to
        		calling fz_new_draw_device. Free the device by calling
        		fz_drop_device.

        		transform: Transform from user space in points to device space
        		in pixels.


        |

        *Overload 4:*
         Constructor using `fz_new_draw_device_with_bbox()`.
        		Create a device to draw on a pixmap.

        		dest: Target pixmap for the draw device. See fz_new_pixmap*
        		for how to obtain a pixmap. The pixmap is not cleared by the
        		draw device, see fz_clear_pixmap* for how to clear it prior to
        		calling fz_new_draw_device. Free the device by calling
        		fz_drop_device.

        		transform: Transform from user space in points to device space
        		in pixels.

        		clip: Bounding box to restrict any marking operations of the
        		draw device.


        |

        *Overload 5:*
         Constructor using `fz_new_draw_device_with_bbox_proof()`.
        		Create a device to draw on a pixmap.

        		dest: Target pixmap for the draw device. See fz_new_pixmap*
        		for how to obtain a pixmap. The pixmap is not cleared by the
        		draw device, see fz_clear_pixmap* for how to clear it prior to
        		calling fz_new_draw_device. Free the device by calling
        		fz_drop_device.

        		transform: Transform from user space in points to device space
        		in pixels.

        		clip: Bounding box to restrict any marking operations of the
        		draw device.

        		proof_cs: Color space to render to prior to mapping to color
        		space defined by pixmap.


        |

        *Overload 6:*
         Constructor using `fz_new_draw_device_with_options()`.
        		Create a new pixmap and draw device, using the specified options.

        		options: Options to configure the draw device, and choose the
        		resolution and colorspace.

        		mediabox: The bounds of the page in points.

        		pixmap: An out parameter containing the newly created pixmap.


        |

        *Overload 7:*
         Constructor using `fz_new_draw_device_with_proof()`.
        		Create a device to draw on a pixmap.

        		dest: Target pixmap for the draw device. See fz_new_pixmap*
        		for how to obtain a pixmap. The pixmap is not cleared by the
        		draw device, see fz_clear_pixmap* for how to clear it prior to
        		calling fz_new_draw_device. Free the device by calling
        		fz_drop_device.

        		transform: Transform from user space in points to device space
        		in pixels.

        		proof_cs: Intermediate color space to map though when mapping to
        		color space defined by pixmap.


        |

        *Overload 8:*
         Constructor using `fz_new_list_device()`.
        		Create a rendering device for a display list.

        		When the device is rendering a page it will populate the
        		display list with drawing commands (text, images, etc.). The
        		display list can later be reused to render a page many times
        		without having to re-interpret the page from the document file
        		for each rendering. Once the device is no longer needed, free
        		it with fz_drop_device.

        		list: A display list that the list device takes a reference to.


        |

        *Overload 9:*
         Constructor using `fz_new_ocr_device()`.
        		Create a device to OCR the text on the page.

        		Renders the page internally to a bitmap that is then OCRd. Text
        		is then forwarded onto the target device.

        		target: The target device to receive the OCRd text.

        		ctm: The transform to apply to the mediabox to get the size for
        		the rendered page image. Also used to calculate the resolution
        		for the page image. In general, this will be the same as the CTM
        		that you pass to fz_run_page (or fz_run_display_list) to feed
        		this device.

        		mediabox: The mediabox (in points). Combined with the CTM to get
        		the bounds of the pixmap used internally for the rendered page
        		image.

        		with_list: If with_list is false, then all non-text operations
        		are forwarded instantly to the target device. This results in
        		the target device seeing all NON-text operations, followed by
        		all the text operations (derived from OCR).

        		If with_list is true, then all the marking operations are
        		collated into a display list which is then replayed to the
        		target device at the end.

        		language: NULL (for "eng"), or a pointer to a string to describe
        		the languages/scripts that should be used for OCR (e.g.
        		"eng,ara").

        		datadir: NULL (for ""), or a pointer to a path string otherwise
        		provided to Tesseract in the TESSDATA_PREFIX environment variable.

        		progress: NULL, or function to be called periodically to indicate
        		progress. Return 0 to continue, or 1 to cancel. progress_arg is
        		returned as the void *. The int is a value between 0 and 100 to
        		indicate progress.

        		progress_arg: A void * value to be parrotted back to the progress
        		function.


        |

        *Overload 10:*
         Constructor using `fz_new_stext_device()`.
        		Create a device to extract the text on a page.

        		Gather the text on a page into blocks and lines.

        		The reading order is taken from the order the text is drawn in
        		the source file, so may not be accurate.

        		page: The text page to which content should be added. This will
        		usually be a newly created (empty) text page, but it can be one
        		containing data already (for example when merging multiple
        		pages, or watermarking).

        		options: Options to configure the stext device.


        |

        *Overload 11:*
         Constructor using `fz_new_svg_device()`.
        		Create a device that outputs (single page) SVG files to
        		the given output stream.

        		Equivalent to fz_new_svg_device_with_id passing id = NULL.


        |

        *Overload 12:*
         Constructor using `fz_new_svg_device_with_id()`.
        		Create a device that outputs (single page) SVG files to
        		the given output stream.

        		output: The output stream to send the constructed SVG page to.

        		page_width, page_height: The page dimensions to use (in points).

        		text_format: How to emit text. One of the following values:
        			FZ_SVG_TEXT_AS_TEXT: As <text> elements with possible
        			layout errors and mismatching fonts.
        			FZ_SVG_TEXT_AS_PATH: As <path> elements with exact
        			visual appearance.

        		reuse_images: Share image resources using <symbol> definitions.

        		id: ID parameter to keep generated IDs unique across SVG files.


        |

        *Overload 13:*
         Constructor using `fz_new_test_device()`.
        		Create a device to test for features.

        		Currently only tests for the presence of non-grayscale colors.

        		is_color: Possible values returned:
        			0: Definitely greyscale
        			1: Probably color (all colors were grey, but there
        			were images or shadings in a non grey colorspace).
        			2: Definitely color

        		threshold: The difference from grayscale that will be tolerated.
        		Typical values to use are either 0 (be exact) and 0.02 (allow an
        		imperceptible amount of slop).

        		options: A set of bitfield options, from the FZ_TEST_OPT set.

        		passthrough: A device to pass all calls through to, or NULL.
        		If set, then the test device can both test and pass through to
        		an underlying device (like, say, the display list device). This
        		means that a display list can be created and at the end we'll
        		know if it's colored or not.

        		In the absence of a passthrough device, the device will throw
        		an exception to stop page interpretation when color is found.


        |

        *Overload 14:*
         Constructor using `fz_new_trace_device()`.
        		Create a device to print a debug trace of all device calls.


        |

        *Overload 15:*
         Constructor using `pdf_new_pdf_device()`.

        |

        *Overload 16:*
         Copy constructor using `fz_keep_device()`.

        |

        *Overload 17:*
         Default constructor, sets `m_internal` to null.

        |

        *Overload 18:*
         Constructor using raw copy of pre-existing `::fz_device`.
        """
        _mupdf.FzDevice_swiginit(self, _mupdf.new_FzDevice(*args))
    __swig_destroy__ = _mupdf.delete_FzDevice

    def m_internal_value(self):
        r""" Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.FzDevice_m_internal_value(self)
    m_internal = property(_mupdf.FzDevice_m_internal_get, _mupdf.FzDevice_m_internal_set, doc=r""" Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.FzDevice_s_num_instances_get, _mupdf.FzDevice_s_num_instances_set)

# Register FzDevice in _mupdf:
_mupdf.FzDevice_swigregister(FzDevice)
class FzDevice2(FzDevice):
    r""" Wrapper class for struct fz_device with virtual fns for each fnptr; this is for use as a SWIG Director class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r""" == Constructor."""
        if self.__class__ == FzDevice2:
            _self = None
        else:
            _self = self
        _mupdf.FzDevice2_swiginit(self, _mupdf.new_FzDevice2(_self, ))

    def use_virtual_close_device(self, use=True):
        r"""
        These methods set the function pointers in *m_internal
        to point to internal callbacks that call our virtual methods.
        """
        return _mupdf.FzDevice2_use_virtual_close_device(self, use)

    def use_virtual_drop_device(self, use=True):
        return _mupdf.FzDevice2_use_virtual_drop_device(self, use)

    def use_virtual_fill_path(self, use=True):
        return _mupdf.FzDevice2_use_virtual_fill_path(self, use)

    def use_virtual_stroke_path(self, use=True):
        return _mupdf.FzDevice2_use_virtual_stroke_path(self, use)

    def use_virtual_clip_path(self, use=True):
        return _mupdf.FzDevice2_use_virtual_clip_path(self, use)

    def use_virtual_clip_stroke_path(self, use=True):
        return _mupdf.FzDevice2_use_virtual_clip_stroke_path(self, use)

    def use_virtual_fill_text(self, use=True):
        return _mupdf.FzDevice2_use_virtual_fill_text(self, use)

    def use_virtual_stroke_text(self, use=True):
        return _mupdf.FzDevice2_use_virtual_stroke_text(self, use)

    def use_virtual_clip_text(self, use=True):
        return _mupdf.FzDevice2_use_virtual_clip_text(self, use)

    def use_virtual_clip_stroke_text(self, use=True):
        return _mupdf.FzDevice2_use_virtual_clip_stroke_text(self, use)

    def use_virtual_ignore_text(self, use=True):
        return _mupdf.FzDevice2_use_virtual_ignore_text(self, use)

    def use_virtual_fill_shade(self, use=True):
        return _mupdf.FzDevice2_use_virtual_fill_shade(self, use)

    def use_virtual_fill_image(self, use=True):
        return _mupdf.FzDevice2_use_virtual_fill_image(self, use)

    def use_virtual_fill_image_mask(self, use=True):
        return _mupdf.FzDevice2_use_virtual_fill_image_mask(self, use)

    def use_virtual_clip_image_mask(self, use=True):
        return _mupdf.FzDevice2_use_virtual_clip_image_mask(self, use)

    def use_virtual_pop_clip(self, use=True):
        return _mupdf.FzDevice2_use_virtual_pop_clip(self, use)

    def use_virtual_begin_mask(self, use=True):
        return _mupdf.FzDevice2_use_virtual_begin_mask(self, use)

    def use_virtual_end_mask(self, use=True):
        return _mupdf.FzDevice2_use_virtual_end_mask(self, use)

    def use_virtual_begin_group(self, use=True):
        return _mupdf.FzDevice2_use_virtual_begin_group(self, use)

    def use_virtual_end_group(self, use=True):
        return _mupdf.FzDevice2_use_virtual_end_group(self, use)

    def use_virtual_begin_tile(self, use=True):
        return _mupdf.FzDevice2_use_virtual_begin_tile(self, use)

    def use_virtual_end_tile(self, use=True):
        return _mupdf.FzDevice2_use_virtual_end_tile(self, use)

    def use_virtual_render_flags(self, use=True):
        return _mupdf.FzDevice2_use_virtual_render_flags(self, use)

    def use_virtual_set_default_colorspaces(self, use=True):
        return _mupdf.FzDevice2_use_virtual_set_default_colorspaces(self, use)

    def use_virtual_begin_layer(self, use=True):
        return _mupdf.FzDevice2_use_virtual_begin_layer(self, use)

    def use_virtual_end_layer(self, use=True):
        return _mupdf.FzDevice2_use_virtual_end_layer(self, use)

    def use_virtual_begin_structure(self, use=True):
        return _mupdf.FzDevice2_use_virtual_begin_structure(self, use)

    def use_virtual_end_structure(self, use=True):
        return _mupdf.FzDevice2_use_virtual_end_structure(self, use)

    def use_virtual_begin_metatext(self, use=True):
        return _mupdf.FzDevice2_use_virtual_begin_metatext(self, use)

    def use_virtual_end_metatext(self, use=True):
        return _mupdf.FzDevice2_use_virtual_end_metatext(self, use)

    def close_device(self, arg_0):
        r""" Default virtual method implementations; these all throw an exception."""
        return _mupdf.FzDevice2_close_device(self, arg_0)

    def drop_device(self, arg_0):
        return _mupdf.FzDevice2_drop_device(self, arg_0)

    def fill_path(self, arg_0, arg_2, arg_3, arg_4, arg_5, arg_6, arg_7, arg_8):
        return _mupdf.FzDevice2_fill_path(self, arg_0, arg_2, arg_3, arg_4, arg_5, arg_6, arg_7, arg_8)

    def stroke_path(self, arg_0, arg_2, arg_3, arg_4, arg_5, arg_6, arg_7, arg_8):
        return _mupdf.FzDevice2_stroke_path(self, arg_0, arg_2, arg_3, arg_4, arg_5, arg_6, arg_7, arg_8)

    def clip_path(self, arg_0, arg_2, arg_3, arg_4, arg_5):
        return _mupdf.FzDevice2_clip_path(self, arg_0, arg_2, arg_3, arg_4, arg_5)

    def clip_stroke_path(self, arg_0, arg_2, arg_3, arg_4, arg_5):
        return _mupdf.FzDevice2_clip_stroke_path(self, arg_0, arg_2, arg_3, arg_4, arg_5)

    def fill_text(self, arg_0, arg_2, arg_3, arg_4, arg_5, arg_6, arg_7):
        return _mupdf.FzDevice2_fill_text(self, arg_0, arg_2, arg_3, arg_4, arg_5, arg_6, arg_7)

    def stroke_text(self, arg_0, arg_2, arg_3, arg_4, arg_5, arg_6, arg_7, arg_8):
        return _mupdf.FzDevice2_stroke_text(self, arg_0, arg_2, arg_3, arg_4, arg_5, arg_6, arg_7, arg_8)

    def clip_text(self, arg_0, arg_2, arg_3, arg_4):
        return _mupdf.FzDevice2_clip_text(self, arg_0, arg_2, arg_3, arg_4)

    def clip_stroke_text(self, arg_0, arg_2, arg_3, arg_4, arg_5):
        return _mupdf.FzDevice2_clip_stroke_text(self, arg_0, arg_2, arg_3, arg_4, arg_5)

    def ignore_text(self, arg_0, arg_2, arg_3):
        return _mupdf.FzDevice2_ignore_text(self, arg_0, arg_2, arg_3)

    def fill_shade(self, arg_0, arg_2, arg_3, arg_4, arg_5):
        return _mupdf.FzDevice2_fill_shade(self, arg_0, arg_2, arg_3, arg_4, arg_5)

    def fill_image(self, arg_0, arg_2, arg_3, arg_4, arg_5):
        return _mupdf.FzDevice2_fill_image(self, arg_0, arg_2, arg_3, arg_4, arg_5)

    def fill_image_mask(self, arg_0, arg_2, arg_3, arg_4, arg_5, arg_6, arg_7):
        return _mupdf.FzDevice2_fill_image_mask(self, arg_0, arg_2, arg_3, arg_4, arg_5, arg_6, arg_7)

    def clip_image_mask(self, arg_0, arg_2, arg_3, arg_4):
        return _mupdf.FzDevice2_clip_image_mask(self, arg_0, arg_2, arg_3, arg_4)

    def pop_clip(self, arg_0):
        return _mupdf.FzDevice2_pop_clip(self, arg_0)

    def begin_mask(self, arg_0, arg_2, arg_3, arg_4, arg_5, arg_6):
        return _mupdf.FzDevice2_begin_mask(self, arg_0, arg_2, arg_3, arg_4, arg_5, arg_6)

    def end_mask(self, arg_0, arg_2):
        return _mupdf.FzDevice2_end_mask(self, arg_0, arg_2)

    def begin_group(self, arg_0, arg_2, arg_3, arg_4, arg_5, arg_6, arg_7):
        return _mupdf.FzDevice2_begin_group(self, arg_0, arg_2, arg_3, arg_4, arg_5, arg_6, arg_7)

    def end_group(self, arg_0):
        return _mupdf.FzDevice2_end_group(self, arg_0)

    def begin_tile(self, arg_0, arg_2, arg_3, arg_4, arg_5, arg_6, arg_7):
        return _mupdf.FzDevice2_begin_tile(self, arg_0, arg_2, arg_3, arg_4, arg_5, arg_6, arg_7)

    def end_tile(self, arg_0):
        return _mupdf.FzDevice2_end_tile(self, arg_0)

    def render_flags(self, arg_0, arg_2, arg_3):
        return _mupdf.FzDevice2_render_flags(self, arg_0, arg_2, arg_3)

    def set_default_colorspaces(self, arg_0, arg_2):
        return _mupdf.FzDevice2_set_default_colorspaces(self, arg_0, arg_2)

    def begin_layer(self, arg_0, arg_2):
        return _mupdf.FzDevice2_begin_layer(self, arg_0, arg_2)

    def end_layer(self, arg_0):
        return _mupdf.FzDevice2_end_layer(self, arg_0)

    def begin_structure(self, arg_0, arg_2, arg_3, arg_4):
        return _mupdf.FzDevice2_begin_structure(self, arg_0, arg_2, arg_3, arg_4)

    def end_structure(self, arg_0):
        return _mupdf.FzDevice2_end_structure(self, arg_0)

    def begin_metatext(self, arg_0, arg_2, arg_3):
        return _mupdf.FzDevice2_begin_metatext(self, arg_0, arg_2, arg_3)

    def end_metatext(self, arg_0):
        return _mupdf.FzDevice2_end_metatext(self, arg_0)
    __swig_destroy__ = _mupdf.delete_FzDevice2
    def __disown__(self):
        self.this.disown()
        _mupdf.disown_FzDevice2(self)
        return weakref.proxy(self)

# Register FzDevice2 in _mupdf:
_mupdf.FzDevice2_swigregister(FzDevice2)
class FzDeviceContainerStack(object):
    r"""
    Wrapper class for struct `fz_device_container_stack`. Not copyable or assignable.
    Devices can keep track of containers (clips/masks/groups/tiles)
    as they go to save callers having to do it.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::fz_device_container_stack`.
        """
        _mupdf.FzDeviceContainerStack_swiginit(self, _mupdf.new_FzDeviceContainerStack(*args))
    __swig_destroy__ = _mupdf.delete_FzDeviceContainerStack

    def m_internal_value(self):
        r""" Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.FzDeviceContainerStack_m_internal_value(self)
    m_internal = property(_mupdf.FzDeviceContainerStack_m_internal_get, _mupdf.FzDeviceContainerStack_m_internal_set, doc=r""" Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.FzDeviceContainerStack_s_num_instances_get, _mupdf.FzDeviceContainerStack_s_num_instances_set)

# Register FzDeviceContainerStack in _mupdf:
_mupdf.FzDeviceContainerStack_swigregister(FzDeviceContainerStack)
class FzDisplayList(object):
    r"""
    Wrapper class for struct `fz_display_list`.
    fz_display_list is a list containing drawing commands (text,
    images, etc.). The intent is two-fold: as a caching-mechanism
    to reduce parsing of a page, and to be used as a data
    structure in multi-threading where one thread parses the page
    and another renders pages.

    Create a display list with fz_new_display_list, hand it over to
    fz_new_list_device to have it populated, and later replay the
    list (once or many times) by calling fz_run_display_list. When
    the list is no longer needed drop it with fz_drop_display_list.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def fz_new_display_list_from_page_contents(page):
        r"""
        Class-aware wrapper for `::fz_new_display_list_from_page_contents()`.
        	Create a display list from page contents (no annotations).

        	Ownership of the display list is returned to the caller.
        """
        return _mupdf.FzDisplayList_fz_new_display_list_from_page_contents(page)

    def fz_bound_display_list(self):
        r"""
        Class-aware wrapper for `::fz_bound_display_list()`.
        	Return the bounding box of the page recorded in a display list.
        """
        return _mupdf.FzDisplayList_fz_bound_display_list(self)

    def fz_display_list_is_empty(self):
        r"""
        Class-aware wrapper for `::fz_display_list_is_empty()`.
        	Check for a display list being empty

        	list: The list to check.

        	Returns true if empty, false otherwise.
        """
        return _mupdf.FzDisplayList_fz_display_list_is_empty(self)

    def fz_fill_pixmap_from_display_list(self, ctm, pix):
        r""" Class-aware wrapper for `::fz_fill_pixmap_from_display_list()`."""
        return _mupdf.FzDisplayList_fz_fill_pixmap_from_display_list(self, ctm, pix)

    def fz_new_buffer_from_display_list(self, options):
        r""" Class-aware wrapper for `::fz_new_buffer_from_display_list()`."""
        return _mupdf.FzDisplayList_fz_new_buffer_from_display_list(self, options)

    def fz_new_list_device(self):
        r"""
        Class-aware wrapper for `::fz_new_list_device()`.
        	Create a rendering device for a display list.

        	When the device is rendering a page it will populate the
        	display list with drawing commands (text, images, etc.). The
        	display list can later be reused to render a page many times
        	without having to re-interpret the page from the document file
        	for each rendering. Once the device is no longer needed, free
        	it with fz_drop_device.

        	list: A display list that the list device takes a reference to.
        """
        return _mupdf.FzDisplayList_fz_new_list_device(self)

    def fz_new_pixmap_from_display_list(self, ctm, cs, alpha):
        r"""
        Class-aware wrapper for `::fz_new_pixmap_from_display_list()`.
        	Render the page to a pixmap using the transform and colorspace.

        	Ownership of the pixmap is returned to the caller.
        """
        return _mupdf.FzDisplayList_fz_new_pixmap_from_display_list(self, ctm, cs, alpha)

    def fz_new_pixmap_from_display_list_with_separations(self, ctm, cs, seps, alpha):
        r"""
        Class-aware wrapper for `::fz_new_pixmap_from_display_list_with_separations()`.
        	Render the page contents with control over spot colors.

        	Ownership of the pixmap is returned to the caller.
        """
        return _mupdf.FzDisplayList_fz_new_pixmap_from_display_list_with_separations(self, ctm, cs, seps, alpha)

    def fz_run_display_list(self, dev, ctm, scissor, cookie):
        r"""
        Class-aware wrapper for `::fz_run_display_list()`.
        	(Re)-run a display list through a device.

        	list: A display list, created by fz_new_display_list and
        	populated with objects from a page by running fz_run_page on a
        	device obtained from fz_new_list_device.

        	ctm: Transform to apply to display list contents. May include
        	for example scaling and rotation, see fz_scale, fz_rotate and
        	fz_concat. Set to fz_identity if no transformation is desired.

        	scissor: Only the part of the contents of the display list
        	visible within this area will be considered when the list is
        	run through the device. This does not imply for tile objects
        	contained in the display list.

        	cookie: Communication mechanism between caller and library
        	running the page. Intended for multi-threaded applications,
        	while single-threaded applications set cookie to NULL. The
        	caller may abort an ongoing page run. Cookie also communicates
        	progress information back to the caller. The fields inside
        	cookie are continually updated while the page is being run.
        """
        return _mupdf.FzDisplayList_fz_run_display_list(self, dev, ctm, scissor, cookie)

    def fz_search_display_list(self, needle, hit_mark, hit_bbox, hit_max):
        r"""
        Class-aware wrapper for `::fz_search_display_list()`.

        This method has out-params. Python/C# wrappers look like:
        	`fz_search_display_list(const char *needle, ::fz_quad *hit_bbox, int hit_max)` => `(int, int hit_mark)`
        """
        return _mupdf.FzDisplayList_fz_search_display_list(self, needle, hit_mark, hit_bbox, hit_max)

    def __init__(self, *args):
        r"""
        *Overload 1:*
         == Constructors.  Constructor using `fz_new_display_list()`.
        		Create an empty display list.

        		A display list contains drawing commands (text, images, etc.).
        		Use fz_new_list_device for populating the list.

        		mediabox: Bounds of the page (in points) represented by the
        		display list.


        |

        *Overload 2:*
         Constructor using `fz_new_display_list_from_page()`.
        		Create a display list.

        		Ownership of the display list is returned to the caller.


        |

        *Overload 3:*
         Constructor using `fz_new_display_list_from_page_number()`.

        |

        *Overload 4:*
         Constructor using `fz_new_display_list_from_svg()`.
        		Parse an SVG document into a display-list.


        |

        *Overload 5:*
         Constructor using `fz_new_display_list_from_svg_xml()`.
        		Parse an SVG document into a display-list.


        |

        *Overload 6:*
         Constructor using `pdf_new_display_list_from_annot()`.

        |

        *Overload 7:*
         Copy constructor using `fz_keep_display_list()`.

        |

        *Overload 8:*
         Default constructor, sets `m_internal` to null.

        |

        *Overload 9:*
         Constructor using raw copy of pre-existing `::fz_display_list`.
        """
        _mupdf.FzDisplayList_swiginit(self, _mupdf.new_FzDisplayList(*args))
    __swig_destroy__ = _mupdf.delete_FzDisplayList

    def m_internal_value(self):
        r""" Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.FzDisplayList_m_internal_value(self)
    m_internal = property(_mupdf.FzDisplayList_m_internal_get, _mupdf.FzDisplayList_m_internal_set, doc=r""" Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.FzDisplayList_s_num_instances_get, _mupdf.FzDisplayList_s_num_instances_set)

# Register FzDisplayList in _mupdf:
_mupdf.FzDisplayList_swigregister(FzDisplayList)
class FzDocument(object):
    r""" Wrapper class for struct `fz_document`."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def fz_authenticate_password(self, password):
        r"""
        Class-aware wrapper for `::fz_authenticate_password()`.
        	Test if the given password can decrypt the document.

        	password: The password string to be checked. Some document
        	specifications do not specify any particular text encoding, so
        	neither do we.

        	Returns 0 for failure to authenticate, non-zero for success.

        	For PDF documents, further information can be given by examining
        	the bits in the return code.

        		Bit 0 => No password required
        		Bit 1 => User password authenticated
        		Bit 2 => Owner password authenticated
        """
        return _mupdf.FzDocument_fz_authenticate_password(self, password)

    def fz_clamp_location(self, loc):
        r"""
        Class-aware wrapper for `::fz_clamp_location()`.
        	Clamps a location into valid chapter/page range. (First clamps
        	the chapter into range, then the page into range).
        """
        return _mupdf.FzDocument_fz_clamp_location(self, loc)

    def fz_count_chapter_pages(self, chapter):
        r"""
        Class-aware wrapper for `::fz_count_chapter_pages()`.
        	Return the number of pages in a chapter.
        	May return 0.
        """
        return _mupdf.FzDocument_fz_count_chapter_pages(self, chapter)

    def fz_count_chapters(self):
        r"""
        Class-aware wrapper for `::fz_count_chapters()`.
        	Return the number of chapters in the document.
        	At least 1.
        """
        return _mupdf.FzDocument_fz_count_chapters(self)

    def fz_count_pages(self):
        r"""
        Class-aware wrapper for `::fz_count_pages()`.
        	Return the number of pages in document

        	May return 0 for documents with no pages.
        """
        return _mupdf.FzDocument_fz_count_pages(self)

    def fz_document_output_intent(self):
        r"""
        Class-aware wrapper for `::fz_document_output_intent()`.
        	Find the output intent colorspace if the document has defined
        	one.

        	Returns a borrowed reference that should not be dropped, unless
        	it is kept first.
        """
        return _mupdf.FzDocument_fz_document_output_intent(self)

    def fz_document_supports_accelerator(self):
        r"""
        Class-aware wrapper for `::fz_document_supports_accelerator()`.
        	Query if the document supports the saving of accelerator data.
        """
        return _mupdf.FzDocument_fz_document_supports_accelerator(self)

    def fz_format_link_uri(self, dest):
        r"""
        Class-aware wrapper for `::fz_format_link_uri()`.
        	Format an internal link to a page number, location, and possible viewing parameters,
        	suitable for use with fz_create_link.

        	Returns a newly allocated string that the caller must free.
        """
        return _mupdf.FzDocument_fz_format_link_uri(self, dest)

    def fz_has_permission(self, p):
        r"""
        Class-aware wrapper for `::fz_has_permission()`.
        	Check permission flags on document.
        """
        return _mupdf.FzDocument_fz_has_permission(self, p)

    def fz_is_document_reflowable(self):
        r"""
        Class-aware wrapper for `::fz_is_document_reflowable()`.
        	Is the document reflowable.

        	Returns 1 to indicate reflowable documents, otherwise 0.
        """
        return _mupdf.FzDocument_fz_is_document_reflowable(self)

    def fz_last_page(self):
        r"""
        Class-aware wrapper for `::fz_last_page()`.
        	Function to get the location for the last page in the document.
        	Using this can be far more efficient in some cases than calling
        	fz_count_pages and using the page number.
        """
        return _mupdf.FzDocument_fz_last_page(self)

    def fz_layout_document(self, w, h, em):
        r"""
        Class-aware wrapper for `::fz_layout_document()`.
        	Layout reflowable document types.

        	w, h: Page size in points.
        	em: Default font size in points.
        """
        return _mupdf.FzDocument_fz_layout_document(self, w, h, em)

    def fz_load_chapter_page(self, chapter, page):
        r"""
        Class-aware wrapper for `::fz_load_chapter_page()`.
        	Load a page.

        	After fz_load_page is it possible to retrieve the size of the
        	page using fz_bound_page, or to render the page using
        	fz_run_page_*. Free the page by calling fz_drop_page.

        	chapter: chapter number, 0 is the first chapter of the document.
        	number: page number, 0 is the first page of the chapter.
        """
        return _mupdf.FzDocument_fz_load_chapter_page(self, chapter, page)

    def fz_load_outline(self):
        r"""
        Class-aware wrapper for `::fz_load_outline()`.
        	Load the hierarchical document outline.

        	Should be freed by fz_drop_outline.
        """
        return _mupdf.FzDocument_fz_load_outline(self)

    def fz_load_page(self, number):
        r"""
        Class-aware wrapper for `::fz_load_page()`.
        	Load a given page number from a document. This may be much less
        	efficient than loading by location (chapter+page) for some
        	document types.
        """
        return _mupdf.FzDocument_fz_load_page(self, number)

    def fz_location_from_page_number(self, number):
        r"""
        Class-aware wrapper for `::fz_location_from_page_number()`.
        	Converts from page number to chapter+page. This may cause many
        	chapters to be laid out in order to calculate the number of
        	pages within those chapters.
        """
        return _mupdf.FzDocument_fz_location_from_page_number(self, number)

    def fz_lookup_bookmark(self, mark):
        r"""
        Class-aware wrapper for `::fz_lookup_bookmark()`.
        	Find a bookmark and return its page number.
        """
        return _mupdf.FzDocument_fz_lookup_bookmark(self, mark)

    def fz_lookup_metadata(self, key, buf, size):
        r"""
        Class-aware wrapper for `::fz_lookup_metadata()`.
        	Retrieve document meta data strings.

        	doc: The document to query.

        	key: Which meta data key to retrieve...

        	Basic information:
        		'format'	-- Document format and version.
        		'encryption'	-- Description of the encryption used.

        	From the document information dictionary:
        		'info:Title'
        		'info:Author'
        		'info:Subject'
        		'info:Keywords'
        		'info:Creator'
        		'info:Producer'
        		'info:CreationDate'
        		'info:ModDate'

        	buf: The buffer to hold the results (a nul-terminated UTF-8
        	string).

        	size: Size of 'buf'.

        	Returns the number of bytes need to store the string plus terminator
        	(will be larger than 'size' if the output was truncated), or -1 if the
        	key is not recognized or found.
        """
        return _mupdf.FzDocument_fz_lookup_metadata(self, key, buf, size)

    def fz_lookup_metadata2(self, key):
        r"""
        Class-aware wrapper for `::fz_lookup_metadata2()`.
        C++ alternative to `fz_lookup_metadata()` that returns a `std::string`
        or calls `fz_throw()` if not found.
        """
        return _mupdf.FzDocument_fz_lookup_metadata2(self, key)

    def fz_needs_password(self):
        r"""
        Class-aware wrapper for `::fz_needs_password()`.
        	Check if a document is encrypted with a
        	non-blank password.
        """
        return _mupdf.FzDocument_fz_needs_password(self)

    def fz_new_buffer_from_page_number(self, number, options):
        r""" Class-aware wrapper for `::fz_new_buffer_from_page_number()`."""
        return _mupdf.FzDocument_fz_new_buffer_from_page_number(self, number, options)

    def fz_new_display_list_from_page_number(self, number):
        r""" Class-aware wrapper for `::fz_new_display_list_from_page_number()`."""
        return _mupdf.FzDocument_fz_new_display_list_from_page_number(self, number)

    def fz_new_pixmap_from_page_number(self, number, ctm, cs, alpha):
        r""" Class-aware wrapper for `::fz_new_pixmap_from_page_number()`."""
        return _mupdf.FzDocument_fz_new_pixmap_from_page_number(self, number, ctm, cs, alpha)

    def fz_new_pixmap_from_page_number_with_separations(self, number, ctm, cs, seps, alpha):
        r""" Class-aware wrapper for `::fz_new_pixmap_from_page_number_with_separations()`."""
        return _mupdf.FzDocument_fz_new_pixmap_from_page_number_with_separations(self, number, ctm, cs, seps, alpha)

    def fz_new_xhtml_document_from_document(self, *args):
        r"""
        *Overload 1:*
         Class-aware wrapper for `::fz_new_xhtml_document_from_document()`.
        		Use text extraction to convert the input document into XHTML,
        		then open the result as a new document that can be reflowed.


        |

        *Overload 2:*
         Class-aware wrapper for `::fz_new_xhtml_document_from_document()`.
        		Use text extraction to convert the input document into XHTML,
        		then open the result as a new document that can be reflowed.
        """
        return _mupdf.FzDocument_fz_new_xhtml_document_from_document(self, *args)

    def fz_next_page(self, loc):
        r"""
        Class-aware wrapper for `::fz_next_page()`.
        	Function to get the location of the next page (allowing for the
        	end of chapters etc). If at the end of the document, returns the
        	current location.
        """
        return _mupdf.FzDocument_fz_next_page(self, loc)

    def fz_open_reflowed_document(self, opts):
        r""" Class-aware wrapper for `::fz_open_reflowed_document()`."""
        return _mupdf.FzDocument_fz_open_reflowed_document(self, opts)

    def fz_output_accelerator(self, accel):
        r"""
        Class-aware wrapper for `::fz_output_accelerator()`.
        	Output accelerator data for the document to a given output
        	stream.
        """
        return _mupdf.FzDocument_fz_output_accelerator(self, accel)

    def fz_page_number_from_location(self, loc):
        r"""
        Class-aware wrapper for `::fz_page_number_from_location()`.
        	Converts from chapter+page to page number. This may cause many
        	chapters to be laid out in order to calculate the number of
        	pages within those chapters.
        """
        return _mupdf.FzDocument_fz_page_number_from_location(self, loc)

    def fz_previous_page(self, loc):
        r"""
        Class-aware wrapper for `::fz_previous_page()`.
        	Function to get the location of the previous page (allowing for
        	the end of chapters etc). If already at the start of the
        	document, returns the current page.
        """
        return _mupdf.FzDocument_fz_previous_page(self, loc)

    def fz_process_opened_pages(self, process_openend_page, state):
        r"""
        Class-aware wrapper for `::fz_process_opened_pages()`.
        	Iterates over all opened pages of the document, calling the
        	provided callback for each page for processing. If the callback
        	returns non-NULL then the iteration stops and that value is returned
        	to the called of fz_process_opened_pages().

        	The state pointer provided to fz_process_opened_pages() is
        	passed on to the callback but is owned by the caller.

        	Returns the first non-NULL value returned by the callback,
        	or NULL if the callback returned NULL for all opened pages.
        """
        return _mupdf.FzDocument_fz_process_opened_pages(self, process_openend_page, state)

    def fz_resolve_link(self, uri, xp, yp):
        r"""
        Class-aware wrapper for `::fz_resolve_link()`.

        This method has out-params. Python/C# wrappers look like:
        	`fz_resolve_link(const char *uri)` => `(fz_location, float xp, float yp)`

        	Resolve an internal link to a page number.

        	xp, yp: Pointer to store coordinate of destination on the page.

        	Returns (-1,-1) if the URI cannot be resolved.
        """
        return _mupdf.FzDocument_fz_resolve_link(self, uri, xp, yp)

    def fz_run_document_structure(self, dev, cookie):
        r"""
        Class-aware wrapper for `::fz_run_document_structure()`.
        	Run the document structure through a device.

        	doc: Document in question.

        	dev: Device obtained from fz_new_*_device.

        	cookie: Communication mechanism between caller and library.
        	Intended for multi-threaded applications, while
        	single-threaded applications set cookie to NULL. The
        	caller may abort an ongoing rendering of a page. Cookie also
        	communicates progress information back to the caller. The
        	fields inside cookie are continually updated while the page is
        	rendering.
        """
        return _mupdf.FzDocument_fz_run_document_structure(self, dev, cookie)

    def fz_save_accelerator(self, accel):
        r"""
        Class-aware wrapper for `::fz_save_accelerator()`.
        	Save accelerator data for the document to a given file.
        """
        return _mupdf.FzDocument_fz_save_accelerator(self, accel)

    def fz_search_chapter_page_number(self, chapter, page, needle, hit_mark, hit_bbox, hit_max):
        r"""
        Class-aware wrapper for `::fz_search_chapter_page_number()`.

        This method has out-params. Python/C# wrappers look like:
        	`fz_search_chapter_page_number(int chapter, int page, const char *needle, ::fz_quad *hit_bbox, int hit_max)` => `(int, int hit_mark)`
        """
        return _mupdf.FzDocument_fz_search_chapter_page_number(self, chapter, page, needle, hit_mark, hit_bbox, hit_max)

    def fz_search_page2(self, number, needle, hit_max):
        r"""
        Class-aware wrapper for `::fz_search_page2()`.
        C++ alternative to fz_search_page() that returns information in a std::vector.
        """
        return _mupdf.FzDocument_fz_search_page2(self, number, needle, hit_max)

    def fz_search_page_number(self, number, needle, hit_mark, hit_bbox, hit_max):
        r"""
        Class-aware wrapper for `::fz_search_page_number()`.

        This method has out-params. Python/C# wrappers look like:
        	`fz_search_page_number(int number, const char *needle, ::fz_quad *hit_bbox, int hit_max)` => `(int, int hit_mark)`
        """
        return _mupdf.FzDocument_fz_search_page_number(self, number, needle, hit_mark, hit_bbox, hit_max)

    def fz_set_metadata(self, key, value):
        r""" Class-aware wrapper for `::fz_set_metadata()`."""
        return _mupdf.FzDocument_fz_set_metadata(self, key, value)

    def pdf_count_pages_imp(self, chapter):
        r""" Class-aware wrapper for `::pdf_count_pages_imp()`."""
        return _mupdf.FzDocument_pdf_count_pages_imp(self, chapter)

    def pdf_document_from_fz_document(self):
        r""" Class-aware wrapper for `::pdf_document_from_fz_document()`."""
        return _mupdf.FzDocument_pdf_document_from_fz_document(self)

    def pdf_load_page_imp(self, chapter, number):
        r""" Class-aware wrapper for `::pdf_load_page_imp()`."""
        return _mupdf.FzDocument_pdf_load_page_imp(self, chapter, number)

    def pdf_page_label_imp(self, chapter, page, buf, size):
        r""" Class-aware wrapper for `::pdf_page_label_imp()`."""
        return _mupdf.FzDocument_pdf_page_label_imp(self, chapter, page, buf, size)

    def pdf_specifics(self):
        r""" Class-aware wrapper for `::pdf_specifics()`."""
        return _mupdf.FzDocument_pdf_specifics(self)

    def __init__(self, *args):
        r"""
        *Overload 1:*
         == Constructors.  Constructor using `fz_open_accelerated_document()`.
        		Open a document file and read its basic structure so pages and
        		objects can be located. MuPDF will try to repair broken
        		documents (without actually changing the file contents).

        		The returned fz_document is used when calling most other
        		document related functions.

        		filename: a path to a file as it would be given to open(2).


        |

        *Overload 2:*
         Constructor using `fz_open_accelerated_document_with_stream()`.
        		Open a document using the specified stream object rather than
        		opening a file on disk.

        		magic: a string used to detect document type; either a file name
        		or mime-type.

        		stream: a stream of the document contents.

        		accel: NULL, or a stream of the 'accelerator' contents for this document.

        		NOTE: The caller retains ownership of 'stream' and 'accel' - the document will
        		take its own references if required.


        |

        *Overload 3:*
         Constructor using `fz_open_accelerated_document_with_stream_and_dir()`.
        		Open a document using the specified stream object rather than
        		opening a file on disk.

        		magic: a string used to detect document type; either a file name
        		or mime-type.

        		stream: a stream of the document contents.

        		accel: NULL, or a stream of the 'accelerator' contents for this document.

        		dir: NULL, or the 'directory context' for the stream contents.

        		NOTE: The caller retains ownership of 'stream', 'accel' and 'dir' - the document will
        		take its own references if required.


        |

        *Overload 4:*
         Constructor using `fz_open_document()`.
        		Open a document file and read its basic structure so pages and
        		objects can be located. MuPDF will try to repair broken
        		documents (without actually changing the file contents).

        		The returned fz_document is used when calling most other
        		document related functions.

        		filename: a path to a file as it would be given to open(2).


        |

        *Overload 5:*
         Constructor using `fz_open_document_with_buffer()`.
        		Open a document using a buffer rather than opening a file on disk.


        |

        *Overload 6:*
         Constructor using `fz_open_document_with_stream()`.
        		Open a document using the specified stream object rather than
        		opening a file on disk.

        		magic: a string used to detect document type; either a file name
        		or mime-type.

        		stream: a stream representing the contents of the document file.

        		NOTE: The caller retains ownership of 'stream' - the document will take its
        		own reference if required.


        |

        *Overload 7:*
         Constructor using `fz_open_document_with_stream_and_dir()`.
        		Open a document using the specified stream object rather than
        		opening a file on disk.

        		magic: a string used to detect document type; either a file name
        		or mime-type.

        		stream: a stream representing the contents of the document file.

        		dir: a 'directory context' for those filetypes that need it.

        		NOTE: The caller retains ownership of 'stream' and 'dir' - the document will
        		take its own references if required.


        |

        *Overload 8:*
         Returns a FzDocument for pdfdocument.m_internal.super.

        |

        *Overload 9:*
         Copy constructor using `fz_keep_document()`.

        |

        *Overload 10:*
         Constructor using raw copy of pre-existing `::fz_document`.

        |

        *Overload 11:*
         Constructor using raw copy of pre-existing `::fz_document`.
        """
        _mupdf.FzDocument_swiginit(self, _mupdf.new_FzDocument(*args))
    __swig_destroy__ = _mupdf.delete_FzDocument

    def m_internal_value(self):
        r""" Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.FzDocument_m_internal_value(self)
    m_internal = property(_mupdf.FzDocument_m_internal_get, _mupdf.FzDocument_m_internal_set, doc=r""" Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.FzDocument_s_num_instances_get, _mupdf.FzDocument_s_num_instances_set)

# Register FzDocument in _mupdf:
_mupdf.FzDocument_swigregister(FzDocument)
class FzDocumentHandler(object):
    r""" Wrapper class for struct `fz_document_handler`. Not copyable or assignable."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def fz_register_document_handler(self):
        r"""
        Class-aware wrapper for `::fz_register_document_handler()`.
        	Register a handler for a document type.

        	handler: The handler to register.
        """
        return _mupdf.FzDocumentHandler_fz_register_document_handler(self)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::fz_document_handler`.
        """
        _mupdf.FzDocumentHandler_swiginit(self, _mupdf.new_FzDocumentHandler(*args))
    __swig_destroy__ = _mupdf.delete_FzDocumentHandler

    def m_internal_value(self):
        r""" Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.FzDocumentHandler_m_internal_value(self)
    m_internal = property(_mupdf.FzDocumentHandler_m_internal_get, _mupdf.FzDocumentHandler_m_internal_set, doc=r""" Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.FzDocumentHandler_s_num_instances_get, _mupdf.FzDocumentHandler_s_num_instances_set)

# Register FzDocumentHandler in _mupdf:
_mupdf.FzDocumentHandler_swigregister(FzDocumentHandler)
class FzDocumentHandlerContext(object):
    r""" Wrapper class for struct `fz_document_handler_context`. Not copyable or assignable."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::fz_document_handler_context`.
        """
        _mupdf.FzDocumentHandlerContext_swiginit(self, _mupdf.new_FzDocumentHandlerContext(*args))
    __swig_destroy__ = _mupdf.delete_FzDocumentHandlerContext

    def m_internal_value(self):
        r""" Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.FzDocumentHandlerContext_m_internal_value(self)
    m_internal = property(_mupdf.FzDocumentHandlerContext_m_internal_get, _mupdf.FzDocumentHandlerContext_m_internal_set, doc=r""" Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.FzDocumentHandlerContext_s_num_instances_get, _mupdf.FzDocumentHandlerContext_s_num_instances_set)

# Register FzDocumentHandlerContext in _mupdf:
_mupdf.FzDocumentHandlerContext_swigregister(FzDocumentHandlerContext)
class FzDocumentWriter(object):
    r""" Wrapper class for struct `fz_document_writer`. Not copyable or assignable."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    PathType_CBZ = _mupdf.FzDocumentWriter_PathType_CBZ
    PathType_DOCX = _mupdf.FzDocumentWriter_PathType_DOCX
    PathType_ODT = _mupdf.FzDocumentWriter_PathType_ODT
    PathType_PAM_PIXMAP = _mupdf.FzDocumentWriter_PathType_PAM_PIXMAP
    PathType_PBM_PIXMAP = _mupdf.FzDocumentWriter_PathType_PBM_PIXMAP
    PathType_PCL = _mupdf.FzDocumentWriter_PathType_PCL
    PathType_PCLM = _mupdf.FzDocumentWriter_PathType_PCLM
    PathType_PDF = _mupdf.FzDocumentWriter_PathType_PDF
    PathType_PDFOCR = _mupdf.FzDocumentWriter_PathType_PDFOCR
    PathType_PGM_PIXMAP = _mupdf.FzDocumentWriter_PathType_PGM_PIXMAP
    PathType_PKM_PIXMAP = _mupdf.FzDocumentWriter_PathType_PKM_PIXMAP
    PathType_PNG_PIXMAP = _mupdf.FzDocumentWriter_PathType_PNG_PIXMAP
    PathType_PNM_PIXMAP = _mupdf.FzDocumentWriter_PathType_PNM_PIXMAP
    PathType_PPM_PIXMAP = _mupdf.FzDocumentWriter_PathType_PPM_PIXMAP
    PathType_PS = _mupdf.FzDocumentWriter_PathType_PS
    PathType_PWG = _mupdf.FzDocumentWriter_PathType_PWG
    PathType_SVG = _mupdf.FzDocumentWriter_PathType_SVG
    OutputType_CBZ = _mupdf.FzDocumentWriter_OutputType_CBZ
    OutputType_DOCX = _mupdf.FzDocumentWriter_OutputType_DOCX
    OutputType_ODT = _mupdf.FzDocumentWriter_OutputType_ODT
    OutputType_PCL = _mupdf.FzDocumentWriter_OutputType_PCL
    OutputType_PCLM = _mupdf.FzDocumentWriter_OutputType_PCLM
    OutputType_PDF = _mupdf.FzDocumentWriter_OutputType_PDF
    OutputType_PDFOCR = _mupdf.FzDocumentWriter_OutputType_PDFOCR
    OutputType_PS = _mupdf.FzDocumentWriter_OutputType_PS
    OutputType_PWG = _mupdf.FzDocumentWriter_OutputType_PWG
    FormatPathType_DOCUMENT = _mupdf.FzDocumentWriter_FormatPathType_DOCUMENT
    FormatPathType_TEXT = _mupdf.FzDocumentWriter_FormatPathType_TEXT

    def fz_begin_page(self, mediabox):
        r"""
        Class-aware wrapper for `::fz_begin_page()`.
        	Called to start the process of writing a page to
        	a document.

        	mediabox: page size rectangle in points.

        	Returns a borrowed fz_device to write page contents to. This
        	should be kept if required, and only dropped if it was kept.
        """
        return _mupdf.FzDocumentWriter_fz_begin_page(self, mediabox)

    def fz_close_document_writer(self):
        r"""
        Class-aware wrapper for `::fz_close_document_writer()`.
        	Called to end the process of writing
        	pages to a document.

        	This writes any file level trailers required. After this
        	completes successfully the file is up to date and complete.
        """
        return _mupdf.FzDocumentWriter_fz_close_document_writer(self)

    def fz_end_page(self):
        r"""
        Class-aware wrapper for `::fz_end_page()`.
        	Called to end the process of writing a page to a
        	document.
        """
        return _mupdf.FzDocumentWriter_fz_end_page(self)

    def fz_pdfocr_writer_set_progress(self, progress, arg_2):
        r""" Class-aware wrapper for `::fz_pdfocr_writer_set_progress()`."""
        return _mupdf.FzDocumentWriter_fz_pdfocr_writer_set_progress(self, progress, arg_2)

    def fz_write_document(self, doc):
        r"""
        Class-aware wrapper for `::fz_write_document()`.
        	Convenience function to feed all the pages of a document to
        	fz_begin_page/fz_run_page/fz_end_page.
        """
        return _mupdf.FzDocumentWriter_fz_write_document(self, doc)

    def fz_write_stabilized_story(self, user_css, em, contentfn, contentfn_ref, rectfn, rectfn_ref, pagefn, pagefn_ref, dir):
        r""" Class-aware wrapper for `::fz_write_stabilized_story()`."""
        return _mupdf.FzDocumentWriter_fz_write_stabilized_story(self, user_css, em, contentfn, contentfn_ref, rectfn, rectfn_ref, pagefn, pagefn_ref, dir)

    def fz_write_story(self, story, rectfn, rectfn_ref, positionfn, positionfn_ref, pagefn, pagefn_ref):
        r""" Class-aware wrapper for `::fz_write_story()`."""
        return _mupdf.FzDocumentWriter_fz_write_story(self, story, rectfn, rectfn_ref, positionfn, positionfn_ref, pagefn, pagefn_ref)

    def __init__(self, *args):
        r"""
        *Overload 1:*
         == Constructors.  Constructor using `fz_new_document_writer_of_size()`.
        		Internal function to allocate a
        		block for a derived document_writer structure, with the base
        		structure's function pointers populated correctly, and the extra
        		space zero initialised.


        |

        *Overload 2:*
         Constructor using `fz_new_document_writer_with_buffer()`.

        |

        *Overload 3:*
         Constructor using `fz_new_jpeg_pixmap_writer()`.

        |

        *Overload 4:*
         Constructor using `fz_new_pixmap_writer()`.

        |

        *Overload 5:*
         Constructor using one of:
        		fz_new_cbz_writer()
        		fz_new_docx_writer()
        		fz_new_odt_writer()
        		fz_new_pam_pixmap_writer()
        		fz_new_pbm_pixmap_writer()
        		fz_new_pcl_writer()
        		fz_new_pclm_writer()
        		fz_new_pdf_writer()
        		fz_new_pdfocr_writer()
        		fz_new_pgm_pixmap_writer()
        		fz_new_pkm_pixmap_writer()
        		fz_new_png_pixmap_writer()
        		fz_new_pnm_pixmap_writer()
        		fz_new_ppm_pixmap_writer()
        		fz_new_ps_writer()
        		fz_new_pwg_writer()
        		fz_new_svg_writer()


        |

        *Overload 6:*
         Constructor using one of:
        		fz_new_cbz_writer_with_output()
        		fz_new_docx_writer_with_output()
        		fz_new_odt_writer_with_output()
        		fz_new_pcl_writer_with_output()
        		fz_new_pclm_writer_with_output()
        		fz_new_pdf_writer_with_output()
        		fz_new_pdfocr_writer_with_output()
        		fz_new_ps_writer_with_output()
        		fz_new_pwg_writer_with_output()

        	This constructor takes ownership of <out> -
        	out.m_internal is set to NULL after this constructor
        	returns so <out> must not be used again.


        |

        *Overload 7:*
         Constructor using one of:
        		fz_new_document_writer()
        		fz_new_text_writer()


        |

        *Overload 8:*
         Constructor using fz_new_document_writer_with_output().

        	This constructor takes ownership of <out> -
        	out.m_internal is set to NULL after this constructor
        	returns so <out> must not be used again.


        |

        *Overload 9:*
         Constructor using fz_new_text_writer_with_output().

        	This constructor takes ownership of <out> -
        	out.m_internal is set to NULL after this constructor
        	returns so <out> must not be used again.


        |

        *Overload 10:*
         Default constructor, sets `m_internal` to null.

        |

        *Overload 11:*
         Constructor using raw copy of pre-existing `::fz_document_writer`.
        """
        _mupdf.FzDocumentWriter_swiginit(self, _mupdf.new_FzDocumentWriter(*args))
    __swig_destroy__ = _mupdf.delete_FzDocumentWriter

    def m_internal_value(self):
        r""" Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.FzDocumentWriter_m_internal_value(self)
    m_internal = property(_mupdf.FzDocumentWriter_m_internal_get, _mupdf.FzDocumentWriter_m_internal_set, doc=r""" Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.FzDocumentWriter_s_num_instances_get, _mupdf.FzDocumentWriter_s_num_instances_set)

# Register FzDocumentWriter in _mupdf:
_mupdf.FzDocumentWriter_swigregister(FzDocumentWriter)
class FzDrawOptions(object):
    r"""
    Wrapper class for struct `fz_draw_options`. Not copyable or assignable.
    struct fz_draw_options: Options for creating a pixmap and draw
    device.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
         == Constructors.  Constructor using `fz_parse_draw_options()`.
        		Parse draw device options from a comma separated key-value string.


        |

        *Overload 2:*
         Default constructor, sets each member to default value.

        |

        *Overload 3:*
         Constructor using raw copy of pre-existing `::fz_draw_options`.

        |

        *Overload 4:*
         Constructor using raw copy of pre-existing `::fz_draw_options`.
        """
        _mupdf.FzDrawOptions_swiginit(self, _mupdf.new_FzDrawOptions(*args))

    def internal(self, *args):
        r"""
        *Overload 1:*
        Access as underlying struct.

        |

        *Overload 2:*
        Access as underlying struct.
        """
        return _mupdf.FzDrawOptions_internal(self, *args)
    __swig_destroy__ = _mupdf.delete_FzDrawOptions
    rotate = property(_mupdf.FzDrawOptions_rotate_get, _mupdf.FzDrawOptions_rotate_set)
    x_resolution = property(_mupdf.FzDrawOptions_x_resolution_get, _mupdf.FzDrawOptions_x_resolution_set)
    y_resolution = property(_mupdf.FzDrawOptions_y_resolution_get, _mupdf.FzDrawOptions_y_resolution_set)
    width = property(_mupdf.FzDrawOptions_width_get, _mupdf.FzDrawOptions_width_set)
    height = property(_mupdf.FzDrawOptions_height_get, _mupdf.FzDrawOptions_height_set)
    colorspace = property(_mupdf.FzDrawOptions_colorspace_get, _mupdf.FzDrawOptions_colorspace_set)
    alpha = property(_mupdf.FzDrawOptions_alpha_get, _mupdf.FzDrawOptions_alpha_set)
    graphics = property(_mupdf.FzDrawOptions_graphics_get, _mupdf.FzDrawOptions_graphics_set)
    text = property(_mupdf.FzDrawOptions_text_get, _mupdf.FzDrawOptions_text_set)
    s_num_instances = property(_mupdf.FzDrawOptions_s_num_instances_get, _mupdf.FzDrawOptions_s_num_instances_set)

    def to_string(self):
        r""" Returns string containing our members, labelled and inside (...), using operator<<."""
        return _mupdf.FzDrawOptions_to_string(self)

    def __eq__(self, rhs):
        r""" Comparison method."""
        return _mupdf.FzDrawOptions___eq__(self, rhs)

    def __ne__(self, rhs):
        r""" Comparison method."""
        return _mupdf.FzDrawOptions___ne__(self, rhs)

# Register FzDrawOptions in _mupdf:
_mupdf.FzDrawOptions_swigregister(FzDrawOptions)
class FzErrorContext(object):
    r""" Wrapper class for struct `fz_error_context`. Not copyable or assignable."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::fz_error_context`.
        """
        _mupdf.FzErrorContext_swiginit(self, _mupdf.new_FzErrorContext(*args))
    __swig_destroy__ = _mupdf.delete_FzErrorContext

    def m_internal_value(self):
        r""" Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.FzErrorContext_m_internal_value(self)
    m_internal = property(_mupdf.FzErrorContext_m_internal_get, _mupdf.FzErrorContext_m_internal_set, doc=r""" Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.FzErrorContext_s_num_instances_get, _mupdf.FzErrorContext_s_num_instances_set)

# Register FzErrorContext in _mupdf:
_mupdf.FzErrorContext_swigregister(FzErrorContext)
class FzErrorStackSlot(object):
    r""" Wrapper class for struct `fz_error_stack_slot`. Not copyable or assignable."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::fz_error_stack_slot`.
        """
        _mupdf.FzErrorStackSlot_swiginit(self, _mupdf.new_FzErrorStackSlot(*args))
    __swig_destroy__ = _mupdf.delete_FzErrorStackSlot

    def m_internal_value(self):
        r""" Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.FzErrorStackSlot_m_internal_value(self)
    m_internal = property(_mupdf.FzErrorStackSlot_m_internal_get, _mupdf.FzErrorStackSlot_m_internal_set, doc=r""" Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.FzErrorStackSlot_s_num_instances_get, _mupdf.FzErrorStackSlot_s_num_instances_set)

# Register FzErrorStackSlot in _mupdf:
_mupdf.FzErrorStackSlot_swigregister(FzErrorStackSlot)
class FzFont(object):
    r"""
    Wrapper class for struct `fz_font`.
    An abstract font handle.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def fz_advance_glyph(self, glyph, wmode):
        r"""
        Class-aware wrapper for `::fz_advance_glyph()`.
        	Return the advance for a given glyph.

        	font: The font to look for the glyph in.

        	glyph: The glyph to find the advance for.

        	wmode: 1 for vertical mode, 0 for horizontal.

        	Returns the advance for the glyph.
        """
        return _mupdf.FzFont_fz_advance_glyph(self, glyph, wmode)

    def fz_bound_glyph(self, gid, trm):
        r"""
        Class-aware wrapper for `::fz_bound_glyph()`.
        	Return a bbox for a given glyph in a font.

        	font: The font to look for the glyph in.

        	gid: The glyph to bound.

        	trm: The matrix to apply to the glyph before bounding.

        	Returns rectangle by value containing the bounds of the given
        	glyph.
        """
        return _mupdf.FzFont_fz_bound_glyph(self, gid, trm)

    def fz_decouple_type3_font(self, t3doc):
        r""" Class-aware wrapper for `::fz_decouple_type3_font()`."""
        return _mupdf.FzFont_fz_decouple_type3_font(self, t3doc)

    def fz_encode_character(self, unicode):
        r"""
        Class-aware wrapper for `::fz_encode_character()`.
        	Find the glyph id for a given unicode
        	character within a font.

        	font: The font to look for the unicode character in.

        	unicode: The unicode character to encode.

        	Returns the glyph id for the given unicode value, or 0 if
        	unknown.
        """
        return _mupdf.FzFont_fz_encode_character(self, unicode)

    def fz_encode_character_by_glyph_name(self, glyphname):
        r"""
        Class-aware wrapper for `::fz_encode_character_by_glyph_name()`.
        	Encode character.

        	Either by direct lookup of glyphname within a font, or, failing
        	that, by mapping glyphname to unicode and thence to the glyph
        	index within the given font.

        	Returns zero for type3 fonts.
        """
        return _mupdf.FzFont_fz_encode_character_by_glyph_name(self, glyphname)

    def fz_encode_character_sc(self, unicode):
        r"""
        Class-aware wrapper for `::fz_encode_character_sc()`.
        	Encode character, preferring small-caps variant if available.

        	font: The font to look for the unicode character in.

        	unicode: The unicode character to encode.

        	Returns the glyph id for the given unicode value, or 0 if
        	unknown.
        """
        return _mupdf.FzFont_fz_encode_character_sc(self, unicode)

    def fz_encode_character_with_fallback(self, unicode, script, language, out_font):
        r"""
        Class-aware wrapper for `::fz_encode_character_with_fallback()`.

        This method has out-params. Python/C# wrappers look like:
        	`fz_encode_character_with_fallback(int unicode, int script, int language, ::fz_font **out_font)` => `(int)`

        	Find the glyph id for
        	a given unicode character within a font, falling back to
        	an alternative if not found.

        	font: The font to look for the unicode character in.

        	unicode: The unicode character to encode.

        	script: The script in use.

        	language: The language in use.

        	out_font: The font handle in which the given glyph represents
        	the requested unicode character. The caller does not own the
        	reference it is passed, so should call fz_keep_font if it is
        	not simply to be used immediately.

        	Returns the glyph id for the given unicode value in the supplied
        	font (and sets *out_font to font) if it is present. Otherwise
        	an alternative fallback font (based on script/language) is
        	searched for. If the glyph is found therein, *out_font is set
        	to this reference, and the glyph reference is returned. If it
        	cannot be found anywhere, the function returns 0.
        """
        return _mupdf.FzFont_fz_encode_character_with_fallback(self, unicode, script, language, out_font)

    def fz_extract_ttf_from_ttc(self):
        r""" Class-aware wrapper for `::fz_extract_ttf_from_ttc()`."""
        return _mupdf.FzFont_fz_extract_ttf_from_ttc(self)

    def fz_font_ascender(self):
        r"""
        Class-aware wrapper for `::fz_font_ascender()`.
        	Retrieve font ascender in ems.
        """
        return _mupdf.FzFont_fz_font_ascender(self)

    def fz_font_bbox(self):
        r"""
        Class-aware wrapper for `::fz_font_bbox()`.
        	Retrieve the font bbox.

        	font: The font to query.

        	Returns the font bbox by value; it is valid only if
        	fz_font_flags(font)->invalid_bbox is zero.
        """
        return _mupdf.FzFont_fz_font_bbox(self)

    def fz_font_descender(self):
        r"""
        Class-aware wrapper for `::fz_font_descender()`.
        	Retrieve font descender in ems.
        """
        return _mupdf.FzFont_fz_font_descender(self)

    def fz_font_digest(self, digest):
        r"""
        Class-aware wrapper for `::fz_font_digest()`.
        	Retrieve the MD5 digest for the font's data.
        """
        return _mupdf.FzFont_fz_font_digest(self, digest)

    def fz_font_ft_face(self):
        r"""
        Class-aware wrapper for `::fz_font_ft_face()`.
        	Retrieve the FT_Face handle
        	for the font.

        	font: The font to query

        	Returns the FT_Face handle for the font, or NULL
        	if not a freetype handled font. (Cast to void *
        	to avoid nasty header exposure).
        """
        return _mupdf.FzFont_fz_font_ft_face(self)

    def fz_font_is_bold(self):
        r"""
        Class-aware wrapper for `::fz_font_is_bold()`.
        	Query whether the font flags say that this font is bold.
        """
        return _mupdf.FzFont_fz_font_is_bold(self)

    def fz_font_is_italic(self):
        r"""
        Class-aware wrapper for `::fz_font_is_italic()`.
        	Query whether the font flags say that this font is italic.
        """
        return _mupdf.FzFont_fz_font_is_italic(self)

    def fz_font_is_monospaced(self):
        r"""
        Class-aware wrapper for `::fz_font_is_monospaced()`.
        	Query whether the font flags say that this font is monospaced.
        """
        return _mupdf.FzFont_fz_font_is_monospaced(self)

    def fz_font_is_serif(self):
        r"""
        Class-aware wrapper for `::fz_font_is_serif()`.
        	Query whether the font flags say that this font is serif.
        """
        return _mupdf.FzFont_fz_font_is_serif(self)

    def fz_font_name(self):
        r"""
        Class-aware wrapper for `::fz_font_name()`.
        	Retrieve a pointer to the name of the font.

        	font: The font to query.

        	Returns a pointer to an internal copy of the font name.
        	Will never be NULL, but may be the empty string.
        """
        return _mupdf.FzFont_fz_font_name(self)

    def fz_font_t3_procs(self):
        r"""
        Class-aware wrapper for `::fz_font_t3_procs()`.
        	Retrieve the Type3 procs
        	for a font.

        	font: The font to query

        	Returns the t3_procs pointer. Will be NULL for a
        	non type-3 font.
        """
        return _mupdf.FzFont_fz_font_t3_procs(self)

    def fz_get_glyph_name(self, glyph, buf, size):
        r"""
        Class-aware wrapper for `::fz_get_glyph_name()`.
        	Find the name of a glyph

        	font: The font to look for the glyph in.

        	glyph: The glyph id to look for.

        	buf: Pointer to a buffer for the name to be inserted into.

        	size: The size of the buffer.

        	If a font contains a name table, then the name of the glyph
        	will be returned in the supplied buffer. Otherwise a name
        	is synthesised. The name will be truncated to fit in
        	the buffer.
        """
        return _mupdf.FzFont_fz_get_glyph_name(self, glyph, buf, size)

    def fz_get_glyph_name2(self, glyph):
        r"""
        Class-aware wrapper for `::fz_get_glyph_name2()`.
        C++ alternative to fz_get_glyph_name() that returns information in a std::string.
        """
        return _mupdf.FzFont_fz_get_glyph_name2(self, glyph)

    def fz_glyph_cacheable(self, gid):
        r"""
        Class-aware wrapper for `::fz_glyph_cacheable()`.
        	Determine if a given glyph in a font
        	is cacheable. Certain glyphs in a type 3 font cannot safely
        	be cached, as their appearance depends on the enclosing
        	graphic state.

        	font: The font to look for the glyph in.

        	gif: The glyph to query.

        	Returns non-zero if cacheable, 0 if not.
        """
        return _mupdf.FzFont_fz_glyph_cacheable(self, gid)

    def fz_measure_string(self, trm, s, wmode, bidi_level, markup_dir, language):
        r"""
        Class-aware wrapper for `::fz_measure_string()`.
        	Measure the advance width of a UTF8 string should it be added to a text object.

        	This uses the same layout algorithms as fz_show_string, and can be used
        	to calculate text alignment adjustments.
        """
        return _mupdf.FzFont_fz_measure_string(self, trm, s, wmode, bidi_level, markup_dir, language)

    def fz_outline_glyph(self, gid, ctm):
        r"""
        Class-aware wrapper for `::fz_outline_glyph()`.
        	Look a glyph up from a font, and return the outline of the
        	glyph using the given transform.

        	The caller owns the returned path, and so is responsible for
        	ensuring that it eventually gets dropped.
        """
        return _mupdf.FzFont_fz_outline_glyph(self, gid, ctm)

    def fz_prepare_t3_glyph(self, gid):
        r"""
        Class-aware wrapper for `::fz_prepare_t3_glyph()`.
        	Force a type3 font to cache the displaylist for a given glyph
        	id.

        	This caching can involve reading the underlying file, so must
        	happen ahead of time, so we aren't suddenly forced to read the
        	file while playing a displaylist back.
        """
        return _mupdf.FzFont_fz_prepare_t3_glyph(self, gid)

    def fz_render_glyph_pixmap(self, gid, ctm, scissor, aa):
        r"""
        Class-aware wrapper for `::fz_render_glyph_pixmap()`.
        	Create a pixmap containing a rendered glyph.

        	Lookup gid from font, clip it with scissor, and rendering it
        	with aa bits of antialiasing into a new pixmap.

        	The caller takes ownership of the pixmap and so must free it.

        	Note: This function is no longer used for normal rendering
        	operations, and is kept around just because we use it in the
        	app. It should be considered "at risk" of removal from the API.
        """
        return _mupdf.FzFont_fz_render_glyph_pixmap(self, gid, ctm, scissor, aa)

    def fz_run_t3_glyph(self, gid, trm, dev):
        r"""
        Class-aware wrapper for `::fz_run_t3_glyph()`.
        	Run a glyph from a Type3 font to
        	a given device.

        	font: The font to find the glyph in.

        	gid: The glyph to run.

        	trm: The transform to apply.

        	dev: The device to render onto.
        """
        return _mupdf.FzFont_fz_run_t3_glyph(self, gid, trm, dev)

    def fz_set_font_bbox(self, xmin, ymin, xmax, ymax):
        r"""
        Class-aware wrapper for `::fz_set_font_bbox()`.
        	Set the font bbox.

        	font: The font to set the bbox for.

        	xmin, ymin, xmax, ymax: The bounding box.
        """
        return _mupdf.FzFont_fz_set_font_bbox(self, xmin, ymin, xmax, ymax)

    def fz_set_font_embedding(self, embed):
        r"""
        Class-aware wrapper for `::fz_set_font_embedding()`.
        	Control whether a given font should be embedded or not when writing.
        """
        return _mupdf.FzFont_fz_set_font_embedding(self, embed)

    def pdf_font_writing_supported(self):
        r""" Class-aware wrapper for `::pdf_font_writing_supported()`."""
        return _mupdf.FzFont_pdf_font_writing_supported(self)

    def pdf_layout_fit_text(self, lang, str, bounds):
        r""" Class-aware wrapper for `::pdf_layout_fit_text()`."""
        return _mupdf.FzFont_pdf_layout_fit_text(self, lang, str, bounds)

    def __init__(self, *args):
        r"""
        *Overload 1:*
         == Constructors.  Constructor using `fz_new_base14_font()`.
        		Create a new font from one of the built-in fonts.


        |

        *Overload 2:*
         Constructor using `fz_new_builtin_font()`.

        |

        *Overload 3:*
         Constructor using `fz_new_cjk_font()`.

        |

        *Overload 4:*
         Constructor using `fz_new_font_from_buffer()`.
        		Create a new font from a font file in a fz_buffer.

        		Fonts created in this way, will be eligible for embedding by default.

        		name: Name of font (leave NULL to use name from font).

        		buffer: Buffer to load from.

        		index: Which font from the file to load (0 for default).

        		use_glyph_box: 1 if we should use the glyph bbox, 0 otherwise.

        		Returns new font handle, or throws exception on error.


        |

        *Overload 5:*
         Constructor using `fz_new_font_from_file()`.
        		Create a new font from a font file.

        		Fonts created in this way, will be eligible for embedding by default.

        		name: Name of font (leave NULL to use name from font).

        		path: File path to load from.

        		index: Which font from the file to load (0 for default).

        		use_glyph_box: 1 if we should use the glyph bbox, 0 otherwise.

        		Returns new font handle, or throws exception on error.


        |

        *Overload 6:*
         Constructor using `fz_new_font_from_memory()`.
        		Create a new font from a font file in memory.

        		Fonts created in this way, will be eligible for embedding by default.

        		name: Name of font (leave NULL to use name from font).

        		data: Pointer to the font file data.

        		len: Length of the font file data.

        		index: Which font from the file to load (0 for default).

        		use_glyph_box: 1 if we should use the glyph bbox, 0 otherwise.

        		Returns new font handle, or throws exception on error.


        |

        *Overload 7:*
         Constructor using `fz_new_type3_font()`.
        		Create a new (empty) type3 font.

        		name: Name of font (or NULL).

        		matrix: Font matrix.

        		Returns a new font handle, or throws exception on
        		allocation failure.


        |

        *Overload 8:*
         Copy constructor using `fz_keep_font()`.

        |

        *Overload 9:*
         Default constructor, sets `m_internal` to null.

        |

        *Overload 10:*
         Constructor using raw copy of pre-existing `::fz_font`.
        """
        _mupdf.FzFont_swiginit(self, _mupdf.new_FzFont(*args))
    __swig_destroy__ = _mupdf.delete_FzFont

    def m_internal_value(self):
        r""" Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.FzFont_m_internal_value(self)
    m_internal = property(_mupdf.FzFont_m_internal_get, _mupdf.FzFont_m_internal_set, doc=r""" Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.FzFont_s_num_instances_get, _mupdf.FzFont_s_num_instances_set)

# Register FzFont in _mupdf:
_mupdf.FzFont_swigregister(FzFont)
class FzFontContext(object):
    r""" Wrapper class for struct `fz_font_context`. Not copyable or assignable."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::fz_font_context`.
        """
        _mupdf.FzFontContext_swiginit(self, _mupdf.new_FzFontContext(*args))
    __swig_destroy__ = _mupdf.delete_FzFontContext

    def m_internal_value(self):
        r""" Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.FzFontContext_m_internal_value(self)
    m_internal = property(_mupdf.FzFontContext_m_internal_get, _mupdf.FzFontContext_m_internal_set, doc=r""" Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.FzFontContext_s_num_instances_get, _mupdf.FzFontContext_s_num_instances_set)

# Register FzFontContext in _mupdf:
_mupdf.FzFontContext_swigregister(FzFontContext)
class FzFontFlagsT(object):
    r"""
    Wrapper class for struct `fz_font_flags_t`. Not copyable or assignable.
    Every fz_font carries a set of flags
    within it, in a fz_font_flags_t structure.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::fz_font_flags_t`.
        """
        _mupdf.FzFontFlagsT_swiginit(self, _mupdf.new_FzFontFlagsT(*args))
    __swig_destroy__ = _mupdf.delete_FzFontFlagsT

    def m_internal_value(self):
        r""" Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.FzFontFlagsT_m_internal_value(self)
    m_internal = property(_mupdf.FzFontFlagsT_m_internal_get, _mupdf.FzFontFlagsT_m_internal_set, doc=r""" Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.FzFontFlagsT_s_num_instances_get, _mupdf.FzFontFlagsT_s_num_instances_set)

# Register FzFontFlagsT in _mupdf:
_mupdf.FzFontFlagsT_swigregister(FzFontFlagsT)
class FzFunction(object):
    r""" Wrapper class for struct `fz_function`."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def fz_eval_function(self, _in, inlen, out, outlen):
        r"""
        Class-aware wrapper for `::fz_eval_function()`.

        This method has out-params. Python/C# wrappers look like:
        	`fz_eval_function(const float *in, int inlen, int outlen)` => float out
        """
        return _mupdf.FzFunction_fz_eval_function(self, _in, inlen, out, outlen)

    def fz_function_size(self):
        r""" Class-aware wrapper for `::fz_function_size()`."""
        return _mupdf.FzFunction_fz_function_size(self)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        == Constructors.  Constructor using `fz_new_function_of_size()`.

        |

        *Overload 2:*
        Copy constructor using `fz_keep_function()`.

        |

        *Overload 3:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 4:*
        Constructor using raw copy of pre-existing `::fz_function`.
        """
        _mupdf.FzFunction_swiginit(self, _mupdf.new_FzFunction(*args))
    __swig_destroy__ = _mupdf.delete_FzFunction

    def m_internal_value(self):
        r""" Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.FzFunction_m_internal_value(self)
    m_internal = property(_mupdf.FzFunction_m_internal_get, _mupdf.FzFunction_m_internal_set, doc=r""" Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.FzFunction_s_num_instances_get, _mupdf.FzFunction_s_num_instances_set)

# Register FzFunction in _mupdf:
_mupdf.FzFunction_swigregister(FzFunction)
class FzGetoptLongOptions(object):
    r""" Wrapper class for struct `fz_getopt_long_options`. Not copyable or assignable."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::fz_getopt_long_options`.
        """
        _mupdf.FzGetoptLongOptions_swiginit(self, _mupdf.new_FzGetoptLongOptions(*args))
    __swig_destroy__ = _mupdf.delete_FzGetoptLongOptions

    def m_internal_value(self):
        r""" Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.FzGetoptLongOptions_m_internal_value(self)
    m_internal = property(_mupdf.FzGetoptLongOptions_m_internal_get, _mupdf.FzGetoptLongOptions_m_internal_set, doc=r""" Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.FzGetoptLongOptions_s_num_instances_get, _mupdf.FzGetoptLongOptions_s_num_instances_set)

# Register FzGetoptLongOptions in _mupdf:
_mupdf.FzGetoptLongOptions_swigregister(FzGetoptLongOptions)
class FzGlyph(object):
    r"""
    Wrapper class for struct `fz_glyph`.
    Glyphs represent a run length encoded set of pixels for a 2
    dimensional region of a plane.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def fz_glyph_bbox(self):
        r"""
        Class-aware wrapper for `::fz_glyph_bbox()`.
        	Return the bounding box of the glyph in pixels.
        """
        return _mupdf.FzGlyph_fz_glyph_bbox(self)

    def fz_glyph_bbox_no_ctx(self):
        r""" Class-aware wrapper for `::fz_glyph_bbox_no_ctx()`."""
        return _mupdf.FzGlyph_fz_glyph_bbox_no_ctx(self)

    def fz_glyph_height(self):
        r"""
        Class-aware wrapper for `::fz_glyph_height()`.
        	Return the height of the glyph in pixels.
        """
        return _mupdf.FzGlyph_fz_glyph_height(self)

    def fz_glyph_width(self):
        r"""
        Class-aware wrapper for `::fz_glyph_width()`.
        	Return the width of the glyph in pixels.
        """
        return _mupdf.FzGlyph_fz_glyph_width(self)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Copy constructor using `fz_keep_glyph()`.

        |

        *Overload 2:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 3:*
        Constructor using raw copy of pre-existing `::fz_glyph`.
        """
        _mupdf.FzGlyph_swiginit(self, _mupdf.new_FzGlyph(*args))
    __swig_destroy__ = _mupdf.delete_FzGlyph

    def m_internal_value(self):
        r""" Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.FzGlyph_m_internal_value(self)
    m_internal = property(_mupdf.FzGlyph_m_internal_get, _mupdf.FzGlyph_m_internal_set, doc=r""" Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.FzGlyph_s_num_instances_get, _mupdf.FzGlyph_s_num_instances_set)

# Register FzGlyph in _mupdf:
_mupdf.FzGlyph_swigregister(FzGlyph)
class FzGlyphCache(object):
    r""" Wrapper class for struct `fz_glyph_cache`. Not copyable or assignable."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::fz_glyph_cache`.
        """
        _mupdf.FzGlyphCache_swiginit(self, _mupdf.new_FzGlyphCache(*args))
    __swig_destroy__ = _mupdf.delete_FzGlyphCache

    def m_internal_value(self):
        r""" Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.FzGlyphCache_m_internal_value(self)
    m_internal = property(_mupdf.FzGlyphCache_m_internal_get, _mupdf.FzGlyphCache_m_internal_set, doc=r""" Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.FzGlyphCache_s_num_instances_get, _mupdf.FzGlyphCache_s_num_instances_set)

# Register FzGlyphCache in _mupdf:
_mupdf.FzGlyphCache_swigregister(FzGlyphCache)
class FzHalftone(object):
    r"""
    Wrapper class for struct `fz_halftone`.
    A halftone is a set of threshold tiles, one per component. Each
    threshold tile is a pixmap, possibly of varying sizes and
    phases. Currently, we only provide one 'default' halftone tile
    for operating on 1 component plus alpha pixmaps (where the alpha
    is ignored). This is signified by a fz_halftone pointer to NULL.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Copy constructor using `fz_keep_halftone()`.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::fz_halftone`.

        |

        *Overload 3:*
        Constructor using raw copy of pre-existing `::fz_halftone`.
        """
        _mupdf.FzHalftone_swiginit(self, _mupdf.new_FzHalftone(*args))
    __swig_destroy__ = _mupdf.delete_FzHalftone

    def m_internal_value(self):
        r""" Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.FzHalftone_m_internal_value(self)
    m_internal = property(_mupdf.FzHalftone_m_internal_get, _mupdf.FzHalftone_m_internal_set, doc=r""" Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.FzHalftone_s_num_instances_get, _mupdf.FzHalftone_s_num_instances_set)

# Register FzHalftone in _mupdf:
_mupdf.FzHalftone_swigregister(FzHalftone)
class FzHashTable(object):
    r"""
    Wrapper class for struct `fz_hash_table`. Not copyable or assignable.
    Generic hash-table with fixed-length keys.

    The keys and values are NOT reference counted by the hash table.
    Callers are responsible for taking care the reference counts are
    correct. Inserting a duplicate entry will NOT overwrite the old
    value, and will return the old value.

    The drop_val callback function is only used to release values
    when the hash table is destroyed.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def fz_hash_filter(self, state, callback):
        r"""
        Class-aware wrapper for `::fz_hash_filter()`.
        	Iterate over the entries in a hash table, removing all the ones where callback returns true.
        	Does NOT free the value of the entry, so the caller is expected to take care of this.
        """
        return _mupdf.FzHashTable_fz_hash_filter(self, state, callback)

    def fz_hash_find(self, key):
        r"""
        Class-aware wrapper for `::fz_hash_find()`.
        	Search for a matching hash within the table, and return the
        	associated value.
        """
        return _mupdf.FzHashTable_fz_hash_find(self, key)

    def fz_hash_for_each(self, state, callback):
        r"""
        Class-aware wrapper for `::fz_hash_for_each()`.
        	Iterate over the entries in a hash table.
        """
        return _mupdf.FzHashTable_fz_hash_for_each(self, state, callback)

    def fz_hash_insert(self, key, val):
        r"""
        Class-aware wrapper for `::fz_hash_insert()`.
        	Insert a new key/value pair into the hash table.

        	If an existing entry with the same key is found, no change is
        	made to the hash table, and a pointer to the existing value is
        	returned.

        	If no existing entry with the same key is found, ownership of
        	val passes in, key is copied, and NULL is returned.
        """
        return _mupdf.FzHashTable_fz_hash_insert(self, key, val)

    def fz_hash_remove(self, key):
        r"""
        Class-aware wrapper for `::fz_hash_remove()`.
        	Remove the entry for a given key.

        	The value is NOT freed, so the caller is expected to take care
        	of this.
        """
        return _mupdf.FzHashTable_fz_hash_remove(self, key)

    def __init__(self, *args):
        r"""
        *Overload 1:*
         == Constructors.  Constructor using `fz_new_hash_table()`.
        		Create a new hash table.

        		initialsize: The initial size of the hashtable. The hashtable
        		may grow (double in size) if it starts to get crowded (80%
        		full).

        		keylen: byte length for each key.

        		lock: -1 for no lock, otherwise the FZ_LOCK to use to protect
        		this table.

        		drop_val: Function to use to destroy values on table drop.


        |

        *Overload 2:*
         Default constructor, sets `m_internal` to null.

        |

        *Overload 3:*
         Constructor using raw copy of pre-existing `::fz_hash_table`.
        """
        _mupdf.FzHashTable_swiginit(self, _mupdf.new_FzHashTable(*args))
    __swig_destroy__ = _mupdf.delete_FzHashTable

    def m_internal_value(self):
        r""" Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.FzHashTable_m_internal_value(self)
    m_internal = property(_mupdf.FzHashTable_m_internal_get, _mupdf.FzHashTable_m_internal_set, doc=r""" Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.FzHashTable_s_num_instances_get, _mupdf.FzHashTable_s_num_instances_set)

# Register FzHashTable in _mupdf:
_mupdf.FzHashTable_swigregister(FzHashTable)
class FzIccProfile(object):
    r"""
    Wrapper class for struct `fz_icc_profile`. Not copyable or assignable.
    Opaque type for an ICC Profile.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::fz_icc_profile`.
        """
        _mupdf.FzIccProfile_swiginit(self, _mupdf.new_FzIccProfile(*args))
    __swig_destroy__ = _mupdf.delete_FzIccProfile

    def m_internal_value(self):
        r""" Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.FzIccProfile_m_internal_value(self)
    m_internal = property(_mupdf.FzIccProfile_m_internal_get, _mupdf.FzIccProfile_m_internal_set, doc=r""" Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.FzIccProfile_s_num_instances_get, _mupdf.FzIccProfile_s_num_instances_set)

# Register FzIccProfile in _mupdf:
_mupdf.FzIccProfile_swigregister(FzIccProfile)
class FzImage(object):
    r"""
    Wrapper class for struct `fz_image`.
    Images are storable objects from which we can obtain fz_pixmaps.
    These may be implemented as simple wrappers around a pixmap, or
    as more complex things that decode at different subsample
    settings on demand.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def fz_compressed_image_buffer(self):
        r"""
        Class-aware wrapper for `::fz_compressed_image_buffer()`.
        	Retrieve the underlying compressed data for an image.

        	Returns a pointer to the underlying data buffer for an image,
        	or NULL if this image is not based upon a compressed data
        	buffer.

        	This is not a reference counted structure, so no reference is
        	returned. Lifespan is limited to that of the image itself.
        """
        return _mupdf.FzImage_fz_compressed_image_buffer(self)

    def fz_compressed_image_type(self):
        r"""
        Class-aware wrapper for `::fz_compressed_image_type()`.
        	Return the type of a compressed image.

        	Any non-compressed image will have the type returned as UNKNOWN.
        """
        return _mupdf.FzImage_fz_compressed_image_type(self)

    def fz_get_pixmap_from_image(self, subarea, ctm, w, h):
        r"""
        Class-aware wrapper for `::fz_get_pixmap_from_image()`.

        This method has out-params. Python/C# wrappers look like:
        	`fz_get_pixmap_from_image(const ::fz_irect *subarea, ::fz_matrix *ctm)` => `(fz_pixmap *, int w, int h)`

        	Called to get a handle to a pixmap from an image.

        	image: The image to retrieve a pixmap from.

        	subarea: The subarea of the image that we actually care about
        	(or NULL to indicate the whole image).

        	ctm: Optional, unless subarea is given. If given, then on
        	entry this is the transform that will be applied to the complete
        	image. It should be updated on exit to the transform to apply to
        	the given subarea of the image. This is used to calculate the
        	desired width/height for subsampling.

        	w: If non-NULL, a pointer to an int to be updated on exit to the
        	width (in pixels) that the scaled output will cover.

        	h: If non-NULL, a pointer to an int to be updated on exit to the
        	height (in pixels) that the scaled output will cover.

        	Returns a non NULL kept pixmap pointer. May throw exceptions.
        """
        return _mupdf.FzImage_fz_get_pixmap_from_image(self, subarea, ctm, w, h)

    def fz_get_unscaled_pixmap_from_image(self):
        r"""
        Class-aware wrapper for `::fz_get_unscaled_pixmap_from_image()`.
        	Calls fz_get_pixmap_from_image() with ctm, subarea, w and h all set to NULL.
        """
        return _mupdf.FzImage_fz_get_unscaled_pixmap_from_image(self)

    def fz_image_orientation(self):
        r"""
        Class-aware wrapper for `::fz_image_orientation()`.
        	Request the natural orientation of an image.

        	This is for images (such as JPEG) that can contain internal
        	specifications of rotation/flips. This is ignored by all the
        	internal decode/rendering routines, but can be used by callers
        	(such as the image document handler) to respect such
        	specifications.

        	The values used by MuPDF are as follows, with the equivalent
        	Exif specifications given for information:

        	0: Undefined
        	1: 0 degree ccw rotation. (Exif = 1)
        	2: 90 degree ccw rotation. (Exif = 8)
        	3: 180 degree ccw rotation. (Exif = 3)
        	4: 270 degree ccw rotation. (Exif = 6)
        	5: flip on X. (Exif = 2)
        	6: flip on X, then rotate ccw by 90 degrees. (Exif = 5)
        	7: flip on X, then rotate ccw by 180 degrees. (Exif = 4)
        	8: flip on X, then rotate ccw by 270 degrees. (Exif = 7)
        """
        return _mupdf.FzImage_fz_image_orientation(self)

    def fz_image_orientation_matrix(self):
        r""" Class-aware wrapper for `::fz_image_orientation_matrix()`."""
        return _mupdf.FzImage_fz_image_orientation_matrix(self)

    def fz_image_resolution(self, xres, yres):
        r"""
        Class-aware wrapper for `::fz_image_resolution()`.

        This method has out-params. Python/C# wrappers look like:
        	`fz_image_resolution()` => `(int xres, int yres)`

        	Request the natural resolution
        	of an image.

        	xres, yres: Pointers to ints to be updated with the
        	natural resolution of an image (or a sensible default
        	if not encoded).
        """
        return _mupdf.FzImage_fz_image_resolution(self, xres, yres)

    def fz_image_size(self):
        r"""
        Class-aware wrapper for `::fz_image_size()`.
        	Return the size of the storage used by an image.
        """
        return _mupdf.FzImage_fz_image_size(self)

    def fz_new_buffer_from_image_as_jpeg(self, color_params, quality, invert_cmyk):
        r""" Class-aware wrapper for `::fz_new_buffer_from_image_as_jpeg()`."""
        return _mupdf.FzImage_fz_new_buffer_from_image_as_jpeg(self, color_params, quality, invert_cmyk)

    def fz_new_buffer_from_image_as_jpx(self, color_params, quality):
        r""" Class-aware wrapper for `::fz_new_buffer_from_image_as_jpx()`."""
        return _mupdf.FzImage_fz_new_buffer_from_image_as_jpx(self, color_params, quality)

    def fz_new_buffer_from_image_as_pam(self, color_params):
        r""" Class-aware wrapper for `::fz_new_buffer_from_image_as_pam()`."""
        return _mupdf.FzImage_fz_new_buffer_from_image_as_pam(self, color_params)

    def fz_new_buffer_from_image_as_png(self, color_params):
        r"""
        Class-aware wrapper for `::fz_new_buffer_from_image_as_png()`.
        	Reencode a given image as a PNG into a buffer.

        	Ownership of the buffer is returned.
        """
        return _mupdf.FzImage_fz_new_buffer_from_image_as_png(self, color_params)

    def fz_new_buffer_from_image_as_pnm(self, color_params):
        r""" Class-aware wrapper for `::fz_new_buffer_from_image_as_pnm()`."""
        return _mupdf.FzImage_fz_new_buffer_from_image_as_pnm(self, color_params)

    def fz_new_buffer_from_image_as_psd(self, color_params):
        r""" Class-aware wrapper for `::fz_new_buffer_from_image_as_psd()`."""
        return _mupdf.FzImage_fz_new_buffer_from_image_as_psd(self, color_params)

    def __init__(self, *args):
        r"""
        *Overload 1:*
         == Constructors.  Constructor using `fz_new_image_from_buffer()`.
        		Create a new image from a
        		buffer of data, inferring its type from the format
        		of the data.


        |

        *Overload 2:*
         Constructor using `fz_new_image_from_compressed_buffer()`.
        		Create an image based on
        		the data in the supplied compressed buffer.

        		w,h: Width and height of the created image.

        		bpc: Bits per component.

        		colorspace: The colorspace (determines the number of components,
        		and any color conversions required while decoding).

        		xres, yres: The X and Y resolutions respectively.

        		interpolate: 1 if interpolation should be used when decoding
        		this image, 0 otherwise.

        		imagemask: 1 if this is an imagemask (i.e. transparency bitmap
        		mask), 0 otherwise.

        		decode: NULL, or a pointer to to a decode array. The default
        		decode array is [0 1] (repeated n times, for n color components).

        		colorkey: NULL, or a pointer to a colorkey array. The default
        		colorkey array is [0 255] (repeated n times, for n color
        		components).

        		buffer: Buffer of compressed data and compression parameters.
        		Ownership of this reference is passed in.

        		mask: NULL, or another image to use as a mask for this one.
        		A new reference is taken to this image. Supplying a masked
        		image as a mask to another image is illegal!


        |

        *Overload 3:*
         Constructor using `fz_new_image_from_compressed_buffer2()`.  Swig-friendly wrapper for fz_new_image_from_compressed_buffer(),
        	uses specified `decode` and `colorkey` if they are not null (in which
        	case we assert that they have size `2*fz_colorspace_n(colorspace)`).

        |

        *Overload 4:*
         Constructor using `fz_new_image_from_display_list()`.
        		Create a new image from a display list.

        		w, h: The conceptual width/height of the image.

        		transform: The matrix that needs to be applied to the given
        		list to make it render to the unit square.

        		list: The display list.


        |

        *Overload 5:*
         Constructor using `fz_new_image_from_file()`.
        		Create a new image from the contents
        		of a file, inferring its type from the format of the
        		data.


        |

        *Overload 6:*
         Constructor using `fz_new_image_from_pixmap()`.
        		Create an image from the given
        		pixmap.

        		pixmap: The pixmap to base the image upon. A new reference
        		to this is taken.

        		mask: NULL, or another image to use as a mask for this one.
        		A new reference is taken to this image. Supplying a masked
        		image as a mask to another image is illegal!


        |

        *Overload 7:*
         Constructor using `fz_new_image_from_svg()`.
        		Create a scalable image from an SVG document.


        |

        *Overload 8:*
         Constructor using `fz_new_image_from_svg_xml()`.
        		Create a scalable image from an SVG document.


        |

        *Overload 9:*
         Constructor using `fz_new_image_of_size()`.
        		Internal function to make a new fz_image structure
        		for a derived class.

        		w,h: Width and height of the created image.

        		bpc: Bits per component.

        		colorspace: The colorspace (determines the number of components,
        		and any color conversions required while decoding).

        		xres, yres: The X and Y resolutions respectively.

        		interpolate: 1 if interpolation should be used when decoding
        		this image, 0 otherwise.

        		imagemask: 1 if this is an imagemask (i.e. transparent), 0
        		otherwise.

        		decode: NULL, or a pointer to to a decode array. The default
        		decode array is [0 1] (repeated n times, for n color components).

        		colorkey: NULL, or a pointer to a colorkey array. The default
        		colorkey array is [0 255] (repeated n times, for n color
        		components).

        		mask: NULL, or another image to use as a mask for this one.
        		A new reference is taken to this image. Supplying a masked
        		image as a mask to another image is illegal!

        		size: The size of the required allocated structure (the size of
        		the derived structure).

        		get: The function to be called to obtain a decoded pixmap.

        		get_size: The function to be called to return the storage size
        		used by this image.

        		drop: The function to be called to dispose of this image once
        		the last reference is dropped.

        		Returns a pointer to an allocated structure of the required size,
        		with the first sizeof(fz_image) bytes initialised as appropriate
        		given the supplied parameters, and the other bytes set to zero.


        |

        *Overload 10:*
         Copy constructor using `fz_keep_image()`.

        |

        *Overload 11:*
         Default constructor, sets `m_internal` to null.

        |

        *Overload 12:*
         Constructor using raw copy of pre-existing `::fz_image`.
        """
        _mupdf.FzImage_swiginit(self, _mupdf.new_FzImage(*args))

    def key_storable(self):
        return _mupdf.FzImage_key_storable(self)

    def w(self):
        return _mupdf.FzImage_w(self)

    def h(self):
        return _mupdf.FzImage_h(self)

    def n(self):
        return _mupdf.FzImage_n(self)

    def bpc(self):
        return _mupdf.FzImage_bpc(self)

    def imagemask(self):
        return _mupdf.FzImage_imagemask(self)

    def interpolate(self):
        return _mupdf.FzImage_interpolate(self)

    def use_colorkey(self):
        return _mupdf.FzImage_use_colorkey(self)

    def use_decode(self):
        return _mupdf.FzImage_use_decode(self)

    def decoded(self):
        return _mupdf.FzImage_decoded(self)

    def scalable(self):
        return _mupdf.FzImage_scalable(self)

    def orientation(self):
        return _mupdf.FzImage_orientation(self)

    def mask(self):
        return _mupdf.FzImage_mask(self)

    def xres(self):
        return _mupdf.FzImage_xres(self)

    def yres(self):
        return _mupdf.FzImage_yres(self)

    def colorspace(self):
        return _mupdf.FzImage_colorspace(self)

    def colorkey(self):
        return _mupdf.FzImage_colorkey(self)

    def decode(self):
        return _mupdf.FzImage_decode(self)
    __swig_destroy__ = _mupdf.delete_FzImage

    def m_internal_value(self):
        r""" Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.FzImage_m_internal_value(self)
    m_internal = property(_mupdf.FzImage_m_internal_get, _mupdf.FzImage_m_internal_set, doc=r""" Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.FzImage_s_num_instances_get, _mupdf.FzImage_s_num_instances_set)

# Register FzImage in _mupdf:
_mupdf.FzImage_swigregister(FzImage)
class FzInstallLoadSystemFontFuncsArgs(object):
    r"""
     Wrapper class for struct `fz_install_load_system_font_funcs_args`.
    Extra struct containing fz_install_load_system_font_funcs()'s args,
    which we wrap with virtual_fnptrs set to allow use from Python/C# via
    Swig Directors.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def fz_install_load_system_font_funcs2(self):
        r"""
        Class-aware wrapper for `::fz_install_load_system_font_funcs2()`.
        Alternative to fz_install_load_system_font_funcs() that takes args in a
        struct, to allow use from Python/C# via Swig Directors.
        """
        return _mupdf.FzInstallLoadSystemFontFuncsArgs_fz_install_load_system_font_funcs2(self)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        We use default copy constructor and operator=.  Default constructor, sets each member to default value.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::fz_install_load_system_font_funcs_args`.
        """
        _mupdf.FzInstallLoadSystemFontFuncsArgs_swiginit(self, _mupdf.new_FzInstallLoadSystemFontFuncsArgs(*args))
    __swig_destroy__ = _mupdf.delete_FzInstallLoadSystemFontFuncsArgs
    m_internal = property(_mupdf.FzInstallLoadSystemFontFuncsArgs_m_internal_get, _mupdf.FzInstallLoadSystemFontFuncsArgs_m_internal_set)
    s_num_instances = property(_mupdf.FzInstallLoadSystemFontFuncsArgs_s_num_instances_get, _mupdf.FzInstallLoadSystemFontFuncsArgs_s_num_instances_set, doc=r""" Wrapped data is held by value.""")

    def to_string(self):
        r""" Returns string containing our members, labelled and inside (...), using operator<<."""
        return _mupdf.FzInstallLoadSystemFontFuncsArgs_to_string(self)

    def __eq__(self, rhs):
        r""" Comparison method."""
        return _mupdf.FzInstallLoadSystemFontFuncsArgs___eq__(self, rhs)

    def __ne__(self, rhs):
        r""" Comparison method."""
        return _mupdf.FzInstallLoadSystemFontFuncsArgs___ne__(self, rhs)

# Register FzInstallLoadSystemFontFuncsArgs in _mupdf:
_mupdf.FzInstallLoadSystemFontFuncsArgs_swigregister(FzInstallLoadSystemFontFuncsArgs)
class FzInstallLoadSystemFontFuncsArgs2(FzInstallLoadSystemFontFuncsArgs):
    r""" Wrapper class for struct fz_install_load_system_font_funcs_args with virtual fns for each fnptr; this is for use as a SWIG Director class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r""" == Constructor."""
        if self.__class__ == FzInstallLoadSystemFontFuncsArgs2:
            _self = None
        else:
            _self = self
        _mupdf.FzInstallLoadSystemFontFuncsArgs2_swiginit(self, _mupdf.new_FzInstallLoadSystemFontFuncsArgs2(_self, ))

    def use_virtual_f(self, use=True):
        r"""
        These methods set the function pointers in *m_internal
        to point to internal callbacks that call our virtual methods.
        """
        return _mupdf.FzInstallLoadSystemFontFuncsArgs2_use_virtual_f(self, use)

    def use_virtual_f_cjk(self, use=True):
        return _mupdf.FzInstallLoadSystemFontFuncsArgs2_use_virtual_f_cjk(self, use)

    def use_virtual_f_fallback(self, use=True):
        return _mupdf.FzInstallLoadSystemFontFuncsArgs2_use_virtual_f_fallback(self, use)

    def f(self, arg_0, arg_1, arg_2, arg_3, arg_4):
        r""" Default virtual method implementations; these all throw an exception."""
        return _mupdf.FzInstallLoadSystemFontFuncsArgs2_f(self, arg_0, arg_1, arg_2, arg_3, arg_4)

    def f_cjk(self, arg_0, arg_1, arg_2, arg_3):
        return _mupdf.FzInstallLoadSystemFontFuncsArgs2_f_cjk(self, arg_0, arg_1, arg_2, arg_3)

    def f_fallback(self, arg_0, arg_1, arg_2, arg_3, arg_4, arg_5):
        return _mupdf.FzInstallLoadSystemFontFuncsArgs2_f_fallback(self, arg_0, arg_1, arg_2, arg_3, arg_4, arg_5)
    __swig_destroy__ = _mupdf.delete_FzInstallLoadSystemFontFuncsArgs2
    def __disown__(self):
        self.this.disown()
        _mupdf.disown_FzInstallLoadSystemFontFuncsArgs2(self)
        return weakref.proxy(self)

# Register FzInstallLoadSystemFontFuncsArgs2 in _mupdf:
_mupdf.FzInstallLoadSystemFontFuncsArgs2_swigregister(FzInstallLoadSystemFontFuncsArgs2)
class FzInt2(object):
    r""" Wrapper class for struct `fz_int2`. Not copyable or assignable."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::fz_int2`.
        """
        _mupdf.FzInt2_swiginit(self, _mupdf.new_FzInt2(*args))
    __swig_destroy__ = _mupdf.delete_FzInt2

    def m_internal_value(self):
        r""" Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.FzInt2_m_internal_value(self)
    m_internal = property(_mupdf.FzInt2_m_internal_get, _mupdf.FzInt2_m_internal_set, doc=r""" Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.FzInt2_s_num_instances_get, _mupdf.FzInt2_s_num_instances_set)

# Register FzInt2 in _mupdf:
_mupdf.FzInt2_swigregister(FzInt2)
class FzInt2Heap(object):
    r""" Wrapper class for struct `fz_int2_heap`. Not copyable or assignable."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def fz_int2_heap_insert(self, v):
        r""" Class-aware wrapper for `::fz_int2_heap_insert()`."""
        return _mupdf.FzInt2Heap_fz_int2_heap_insert(self, v)

    def fz_int2_heap_sort(self):
        r""" Class-aware wrapper for `::fz_int2_heap_sort()`."""
        return _mupdf.FzInt2Heap_fz_int2_heap_sort(self)

    def fz_int2_heap_uniq(self):
        r""" Class-aware wrapper for `::fz_int2_heap_uniq()`."""
        return _mupdf.FzInt2Heap_fz_int2_heap_uniq(self)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::fz_int2_heap`.
        """
        _mupdf.FzInt2Heap_swiginit(self, _mupdf.new_FzInt2Heap(*args))
    __swig_destroy__ = _mupdf.delete_FzInt2Heap

    def m_internal_value(self):
        r""" Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.FzInt2Heap_m_internal_value(self)
    m_internal = property(_mupdf.FzInt2Heap_m_internal_get, _mupdf.FzInt2Heap_m_internal_set, doc=r""" Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.FzInt2Heap_s_num_instances_get, _mupdf.FzInt2Heap_s_num_instances_set)

# Register FzInt2Heap in _mupdf:
_mupdf.FzInt2Heap_swigregister(FzInt2Heap)
class FzIntHeap(object):
    r""" Wrapper class for struct `fz_int_heap`. Not copyable or assignable."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def fz_int_heap_insert(self, v):
        r""" Class-aware wrapper for `::fz_int_heap_insert()`."""
        return _mupdf.FzIntHeap_fz_int_heap_insert(self, v)

    def fz_int_heap_sort(self):
        r""" Class-aware wrapper for `::fz_int_heap_sort()`."""
        return _mupdf.FzIntHeap_fz_int_heap_sort(self)

    def fz_int_heap_uniq(self):
        r""" Class-aware wrapper for `::fz_int_heap_uniq()`."""
        return _mupdf.FzIntHeap_fz_int_heap_uniq(self)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::fz_int_heap`.
        """
        _mupdf.FzIntHeap_swiginit(self, _mupdf.new_FzIntHeap(*args))
    __swig_destroy__ = _mupdf.delete_FzIntHeap

    def m_internal_value(self):
        r""" Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.FzIntHeap_m_internal_value(self)
    m_internal = property(_mupdf.FzIntHeap_m_internal_get, _mupdf.FzIntHeap_m_internal_set, doc=r""" Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.FzIntHeap_s_num_instances_get, _mupdf.FzIntHeap_s_num_instances_set)

# Register FzIntHeap in _mupdf:
_mupdf.FzIntHeap_swigregister(FzIntHeap)
class FzIntptr(object):
    r""" Wrapper class for struct `fz_intptr`. Not copyable or assignable."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::fz_intptr`.
        """
        _mupdf.FzIntptr_swiginit(self, _mupdf.new_FzIntptr(*args))
    __swig_destroy__ = _mupdf.delete_FzIntptr

    def m_internal_value(self):
        r""" Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.FzIntptr_m_internal_value(self)
    m_internal = property(_mupdf.FzIntptr_m_internal_get, _mupdf.FzIntptr_m_internal_set, doc=r""" Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.FzIntptr_s_num_instances_get, _mupdf.FzIntptr_s_num_instances_set)

# Register FzIntptr in _mupdf:
_mupdf.FzIntptr_swigregister(FzIntptr)
class FzIntptrHeap(object):
    r""" Wrapper class for struct `fz_intptr_heap`. Not copyable or assignable."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def fz_intptr_heap_insert(self, v):
        r""" Class-aware wrapper for `::fz_intptr_heap_insert()`."""
        return _mupdf.FzIntptrHeap_fz_intptr_heap_insert(self, v)

    def fz_intptr_heap_sort(self):
        r""" Class-aware wrapper for `::fz_intptr_heap_sort()`."""
        return _mupdf.FzIntptrHeap_fz_intptr_heap_sort(self)

    def fz_intptr_heap_uniq(self):
        r""" Class-aware wrapper for `::fz_intptr_heap_uniq()`."""
        return _mupdf.FzIntptrHeap_fz_intptr_heap_uniq(self)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::fz_intptr_heap`.
        """
        _mupdf.FzIntptrHeap_swiginit(self, _mupdf.new_FzIntptrHeap(*args))
    __swig_destroy__ = _mupdf.delete_FzIntptrHeap

    def m_internal_value(self):
        r""" Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.FzIntptrHeap_m_internal_value(self)
    m_internal = property(_mupdf.FzIntptrHeap_m_internal_get, _mupdf.FzIntptrHeap_m_internal_set, doc=r""" Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.FzIntptrHeap_s_num_instances_get, _mupdf.FzIntptrHeap_s_num_instances_set)

# Register FzIntptrHeap in _mupdf:
_mupdf.FzIntptrHeap_swigregister(FzIntptrHeap)
class FzIrect(object):
    r"""
    Wrapper class for struct `fz_irect`.
    fz_irect is a rectangle using integers instead of floats.

    It's used in the draw device and for pixmap dimensions.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def fz_expand_irect(self, expand):
        r""" Class-aware wrapper for `::fz_expand_irect()`."""
        return _mupdf.FzIrect_fz_expand_irect(self, expand)

    def fz_intersect_irect(self, b):
        r"""
        Class-aware wrapper for `::fz_intersect_irect()`.
        	Compute intersection of two bounding boxes.

        	Similar to fz_intersect_rect but operates on two bounding
        	boxes instead of two rectangles.
        """
        return _mupdf.FzIrect_fz_intersect_irect(self, b)

    def fz_irect_height(self):
        r"""
        Class-aware wrapper for `::fz_irect_height()`.
        	Return the height of an irect. Invalid irects return 0.
        """
        return _mupdf.FzIrect_fz_irect_height(self)

    def fz_irect_width(self):
        r"""
        Class-aware wrapper for `::fz_irect_width()`.
        	Return the width of an irect. Invalid irects return 0.
        """
        return _mupdf.FzIrect_fz_irect_width(self)

    def fz_is_empty_irect(self):
        r""" Class-aware wrapper for `::fz_is_empty_irect()`."""
        return _mupdf.FzIrect_fz_is_empty_irect(self)

    def fz_is_infinite_irect(self):
        r"""
        Class-aware wrapper for `::fz_is_infinite_irect()`.
        	Check if an integer rectangle
        	is infinite.
        """
        return _mupdf.FzIrect_fz_is_infinite_irect(self)

    def fz_is_valid_irect(self):
        r"""
        Class-aware wrapper for `::fz_is_valid_irect()`.
        	Check if an integer rectangle is valid.
        """
        return _mupdf.FzIrect_fz_is_valid_irect(self)

    def fz_rect_from_irect(self):
        r"""
        Class-aware wrapper for `::fz_rect_from_irect()`.
        	Convert a bbox into a rect.

        	For our purposes, a rect can represent all the values we meet in
        	a bbox, so nothing can go wrong.

        	rect: A place to store the generated rectangle.

        	bbox: The bbox to convert.

        	Returns rect (updated).
        """
        return _mupdf.FzIrect_fz_rect_from_irect(self)

    def fz_translate_irect(self, xoff, yoff):
        r""" Class-aware wrapper for `::fz_translate_irect()`."""
        return _mupdf.FzIrect_fz_translate_irect(self, xoff, yoff)

    def __init__(self, *args):
        r"""
        *Overload 1:*
         == Constructors.  Constructor using `fz_irect_from_rect()`.
        		Convert a rect into the minimal bounding box
        		that covers the rectangle.

        		Coordinates in a bounding box are integers, so rounding of the
        		rects coordinates takes place. The top left corner is rounded
        		upwards and left while the bottom right corner is rounded
        		downwards and to the right.


        |

        *Overload 2:*
         Constructor using `fz_make_irect()`.

        |

        *Overload 3:*
         We use default copy constructor and operator=.  Default constructor, sets each member to default value.

        |

        *Overload 4:*
         Constructor using raw copy of pre-existing `::fz_irect`.

        |

        *Overload 5:*
         Constructor using raw copy of pre-existing `::fz_irect`.
        """
        _mupdf.FzIrect_swiginit(self, _mupdf.new_FzIrect(*args))

    def internal(self, *args):
        r"""
        *Overload 1:*
        Access as underlying struct.

        |

        *Overload 2:*
        Access as underlying struct.
        """
        return _mupdf.FzIrect_internal(self, *args)
    __swig_destroy__ = _mupdf.delete_FzIrect
    x0 = property(_mupdf.FzIrect_x0_get, _mupdf.FzIrect_x0_set)
    y0 = property(_mupdf.FzIrect_y0_get, _mupdf.FzIrect_y0_set)
    x1 = property(_mupdf.FzIrect_x1_get, _mupdf.FzIrect_x1_set)
    y1 = property(_mupdf.FzIrect_y1_get, _mupdf.FzIrect_y1_set)
    s_num_instances = property(_mupdf.FzIrect_s_num_instances_get, _mupdf.FzIrect_s_num_instances_set)

    def to_string(self):
        r""" Returns string containing our members, labelled and inside (...), using operator<<."""
        return _mupdf.FzIrect_to_string(self)

    def __eq__(self, rhs):
        r""" Comparison method."""
        return _mupdf.FzIrect___eq__(self, rhs)

    def __ne__(self, rhs):
        r""" Comparison method."""
        return _mupdf.FzIrect___ne__(self, rhs)

# Register FzIrect in _mupdf:
_mupdf.FzIrect_swigregister(FzIrect)
class FzJbig2Globals(object):
    r""" Wrapper class for struct `fz_jbig2_globals`."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def fz_jbig2_globals_data(self):
        r"""
        Class-aware wrapper for `::fz_jbig2_globals_data()`.
        	Return buffer containing jbig2 globals data stream.
        """
        return _mupdf.FzJbig2Globals_fz_jbig2_globals_data(self)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Copy constructor using `fz_keep_jbig2_globals()`.

        |

        *Overload 2:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 3:*
        Constructor using raw copy of pre-existing `::fz_jbig2_globals`.
        """
        _mupdf.FzJbig2Globals_swiginit(self, _mupdf.new_FzJbig2Globals(*args))
    __swig_destroy__ = _mupdf.delete_FzJbig2Globals

    def m_internal_value(self):
        r""" Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.FzJbig2Globals_m_internal_value(self)
    m_internal = property(_mupdf.FzJbig2Globals_m_internal_get, _mupdf.FzJbig2Globals_m_internal_set, doc=r""" Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.FzJbig2Globals_s_num_instances_get, _mupdf.FzJbig2Globals_s_num_instances_set)

# Register FzJbig2Globals in _mupdf:
_mupdf.FzJbig2Globals_swigregister(FzJbig2Globals)
class FzKeyStorable(object):
    r"""
    Wrapper class for struct `fz_key_storable`.
    Any storable object that can appear in the key of another
    storable object should include an fz_key_storable structure
    at the start (by convention at least) of their structure.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Copy constructor using `fz_keep_key_storable()`.

        |

        *Overload 2:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 3:*
        Constructor using raw copy of pre-existing `::fz_key_storable`.
        """
        _mupdf.FzKeyStorable_swiginit(self, _mupdf.new_FzKeyStorable(*args))
    __swig_destroy__ = _mupdf.delete_FzKeyStorable

    def m_internal_value(self):
        r""" Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.FzKeyStorable_m_internal_value(self)
    m_internal = property(_mupdf.FzKeyStorable_m_internal_get, _mupdf.FzKeyStorable_m_internal_set, doc=r""" Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.FzKeyStorable_s_num_instances_get, _mupdf.FzKeyStorable_s_num_instances_set)

# Register FzKeyStorable in _mupdf:
_mupdf.FzKeyStorable_swigregister(FzKeyStorable)
class FzLayoutBlock(object):
    r""" Wrapper class for struct `fz_layout_block`. Not copyable or assignable."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def fz_add_layout_char(self, x, w, p):
        r"""
        Class-aware wrapper for `::fz_add_layout_char()`.
        	Add a new char to the line at the end of the layout block.
        """
        return _mupdf.FzLayoutBlock_fz_add_layout_char(self, x, w, p)

    def fz_add_layout_line(self, x, y, h, p):
        r"""
        Class-aware wrapper for `::fz_add_layout_line()`.
        	Add a new line to the end of the layout block.
        """
        return _mupdf.FzLayoutBlock_fz_add_layout_line(self, x, y, h, p)

    def __init__(self, *args):
        r"""
        *Overload 1:*
         == Constructors.  Constructor using `fz_new_layout()`.
        		Create a new layout block, with new allocation pool, zero
        		matrices, and initialise linked pointers.


        |

        *Overload 2:*
         Constructor using raw copy of pre-existing `::fz_layout_block`.
        """
        _mupdf.FzLayoutBlock_swiginit(self, _mupdf.new_FzLayoutBlock(*args))
    __swig_destroy__ = _mupdf.delete_FzLayoutBlock

    def m_internal_value(self):
        r""" Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.FzLayoutBlock_m_internal_value(self)
    m_internal = property(_mupdf.FzLayoutBlock_m_internal_get, _mupdf.FzLayoutBlock_m_internal_set, doc=r""" Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.FzLayoutBlock_s_num_instances_get, _mupdf.FzLayoutBlock_s_num_instances_set)

# Register FzLayoutBlock in _mupdf:
_mupdf.FzLayoutBlock_swigregister(FzLayoutBlock)
class FzLayoutChar(object):
    r"""
    Wrapper class for struct `fz_layout_char`. Not copyable or assignable.
    Simple text layout (for use with annotation editing primarily).
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::fz_layout_char`.
        """
        _mupdf.FzLayoutChar_swiginit(self, _mupdf.new_FzLayoutChar(*args))
    __swig_destroy__ = _mupdf.delete_FzLayoutChar

    def m_internal_value(self):
        r""" Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.FzLayoutChar_m_internal_value(self)
    m_internal = property(_mupdf.FzLayoutChar_m_internal_get, _mupdf.FzLayoutChar_m_internal_set, doc=r""" Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.FzLayoutChar_s_num_instances_get, _mupdf.FzLayoutChar_s_num_instances_set)

# Register FzLayoutChar in _mupdf:
_mupdf.FzLayoutChar_swigregister(FzLayoutChar)
class FzLayoutLine(object):
    r""" Wrapper class for struct `fz_layout_line`. Not copyable or assignable."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::fz_layout_line`.
        """
        _mupdf.FzLayoutLine_swiginit(self, _mupdf.new_FzLayoutLine(*args))
    __swig_destroy__ = _mupdf.delete_FzLayoutLine

    def m_internal_value(self):
        r""" Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.FzLayoutLine_m_internal_value(self)
    m_internal = property(_mupdf.FzLayoutLine_m_internal_get, _mupdf.FzLayoutLine_m_internal_set, doc=r""" Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.FzLayoutLine_s_num_instances_get, _mupdf.FzLayoutLine_s_num_instances_set)

# Register FzLayoutLine in _mupdf:
_mupdf.FzLayoutLine_swigregister(FzLayoutLine)
class FzLink(object):
    r"""
    Wrapper class for struct `fz_link`.
    fz_link is a list of interactive links on a page.

    There is no relation between the order of the links in the
    list and the order they appear on the page. The list of links
    for a given page can be obtained from fz_load_links.

    A link is reference counted. Dropping a reference to a link is
    done by calling fz_drop_link.

    rect: The hot zone. The area that can be clicked in
    untransformed coordinates.

    uri: Link destinations come in two forms: internal and external.
    Internal links refer to other pages in the same document.
    External links are URLs to other documents.

    next: A pointer to the next link on the same page.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def fz_set_link_rect(self, rect):
        r""" Class-aware wrapper for `::fz_set_link_rect()`."""
        return _mupdf.FzLink_fz_set_link_rect(self, rect)

    def fz_set_link_uri(self, uri):
        r""" Class-aware wrapper for `::fz_set_link_uri()`."""
        return _mupdf.FzLink_fz_set_link_uri(self, uri)

    def begin(self):
        r""" Used for iteration over linked list of FzLink items starting at fz_link::."""
        return _mupdf.FzLink_begin(self)

    def end(self):
        r""" Used for iteration over linked list of FzLink items starting at fz_link::."""
        return _mupdf.FzLink_end(self)

    def __init__(self, *args):
        r"""
        *Overload 1:*
         == Constructors.  Constructor using `fz_new_link_of_size()`.
        		Create a new link record.

        		next is set to NULL with the expectation that the caller will
        		handle the linked list setup. Internal function.

        		Different document types will be implemented by deriving from
        		fz_link. This macro allocates such derived structures, and
        		initialises the base sections.


        |

        *Overload 2:*
         Constructor using `pdf_new_link()`.

        |

        *Overload 3:*
         Construct by calling fz_new_link_of_size() with size=sizeof(fz_link).

        |

        *Overload 4:*
         Copy constructor using `fz_keep_link()`.

        |

        *Overload 5:*
         Constructor using raw copy of pre-existing `::fz_link`.

        |

        *Overload 6:*
         Constructor using raw copy of pre-existing `::fz_link`.
        """
        _mupdf.FzLink_swiginit(self, _mupdf.new_FzLink(*args))

    def refs(self):
        return _mupdf.FzLink_refs(self)

    def next(self):
        return _mupdf.FzLink_next(self)

    def rect(self):
        return _mupdf.FzLink_rect(self)

    def uri(self):
        return _mupdf.FzLink_uri(self)
    __swig_destroy__ = _mupdf.delete_FzLink

    def m_internal_value(self):
        r""" Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.FzLink_m_internal_value(self)
    m_internal = property(_mupdf.FzLink_m_internal_get, _mupdf.FzLink_m_internal_set, doc=r""" Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.FzLink_s_num_instances_get, _mupdf.FzLink_s_num_instances_set)

# Register FzLink in _mupdf:
_mupdf.FzLink_swigregister(FzLink)
class FzLinkDest(object):
    r""" Wrapper class for struct `fz_link_dest`. Not copyable or assignable."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def pdf_new_uri_from_explicit_dest(self):
        r""" Class-aware wrapper for `::pdf_new_uri_from_explicit_dest()`."""
        return _mupdf.FzLinkDest_pdf_new_uri_from_explicit_dest(self)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::fz_link_dest`.
        """
        _mupdf.FzLinkDest_swiginit(self, _mupdf.new_FzLinkDest(*args))
    __swig_destroy__ = _mupdf.delete_FzLinkDest

    def m_internal_value(self):
        r""" Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.FzLinkDest_m_internal_value(self)
    m_internal = property(_mupdf.FzLinkDest_m_internal_get, _mupdf.FzLinkDest_m_internal_set, doc=r""" Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.FzLinkDest_s_num_instances_get, _mupdf.FzLinkDest_s_num_instances_set)

# Register FzLinkDest in _mupdf:
_mupdf.FzLinkDest_swigregister(FzLinkDest)
class FzLocation(object):
    r"""
    Wrapper class for struct `fz_location`.
    Locations within the document are referred to in terms of
    chapter and page, rather than just a page number. For some
    documents (such as epub documents with large numbers of pages
    broken into many chapters) this can make navigation much faster
    as only the required chapter needs to be decoded at a time.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
         == Constructors.  Constructor using `fz_make_location()`.
        		Simple constructor for fz_locations.


        |

        *Overload 2:*
         We use default copy constructor and operator=.  Default constructor, sets each member to default value.

        |

        *Overload 3:*
         Constructor using raw copy of pre-existing `::fz_location`.

        |

        *Overload 4:*
         Constructor using raw copy of pre-existing `::fz_location`.
        """
        _mupdf.FzLocation_swiginit(self, _mupdf.new_FzLocation(*args))

    def internal(self, *args):
        r"""
        *Overload 1:*
        Access as underlying struct.

        |

        *Overload 2:*
        Access as underlying struct.
        """
        return _mupdf.FzLocation_internal(self, *args)
    __swig_destroy__ = _mupdf.delete_FzLocation
    chapter = property(_mupdf.FzLocation_chapter_get, _mupdf.FzLocation_chapter_set)
    page = property(_mupdf.FzLocation_page_get, _mupdf.FzLocation_page_set)
    s_num_instances = property(_mupdf.FzLocation_s_num_instances_get, _mupdf.FzLocation_s_num_instances_set)

    def to_string(self):
        r""" Returns string containing our members, labelled and inside (...), using operator<<."""
        return _mupdf.FzLocation_to_string(self)

    def __eq__(self, rhs):
        r""" Comparison method."""
        return _mupdf.FzLocation___eq__(self, rhs)

    def __ne__(self, rhs):
        r""" Comparison method."""
        return _mupdf.FzLocation___ne__(self, rhs)

# Register FzLocation in _mupdf:
_mupdf.FzLocation_swigregister(FzLocation)
class FzLocksContext(object):
    r"""
    Wrapper class for struct `fz_locks_context`. Not copyable or assignable.
    Locking functions

    MuPDF is kept deliberately free of any knowledge of particular
    threading systems. As such, in order for safe multi-threaded
    operation, we rely on callbacks to client provided functions.

    A client is expected to provide FZ_LOCK_MAX number of mutexes,
    and a function to lock/unlock each of them. These may be
    recursive mutexes, but do not have to be.

    If a client does not intend to use multiple threads, then it
    may pass NULL instead of a lock structure.

    In order to avoid deadlocks, we have one simple rule
    internally as to how we use locks: We can never take lock n
    when we already hold any lock i, where 0 <= i <= n. In order
    to verify this, we have some debugging code, that can be
    enabled by defining FITZ_DEBUG_LOCKING.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::fz_locks_context`.
        """
        _mupdf.FzLocksContext_swiginit(self, _mupdf.new_FzLocksContext(*args))
    __swig_destroy__ = _mupdf.delete_FzLocksContext

    def m_internal_value(self):
        r""" Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.FzLocksContext_m_internal_value(self)
    m_internal = property(_mupdf.FzLocksContext_m_internal_get, _mupdf.FzLocksContext_m_internal_set, doc=r""" Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.FzLocksContext_s_num_instances_get, _mupdf.FzLocksContext_s_num_instances_set)

# Register FzLocksContext in _mupdf:
_mupdf.FzLocksContext_swigregister(FzLocksContext)
class FzMatrix(object):
    r"""
     Wrapper class for struct `fz_matrix`.
    	fz_matrix is a row-major 3x3 matrix used for representing
    	transformations of coordinates throughout MuPDF.

    	Since all points reside in a two-dimensional space, one vector
    	is always a constant unit vector; hence only some elements may
    	vary in a matrix. Below is how the elements map between
    	different representations.

    a b 0
    	| c d 0 | normally represented as [ a b c d e f ].
    	\ e f 1 /
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def fz_scale(sx, sy):
        r"""
        Class-aware wrapper for `::fz_scale()`.
        	Create a scaling matrix.

        	The returned matrix is of the form [ sx 0 0 sy 0 0 ].

        	m: Pointer to the matrix to populate

        	sx, sy: Scaling factors along the X- and Y-axes. A scaling
        	factor of 1.0 will not cause any scaling along the relevant
        	axis.

        	Returns m.
        """
        return _mupdf.FzMatrix_fz_scale(sx, sy)

    @staticmethod
    def fz_shear(sx, sy):
        r"""
        Class-aware wrapper for `::fz_shear()`.
        	Create a shearing matrix.

        	The returned matrix is of the form [ 1 sy sx 1 0 0 ].

        	m: pointer to place to store returned matrix

        	sx, sy: Shearing factors. A shearing factor of 0.0 will not
        	cause any shearing along the relevant axis.

        	Returns m.
        """
        return _mupdf.FzMatrix_fz_shear(sx, sy)

    @staticmethod
    def fz_rotate(degrees):
        r"""
        Class-aware wrapper for `::fz_rotate()`.
        	Create a rotation matrix.

        	The returned matrix is of the form
        	[ cos(deg) sin(deg) -sin(deg) cos(deg) 0 0 ].

        	m: Pointer to place to store matrix

        	degrees: Degrees of counter clockwise rotation. Values less
        	than zero and greater than 360 are handled as expected.

        	Returns m.
        """
        return _mupdf.FzMatrix_fz_rotate(degrees)

    @staticmethod
    def fz_translate(tx, ty):
        r"""
        Class-aware wrapper for `::fz_translate()`.
        	Create a translation matrix.

        	The returned matrix is of the form [ 1 0 0 1 tx ty ].

        	m: A place to store the created matrix.

        	tx, ty: Translation distances along the X- and Y-axes. A
        	translation of 0 will not cause any translation along the
        	relevant axis.

        	Returns m.
        """
        return _mupdf.FzMatrix_fz_translate(tx, ty)

    @staticmethod
    def fz_transform_page(mediabox, resolution, rotate):
        r"""
        Class-aware wrapper for `::fz_transform_page()`.
        	Create transform matrix to draw page
        	at a given resolution and rotation. Adjusts the scaling
        	factors so that the page covers whole number of
        	pixels and adjust the page origin to be at 0,0.
        """
        return _mupdf.FzMatrix_fz_transform_page(mediabox, resolution, rotate)

    def fz_concat(self, *args):
        r"""
        *Overload 1:*
         We use default copy constructor and operator=.  Class-aware wrapper for `::fz_concat()`.
        		Multiply two matrices.

        		The order of the two matrices are important since matrix
        		multiplication is not commutative.

        		Returns result.


        |

        *Overload 2:*
         Class-aware wrapper for `::fz_concat()`.
        		Multiply two matrices.

        		The order of the two matrices are important since matrix
        		multiplication is not commutative.

        		Returns result.
        """
        return _mupdf.FzMatrix_fz_concat(self, *args)

    def fz_invert_matrix(self):
        r"""
        Class-aware wrapper for `::fz_invert_matrix()`.
        	Create an inverse matrix.

        	inverse: Place to store inverse matrix.

        	matrix: Matrix to invert. A degenerate matrix, where the
        	determinant is equal to zero, can not be inverted and the
        	original matrix is returned instead.

        	Returns inverse.
        """
        return _mupdf.FzMatrix_fz_invert_matrix(self)

    def fz_is_identity(self):
        r""" Class-aware wrapper for `::fz_is_identity()`."""
        return _mupdf.FzMatrix_fz_is_identity(self)

    def fz_is_rectilinear(self):
        r"""
        Class-aware wrapper for `::fz_is_rectilinear()`.
        	Check if a transformation is rectilinear.

        	Rectilinear means that no shearing is present and that any
        	rotations present are a multiple of 90 degrees. Usually this
        	is used to make sure that axis-aligned rectangles before the
        	transformation are still axis-aligned rectangles afterwards.
        """
        return _mupdf.FzMatrix_fz_is_rectilinear(self)

    def fz_matrix_expansion(self):
        r"""
        Class-aware wrapper for `::fz_matrix_expansion()`.
        	Calculate average scaling factor of matrix.
        """
        return _mupdf.FzMatrix_fz_matrix_expansion(self)

    def fz_matrix_max_expansion(self):
        r"""
        Class-aware wrapper for `::fz_matrix_max_expansion()`.
        	Find the largest expansion performed by this matrix.
        	(i.e. max(abs(m.a),abs(m.b),abs(m.c),abs(m.d))
        """
        return _mupdf.FzMatrix_fz_matrix_max_expansion(self)

    def fz_post_scale(self, sx, sy):
        r"""
        Class-aware wrapper for `::fz_post_scale()`.
        	Scale a matrix by postmultiplication.

        	m: Pointer to the matrix to scale

        	sx, sy: Scaling factors along the X- and Y-axes. A scaling
        	factor of 1.0 will not cause any scaling along the relevant
        	axis.

        	Returns m (updated).
        """
        return _mupdf.FzMatrix_fz_post_scale(self, sx, sy)

    def fz_pre_rotate(self, degrees):
        r"""
        Class-aware wrapper for `::fz_pre_rotate()`.
        	Rotate a transformation by premultiplying.

        	The premultiplied matrix is of the form
        	[ cos(deg) sin(deg) -sin(deg) cos(deg) 0 0 ].

        	m: Pointer to matrix to premultiply.

        	degrees: Degrees of counter clockwise rotation. Values less
        	than zero and greater than 360 are handled as expected.

        	Returns m (updated).
        """
        return _mupdf.FzMatrix_fz_pre_rotate(self, degrees)

    def fz_pre_scale(self, sx, sy):
        r"""
        Class-aware wrapper for `::fz_pre_scale()`.
        	Scale a matrix by premultiplication.

        	m: Pointer to the matrix to scale

        	sx, sy: Scaling factors along the X- and Y-axes. A scaling
        	factor of 1.0 will not cause any scaling along the relevant
        	axis.

        	Returns m (updated).
        """
        return _mupdf.FzMatrix_fz_pre_scale(self, sx, sy)

    def fz_pre_shear(self, sx, sy):
        r"""
        Class-aware wrapper for `::fz_pre_shear()`.
        	Premultiply a matrix with a shearing matrix.

        	The shearing matrix is of the form [ 1 sy sx 1 0 0 ].

        	m: pointer to matrix to premultiply

        	sx, sy: Shearing factors. A shearing factor of 0.0 will not
        	cause any shearing along the relevant axis.

        	Returns m (updated).
        """
        return _mupdf.FzMatrix_fz_pre_shear(self, sx, sy)

    def fz_pre_translate(self, tx, ty):
        r"""
        Class-aware wrapper for `::fz_pre_translate()`.
        	Translate a matrix by premultiplication.

        	m: The matrix to translate

        	tx, ty: Translation distances along the X- and Y-axes. A
        	translation of 0 will not cause any translation along the
        	relevant axis.

        	Returns m.
        """
        return _mupdf.FzMatrix_fz_pre_translate(self, tx, ty)

    def fz_subpixel_adjust(self, subpix_ctm, qe, qf):
        r"""
        Class-aware wrapper for `::fz_subpixel_adjust()`.
        	Perform subpixel quantisation and adjustment on a glyph matrix.

        	ctm: On entry, the desired 'ideal' transformation for a glyph.
        	On exit, adjusted to a (very similar) transformation quantised
        	for subpixel caching.

        	subpix_ctm: Initialised by the routine to the transform that
        	should be used to render the glyph.

        	qe, qf: which subpixel position we quantised to.

        	Returns: the size of the glyph.

        	Note: This is currently only exposed for use in our app. It
        	should be considered "at risk" of removal from the API.
        """
        return _mupdf.FzMatrix_fz_subpixel_adjust(self, subpix_ctm, qe, qf)

    def fz_try_invert_matrix(self, src):
        r"""
        Class-aware wrapper for `::fz_try_invert_matrix()`.
        	Attempt to create an inverse matrix.

        	inverse: Place to store inverse matrix.

        	matrix: Matrix to invert. A degenerate matrix, where the
        	determinant is equal to zero, can not be inverted.

        	Returns 1 if matrix is degenerate (singular), or 0 otherwise.
        """
        return _mupdf.FzMatrix_fz_try_invert_matrix(self, src)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        == Constructors.  Constructor using `fz_make_matrix()`.

        |

        *Overload 2:*
        Constructs identity matrix (like fz_identity).

        |

        *Overload 3:*
        Constructor using raw copy of pre-existing `::fz_matrix`.

        |

        *Overload 4:*
        Constructor using raw copy of pre-existing `::fz_matrix`.
        """
        _mupdf.FzMatrix_swiginit(self, _mupdf.new_FzMatrix(*args))

    def internal(self, *args):
        r"""
        *Overload 1:*
        Access as underlying struct.

        |

        *Overload 2:*
        Access as underlying struct.
        """
        return _mupdf.FzMatrix_internal(self, *args)
    __swig_destroy__ = _mupdf.delete_FzMatrix
    a = property(_mupdf.FzMatrix_a_get, _mupdf.FzMatrix_a_set)
    b = property(_mupdf.FzMatrix_b_get, _mupdf.FzMatrix_b_set)
    c = property(_mupdf.FzMatrix_c_get, _mupdf.FzMatrix_c_set)
    d = property(_mupdf.FzMatrix_d_get, _mupdf.FzMatrix_d_set)
    e = property(_mupdf.FzMatrix_e_get, _mupdf.FzMatrix_e_set)
    f = property(_mupdf.FzMatrix_f_get, _mupdf.FzMatrix_f_set)
    s_num_instances = property(_mupdf.FzMatrix_s_num_instances_get, _mupdf.FzMatrix_s_num_instances_set)

    def to_string(self):
        r""" Returns string containing our members, labelled and inside (...), using operator<<."""
        return _mupdf.FzMatrix_to_string(self)

    def __eq__(self, rhs):
        r""" Comparison method."""
        return _mupdf.FzMatrix___eq__(self, rhs)

    def __ne__(self, rhs):
        r""" Comparison method."""
        return _mupdf.FzMatrix___ne__(self, rhs)

# Register FzMatrix in _mupdf:
_mupdf.FzMatrix_swigregister(FzMatrix)
class FzMd5(object):
    r"""
    Wrapper class for struct `fz_md5`.
    Structure definition is public to enable stack
    based allocation. Do not access the members directly.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def fz_md5_final(self, digest):
        r"""
        We use default copy constructor and operator=.  Class-aware wrapper for `::fz_md5_final()`.
        	MD5 finalization. Ends an MD5 message-digest operation, writing
        	the message digest and zeroizing the context.

        	Never throws an exception.
        """
        return _mupdf.FzMd5_fz_md5_final(self, digest)

    def fz_md5_final2(self):
        r"""
        Class-aware wrapper for `::fz_md5_final2()`.
        C++ alternative to fz_md5_final() that returns the digest by value.
        """
        return _mupdf.FzMd5_fz_md5_final2(self)

    def fz_md5_init(self):
        r"""
        Class-aware wrapper for `::fz_md5_init()`.
        	MD5 initialization. Begins an MD5 operation, writing a new
        	context.

        	Never throws an exception.
        """
        return _mupdf.FzMd5_fz_md5_init(self)

    def fz_md5_update(self, input, inlen):
        r"""
        Class-aware wrapper for `::fz_md5_update()`.
        	MD5 block update operation. Continues an MD5 message-digest
        	operation, processing another message block, and updating the
        	context.

        	Never throws an exception.
        """
        return _mupdf.FzMd5_fz_md5_update(self, input, inlen)

    def fz_md5_update_int64(self, i):
        r"""
        Class-aware wrapper for `::fz_md5_update_int64()`.
        	MD5 block update operation. Continues an MD5 message-digest
        	operation, processing an int64, and updating the context.

        	Never throws an exception.
        """
        return _mupdf.FzMd5_fz_md5_update_int64(self, i)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor calls md5_init().

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::fz_md5`.
        """
        _mupdf.FzMd5_swiginit(self, _mupdf.new_FzMd5(*args))

    def lo(self):
        return _mupdf.FzMd5_lo(self)

    def hi(self):
        return _mupdf.FzMd5_hi(self)

    def a(self):
        return _mupdf.FzMd5_a(self)

    def b(self):
        return _mupdf.FzMd5_b(self)

    def c(self):
        return _mupdf.FzMd5_c(self)

    def d(self):
        return _mupdf.FzMd5_d(self)

    def buffer(self):
        return _mupdf.FzMd5_buffer(self)
    __swig_destroy__ = _mupdf.delete_FzMd5
    m_internal = property(_mupdf.FzMd5_m_internal_get, _mupdf.FzMd5_m_internal_set)
    s_num_instances = property(_mupdf.FzMd5_s_num_instances_get, _mupdf.FzMd5_s_num_instances_set, doc=r""" Wrapped data is held by value.""")

    def to_string(self):
        r""" Returns string containing our members, labelled and inside (...), using operator<<."""
        return _mupdf.FzMd5_to_string(self)

    def __eq__(self, rhs):
        r""" Comparison method."""
        return _mupdf.FzMd5___eq__(self, rhs)

    def __ne__(self, rhs):
        r""" Comparison method."""
        return _mupdf.FzMd5___ne__(self, rhs)

# Register FzMd5 in _mupdf:
_mupdf.FzMd5_swigregister(FzMd5)
class FzOutline(object):
    r"""
    Wrapper class for struct `fz_outline`.
    fz_outline is a tree of the outline of a document (also known
    as table of contents).

    title: Title of outline item using UTF-8 encoding. May be NULL
    if the outline item has no text string.

    uri: Destination in the document to be displayed when this
    outline item is activated. May be an internal or external
    link, or NULL if the outline item does not have a destination.

    page: The page number of an internal link, or -1 for external
    links or links with no destination.

    next: The next outline item at the same level as this outline
    item. May be NULL if no more outline items exist at this level.

    down: The outline items immediate children in the hierarchy.
    May be NULL if no children exist.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
         == Constructors.  Constructor using `fz_load_outline()`.
        		Load the hierarchical document outline.

        		Should be freed by fz_drop_outline.


        |

        *Overload 2:*
         Constructor using `fz_load_outline_from_iterator()`.
        		Routine to implement the old Structure based API from an iterator.


        |

        *Overload 3:*
         Constructor using `fz_new_outline()`.
        		Create a new outline entry with zeroed fields for the caller
        		to fill in.


        |

        *Overload 4:*
         Copy constructor using `fz_keep_outline()`.

        |

        *Overload 5:*
         Constructor using raw copy of pre-existing `::fz_outline`.
        """
        _mupdf.FzOutline_swiginit(self, _mupdf.new_FzOutline(*args))

    def refs(self):
        return _mupdf.FzOutline_refs(self)

    def title(self):
        return _mupdf.FzOutline_title(self)

    def uri(self):
        return _mupdf.FzOutline_uri(self)

    def page(self):
        return _mupdf.FzOutline_page(self)

    def x(self):
        return _mupdf.FzOutline_x(self)

    def y(self):
        return _mupdf.FzOutline_y(self)

    def next(self):
        return _mupdf.FzOutline_next(self)

    def down(self):
        return _mupdf.FzOutline_down(self)

    def is_open(self):
        return _mupdf.FzOutline_is_open(self)
    __swig_destroy__ = _mupdf.delete_FzOutline

    def m_internal_value(self):
        r""" Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.FzOutline_m_internal_value(self)
    m_internal = property(_mupdf.FzOutline_m_internal_get, _mupdf.FzOutline_m_internal_set, doc=r""" Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.FzOutline_s_num_instances_get, _mupdf.FzOutline_s_num_instances_set)

# Register FzOutline in _mupdf:
_mupdf.FzOutline_swigregister(FzOutline)
class FzOutlineItem(object):
    r""" Wrapper class for struct `fz_outline_item`."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def valid(self):
        return _mupdf.FzOutlineItem_valid(self)

    def title(self):
        return _mupdf.FzOutlineItem_title(self)

    def uri(self):
        return _mupdf.FzOutlineItem_uri(self)

    def is_open(self):
        return _mupdf.FzOutlineItem_is_open(self)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        We use default copy constructor and operator=.  Default constructor, sets each member to default value.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::fz_outline_item`.
        """
        _mupdf.FzOutlineItem_swiginit(self, _mupdf.new_FzOutlineItem(*args))
    __swig_destroy__ = _mupdf.delete_FzOutlineItem
    s_num_instances = property(_mupdf.FzOutlineItem_s_num_instances_get, _mupdf.FzOutlineItem_s_num_instances_set)

# Register FzOutlineItem in _mupdf:
_mupdf.FzOutlineItem_swigregister(FzOutlineItem)
class FzOutlineIterator(object):
    r""" Wrapper class for struct `fz_outline_iterator`. Not copyable or assignable."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def fz_load_outline_from_iterator(self):
        r"""
        Class-aware wrapper for `::fz_load_outline_from_iterator()`.
        	Routine to implement the old Structure based API from an iterator.
        """
        return _mupdf.FzOutlineIterator_fz_load_outline_from_iterator(self)

    def fz_outline_iterator_delete(self):
        r"""
        Class-aware wrapper for `::fz_outline_iterator_delete()`.
        	Delete the current item.

        	This implicitly moves us to the 'next' item, and the return code is as for fz_outline_iterator_next.
        """
        return _mupdf.FzOutlineIterator_fz_outline_iterator_delete(self)

    def fz_outline_iterator_down(self):
        r""" Class-aware wrapper for `::fz_outline_iterator_down()`."""
        return _mupdf.FzOutlineIterator_fz_outline_iterator_down(self)

    def fz_outline_iterator_item(self):
        r"""
        Class-aware wrapper for `::fz_outline_iterator_item()`.
        	Call to get the current outline item.

        	Can return NULL. The item is only valid until the next call.
        """
        return _mupdf.FzOutlineIterator_fz_outline_iterator_item(self)

    def fz_outline_iterator_next(self):
        r"""
        Class-aware wrapper for `::fz_outline_iterator_next()`.
        	Calls to move the iterator position.

        	A negative return value means we could not move as requested. Otherwise:
        	0 = the final position has a valid item.
        	1 = not a valid item, but we can insert an item here.
        """
        return _mupdf.FzOutlineIterator_fz_outline_iterator_next(self)

    def fz_outline_iterator_prev(self):
        r""" Class-aware wrapper for `::fz_outline_iterator_prev()`."""
        return _mupdf.FzOutlineIterator_fz_outline_iterator_prev(self)

    def fz_outline_iterator_up(self):
        r""" Class-aware wrapper for `::fz_outline_iterator_up()`."""
        return _mupdf.FzOutlineIterator_fz_outline_iterator_up(self)

    def fz_outline_iterator_insert(self, item):
        r""" Custom wrapper for fz_outline_iterator_insert()."""
        return _mupdf.FzOutlineIterator_fz_outline_iterator_insert(self, item)

    def fz_outline_iterator_update(self, item):
        r""" Custom wrapper for fz_outline_iterator_update()."""
        return _mupdf.FzOutlineIterator_fz_outline_iterator_update(self, item)

    def __init__(self, *args):
        r"""
        *Overload 1:*
         == Constructors.  Constructor using `fz_new_outline_iterator()`.
        		Get an iterator for the document outline.

        		Should be freed by fz_drop_outline_iterator.


        |

        *Overload 2:*
         Constructor using `fz_new_outline_iterator_of_size()`.

        |

        *Overload 3:*
         Constructor using `pdf_new_outline_iterator()`.

        |

        *Overload 4:*
         Default constructor, sets `m_internal` to null.

        |

        *Overload 5:*
         Constructor using raw copy of pre-existing `::fz_outline_iterator`.
        """
        _mupdf.FzOutlineIterator_swiginit(self, _mupdf.new_FzOutlineIterator(*args))
    __swig_destroy__ = _mupdf.delete_FzOutlineIterator

    def m_internal_value(self):
        r""" Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.FzOutlineIterator_m_internal_value(self)
    m_internal = property(_mupdf.FzOutlineIterator_m_internal_get, _mupdf.FzOutlineIterator_m_internal_set, doc=r""" Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.FzOutlineIterator_s_num_instances_get, _mupdf.FzOutlineIterator_s_num_instances_set)

# Register FzOutlineIterator in _mupdf:
_mupdf.FzOutlineIterator_swigregister(FzOutlineIterator)
class FzOutput(object):
    r""" Wrapper class for struct `fz_output`. Not copyable or assignable."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    Fixed_STDOUT = _mupdf.FzOutput_Fixed_STDOUT
    Fixed_STDERR = _mupdf.FzOutput_Fixed_STDERR
    Filter_HEX = _mupdf.FzOutput_Filter_HEX
    Filter_85 = _mupdf.FzOutput_Filter_85
    Filter_RLE = _mupdf.FzOutput_Filter_RLE

    def fz_close_output(self):
        r"""
        Class-aware wrapper for `::fz_close_output()`.
        	Flush pending output and close an output stream.
        """
        return _mupdf.FzOutput_fz_close_output(self)

    def fz_debug_store(self):
        r"""
        Class-aware wrapper for `::fz_debug_store()`.
        	Output debugging information for the current state of the store
        	to the given output channel.
        """
        return _mupdf.FzOutput_fz_debug_store(self)

    def fz_dump_glyph_cache_stats(self):
        r"""
        Class-aware wrapper for `::fz_dump_glyph_cache_stats()`.
        	Dump debug statistics for the glyph cache.
        """
        return _mupdf.FzOutput_fz_dump_glyph_cache_stats(self)

    def fz_flush_output(self):
        r"""
        Class-aware wrapper for `::fz_flush_output()`.
        	Flush unwritten data.
        """
        return _mupdf.FzOutput_fz_flush_output(self)

    def fz_new_svg_device(self, page_width, page_height, text_format, reuse_images):
        r"""
        Class-aware wrapper for `::fz_new_svg_device()`.
        	Create a device that outputs (single page) SVG files to
        	the given output stream.

        	Equivalent to fz_new_svg_device_with_id passing id = NULL.
        """
        return _mupdf.FzOutput_fz_new_svg_device(self, page_width, page_height, text_format, reuse_images)

    def fz_new_svg_device_with_id(self, page_width, page_height, text_format, reuse_images, id):
        r"""
        Class-aware wrapper for `::fz_new_svg_device_with_id()`.

        This method has out-params. Python/C# wrappers look like:
        	`fz_new_svg_device_with_id(float page_width, float page_height, int text_format, int reuse_images)` => `(fz_device *, int id)`

        	Create a device that outputs (single page) SVG files to
        	the given output stream.

        	output: The output stream to send the constructed SVG page to.

        	page_width, page_height: The page dimensions to use (in points).

        	text_format: How to emit text. One of the following values:
        		FZ_SVG_TEXT_AS_TEXT: As <text> elements with possible
        		layout errors and mismatching fonts.
        		FZ_SVG_TEXT_AS_PATH: As <path> elements with exact
        		visual appearance.

        	reuse_images: Share image resources using <symbol> definitions.

        	id: ID parameter to keep generated IDs unique across SVG files.
        """
        return _mupdf.FzOutput_fz_new_svg_device_with_id(self, page_width, page_height, text_format, reuse_images, id)

    def fz_new_trace_device(self):
        r"""
        Class-aware wrapper for `::fz_new_trace_device()`.
        	Create a device to print a debug trace of all device calls.
        """
        return _mupdf.FzOutput_fz_new_trace_device(self)

    def fz_new_xmltext_device(self):
        r"""
        Class-aware wrapper for `::fz_new_xmltext_device()`.
        	Create a device to output raw information.
        """
        return _mupdf.FzOutput_fz_new_xmltext_device(self)

    def fz_output_supports_stream(self):
        r"""
        Class-aware wrapper for `::fz_output_supports_stream()`.
        	Query whether a given fz_output supports fz_stream_from_output.
        """
        return _mupdf.FzOutput_fz_output_supports_stream(self)

    def fz_output_xml(self, item, level):
        r"""
        Class-aware wrapper for `::fz_output_xml()`.
        	Pretty-print an XML tree to given output.
        """
        return _mupdf.FzOutput_fz_output_xml(self, item, level)

    def fz_print_stext_header_as_html(self):
        r""" Class-aware wrapper for `::fz_print_stext_header_as_html()`."""
        return _mupdf.FzOutput_fz_print_stext_header_as_html(self)

    def fz_print_stext_header_as_xhtml(self):
        r""" Class-aware wrapper for `::fz_print_stext_header_as_xhtml()`."""
        return _mupdf.FzOutput_fz_print_stext_header_as_xhtml(self)

    def fz_print_stext_page_as_html(self, page, id):
        r"""
        Class-aware wrapper for `::fz_print_stext_page_as_html()`.
        	Output structured text to a file in HTML (visual) format.
        """
        return _mupdf.FzOutput_fz_print_stext_page_as_html(self, page, id)

    def fz_print_stext_page_as_json(self, page, scale):
        r"""
        Class-aware wrapper for `::fz_print_stext_page_as_json()`.
        	Output structured text to a file in JSON format.
        """
        return _mupdf.FzOutput_fz_print_stext_page_as_json(self, page, scale)

    def fz_print_stext_page_as_text(self, page):
        r"""
        Class-aware wrapper for `::fz_print_stext_page_as_text()`.
        	Output structured text to a file in plain-text UTF-8 format.
        """
        return _mupdf.FzOutput_fz_print_stext_page_as_text(self, page)

    def fz_print_stext_page_as_xhtml(self, page, id):
        r"""
        Class-aware wrapper for `::fz_print_stext_page_as_xhtml()`.
        	Output structured text to a file in XHTML (semantic) format.
        """
        return _mupdf.FzOutput_fz_print_stext_page_as_xhtml(self, page, id)

    def fz_print_stext_page_as_xml(self, page, id):
        r"""
        Class-aware wrapper for `::fz_print_stext_page_as_xml()`.
        	Output structured text to a file in XML format.
        """
        return _mupdf.FzOutput_fz_print_stext_page_as_xml(self, page, id)

    def fz_print_stext_trailer_as_html(self):
        r""" Class-aware wrapper for `::fz_print_stext_trailer_as_html()`."""
        return _mupdf.FzOutput_fz_print_stext_trailer_as_html(self)

    def fz_print_stext_trailer_as_xhtml(self):
        r""" Class-aware wrapper for `::fz_print_stext_trailer_as_xhtml()`."""
        return _mupdf.FzOutput_fz_print_stext_trailer_as_xhtml(self)

    def fz_reset_output(self):
        r"""
        Class-aware wrapper for `::fz_reset_output()`.
        	Reset a closed output stream. Returns state to
        	(broadly) that which it was in when opened. Not
        	all outputs can be reset, so this may throw an
        	exception.
        """
        return _mupdf.FzOutput_fz_reset_output(self)

    def fz_seek_output(self, off, whence):
        r"""
        Class-aware wrapper for `::fz_seek_output()`.
        	Seek to the specified file position.
        	See fseek for arguments.

        	Throw an error on unseekable outputs.
        """
        return _mupdf.FzOutput_fz_seek_output(self, off, whence)

    def fz_set_stddbg(self):
        r"""
        Class-aware wrapper for `::fz_set_stddbg()`.
        	Set the output stream to be used for fz_stddbg. Set to NULL to
        	reset to default (stderr).
        """
        return _mupdf.FzOutput_fz_set_stddbg(self)

    def fz_stream_from_output(self):
        r"""
        Class-aware wrapper for `::fz_stream_from_output()`.
        	Obtain the fz_output in the form of a fz_stream.

        	This allows data to be read back from some forms of fz_output
        	object. When finished reading, the fz_stream should be released
        	by calling fz_drop_stream. Until the fz_stream is dropped, no
        	further operations should be performed on the fz_output object.
        """
        return _mupdf.FzOutput_fz_stream_from_output(self)

    def fz_tell_output(self):
        r"""
        Class-aware wrapper for `::fz_tell_output()`.
        	Return the current file position.

        	Throw an error on untellable outputs.
        """
        return _mupdf.FzOutput_fz_tell_output(self)

    def fz_truncate_output(self):
        r"""
        Class-aware wrapper for `::fz_truncate_output()`.
        	Truncate the output at the current position.

        	This allows output streams which have seeked back from the end
        	of their storage to be truncated at the current point.
        """
        return _mupdf.FzOutput_fz_truncate_output(self)

    def fz_write_base64(self, data, size, newline):
        r"""
        Class-aware wrapper for `::fz_write_base64()`.
        	Write a base64 encoded data block, optionally with periodic
        	newlines.
        """
        return _mupdf.FzOutput_fz_write_base64(self, data, size, newline)

    def fz_write_base64_buffer(self, data, newline):
        r"""
        Class-aware wrapper for `::fz_write_base64_buffer()`.
        	Write a base64 encoded fz_buffer, optionally with periodic
        	newlines.
        """
        return _mupdf.FzOutput_fz_write_base64_buffer(self, data, newline)

    def fz_write_bitmap_as_pbm(self, bitmap):
        r"""
        Class-aware wrapper for `::fz_write_bitmap_as_pbm()`.
        	Write a bitmap as a pbm.
        """
        return _mupdf.FzOutput_fz_write_bitmap_as_pbm(self, bitmap)

    def fz_write_bitmap_as_pcl(self, bitmap, pcl):
        r"""
        Class-aware wrapper for `::fz_write_bitmap_as_pcl()`.
        	Write a bitmap as mono PCL.
        """
        return _mupdf.FzOutput_fz_write_bitmap_as_pcl(self, bitmap, pcl)

    def fz_write_bitmap_as_pkm(self, bitmap):
        r"""
        Class-aware wrapper for `::fz_write_bitmap_as_pkm()`.
        	Write a CMYK bitmap as a pkm.
        """
        return _mupdf.FzOutput_fz_write_bitmap_as_pkm(self, bitmap)

    def fz_write_bitmap_as_pwg(self, bitmap, pwg):
        r"""
        Class-aware wrapper for `::fz_write_bitmap_as_pwg()`.
        	Write a bitmap as a PWG.
        """
        return _mupdf.FzOutput_fz_write_bitmap_as_pwg(self, bitmap, pwg)

    def fz_write_bitmap_as_pwg_page(self, bitmap, pwg):
        r"""
        Class-aware wrapper for `::fz_write_bitmap_as_pwg_page()`.
        	Write a bitmap as a PWG page.

        	Caller should provide a file header by calling
        	fz_write_pwg_file_header, but can then write several pages to
        	the same file.
        """
        return _mupdf.FzOutput_fz_write_bitmap_as_pwg_page(self, bitmap, pwg)

    def fz_write_bits(self, data, num_bits):
        r"""
        Class-aware wrapper for `::fz_write_bits()`.
        	Write num_bits of data to the end of the output stream, assumed to be packed
        	most significant bits first.
        """
        return _mupdf.FzOutput_fz_write_bits(self, data, num_bits)

    def fz_write_bits_sync(self):
        r"""
        Class-aware wrapper for `::fz_write_bits_sync()`.
        	Sync to byte boundary after writing bits.
        """
        return _mupdf.FzOutput_fz_write_bits_sync(self)

    def fz_write_buffer(self, data):
        r""" Class-aware wrapper for `::fz_write_buffer()`."""
        return _mupdf.FzOutput_fz_write_buffer(self, data)

    def fz_write_byte(self, x):
        r""" Class-aware wrapper for `::fz_write_byte()`."""
        return _mupdf.FzOutput_fz_write_byte(self, x)

    def fz_write_char(self, x):
        r""" Class-aware wrapper for `::fz_write_char()`."""
        return _mupdf.FzOutput_fz_write_char(self, x)

    def fz_write_data(self, data, size):
        r"""
        Class-aware wrapper for `::fz_write_data()`.
        	Write data to output.

        	data: Pointer to data to write.
        	size: Size of data to write in bytes.
        """
        return _mupdf.FzOutput_fz_write_data(self, data, size)

    def fz_write_float_be(self, f):
        r""" Class-aware wrapper for `::fz_write_float_be()`."""
        return _mupdf.FzOutput_fz_write_float_be(self, f)

    def fz_write_float_le(self, f):
        r""" Class-aware wrapper for `::fz_write_float_le()`."""
        return _mupdf.FzOutput_fz_write_float_le(self, f)

    def fz_write_image_as_data_uri(self, image):
        r"""
        Class-aware wrapper for `::fz_write_image_as_data_uri()`.
        	Write image as a data URI (for HTML and SVG output).
        """
        return _mupdf.FzOutput_fz_write_image_as_data_uri(self, image)

    def fz_write_int16_be(self, x):
        r""" Class-aware wrapper for `::fz_write_int16_be()`."""
        return _mupdf.FzOutput_fz_write_int16_be(self, x)

    def fz_write_int16_le(self, x):
        r""" Class-aware wrapper for `::fz_write_int16_le()`."""
        return _mupdf.FzOutput_fz_write_int16_le(self, x)

    def fz_write_int32_be(self, x):
        r"""
        Class-aware wrapper for `::fz_write_int32_be()`.
        	Write different sized data to an output stream.
        """
        return _mupdf.FzOutput_fz_write_int32_be(self, x)

    def fz_write_int32_le(self, x):
        r""" Class-aware wrapper for `::fz_write_int32_le()`."""
        return _mupdf.FzOutput_fz_write_int32_le(self, x)

    def fz_write_pixmap_as_data_uri(self, pixmap):
        r""" Class-aware wrapper for `::fz_write_pixmap_as_data_uri()`."""
        return _mupdf.FzOutput_fz_write_pixmap_as_data_uri(self, pixmap)

    def fz_write_pixmap_as_jpeg(self, pix, quality, invert_cmyk):
        r"""
        Class-aware wrapper for `::fz_write_pixmap_as_jpeg()`.
        	Write a pixmap as a JPEG.
        """
        return _mupdf.FzOutput_fz_write_pixmap_as_jpeg(self, pix, quality, invert_cmyk)

    def fz_write_pixmap_as_jpx(self, pix, quality):
        r"""
        Class-aware wrapper for `::fz_write_pixmap_as_jpx()`.
        	Pixmap data as JP2K with no subsampling.

        	quality = 100 = lossless
        	otherwise for a factor of x compression use 100-x. (so 80 is 1:20 compression)
        """
        return _mupdf.FzOutput_fz_write_pixmap_as_jpx(self, pix, quality)

    def fz_write_pixmap_as_pam(self, pixmap):
        r"""
        Class-aware wrapper for `::fz_write_pixmap_as_pam()`.
        	Write a pixmap as a pnm (greyscale, rgb or cmyk, with or without
        	alpha).
        """
        return _mupdf.FzOutput_fz_write_pixmap_as_pam(self, pixmap)

    def fz_write_pixmap_as_pcl(self, pixmap, pcl):
        r"""
        Class-aware wrapper for `::fz_write_pixmap_as_pcl()`.
        	Write an (RGB) pixmap as color PCL.
        """
        return _mupdf.FzOutput_fz_write_pixmap_as_pcl(self, pixmap, pcl)

    def fz_write_pixmap_as_pclm(self, pixmap, options):
        r"""
        Class-aware wrapper for `::fz_write_pixmap_as_pclm()`.
        	Write a (Greyscale or RGB) pixmap as pclm.
        """
        return _mupdf.FzOutput_fz_write_pixmap_as_pclm(self, pixmap, options)

    def fz_write_pixmap_as_pdfocr(self, pixmap, options):
        r"""
        Class-aware wrapper for `::fz_write_pixmap_as_pdfocr()`.
        	Write a (Greyscale or RGB) pixmap as pdfocr.
        """
        return _mupdf.FzOutput_fz_write_pixmap_as_pdfocr(self, pixmap, options)

    def fz_write_pixmap_as_png(self, pixmap):
        r"""
        Class-aware wrapper for `::fz_write_pixmap_as_png()`.
        	Write a (Greyscale or RGB) pixmap as a png.
        """
        return _mupdf.FzOutput_fz_write_pixmap_as_png(self, pixmap)

    def fz_write_pixmap_as_pnm(self, pixmap):
        r"""
        Class-aware wrapper for `::fz_write_pixmap_as_pnm()`.
        	Write a pixmap as a pnm (greyscale or rgb, no alpha).
        """
        return _mupdf.FzOutput_fz_write_pixmap_as_pnm(self, pixmap)

    def fz_write_pixmap_as_ps(self, pixmap):
        r"""
        Class-aware wrapper for `::fz_write_pixmap_as_ps()`.
        	Write a (gray, rgb, or cmyk, no alpha) pixmap out as postscript.
        """
        return _mupdf.FzOutput_fz_write_pixmap_as_ps(self, pixmap)

    def fz_write_pixmap_as_psd(self, pixmap):
        r"""
        Class-aware wrapper for `::fz_write_pixmap_as_psd()`.
        	Write a pixmap as a PSD file.
        """
        return _mupdf.FzOutput_fz_write_pixmap_as_psd(self, pixmap)

    def fz_write_pixmap_as_pwg(self, pixmap, pwg):
        r"""
        Class-aware wrapper for `::fz_write_pixmap_as_pwg()`.
        	Write a pixmap as a PWG.
        """
        return _mupdf.FzOutput_fz_write_pixmap_as_pwg(self, pixmap, pwg)

    def fz_write_pixmap_as_pwg_page(self, pixmap, pwg):
        r"""
        Class-aware wrapper for `::fz_write_pixmap_as_pwg_page()`.
        	Write a pixmap as a PWG page.

        	Caller should provide a file header by calling
        	fz_write_pwg_file_header, but can then write several pages to
        	the same file.
        """
        return _mupdf.FzOutput_fz_write_pixmap_as_pwg_page(self, pixmap, pwg)

    def fz_write_ps_file_header(self):
        r"""
        Class-aware wrapper for `::fz_write_ps_file_header()`.
        	Write the file level header for ps band writer output.
        """
        return _mupdf.FzOutput_fz_write_ps_file_header(self)

    def fz_write_ps_file_trailer(self, pages):
        r"""
        Class-aware wrapper for `::fz_write_ps_file_trailer()`.
        	Write the file level trailer for ps band writer output.
        """
        return _mupdf.FzOutput_fz_write_ps_file_trailer(self, pages)

    def fz_write_pwg_file_header(self):
        r"""
        Class-aware wrapper for `::fz_write_pwg_file_header()`.
        	Output the file header to a pwg stream, ready for pages to follow it.
        """
        return _mupdf.FzOutput_fz_write_pwg_file_header(self)

    def fz_write_rune(self, rune):
        r"""
        Class-aware wrapper for `::fz_write_rune()`.
        	Write a UTF-8 encoded unicode character.
        """
        return _mupdf.FzOutput_fz_write_rune(self, rune)

    def fz_write_string(self, s):
        r"""
        Class-aware wrapper for `::fz_write_string()`.
        	Write a string. Does not write zero terminator.
        """
        return _mupdf.FzOutput_fz_write_string(self, s)

    def fz_write_uint16_be(self, x):
        r""" Class-aware wrapper for `::fz_write_uint16_be()`."""
        return _mupdf.FzOutput_fz_write_uint16_be(self, x)

    def fz_write_uint16_le(self, x):
        r""" Class-aware wrapper for `::fz_write_uint16_le()`."""
        return _mupdf.FzOutput_fz_write_uint16_le(self, x)

    def fz_write_uint32_be(self, x):
        r""" Class-aware wrapper for `::fz_write_uint32_be()`."""
        return _mupdf.FzOutput_fz_write_uint32_be(self, x)

    def fz_write_uint32_le(self, x):
        r""" Class-aware wrapper for `::fz_write_uint32_le()`."""
        return _mupdf.FzOutput_fz_write_uint32_le(self, x)

    def pdf_new_output_processor(self, ahxencode, newlines):
        r""" Class-aware wrapper for `::pdf_new_output_processor()`."""
        return _mupdf.FzOutput_pdf_new_output_processor(self, ahxencode, newlines)

    def pdf_print_crypt(self, crypt):
        r""" Class-aware wrapper for `::pdf_print_crypt()`."""
        return _mupdf.FzOutput_pdf_print_crypt(self, crypt)

    def pdf_print_encrypted_obj(self, obj, tight, ascii, crypt, num, gen, sep):
        r"""
        Class-aware wrapper for `::pdf_print_encrypted_obj()`.

        This method has out-params. Python/C# wrappers look like:
        	`pdf_print_encrypted_obj(::pdf_obj *obj, int tight, int ascii, ::pdf_crypt *crypt, int num, int gen)` => int sep
        """
        return _mupdf.FzOutput_pdf_print_encrypted_obj(self, obj, tight, ascii, crypt, num, gen, sep)

    def pdf_print_font(self, fontdesc):
        r""" Class-aware wrapper for `::pdf_print_font()`."""
        return _mupdf.FzOutput_pdf_print_font(self, fontdesc)

    def pdf_print_obj(self, obj, tight, ascii):
        r""" Class-aware wrapper for `::pdf_print_obj()`."""
        return _mupdf.FzOutput_pdf_print_obj(self, obj, tight, ascii)

    def pdf_write_digest(self, byte_range, field, digest_offset, digest_length, signer):
        r""" Class-aware wrapper for `::pdf_write_digest()`."""
        return _mupdf.FzOutput_pdf_write_digest(self, byte_range, field, digest_offset, digest_length, signer)

    def __init__(self, *args):
        r"""
        *Overload 1:*
         == Constructors.  Constructor using `fz_new_arc4_output()`.

        |

        *Overload 2:*
         Constructor using `fz_new_deflate_output()`.

        |

        *Overload 3:*
         Constructor using `fz_new_log_for_module()`.
        		Internal function to actually do the opening of the logfile.

        		Caller should close/drop the output when finished with it.


        |

        *Overload 4:*
         Constructor using `fz_new_output()`.
        		Create a new output object with the given
        		internal state and function pointers.

        		state: Internal state (opaque to everything but implementation).

        		write: Function to output a given buffer.

        		close: Cleanup function to destroy state when output closed.
        		May permissibly be null.


        |

        *Overload 5:*
         Constructor using `fz_new_output_with_buffer()`.
        		Open an output stream that appends
        		to a buffer.

        		buf: The buffer to append to.


        |

        *Overload 6:*
         Constructor using `fz_new_output_with_path()`.
        		Open an output stream that writes to a
        		given path.

        		filename: The filename to write to (specified in UTF-8).

        		append: non-zero if we should append to the file, rather than
        		overwriting it.


        |

        *Overload 7:*
         Uses fz_stdout() or fz_stderr().

        |

        *Overload 8:*
         Calls one of: fz_new_asciihex_output(), fz_new_ascii85_output(), fz_new_rle_output().

        |

        *Overload 9:*
         Constructor using raw copy of pre-existing `::fz_output`.

        |

        *Overload 10:*
         Constructor using raw copy of pre-existing `::fz_output`.
        """
        _mupdf.FzOutput_swiginit(self, _mupdf.new_FzOutput(*args))
    __swig_destroy__ = _mupdf.delete_FzOutput

    def m_internal_value(self):
        r""" Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.FzOutput_m_internal_value(self)
    m_internal = property(_mupdf.FzOutput_m_internal_get, _mupdf.FzOutput_m_internal_set, doc=r""" Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.FzOutput_s_num_instances_get, _mupdf.FzOutput_s_num_instances_set)

# Register FzOutput in _mupdf:
_mupdf.FzOutput_swigregister(FzOutput)
class FzOutput2(FzOutput):
    r""" Wrapper class for struct fz_output with virtual fns for each fnptr; this is for use as a SWIG Director class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r""" == Constructor."""
        if self.__class__ == FzOutput2:
            _self = None
        else:
            _self = self
        _mupdf.FzOutput2_swiginit(self, _mupdf.new_FzOutput2(_self, ))

    def use_virtual_write(self, use=True):
        r"""
        These methods set the function pointers in *m_internal
        to point to internal callbacks that call our virtual methods.
        """
        return _mupdf.FzOutput2_use_virtual_write(self, use)

    def use_virtual_seek(self, use=True):
        return _mupdf.FzOutput2_use_virtual_seek(self, use)

    def use_virtual_tell(self, use=True):
        return _mupdf.FzOutput2_use_virtual_tell(self, use)

    def use_virtual_close(self, use=True):
        return _mupdf.FzOutput2_use_virtual_close(self, use)

    def use_virtual_drop(self, use=True):
        return _mupdf.FzOutput2_use_virtual_drop(self, use)

    def use_virtual_reset(self, use=True):
        return _mupdf.FzOutput2_use_virtual_reset(self, use)

    def use_virtual_as_stream(self, use=True):
        return _mupdf.FzOutput2_use_virtual_as_stream(self, use)

    def use_virtual_truncate(self, use=True):
        return _mupdf.FzOutput2_use_virtual_truncate(self, use)

    def write(self, arg_0, arg_2, arg_3):
        r""" Default virtual method implementations; these all throw an exception."""
        return _mupdf.FzOutput2_write(self, arg_0, arg_2, arg_3)

    def seek(self, arg_0, arg_2, arg_3):
        return _mupdf.FzOutput2_seek(self, arg_0, arg_2, arg_3)

    def tell(self, arg_0):
        return _mupdf.FzOutput2_tell(self, arg_0)

    def close(self, arg_0):
        return _mupdf.FzOutput2_close(self, arg_0)

    def drop(self, arg_0):
        return _mupdf.FzOutput2_drop(self, arg_0)

    def reset(self, arg_0):
        return _mupdf.FzOutput2_reset(self, arg_0)

    def as_stream(self, arg_0):
        return _mupdf.FzOutput2_as_stream(self, arg_0)

    def truncate(self, arg_0):
        return _mupdf.FzOutput2_truncate(self, arg_0)
    __swig_destroy__ = _mupdf.delete_FzOutput2
    def __disown__(self):
        self.this.disown()
        _mupdf.disown_FzOutput2(self)
        return weakref.proxy(self)

# Register FzOutput2 in _mupdf:
_mupdf.FzOutput2_swigregister(FzOutput2)
class FzOverprint(object):
    r"""
    Wrapper class for struct `fz_overprint`. Not copyable or assignable.
    Pixmaps represent a set of pixels for a 2 dimensional region of
    a plane. Each pixel has n components per pixel. The components
    are in the order process-components, spot-colors, alpha, where
    there can be 0 of any of those types. The data is in
    premultiplied alpha when rendering, but non-premultiplied for
    colorspace conversions and rescaling.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::fz_overprint`.
        """
        _mupdf.FzOverprint_swiginit(self, _mupdf.new_FzOverprint(*args))
    __swig_destroy__ = _mupdf.delete_FzOverprint

    def m_internal_value(self):
        r""" Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.FzOverprint_m_internal_value(self)
    m_internal = property(_mupdf.FzOverprint_m_internal_get, _mupdf.FzOverprint_m_internal_set, doc=r""" Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.FzOverprint_s_num_instances_get, _mupdf.FzOverprint_s_num_instances_set)

# Register FzOverprint in _mupdf:
_mupdf.FzOverprint_swigregister(FzOverprint)
class FzPage(object):
    r""" Wrapper class for struct `fz_page`."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def fz_bound_page(self):
        r"""
        Class-aware wrapper for `::fz_bound_page()`.
        	Determine the size of a page at 72 dpi.
        """
        return _mupdf.FzPage_fz_bound_page(self)

    def fz_bound_page_box(self, box):
        r""" Class-aware wrapper for `::fz_bound_page_box()`."""
        return _mupdf.FzPage_fz_bound_page_box(self, box)

    def fz_create_link(self, bbox, uri):
        r"""
        Class-aware wrapper for `::fz_create_link()`.
        	Create a new link on a page.
        """
        return _mupdf.FzPage_fz_create_link(self, bbox, uri)

    def fz_delete_link(self, link):
        r"""
        Class-aware wrapper for `::fz_delete_link()`.
        	Delete an existing link on a page.
        """
        return _mupdf.FzPage_fz_delete_link(self, link)

    def fz_load_links(self):
        r"""
        Class-aware wrapper for `::fz_load_links()`.
        	Load the list of links for a page.

        	Returns a linked list of all the links on the page, each with
        	its clickable region and link destination. Each link is
        	reference counted so drop and free the list of links by
        	calling fz_drop_link on the pointer return from fz_load_links.

        	page: Page obtained from fz_load_page.
        """
        return _mupdf.FzPage_fz_load_links(self)

    def fz_new_buffer_from_page(self, options):
        r""" Class-aware wrapper for `::fz_new_buffer_from_page()`."""
        return _mupdf.FzPage_fz_new_buffer_from_page(self, options)

    def fz_new_buffer_from_page_with_format(self, format, options, transform, cookie):
        r"""
        Class-aware wrapper for `::fz_new_buffer_from_page_with_format()`.
        	Returns an fz_buffer containing a page after conversion to specified format.

        	page: The page to convert.
        	format, options: Passed to fz_new_document_writer_with_output() internally.
        	transform, cookie: Passed to fz_run_page() internally.
        """
        return _mupdf.FzPage_fz_new_buffer_from_page_with_format(self, format, options, transform, cookie)

    def fz_new_display_list_from_page(self):
        r"""
        Class-aware wrapper for `::fz_new_display_list_from_page()`.
        	Create a display list.

        	Ownership of the display list is returned to the caller.
        """
        return _mupdf.FzPage_fz_new_display_list_from_page(self)

    def fz_new_display_list_from_page_contents(self):
        r"""
        Class-aware wrapper for `::fz_new_display_list_from_page_contents()`.
        	Create a display list from page contents (no annotations).

        	Ownership of the display list is returned to the caller.
        """
        return _mupdf.FzPage_fz_new_display_list_from_page_contents(self)

    def fz_new_pixmap_from_page(self, ctm, cs, alpha):
        r""" Class-aware wrapper for `::fz_new_pixmap_from_page()`."""
        return _mupdf.FzPage_fz_new_pixmap_from_page(self, ctm, cs, alpha)

    def fz_new_pixmap_from_page_contents(self, ctm, cs, alpha):
        r"""
        Class-aware wrapper for `::fz_new_pixmap_from_page_contents()`.
        	Render the page contents without annotations.

        	Ownership of the pixmap is returned to the caller.
        """
        return _mupdf.FzPage_fz_new_pixmap_from_page_contents(self, ctm, cs, alpha)

    def fz_new_pixmap_from_page_contents_with_separations(self, ctm, cs, seps, alpha):
        r""" Class-aware wrapper for `::fz_new_pixmap_from_page_contents_with_separations()`."""
        return _mupdf.FzPage_fz_new_pixmap_from_page_contents_with_separations(self, ctm, cs, seps, alpha)

    def fz_new_pixmap_from_page_with_separations(self, ctm, cs, seps, alpha):
        r""" Class-aware wrapper for `::fz_new_pixmap_from_page_with_separations()`."""
        return _mupdf.FzPage_fz_new_pixmap_from_page_with_separations(self, ctm, cs, seps, alpha)

    def fz_page_label(self, buf, size):
        r"""
        Class-aware wrapper for `::fz_page_label()`.
        	Get page label for a given page.
        """
        return _mupdf.FzPage_fz_page_label(self, buf, size)

    def fz_page_presentation(self, transition, duration):
        r"""
        Class-aware wrapper for `::fz_page_presentation()`.

        This method has out-params. Python/C# wrappers look like:
        	`fz_page_presentation(::fz_transition *transition)` => `(fz_transition *, float duration)`

        	Get the presentation details for a given page.

        	transition: A pointer to a transition struct to fill out.

        	duration: A pointer to a place to set the page duration in
        	seconds. Will be set to 0 if no transition is specified for the
        	page.

        	Returns: a pointer to the transition structure, or NULL if there
        	is no transition specified for the page.
        """
        return _mupdf.FzPage_fz_page_presentation(self, transition, duration)

    def fz_page_separations(self):
        r"""
        Class-aware wrapper for `::fz_page_separations()`.
        	Get the separations details for a page.
        	This will be NULL, unless the format specifically supports
        	separations (such as PDF files). May be NULL even
        	so, if there are no separations on a page.

        	Returns a reference that must be dropped.
        """
        return _mupdf.FzPage_fz_page_separations(self)

    def fz_page_uses_overprint(self):
        r"""
        Class-aware wrapper for `::fz_page_uses_overprint()`.
        	Query if a given page requires overprint.
        """
        return _mupdf.FzPage_fz_page_uses_overprint(self)

    def fz_run_page(self, dev, transform, cookie):
        r"""
        Class-aware wrapper for `::fz_run_page()`.
        	Run a page through a device.

        	page: Page obtained from fz_load_page.

        	dev: Device obtained from fz_new_*_device.

        	transform: Transform to apply to page. May include for example
        	scaling and rotation, see fz_scale, fz_rotate and fz_concat.
        	Set to fz_identity if no transformation is desired.

        	cookie: Communication mechanism between caller and library
        	rendering the page. Intended for multi-threaded applications,
        	while single-threaded applications set cookie to NULL. The
        	caller may abort an ongoing rendering of a page. Cookie also
        	communicates progress information back to the caller. The
        	fields inside cookie are continually updated while the page is
        	rendering.
        """
        return _mupdf.FzPage_fz_run_page(self, dev, transform, cookie)

    def fz_run_page_annots(self, dev, transform, cookie):
        r"""
        Class-aware wrapper for `::fz_run_page_annots()`.
        	Run the annotations on a page through a device.
        """
        return _mupdf.FzPage_fz_run_page_annots(self, dev, transform, cookie)

    def fz_run_page_contents(self, dev, transform, cookie):
        r"""
        Class-aware wrapper for `::fz_run_page_contents()`.
        	Run a page through a device. Just the main
        	page content, without the annotations, if any.

        	page: Page obtained from fz_load_page.

        	dev: Device obtained from fz_new_*_device.

        	transform: Transform to apply to page. May include for example
        	scaling and rotation, see fz_scale, fz_rotate and fz_concat.
        	Set to fz_identity if no transformation is desired.

        	cookie: Communication mechanism between caller and library
        	rendering the page. Intended for multi-threaded applications,
        	while single-threaded applications set cookie to NULL. The
        	caller may abort an ongoing rendering of a page. Cookie also
        	communicates progress information back to the caller. The
        	fields inside cookie are continually updated while the page is
        	rendering.
        """
        return _mupdf.FzPage_fz_run_page_contents(self, dev, transform, cookie)

    def fz_run_page_widgets(self, dev, transform, cookie):
        r"""
        Class-aware wrapper for `::fz_run_page_widgets()`.
        	Run the widgets on a page through a device.
        """
        return _mupdf.FzPage_fz_run_page_widgets(self, dev, transform, cookie)

    def fz_search_page(self, needle, hit_mark, hit_bbox, hit_max):
        r"""
        Class-aware wrapper for `::fz_search_page()`.

        This method has out-params. Python/C# wrappers look like:
        	`fz_search_page(const char *needle, ::fz_quad *hit_bbox, int hit_max)` => `(int, int hit_mark)`

        	Search for the 'needle' text on the page.
        	Record the hits in the hit_bbox array and return the number of
        	hits. Will stop looking once it has filled hit_max rectangles.
        """
        return _mupdf.FzPage_fz_search_page(self, needle, hit_mark, hit_bbox, hit_max)

    def pdf_page_from_fz_page(self):
        r""" Class-aware wrapper for `::pdf_page_from_fz_page()`."""
        return _mupdf.FzPage_pdf_page_from_fz_page(self)

    def doc(self):
        r""" Returns wrapper for .doc member."""
        return _mupdf.FzPage_doc(self)

    def __init__(self, *args):
        r"""
        *Overload 1:*
         == Constructors.  Constructor using `fz_load_chapter_page()`.
        		Load a page.

        		After fz_load_page is it possible to retrieve the size of the
        		page using fz_bound_page, or to render the page using
        		fz_run_page_*. Free the page by calling fz_drop_page.

        		chapter: chapter number, 0 is the first chapter of the document.
        		number: page number, 0 is the first page of the chapter.


        |

        *Overload 2:*
         Constructor using `fz_load_page()`.
        		Load a given page number from a document. This may be much less
        		efficient than loading by location (chapter+page) for some
        		document types.


        |

        *Overload 3:*
         Constructor using `fz_new_page_of_size()`.
        		Different document types will be implemented by deriving from
        		fz_page. This macro allocates such derived structures, and
        		initialises the base sections.


        |

        *Overload 4:*
         Return FzPage for pdfpage.m_internal.super.

        |

        *Overload 5:*
         Copy constructor using `fz_keep_page()`.

        |

        *Overload 6:*
         Default constructor, sets `m_internal` to null.

        |

        *Overload 7:*
         Constructor using raw copy of pre-existing `::fz_page`.
        """
        _mupdf.FzPage_swiginit(self, _mupdf.new_FzPage(*args))
    __swig_destroy__ = _mupdf.delete_FzPage

    def m_internal_value(self):
        r""" Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.FzPage_m_internal_value(self)
    m_internal = property(_mupdf.FzPage_m_internal_get, _mupdf.FzPage_m_internal_set, doc=r""" Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.FzPage_s_num_instances_get, _mupdf.FzPage_s_num_instances_set)

# Register FzPage in _mupdf:
_mupdf.FzPage_swigregister(FzPage)
class FzPath(object):
    r"""
     Wrapper class for struct `fz_path`.
    Vector path buffer.
    It can be stroked and dashed, or be filled.
    It has a fill rule (nonzero or even_odd).

    When rendering, they are flattened, stroked and dashed straight
    into the Global Edge List.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def fz_bound_path(self, stroke, ctm):
        r"""
        Class-aware wrapper for `::fz_bound_path()`.
        	Return a bounding rectangle for a path.

        	path: The path to bound.

        	stroke: If NULL, the bounding rectangle given is for
        	the filled path. If non-NULL the bounding rectangle
        	given is for the path stroked with the given attributes.

        	ctm: The matrix to apply to the path during stroking.

        	r: Pointer to a fz_rect which will be used to hold
        	the result.

        	Returns r, updated to contain the bounding rectangle.
        """
        return _mupdf.FzPath_fz_bound_path(self, stroke, ctm)

    def fz_clone_path(self):
        r"""
        Class-aware wrapper for `::fz_clone_path()`.
        	Clone the data for a path.

        	This is used in preference to fz_keep_path when a whole
        	new copy of a path is required, rather than just a shared
        	pointer. This probably indicates that the path is about to
        	be modified.

        	path: path to clone.

        	Throws exceptions on failure to allocate.
        """
        return _mupdf.FzPath_fz_clone_path(self)

    def fz_closepath(self):
        r"""
        Class-aware wrapper for `::fz_closepath()`.
        	Close the current subpath.

        	path: The path to modify.

        	Throws exceptions on failure to allocate, attempting to modify
        	a packed path, and illegal path closes (i.e. closing a non open
        	path).
        """
        return _mupdf.FzPath_fz_closepath(self)

    def fz_currentpoint(self):
        r"""
        Class-aware wrapper for `::fz_currentpoint()`.
        	Return the current point that a path has
        	reached or (0,0) if empty.

        	path: path to return the current point of.
        """
        return _mupdf.FzPath_fz_currentpoint(self)

    def fz_curveto(self, x0, y0, x1, y1, x2, y2):
        r"""
        Class-aware wrapper for `::fz_curveto()`.
        	Append a 'curveto' command to an open path. (For a
        	cubic bezier).

        	path: The path to modify.

        	x0, y0: The coordinates of the first control point for the
        	curve.

        	x1, y1: The coordinates of the second control point for the
        	curve.

        	x2, y2: The end coordinates for the curve.

        	Throws exceptions on failure to allocate, or attempting to
        	modify a packed path.
        """
        return _mupdf.FzPath_fz_curveto(self, x0, y0, x1, y1, x2, y2)

    def fz_curvetov(self, x1, y1, x2, y2):
        r"""
        Class-aware wrapper for `::fz_curvetov()`.
        	Append a 'curvetov' command to an open path. (For a
        	cubic bezier with the first control coordinate equal to
        	the start point).

        	path: The path to modify.

        	x1, y1: The coordinates of the second control point for the
        	curve.

        	x2, y2: The end coordinates for the curve.

        	Throws exceptions on failure to allocate, or attempting to
        	modify a packed path.
        """
        return _mupdf.FzPath_fz_curvetov(self, x1, y1, x2, y2)

    def fz_curvetoy(self, x0, y0, x2, y2):
        r"""
        Class-aware wrapper for `::fz_curvetoy()`.
        	Append a 'curvetoy' command to an open path. (For a
        	cubic bezier with the second control coordinate equal to
        	the end point).

        	path: The path to modify.

        	x0, y0: The coordinates of the first control point for the
        	curve.

        	x2, y2: The end coordinates for the curve (and the second
        	control coordinate).

        	Throws exceptions on failure to allocate, or attempting to
        	modify a packed path.
        """
        return _mupdf.FzPath_fz_curvetoy(self, x0, y0, x2, y2)

    def fz_lineto(self, x, y):
        r"""
        Class-aware wrapper for `::fz_lineto()`.
        	Append a 'lineto' command to an open path.

        	path: The path to modify.

        	x, y: The coordinate to line to.

        	Throws exceptions on failure to allocate, or attempting to
        	modify a packed path.
        """
        return _mupdf.FzPath_fz_lineto(self, x, y)

    def fz_moveto(self, x, y):
        r"""
        Class-aware wrapper for `::fz_moveto()`.
        	Append a 'moveto' command to a path.
        	This 'opens' a path.

        	path: The path to modify.

        	x, y: The coordinate to move to.

        	Throws exceptions on failure to allocate, or attempting to
        	modify a packed path.
        """
        return _mupdf.FzPath_fz_moveto(self, x, y)

    def fz_packed_path_size(self):
        r"""
        Class-aware wrapper for `::fz_packed_path_size()`.
        	Return the number of bytes required to pack a path.
        """
        return _mupdf.FzPath_fz_packed_path_size(self)

    def fz_quadto(self, x0, y0, x1, y1):
        r"""
        Class-aware wrapper for `::fz_quadto()`.
        	Append a 'quadto' command to an open path. (For a
        	quadratic bezier).

        	path: The path to modify.

        	x0, y0: The control coordinates for the quadratic curve.

        	x1, y1: The end coordinates for the quadratic curve.

        	Throws exceptions on failure to allocate, or attempting to
        	modify a packed path.
        """
        return _mupdf.FzPath_fz_quadto(self, x0, y0, x1, y1)

    def fz_rectto(self, x0, y0, x1, y1):
        r"""
        Class-aware wrapper for `::fz_rectto()`.
        	Append a 'rectto' command to an open path.

        	The rectangle is equivalent to:
        		moveto x0 y0
        		lineto x1 y0
        		lineto x1 y1
        		lineto x0 y1
        		closepath

        	path: The path to modify.

        	x0, y0: First corner of the rectangle.

        	x1, y1: Second corner of the rectangle.

        	Throws exceptions on failure to allocate, or attempting to
        	modify a packed path.
        """
        return _mupdf.FzPath_fz_rectto(self, x0, y0, x1, y1)

    def fz_transform_path(self, transform):
        r"""
        Class-aware wrapper for `::fz_transform_path()`.
        	Transform a path by a given
        	matrix.

        	path: The path to modify (must not be a packed path).

        	transform: The transform to apply.

        	Throws exceptions if the path is packed, or on failure
        	to allocate.
        """
        return _mupdf.FzPath_fz_transform_path(self, transform)

    def fz_trim_path(self):
        r"""
        Class-aware wrapper for `::fz_trim_path()`.
        	Minimise the internal storage used by a path.

        	As paths are constructed, the internal buffers
        	grow. To avoid repeated reallocations they
        	grow with some spare space. Once a path has
        	been fully constructed, this call allows the
        	excess space to be trimmed.
        """
        return _mupdf.FzPath_fz_trim_path(self)

    def fz_walk_path(self, walker, arg):
        r"""
        Class-aware wrapper for `::fz_walk_path()`.
        	Walk the segments of a path, calling the
        	appropriate callback function from a given set for each
        	segment of the path.

        	path: The path to walk.

        	walker: The set of callback functions to use. The first
        	4 callback pointers in the set must be non-NULL. The
        	subsequent ones can either be supplied, or can be left
        	as NULL, in which case the top 4 functions will be
        	called as appropriate to simulate them.

        	arg: An opaque argument passed in to each callback.

        	Exceptions will only be thrown if the underlying callback
        	functions throw them.
        """
        return _mupdf.FzPath_fz_walk_path(self, walker, arg)

    def __init__(self, *args):
        r"""
        *Overload 1:*
         == Constructors.  Constructor using `fz_new_path()`.
        		Create a new (empty) path structure.


        |

        *Overload 2:*
         Copy constructor using `fz_keep_path()`.

        |

        *Overload 3:*
         Constructor using raw copy of pre-existing `::fz_path`.
        """
        _mupdf.FzPath_swiginit(self, _mupdf.new_FzPath(*args))
    __swig_destroy__ = _mupdf.delete_FzPath

    def m_internal_value(self):
        r""" Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.FzPath_m_internal_value(self)
    m_internal = property(_mupdf.FzPath_m_internal_get, _mupdf.FzPath_m_internal_set, doc=r""" Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.FzPath_s_num_instances_get, _mupdf.FzPath_s_num_instances_set)

# Register FzPath in _mupdf:
_mupdf.FzPath_swigregister(FzPath)
class FzPathWalker(object):
    r""" Wrapper class for struct `fz_path_walker`. Not copyable or assignable."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, internal=None):
        r""" Constructor using raw copy of pre-existing `::fz_path_walker`."""
        _mupdf.FzPathWalker_swiginit(self, _mupdf.new_FzPathWalker(internal))
    __swig_destroy__ = _mupdf.delete_FzPathWalker

    def m_internal_value(self):
        r""" Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.FzPathWalker_m_internal_value(self)
    m_internal = property(_mupdf.FzPathWalker_m_internal_get, _mupdf.FzPathWalker_m_internal_set, doc=r""" Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.FzPathWalker_s_num_instances_get, _mupdf.FzPathWalker_s_num_instances_set)

# Register FzPathWalker in _mupdf:
_mupdf.FzPathWalker_swigregister(FzPathWalker)
class FzPathWalker2(FzPathWalker):
    r""" Wrapper class for struct fz_path_walker with virtual fns for each fnptr; this is for use as a SWIG Director class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r""" == Constructor."""
        if self.__class__ == FzPathWalker2:
            _self = None
        else:
            _self = self
        _mupdf.FzPathWalker2_swiginit(self, _mupdf.new_FzPathWalker2(_self, ))
    __swig_destroy__ = _mupdf.delete_FzPathWalker2

    def use_virtual_moveto(self, use=True):
        r"""
        These methods set the function pointers in *m_internal
        to point to internal callbacks that call our virtual methods.
        """
        return _mupdf.FzPathWalker2_use_virtual_moveto(self, use)

    def use_virtual_lineto(self, use=True):
        return _mupdf.FzPathWalker2_use_virtual_lineto(self, use)

    def use_virtual_curveto(self, use=True):
        return _mupdf.FzPathWalker2_use_virtual_curveto(self, use)

    def use_virtual_closepath(self, use=True):
        return _mupdf.FzPathWalker2_use_virtual_closepath(self, use)

    def use_virtual_quadto(self, use=True):
        return _mupdf.FzPathWalker2_use_virtual_quadto(self, use)

    def use_virtual_curvetov(self, use=True):
        return _mupdf.FzPathWalker2_use_virtual_curvetov(self, use)

    def use_virtual_curvetoy(self, use=True):
        return _mupdf.FzPathWalker2_use_virtual_curvetoy(self, use)

    def use_virtual_rectto(self, use=True):
        return _mupdf.FzPathWalker2_use_virtual_rectto(self, use)

    def moveto(self, arg_0, arg_2, arg_3):
        r""" Default virtual method implementations; these all throw an exception."""
        return _mupdf.FzPathWalker2_moveto(self, arg_0, arg_2, arg_3)

    def lineto(self, arg_0, arg_2, arg_3):
        return _mupdf.FzPathWalker2_lineto(self, arg_0, arg_2, arg_3)

    def curveto(self, arg_0, arg_2, arg_3, arg_4, arg_5, arg_6, arg_7):
        return _mupdf.FzPathWalker2_curveto(self, arg_0, arg_2, arg_3, arg_4, arg_5, arg_6, arg_7)

    def closepath(self, arg_0):
        return _mupdf.FzPathWalker2_closepath(self, arg_0)

    def quadto(self, arg_0, arg_2, arg_3, arg_4, arg_5):
        return _mupdf.FzPathWalker2_quadto(self, arg_0, arg_2, arg_3, arg_4, arg_5)

    def curvetov(self, arg_0, arg_2, arg_3, arg_4, arg_5):
        return _mupdf.FzPathWalker2_curvetov(self, arg_0, arg_2, arg_3, arg_4, arg_5)

    def curvetoy(self, arg_0, arg_2, arg_3, arg_4, arg_5):
        return _mupdf.FzPathWalker2_curvetoy(self, arg_0, arg_2, arg_3, arg_4, arg_5)

    def rectto(self, arg_0, arg_2, arg_3, arg_4, arg_5):
        return _mupdf.FzPathWalker2_rectto(self, arg_0, arg_2, arg_3, arg_4, arg_5)
    def __disown__(self):
        self.this.disown()
        _mupdf.disown_FzPathWalker2(self)
        return weakref.proxy(self)

# Register FzPathWalker2 in _mupdf:
_mupdf.FzPathWalker2_swigregister(FzPathWalker2)
class FzPclOptions(object):
    r"""
    Wrapper class for struct `fz_pcl_options`. Not copyable or assignable.
    PCL output
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def fz_pcl_preset(self, preset):
        r"""
        Class-aware wrapper for `::fz_pcl_preset()`.
        	Initialize PCL option struct for a given preset.

        	Currently defined presets include:

        		generic	Generic PCL printer
        		ljet4	HP DeskJet
        		dj500	HP DeskJet 500
        		fs600	Kyocera FS-600
        		lj	HP LaserJet, HP LaserJet Plus
        		lj2	HP LaserJet IIp, HP LaserJet IId
        		lj3	HP LaserJet III
        		lj3d	HP LaserJet IIId
        		lj4	HP LaserJet 4
        		lj4pl	HP LaserJet 4 PL
        		lj4d	HP LaserJet 4d
        		lp2563b	HP 2563B line printer
        		oce9050	Oce 9050 Line printer
        """
        return _mupdf.FzPclOptions_fz_pcl_preset(self, preset)

    def __init__(self, *args):
        r"""
        *Overload 1:*
         == Constructors.  Constructor using `fz_parse_pcl_options()`.
        		Parse PCL options.

        		Currently defined options and values are as follows:

        			preset=X	Either "generic" or one of the presets as for fz_pcl_preset.
        			spacing=0	No vertical spacing capability
        			spacing=1	PCL 3 spacing (<ESC>*p+<n>Y)
        			spacing=2	PCL 4 spacing (<ESC>*b<n>Y)
        			spacing=3	PCL 5 spacing (<ESC>*b<n>Y and clear seed row)
        			mode2		Disable/Enable mode 2 graphics compression
        			mode3		Disable/Enable mode 3 graphics compression
        			eog_reset	End of graphics (<ESC>*rB) resets all parameters
        			has_duplex	Duplex supported (<ESC>&l<duplex>S)
        			has_papersize	Papersize setting supported (<ESC>&l<sizecode>A)
        			has_copies	Number of copies supported (<ESC>&l<copies>X)
        			is_ljet4pjl	Disable/Enable HP 4PJL model-specific output
        			is_oce9050	Disable/Enable Oce 9050 model-specific output


        |

        *Overload 2:*
         Default constructor, sets `m_internal` to null.

        |

        *Overload 3:*
         Constructor using raw copy of pre-existing `::fz_pcl_options`.
        """
        _mupdf.FzPclOptions_swiginit(self, _mupdf.new_FzPclOptions(*args))
    __swig_destroy__ = _mupdf.delete_FzPclOptions

    def m_internal_value(self):
        r""" Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.FzPclOptions_m_internal_value(self)
    m_internal = property(_mupdf.FzPclOptions_m_internal_get, _mupdf.FzPclOptions_m_internal_set, doc=r""" Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.FzPclOptions_s_num_instances_get, _mupdf.FzPclOptions_s_num_instances_set)

# Register FzPclOptions in _mupdf:
_mupdf.FzPclOptions_swigregister(FzPclOptions)
class FzPclmOptions(object):
    r"""
    Wrapper class for struct `fz_pclm_options`. Not copyable or assignable.
    PCLm output
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
         == Constructors.  Constructor using `fz_parse_pclm_options()`.
        		Parse PCLm options.

        		Currently defined options and values are as follows:

        			compression=none: No compression
        			compression=flate: Flate compression
        			strip-height=n: Strip height (default 16)


        |

        *Overload 2:*
         Construct using fz_parse_pclm_options().

        |

        *Overload 3:*
         Default constructor, sets `m_internal` to null.

        |

        *Overload 4:*
         Constructor using raw copy of pre-existing `::fz_pclm_options`.
        """
        _mupdf.FzPclmOptions_swiginit(self, _mupdf.new_FzPclmOptions(*args))
    __swig_destroy__ = _mupdf.delete_FzPclmOptions

    def m_internal_value(self):
        r""" Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.FzPclmOptions_m_internal_value(self)
    m_internal = property(_mupdf.FzPclmOptions_m_internal_get, _mupdf.FzPclmOptions_m_internal_set, doc=r""" Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.FzPclmOptions_s_num_instances_get, _mupdf.FzPclmOptions_s_num_instances_set)

# Register FzPclmOptions in _mupdf:
_mupdf.FzPclmOptions_swigregister(FzPclmOptions)
class FzPdfocrOptions(object):
    r"""
    Wrapper class for struct `fz_pdfocr_options`.
    PDFOCR output
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def fz_parse_pdfocr_options(self, args):
        r"""
        Class-aware wrapper for `::fz_parse_pdfocr_options()`.
        	Parse PDFOCR options.

        	Currently defined options and values are as follows:

        		compression=none: No compression
        		compression=flate: Flate compression
        		strip-height=n: Strip height (default 16)
        		ocr-language=<lang>: OCR Language (default eng)
        		ocr-datadir=<datadir>: OCR data path (default rely on TESSDATA_PREFIX)
        """
        return _mupdf.FzPdfocrOptions_fz_parse_pdfocr_options(self, args)

    def language_set2(self, language):
        r""" Copies <language> into this->language, truncating if necessary."""
        return _mupdf.FzPdfocrOptions_language_set2(self, language)

    def datadir_set2(self, datadir):
        r""" Copies <datadir> into this->datadir, truncating if necessary."""
        return _mupdf.FzPdfocrOptions_datadir_set2(self, datadir)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        We use default copy constructor and operator=.  Default constructor, sets each member to default value.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::fz_pdfocr_options`.

        |

        *Overload 3:*
        Constructor using raw copy of pre-existing `::fz_pdfocr_options`.
        """
        _mupdf.FzPdfocrOptions_swiginit(self, _mupdf.new_FzPdfocrOptions(*args))

    def internal(self, *args):
        r"""
        *Overload 1:*
        Access as underlying struct.

        |

        *Overload 2:*
        Access as underlying struct.
        """
        return _mupdf.FzPdfocrOptions_internal(self, *args)
    __swig_destroy__ = _mupdf.delete_FzPdfocrOptions
    compress = property(_mupdf.FzPdfocrOptions_compress_get, _mupdf.FzPdfocrOptions_compress_set)
    strip_height = property(_mupdf.FzPdfocrOptions_strip_height_get, _mupdf.FzPdfocrOptions_strip_height_set)
    language = property(_mupdf.FzPdfocrOptions_language_get, _mupdf.FzPdfocrOptions_language_set)
    datadir = property(_mupdf.FzPdfocrOptions_datadir_get, _mupdf.FzPdfocrOptions_datadir_set)
    page_count = property(_mupdf.FzPdfocrOptions_page_count_get, _mupdf.FzPdfocrOptions_page_count_set)
    s_num_instances = property(_mupdf.FzPdfocrOptions_s_num_instances_get, _mupdf.FzPdfocrOptions_s_num_instances_set)

    def to_string(self):
        r""" Returns string containing our members, labelled and inside (...), using operator<<."""
        return _mupdf.FzPdfocrOptions_to_string(self)

    def __eq__(self, rhs):
        r""" Comparison method."""
        return _mupdf.FzPdfocrOptions___eq__(self, rhs)

    def __ne__(self, rhs):
        r""" Comparison method."""
        return _mupdf.FzPdfocrOptions___ne__(self, rhs)

# Register FzPdfocrOptions in _mupdf:
_mupdf.FzPdfocrOptions_swigregister(FzPdfocrOptions)
class FzPixmap(object):
    r"""
    Wrapper class for struct `fz_pixmap`.
    Pixmaps represent a set of pixels for a 2 dimensional region of
    a plane. Each pixel has n components per pixel. The components
    are in the order process-components, spot-colors, alpha, where
    there can be 0 of any of those types. The data is in
    premultiplied alpha when rendering, but non-premultiplied for
    colorspace conversions and rescaling.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def pdf_new_pixmap_from_page_with_usage(page, ctm, cs, alpha, usage, box):
        r""" Class-aware wrapper for `::pdf_new_pixmap_from_page_with_usage()`."""
        return _mupdf.FzPixmap_pdf_new_pixmap_from_page_with_usage(page, ctm, cs, alpha, usage, box)

    @staticmethod
    def pdf_new_pixmap_from_page_with_separations_and_usage(page, ctm, cs, seps, alpha, usage, box):
        r""" Class-aware wrapper for `::pdf_new_pixmap_from_page_with_separations_and_usage()`."""
        return _mupdf.FzPixmap_pdf_new_pixmap_from_page_with_separations_and_usage(page, ctm, cs, seps, alpha, usage, box)

    @staticmethod
    def fz_new_pixmap_from_page_contents(page, ctm, cs, alpha):
        r"""
        Class-aware wrapper for `::fz_new_pixmap_from_page_contents()`.
        	Render the page contents without annotations.

        	Ownership of the pixmap is returned to the caller.
        """
        return _mupdf.FzPixmap_fz_new_pixmap_from_page_contents(page, ctm, cs, alpha)

    @staticmethod
    def fz_new_pixmap_from_page_contents_with_separations(page, ctm, cs, seps, alpha):
        r""" Class-aware wrapper for `::fz_new_pixmap_from_page_contents_with_separations()`."""
        return _mupdf.FzPixmap_fz_new_pixmap_from_page_contents_with_separations(page, ctm, cs, seps, alpha)

    def fz_alpha_from_gray(self):
        r""" Class-aware wrapper for `::fz_alpha_from_gray()`."""
        return _mupdf.FzPixmap_fz_alpha_from_gray(self)

    def fz_clear_pixmap(self):
        r"""
        Class-aware wrapper for `::fz_clear_pixmap()`.
        	Sets all components (including alpha) of
        	all pixels in a pixmap to 0.

        	pix: The pixmap to clear.
        """
        return _mupdf.FzPixmap_fz_clear_pixmap(self)

    def fz_clear_pixmap_rect_with_value(self, value, r):
        r"""
        Class-aware wrapper for `::fz_clear_pixmap_rect_with_value()`.
        	Clears a subrect of a pixmap with the given value.

        	pix: The pixmap to clear.

        	value: Values in the range 0 to 255 are valid. Each component
        	sample for each pixel in the pixmap will be set to this value,
        	while alpha will always be set to 255 (non-transparent).

        	r: the rectangle.
        """
        return _mupdf.FzPixmap_fz_clear_pixmap_rect_with_value(self, value, r)

    def fz_clear_pixmap_with_value(self, value):
        r"""
        Class-aware wrapper for `::fz_clear_pixmap_with_value()`.
        	Clears a pixmap with the given value.

        	pix: The pixmap to clear.

        	value: Values in the range 0 to 255 are valid. Each component
        	sample for each pixel in the pixmap will be set to this value,
        	while alpha will always be set to 255 (non-transparent).

        	This function is horrible, and should be removed from the
        	API and replaced with a less magic one.
        """
        return _mupdf.FzPixmap_fz_clear_pixmap_with_value(self, value)

    def fz_clone_pixmap(self):
        r"""
        Class-aware wrapper for `::fz_clone_pixmap()`.
        	Clone a pixmap, copying the pixels and associated data to new
        	storage.

        	The reference count of 'old' is unchanged.
        """
        return _mupdf.FzPixmap_fz_clone_pixmap(self)

    def fz_clone_pixmap_area_with_different_seps(self, bbox, dcs, seps, color_params, default_cs):
        r""" Class-aware wrapper for `::fz_clone_pixmap_area_with_different_seps()`."""
        return _mupdf.FzPixmap_fz_clone_pixmap_area_with_different_seps(self, bbox, dcs, seps, color_params, default_cs)

    def fz_convert_indexed_pixmap_to_base(self):
        r"""
        Class-aware wrapper for `::fz_convert_indexed_pixmap_to_base()`.
        	Convert pixmap from indexed to base colorspace.

        	This creates a new bitmap containing the converted pixmap data.
        """
        return _mupdf.FzPixmap_fz_convert_indexed_pixmap_to_base(self)

    def fz_convert_pixmap(self, cs_des, prf, default_cs, color_params, keep_alpha):
        r"""
        Class-aware wrapper for `::fz_convert_pixmap()`.
        	Convert an existing pixmap to a desired
        	colorspace. Other properties of the pixmap, such as resolution
        	and position are copied to the converted pixmap.

        	pix: The pixmap to convert.

        	default_cs: If NULL pix->colorspace is used. It is possible that
        	the data may need to be interpreted as one of the color spaces
        	in default_cs.

        	cs_des: Desired colorspace, may be NULL to denote alpha-only.

        	prf: Proofing color space through which we need to convert.

        	color_params: Parameters that may be used in conversion (e.g.
        	ri).

        	keep_alpha: If 0 any alpha component is removed, otherwise
        	alpha is kept if present in the pixmap.
        """
        return _mupdf.FzPixmap_fz_convert_pixmap(self, cs_des, prf, default_cs, color_params, keep_alpha)

    def fz_convert_separation_pixmap_to_base(self):
        r"""
        Class-aware wrapper for `::fz_convert_separation_pixmap_to_base()`.
        	Convert pixmap from DeviceN/Separation to base colorspace.

        	This creates a new bitmap containing the converted pixmap data.
        """
        return _mupdf.FzPixmap_fz_convert_separation_pixmap_to_base(self)

    def fz_copy_pixmap_rect(self, src, r, default_cs):
        r""" Class-aware wrapper for `::fz_copy_pixmap_rect()`."""
        return _mupdf.FzPixmap_fz_copy_pixmap_rect(self, src, r, default_cs)

    def fz_decode_tile(self, decode):
        r""" Class-aware wrapper for `::fz_decode_tile()`."""
        return _mupdf.FzPixmap_fz_decode_tile(self, decode)

    def fz_fill_pixmap_with_color(self, colorspace, color, color_params):
        r"""
        Class-aware wrapper for `::fz_fill_pixmap_with_color()`.

        This method has out-params. Python/C# wrappers look like:
        	`fz_fill_pixmap_with_color(::fz_colorspace *colorspace, ::fz_color_params color_params)` => float color

        	Fill pixmap with solid color.
        """
        return _mupdf.FzPixmap_fz_fill_pixmap_with_color(self, colorspace, color, color_params)

    def fz_gamma_pixmap(self, gamma):
        r"""
        Class-aware wrapper for `::fz_gamma_pixmap()`.
        	Apply gamma correction to a pixmap. All components
        	of all pixels are modified (except alpha, which is unchanged).

        	gamma: The gamma value to apply; 1.0 for no change.
        """
        return _mupdf.FzPixmap_fz_gamma_pixmap(self, gamma)

    def fz_generate_transition(self, opix, npix, time, trans):
        r"""
        Class-aware wrapper for `::fz_generate_transition()`.
        	Generate a frame of a transition.

        	tpix: Target pixmap
        	opix: Old pixmap
        	npix: New pixmap
        	time: Position within the transition (0 to 256)
        	trans: Transition details

        	Returns 1 if successfully generated a frame.

        	Note: Pixmaps must include alpha.
        """
        return _mupdf.FzPixmap_fz_generate_transition(self, opix, npix, time, trans)

    def fz_invert_pixmap(self):
        r"""
        Class-aware wrapper for `::fz_invert_pixmap()`.
        	Invert all the pixels in a pixmap. All components (process and
        	spots) of all pixels are inverted (except alpha, which is
        	unchanged).
        """
        return _mupdf.FzPixmap_fz_invert_pixmap(self)

    def fz_invert_pixmap_alpha(self):
        r"""
        Class-aware wrapper for `::fz_invert_pixmap_alpha()`.
        	Invert the alpha fo all the pixels in a pixmap.
        """
        return _mupdf.FzPixmap_fz_invert_pixmap_alpha(self)

    def fz_invert_pixmap_luminance(self):
        r"""
        Class-aware wrapper for `::fz_invert_pixmap_luminance()`.
        	Transform the pixels in a pixmap so that luminance of each
        	pixel is inverted, and the chrominance remains unchanged (as
        	much as accuracy allows).

        	All components of all pixels are inverted (except alpha, which
        	is unchanged). Only supports Grey and RGB bitmaps.
        """
        return _mupdf.FzPixmap_fz_invert_pixmap_luminance(self)

    def fz_invert_pixmap_raw(self):
        r"""
        Class-aware wrapper for `::fz_invert_pixmap_raw()`.
        	Invert all the pixels in a non-premultiplied pixmap in a
        	very naive manner.
        """
        return _mupdf.FzPixmap_fz_invert_pixmap_raw(self)

    def fz_invert_pixmap_rect(self, rect):
        r"""
        Class-aware wrapper for `::fz_invert_pixmap_rect()`.
        	Invert all the pixels in a given rectangle of a (premultiplied)
        	pixmap. All components of all pixels in the rectangle are
        	inverted (except alpha, which is unchanged).
        """
        return _mupdf.FzPixmap_fz_invert_pixmap_rect(self, rect)

    def fz_is_pixmap_monochrome(self):
        r"""
        Class-aware wrapper for `::fz_is_pixmap_monochrome()`.
        	Check if the pixmap is a 1-channel image containing samples with
        	only values 0 and 255
        """
        return _mupdf.FzPixmap_fz_is_pixmap_monochrome(self)

    def fz_md5_pixmap(self, digest):
        r""" Class-aware wrapper for `::fz_md5_pixmap()`."""
        return _mupdf.FzPixmap_fz_md5_pixmap(self, digest)

    def fz_md5_pixmap2(self):
        r"""
        Class-aware wrapper for `::fz_md5_pixmap2()`.
        C++ alternative to `fz_md5_pixmap()` that returns the digest by value.
        """
        return _mupdf.FzPixmap_fz_md5_pixmap2(self)

    def fz_new_bitmap_from_pixmap(self, ht):
        r"""
        Class-aware wrapper for `::fz_new_bitmap_from_pixmap()`.
        	Make a bitmap from a pixmap and a halftone.

        	pix: The pixmap to generate from. Currently must be a single
        	color component with no alpha.

        	ht: The halftone to use. NULL implies the default halftone.

        	Returns the resultant bitmap. Throws exceptions in the case of
        	failure to allocate.
        """
        return _mupdf.FzPixmap_fz_new_bitmap_from_pixmap(self, ht)

    def fz_new_bitmap_from_pixmap_band(self, ht, band_start):
        r"""
        Class-aware wrapper for `::fz_new_bitmap_from_pixmap_band()`.
        	Make a bitmap from a pixmap and a
        	halftone, allowing for the position of the pixmap within an
        	overall banded rendering.

        	pix: The pixmap to generate from. Currently must be a single
        	color component with no alpha.

        	ht: The halftone to use. NULL implies the default halftone.

        	band_start: Vertical offset within the overall banded rendering
        	(in pixels)

        	Returns the resultant bitmap. Throws exceptions in the case of
        	failure to allocate.
        """
        return _mupdf.FzPixmap_fz_new_bitmap_from_pixmap_band(self, ht, band_start)

    def fz_new_buffer_from_pixmap_as_jpeg(self, color_params, quality, invert_cmyk):
        r""" Class-aware wrapper for `::fz_new_buffer_from_pixmap_as_jpeg()`."""
        return _mupdf.FzPixmap_fz_new_buffer_from_pixmap_as_jpeg(self, color_params, quality, invert_cmyk)

    def fz_new_buffer_from_pixmap_as_jpx(self, color_params, quality):
        r""" Class-aware wrapper for `::fz_new_buffer_from_pixmap_as_jpx()`."""
        return _mupdf.FzPixmap_fz_new_buffer_from_pixmap_as_jpx(self, color_params, quality)

    def fz_new_buffer_from_pixmap_as_pam(self, color_params):
        r""" Class-aware wrapper for `::fz_new_buffer_from_pixmap_as_pam()`."""
        return _mupdf.FzPixmap_fz_new_buffer_from_pixmap_as_pam(self, color_params)

    def fz_new_buffer_from_pixmap_as_png(self, color_params):
        r"""
        Class-aware wrapper for `::fz_new_buffer_from_pixmap_as_png()`.
        	Reencode a given pixmap as a PNG into a buffer.

        	Ownership of the buffer is returned.
        """
        return _mupdf.FzPixmap_fz_new_buffer_from_pixmap_as_png(self, color_params)

    def fz_new_buffer_from_pixmap_as_pnm(self, color_params):
        r""" Class-aware wrapper for `::fz_new_buffer_from_pixmap_as_pnm()`."""
        return _mupdf.FzPixmap_fz_new_buffer_from_pixmap_as_pnm(self, color_params)

    def fz_new_buffer_from_pixmap_as_psd(self, color_params):
        r""" Class-aware wrapper for `::fz_new_buffer_from_pixmap_as_psd()`."""
        return _mupdf.FzPixmap_fz_new_buffer_from_pixmap_as_psd(self, color_params)

    def fz_new_image_from_pixmap(self, mask):
        r"""
        Class-aware wrapper for `::fz_new_image_from_pixmap()`.
        	Create an image from the given
        	pixmap.

        	pixmap: The pixmap to base the image upon. A new reference
        	to this is taken.

        	mask: NULL, or another image to use as a mask for this one.
        	A new reference is taken to this image. Supplying a masked
        	image as a mask to another image is illegal!
        """
        return _mupdf.FzPixmap_fz_new_image_from_pixmap(self, mask)

    def fz_new_pixmap_from_alpha_channel(self):
        r""" Class-aware wrapper for `::fz_new_pixmap_from_alpha_channel()`."""
        return _mupdf.FzPixmap_fz_new_pixmap_from_alpha_channel(self)

    def fz_new_pixmap_from_color_and_mask(self, mask):
        r""" Class-aware wrapper for `::fz_new_pixmap_from_color_and_mask()`."""
        return _mupdf.FzPixmap_fz_new_pixmap_from_color_and_mask(self, mask)

    def fz_new_pixmap_from_pixmap(self, rect):
        r"""
        Class-aware wrapper for `::fz_new_pixmap_from_pixmap()`.
        	Create a new pixmap that represents a subarea of the specified
        	pixmap. A reference is taken to this pixmap that will be dropped
        	on destruction.

        	The supplied rectangle must be wholly contained within the
        	original pixmap.

        	Returns a pointer to the new pixmap. Throws exception on failure
        	to allocate.
        """
        return _mupdf.FzPixmap_fz_new_pixmap_from_pixmap(self, rect)

    def fz_pixmap_alpha(self):
        r"""
        Class-aware wrapper for `::fz_pixmap_alpha()`.
        	Return the number of alpha planes in a pixmap.

        	Returns the number of alphas. Does not throw exceptions.
        """
        return _mupdf.FzPixmap_fz_pixmap_alpha(self)

    def fz_pixmap_bbox(self):
        r"""
        Class-aware wrapper for `::fz_pixmap_bbox()`.
        	Return the bounding box for a pixmap.
        """
        return _mupdf.FzPixmap_fz_pixmap_bbox(self)

    def fz_pixmap_colorants(self):
        r"""
        Class-aware wrapper for `::fz_pixmap_colorants()`.
        	Return the number of colorants in a pixmap.

        	Returns the number of colorants (components, less any spots and
        	alpha).
        """
        return _mupdf.FzPixmap_fz_pixmap_colorants(self)

    def fz_pixmap_colorspace(self):
        r"""
        Class-aware wrapper for `::fz_pixmap_colorspace()`.
        	Return the colorspace of a pixmap

        	Returns colorspace.
        """
        return _mupdf.FzPixmap_fz_pixmap_colorspace(self)

    def fz_pixmap_components(self):
        r"""
        Class-aware wrapper for `::fz_pixmap_components()`.
        	Return the number of components in a pixmap.

        	Returns the number of components (including spots and alpha).
        """
        return _mupdf.FzPixmap_fz_pixmap_components(self)

    def fz_pixmap_height(self):
        r"""
        Class-aware wrapper for `::fz_pixmap_height()`.
        	Return the height of the pixmap in pixels.
        """
        return _mupdf.FzPixmap_fz_pixmap_height(self)

    def fz_pixmap_samples(self):
        r"""
        Class-aware wrapper for `::fz_pixmap_samples()`.
        	Returns a pointer to the pixel data of a pixmap.

        	Returns the pointer.
        """
        return _mupdf.FzPixmap_fz_pixmap_samples(self)

    def fz_pixmap_samples_int(self):
        r""" Class-aware wrapper for `::fz_pixmap_samples_int()`."""
        return _mupdf.FzPixmap_fz_pixmap_samples_int(self)

    def fz_pixmap_size(self):
        r"""
        Class-aware wrapper for `::fz_pixmap_size()`.
        	Return sizeof fz_pixmap plus size of data, in bytes.
        """
        return _mupdf.FzPixmap_fz_pixmap_size(self)

    def fz_pixmap_spots(self):
        r"""
        Class-aware wrapper for `::fz_pixmap_spots()`.
        	Return the number of spots in a pixmap.

        	Returns the number of spots (components, less colorants and
        	alpha). Does not throw exceptions.
        """
        return _mupdf.FzPixmap_fz_pixmap_spots(self)

    def fz_pixmap_stride(self):
        r"""
        Class-aware wrapper for `::fz_pixmap_stride()`.
        	Return the number of bytes in a row in the pixmap.
        """
        return _mupdf.FzPixmap_fz_pixmap_stride(self)

    def fz_pixmap_width(self):
        r"""
        Class-aware wrapper for `::fz_pixmap_width()`.
        	Return the width of the pixmap in pixels.
        """
        return _mupdf.FzPixmap_fz_pixmap_width(self)

    def fz_pixmap_x(self):
        r"""
        Class-aware wrapper for `::fz_pixmap_x()`.
        	Return the x value of the pixmap in pixels.
        """
        return _mupdf.FzPixmap_fz_pixmap_x(self)

    def fz_pixmap_y(self):
        r"""
        Class-aware wrapper for `::fz_pixmap_y()`.
        	Return the y value of the pixmap in pixels.
        """
        return _mupdf.FzPixmap_fz_pixmap_y(self)

    def fz_samples_get(self, offset):
        r"""
        Class-aware wrapper for `::fz_samples_get()`.
        Provides simple (but slow) access to pixmap data from Python and C#.
        """
        return _mupdf.FzPixmap_fz_samples_get(self, offset)

    def fz_samples_set(self, offset, value):
        r"""
        Class-aware wrapper for `::fz_samples_set()`.
        Provides simple (but slow) write access to pixmap data from Python and
        C#.
        """
        return _mupdf.FzPixmap_fz_samples_set(self, offset, value)

    def fz_save_pixmap_as_jpeg(self, filename, quality):
        r"""
        Class-aware wrapper for `::fz_save_pixmap_as_jpeg()`.
        	Save a pixmap as a JPEG.
        """
        return _mupdf.FzPixmap_fz_save_pixmap_as_jpeg(self, filename, quality)

    def fz_save_pixmap_as_jpx(self, filename, q):
        r"""
        Class-aware wrapper for `::fz_save_pixmap_as_jpx()`.
        	Save pixmap data as JP2K with no subsampling.

        	quality = 100 = lossless
        	otherwise for a factor of x compression use 100-x. (so 80 is 1:20 compression)
        """
        return _mupdf.FzPixmap_fz_save_pixmap_as_jpx(self, filename, q)

    def fz_save_pixmap_as_pam(self, filename):
        r"""
        Class-aware wrapper for `::fz_save_pixmap_as_pam()`.
        	Save a pixmap as a pnm (greyscale, rgb or cmyk, with or without
        	alpha).
        """
        return _mupdf.FzPixmap_fz_save_pixmap_as_pam(self, filename)

    def fz_save_pixmap_as_pbm(self, filename):
        r"""
        Class-aware wrapper for `::fz_save_pixmap_as_pbm()`.
        	Save a pixmap as a pbm. (Performing halftoning).
        """
        return _mupdf.FzPixmap_fz_save_pixmap_as_pbm(self, filename)

    def fz_save_pixmap_as_pcl(self, filename, append, pcl):
        r"""
        Class-aware wrapper for `::fz_save_pixmap_as_pcl()`.
        	Save an (RGB) pixmap as color PCL.
        """
        return _mupdf.FzPixmap_fz_save_pixmap_as_pcl(self, filename, append, pcl)

    def fz_save_pixmap_as_pclm(self, filename, append, options):
        r"""
        Class-aware wrapper for `::fz_save_pixmap_as_pclm()`.
        	Save a (Greyscale or RGB) pixmap as pclm.
        """
        return _mupdf.FzPixmap_fz_save_pixmap_as_pclm(self, filename, append, options)

    def fz_save_pixmap_as_pdfocr(self, filename, append, options):
        r"""
        Class-aware wrapper for `::fz_save_pixmap_as_pdfocr()`.
        	Save a (Greyscale or RGB) pixmap as pdfocr.
        """
        return _mupdf.FzPixmap_fz_save_pixmap_as_pdfocr(self, filename, append, options)

    def fz_save_pixmap_as_pkm(self, filename):
        r"""
        Class-aware wrapper for `::fz_save_pixmap_as_pkm()`.
        	Save a CMYK pixmap as a pkm. (Performing halftoning).
        """
        return _mupdf.FzPixmap_fz_save_pixmap_as_pkm(self, filename)

    def fz_save_pixmap_as_png(self, filename):
        r"""
        Class-aware wrapper for `::fz_save_pixmap_as_png()`.
        	Save a (Greyscale or RGB) pixmap as a png.
        """
        return _mupdf.FzPixmap_fz_save_pixmap_as_png(self, filename)

    def fz_save_pixmap_as_pnm(self, filename):
        r"""
        Class-aware wrapper for `::fz_save_pixmap_as_pnm()`.
        	Save a pixmap as a pnm (greyscale or rgb, no alpha).
        """
        return _mupdf.FzPixmap_fz_save_pixmap_as_pnm(self, filename)

    def fz_save_pixmap_as_ps(self, filename, append):
        r"""
        Class-aware wrapper for `::fz_save_pixmap_as_ps()`.
        	Save a (gray, rgb, or cmyk, no alpha) pixmap out as postscript.
        """
        return _mupdf.FzPixmap_fz_save_pixmap_as_ps(self, filename, append)

    def fz_save_pixmap_as_psd(self, filename):
        r"""
        Class-aware wrapper for `::fz_save_pixmap_as_psd()`.
        	Save a pixmap as a PSD file.
        """
        return _mupdf.FzPixmap_fz_save_pixmap_as_psd(self, filename)

    def fz_save_pixmap_as_pwg(self, filename, append, pwg):
        r"""
        Class-aware wrapper for `::fz_save_pixmap_as_pwg()`.
        	Save a pixmap as a PWG.
        """
        return _mupdf.FzPixmap_fz_save_pixmap_as_pwg(self, filename, append, pwg)

    def fz_scale_pixmap(self, x, y, w, h, clip):
        r""" Class-aware wrapper for `::fz_scale_pixmap()`."""
        return _mupdf.FzPixmap_fz_scale_pixmap(self, x, y, w, h, clip)

    def fz_set_pixmap_resolution(self, xres, yres):
        r"""
        Class-aware wrapper for `::fz_set_pixmap_resolution()`.
        	Set the pixels per inch resolution of the pixmap.
        """
        return _mupdf.FzPixmap_fz_set_pixmap_resolution(self, xres, yres)

    def fz_subsample_pixmap(self, factor):
        r""" Class-aware wrapper for `::fz_subsample_pixmap()`."""
        return _mupdf.FzPixmap_fz_subsample_pixmap(self, factor)

    def fz_tint_pixmap(self, black, white):
        r"""
        Class-aware wrapper for `::fz_tint_pixmap()`.
        	Tint all the pixels in an RGB, BGR, or Gray pixmap.

        	black: Map black to this hexadecimal RGB color.

        	white: Map white to this hexadecimal RGB color.
        """
        return _mupdf.FzPixmap_fz_tint_pixmap(self, black, white)

    def __init__(self, *args):
        r"""
        *Overload 1:*
         == Constructors.  Constructor using `fz_new_pixmap()`.
        		Create a new pixmap, with its origin at (0,0)

        		cs: The colorspace to use for the pixmap, or NULL for an alpha
        		plane/mask.

        		w: The width of the pixmap (in pixels)

        		h: The height of the pixmap (in pixels)

        		seps: Details of separations.

        		alpha: 0 for no alpha, 1 for alpha.

        		Returns a pointer to the new pixmap. Throws exception on failure
        		to allocate.


        |

        *Overload 2:*
         Constructor using `fz_new_pixmap_from_color_and_mask()`.

        |

        *Overload 3:*
         Constructor using `fz_new_pixmap_from_display_list()`.
        		Render the page to a pixmap using the transform and colorspace.

        		Ownership of the pixmap is returned to the caller.


        |

        *Overload 4:*
         Constructor using `fz_new_pixmap_from_display_list_with_separations()`.
        		Render the page contents with control over spot colors.

        		Ownership of the pixmap is returned to the caller.


        |

        *Overload 5:*
         Constructor using `fz_new_pixmap_from_page()`.

        |

        *Overload 6:*
         Constructor using `fz_new_pixmap_from_page_number()`.

        |

        *Overload 7:*
         Constructor using `fz_new_pixmap_from_page_number_with_separations()`.

        |

        *Overload 8:*
         Constructor using `fz_new_pixmap_from_page_with_separations()`.

        |

        *Overload 9:*
         Constructor using `fz_new_pixmap_from_pixmap()`.
        		Create a new pixmap that represents a subarea of the specified
        		pixmap. A reference is taken to this pixmap that will be dropped
        		on destruction.

        		The supplied rectangle must be wholly contained within the
        		original pixmap.

        		Returns a pointer to the new pixmap. Throws exception on failure
        		to allocate.


        |

        *Overload 10:*
         Constructor using `fz_new_pixmap_with_bbox()`.
        		Create a pixmap of a given size, location and pixel format.

        		The bounding box specifies the size of the created pixmap and
        		where it will be located. The colorspace determines the number
        		of components per pixel. Alpha is always present. Pixmaps are
        		reference counted, so drop references using fz_drop_pixmap.

        		colorspace: Colorspace format used for the created pixmap. The
        		pixmap will keep a reference to the colorspace.

        		bbox: Bounding box specifying location/size of created pixmap.

        		seps: Details of separations.

        		alpha: 0 for no alpha, 1 for alpha.

        		Returns a pointer to the new pixmap. Throws exception on failure
        		to allocate.


        |

        *Overload 11:*
         Constructor using `fz_new_pixmap_with_bbox_and_data()`.
        		Create a pixmap of a given size, location and pixel format,
        		using the supplied data block.

        		The bounding box specifies the size of the created pixmap and
        		where it will be located. The colorspace determines the number
        		of components per pixel. Alpha is always present. Pixmaps are
        		reference counted, so drop references using fz_drop_pixmap.

        		colorspace: Colorspace format used for the created pixmap. The
        		pixmap will keep a reference to the colorspace.

        		rect: Bounding box specifying location/size of created pixmap.

        		seps: Details of separations.

        		alpha: Number of alpha planes (0 or 1).

        		samples: The data block to keep the samples in.

        		Returns a pointer to the new pixmap. Throws exception on failure
        		to allocate.


        |

        *Overload 12:*
         Constructor using `fz_new_pixmap_with_data()`.
        		Create a new pixmap, with its origin at
        		(0,0) using the supplied data block.

        		cs: The colorspace to use for the pixmap, or NULL for an alpha
        		plane/mask.

        		w: The width of the pixmap (in pixels)

        		h: The height of the pixmap (in pixels)

        		seps: Details of separations.

        		alpha: 0 for no alpha, 1 for alpha.

        		stride: The byte offset from the pixel data in a row to the
        		pixel data in the next row.

        		samples: The data block to keep the samples in.

        		Returns a pointer to the new pixmap. Throws exception on failure to
        		allocate.


        |

        *Overload 13:*
         Constructor using `pdf_new_pixmap_from_annot()`.

        |

        *Overload 14:*
         Constructor using `pdf_new_pixmap_from_page_contents_with_separations_and_usage()`.

        |

        *Overload 15:*
         Constructor using `pdf_new_pixmap_from_page_contents_with_usage()`.

        |

        *Overload 16:*
         Copy constructor using `fz_keep_pixmap()`.

        |

        *Overload 17:*
         Default constructor, sets `m_internal` to null.

        |

        *Overload 18:*
         Constructor using raw copy of pre-existing `::fz_pixmap`.
        """
        _mupdf.FzPixmap_swiginit(self, _mupdf.new_FzPixmap(*args))

    def storable(self):
        return _mupdf.FzPixmap_storable(self)

    def x(self):
        return _mupdf.FzPixmap_x(self)

    def y(self):
        return _mupdf.FzPixmap_y(self)

    def w(self):
        return _mupdf.FzPixmap_w(self)

    def h(self):
        return _mupdf.FzPixmap_h(self)

    def n(self):
        return _mupdf.FzPixmap_n(self)

    def s(self):
        return _mupdf.FzPixmap_s(self)

    def alpha(self):
        return _mupdf.FzPixmap_alpha(self)

    def flags(self):
        return _mupdf.FzPixmap_flags(self)

    def stride(self):
        return _mupdf.FzPixmap_stride(self)

    def seps(self):
        return _mupdf.FzPixmap_seps(self)

    def xres(self):
        return _mupdf.FzPixmap_xres(self)

    def yres(self):
        return _mupdf.FzPixmap_yres(self)

    def colorspace(self):
        return _mupdf.FzPixmap_colorspace(self)

    def samples(self):
        return _mupdf.FzPixmap_samples(self)

    def underlying(self):
        return _mupdf.FzPixmap_underlying(self)
    __swig_destroy__ = _mupdf.delete_FzPixmap

    def m_internal_value(self):
        r""" Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.FzPixmap_m_internal_value(self)
    m_internal = property(_mupdf.FzPixmap_m_internal_get, _mupdf.FzPixmap_m_internal_set, doc=r""" Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.FzPixmap_s_num_instances_get, _mupdf.FzPixmap_s_num_instances_set)

# Register FzPixmap in _mupdf:
_mupdf.FzPixmap_swigregister(FzPixmap)
class FzPixmapImage(object):
    r""" Wrapper class for struct `fz_pixmap_image`. Not copyable or assignable."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def fz_pixmap_image_tile(self):
        r"""
        Class-aware wrapper for `::fz_pixmap_image_tile()`.
        	Retrieve the underlying fz_pixmap for an image.

        	Returns a pointer to the underlying fz_pixmap for an image,
        	or NULL if this image is not based upon an fz_pixmap.

        	No reference is returned. Lifespan is limited to that of
        	the image itself. If required, use fz_keep_pixmap to take
        	a reference to keep it longer.
        """
        return _mupdf.FzPixmapImage_fz_pixmap_image_tile(self)

    def fz_set_pixmap_image_tile(self, pix):
        r""" Class-aware wrapper for `::fz_set_pixmap_image_tile()`."""
        return _mupdf.FzPixmapImage_fz_set_pixmap_image_tile(self, pix)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::fz_pixmap_image`.
        """
        _mupdf.FzPixmapImage_swiginit(self, _mupdf.new_FzPixmapImage(*args))
    __swig_destroy__ = _mupdf.delete_FzPixmapImage

    def m_internal_value(self):
        r""" Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.FzPixmapImage_m_internal_value(self)
    m_internal = property(_mupdf.FzPixmapImage_m_internal_get, _mupdf.FzPixmapImage_m_internal_set, doc=r""" Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.FzPixmapImage_s_num_instances_get, _mupdf.FzPixmapImage_s_num_instances_set)

# Register FzPixmapImage in _mupdf:
_mupdf.FzPixmapImage_swigregister(FzPixmapImage)
class FzPoint(object):
    r"""
    Wrapper class for struct `fz_point`.
    fz_point is a point in a two-dimensional space.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def fz_transform_point_xy(x, y, m):
        r""" Class-aware wrapper for `::fz_transform_point_xy()`."""
        return _mupdf.FzPoint_fz_transform_point_xy(x, y, m)

    def fz_is_point_inside_quad(self, q):
        r"""
        Class-aware wrapper for `::fz_is_point_inside_quad()`.
        	Inclusion test for quads.
        """
        return _mupdf.FzPoint_fz_is_point_inside_quad(self, q)

    def fz_is_point_inside_rect(self, r):
        r"""
        Class-aware wrapper for `::fz_is_point_inside_rect()`.
        	Inclusion test for rects. (Rect is assumed to be open, i.e.
        	top right corner is not included).
        """
        return _mupdf.FzPoint_fz_is_point_inside_rect(self, r)

    def fz_normalize_vector(self):
        r"""
        Class-aware wrapper for `::fz_normalize_vector()`.
        	Normalize a vector to length one.
        """
        return _mupdf.FzPoint_fz_normalize_vector(self)

    def fz_transform_point(self, *args):
        r"""
        *Overload 1:*
         Class-aware wrapper for `::fz_transform_point()`.
        		Apply a transformation to a point.

        		transform: Transformation matrix to apply. See fz_concat,
        		fz_scale, fz_rotate and fz_translate for how to create a
        		matrix.

        		point: Pointer to point to update.

        		Returns transform (unchanged).


        |

        *Overload 2:*
         Class-aware wrapper for `::fz_transform_point()`.
        		Apply a transformation to a point.

        		transform: Transformation matrix to apply. See fz_concat,
        		fz_scale, fz_rotate and fz_translate for how to create a
        		matrix.

        		point: Pointer to point to update.

        		Returns transform (unchanged).
        """
        return _mupdf.FzPoint_fz_transform_point(self, *args)

    def fz_transform_vector(self, *args):
        r"""
        *Overload 1:*
         Class-aware wrapper for `::fz_transform_vector()`.
        		Apply a transformation to a vector.

        		transform: Transformation matrix to apply. See fz_concat,
        		fz_scale and fz_rotate for how to create a matrix. Any
        		translation will be ignored.

        		vector: Pointer to vector to update.


        |

        *Overload 2:*
         Class-aware wrapper for `::fz_transform_vector()`.
        		Apply a transformation to a vector.

        		transform: Transformation matrix to apply. See fz_concat,
        		fz_scale and fz_rotate for how to create a matrix. Any
        		translation will be ignored.

        		vector: Pointer to vector to update.
        """
        return _mupdf.FzPoint_fz_transform_vector(self, *args)

    def transform(self, m):
        r""" Post-multiply *this by <m> and return *this."""
        return _mupdf.FzPoint_transform(self, m)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Construct using specified values.

        |

        *Overload 2:*
        We use default copy constructor and operator=.  Default constructor, sets each member to default value.

        |

        *Overload 3:*
        Constructor using raw copy of pre-existing `::fz_point`.

        |

        *Overload 4:*
        Constructor using raw copy of pre-existing `::fz_point`.
        """
        _mupdf.FzPoint_swiginit(self, _mupdf.new_FzPoint(*args))

    def internal(self, *args):
        r"""
        *Overload 1:*
        Access as underlying struct.

        |

        *Overload 2:*
        Access as underlying struct.
        """
        return _mupdf.FzPoint_internal(self, *args)
    __swig_destroy__ = _mupdf.delete_FzPoint
    x = property(_mupdf.FzPoint_x_get, _mupdf.FzPoint_x_set)
    y = property(_mupdf.FzPoint_y_get, _mupdf.FzPoint_y_set)
    s_num_instances = property(_mupdf.FzPoint_s_num_instances_get, _mupdf.FzPoint_s_num_instances_set)

    def to_string(self):
        r""" Returns string containing our members, labelled and inside (...), using operator<<."""
        return _mupdf.FzPoint_to_string(self)

    def __eq__(self, rhs):
        r""" Comparison method."""
        return _mupdf.FzPoint___eq__(self, rhs)

    def __ne__(self, rhs):
        r""" Comparison method."""
        return _mupdf.FzPoint___ne__(self, rhs)

# Register FzPoint in _mupdf:
_mupdf.FzPoint_swigregister(FzPoint)
class FzPool(object):
    r"""
    Wrapper class for struct `fz_pool`. Not copyable or assignable.
    Simple pool allocators.

    Allocate from the pool, which can then be freed at once.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def fz_pool_alloc(self, size):
        r"""
        Class-aware wrapper for `::fz_pool_alloc()`.
        	Allocate a block of size bytes from the pool.
        """
        return _mupdf.FzPool_fz_pool_alloc(self, size)

    def fz_pool_size(self):
        r"""
        Class-aware wrapper for `::fz_pool_size()`.
        	The current size of the pool.

        	The number of bytes of storage currently allocated to the pool.
        	This is the total of the storage used for the blocks making
        	up the pool, rather then total of the allocated blocks so far,
        	so it will increase in 'lumps'.
        	from the pool, then the pool size may still be X
        """
        return _mupdf.FzPool_fz_pool_size(self)

    def fz_pool_strdup(self, s):
        r"""
        Class-aware wrapper for `::fz_pool_strdup()`.
        	strdup equivalent allocating from the pool.
        """
        return _mupdf.FzPool_fz_pool_strdup(self, s)

    def fz_xml_add_att(self, node, key, val):
        r"""
        Class-aware wrapper for `::fz_xml_add_att()`.
        	Add an attribute to an XML node.
        """
        return _mupdf.FzPool_fz_xml_add_att(self, node, key, val)

    def __init__(self, *args):
        r"""
        *Overload 1:*
         == Constructors.  Constructor using `fz_new_pool()`.
        		Create a new pool to allocate from.


        |

        *Overload 2:*
         Constructor using raw copy of pre-existing `::fz_pool`.
        """
        _mupdf.FzPool_swiginit(self, _mupdf.new_FzPool(*args))
    __swig_destroy__ = _mupdf.delete_FzPool

    def m_internal_value(self):
        r""" Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.FzPool_m_internal_value(self)
    m_internal = property(_mupdf.FzPool_m_internal_get, _mupdf.FzPool_m_internal_set, doc=r""" Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.FzPool_s_num_instances_get, _mupdf.FzPool_s_num_instances_set)

# Register FzPool in _mupdf:
_mupdf.FzPool_swigregister(FzPool)
class FzPtrHeap(object):
    r""" Wrapper class for struct `fz_ptr_heap`. Not copyable or assignable."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def fz_ptr_heap_insert(self, v, HEAP_CMP):
        r""" Class-aware wrapper for `::fz_ptr_heap_insert()`."""
        return _mupdf.FzPtrHeap_fz_ptr_heap_insert(self, v, HEAP_CMP)

    def fz_ptr_heap_sort(self, HEAP_CMP):
        r""" Class-aware wrapper for `::fz_ptr_heap_sort()`."""
        return _mupdf.FzPtrHeap_fz_ptr_heap_sort(self, HEAP_CMP)

    def fz_ptr_heap_uniq(self, HEAP_CMP):
        r""" Class-aware wrapper for `::fz_ptr_heap_uniq()`."""
        return _mupdf.FzPtrHeap_fz_ptr_heap_uniq(self, HEAP_CMP)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::fz_ptr_heap`.
        """
        _mupdf.FzPtrHeap_swiginit(self, _mupdf.new_FzPtrHeap(*args))
    __swig_destroy__ = _mupdf.delete_FzPtrHeap

    def m_internal_value(self):
        r""" Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.FzPtrHeap_m_internal_value(self)
    m_internal = property(_mupdf.FzPtrHeap_m_internal_get, _mupdf.FzPtrHeap_m_internal_set, doc=r""" Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.FzPtrHeap_s_num_instances_get, _mupdf.FzPtrHeap_s_num_instances_set)

# Register FzPtrHeap in _mupdf:
_mupdf.FzPtrHeap_swigregister(FzPtrHeap)
class FzPwgOptions(object):
    r""" Wrapper class for struct `fz_pwg_options`."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        We use default copy constructor and operator=.  Default constructor, sets each member to default value.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::fz_pwg_options`.
        """
        _mupdf.FzPwgOptions_swiginit(self, _mupdf.new_FzPwgOptions(*args))

    def media_class(self):
        return _mupdf.FzPwgOptions_media_class(self)

    def media_color(self):
        return _mupdf.FzPwgOptions_media_color(self)

    def media_type(self):
        return _mupdf.FzPwgOptions_media_type(self)

    def output_type(self):
        return _mupdf.FzPwgOptions_output_type(self)

    def advance_distance(self):
        return _mupdf.FzPwgOptions_advance_distance(self)

    def advance_media(self):
        return _mupdf.FzPwgOptions_advance_media(self)

    def collate(self):
        return _mupdf.FzPwgOptions_collate(self)

    def cut_media(self):
        return _mupdf.FzPwgOptions_cut_media(self)

    def duplex(self):
        return _mupdf.FzPwgOptions_duplex(self)

    def insert_sheet(self):
        return _mupdf.FzPwgOptions_insert_sheet(self)

    def jog(self):
        return _mupdf.FzPwgOptions_jog(self)

    def leading_edge(self):
        return _mupdf.FzPwgOptions_leading_edge(self)

    def manual_feed(self):
        return _mupdf.FzPwgOptions_manual_feed(self)

    def media_position(self):
        return _mupdf.FzPwgOptions_media_position(self)

    def media_weight(self):
        return _mupdf.FzPwgOptions_media_weight(self)

    def mirror_print(self):
        return _mupdf.FzPwgOptions_mirror_print(self)

    def negative_print(self):
        return _mupdf.FzPwgOptions_negative_print(self)

    def num_copies(self):
        return _mupdf.FzPwgOptions_num_copies(self)

    def orientation(self):
        return _mupdf.FzPwgOptions_orientation(self)

    def output_face_up(self):
        return _mupdf.FzPwgOptions_output_face_up(self)

    def PageSize(self):
        return _mupdf.FzPwgOptions_PageSize(self)

    def separations(self):
        return _mupdf.FzPwgOptions_separations(self)

    def tray_switch(self):
        return _mupdf.FzPwgOptions_tray_switch(self)

    def tumble(self):
        return _mupdf.FzPwgOptions_tumble(self)

    def media_type_num(self):
        return _mupdf.FzPwgOptions_media_type_num(self)

    def compression(self):
        return _mupdf.FzPwgOptions_compression(self)

    def row_count(self):
        return _mupdf.FzPwgOptions_row_count(self)

    def row_feed(self):
        return _mupdf.FzPwgOptions_row_feed(self)

    def row_step(self):
        return _mupdf.FzPwgOptions_row_step(self)

    def rendering_intent(self):
        return _mupdf.FzPwgOptions_rendering_intent(self)

    def page_size_name(self):
        return _mupdf.FzPwgOptions_page_size_name(self)
    __swig_destroy__ = _mupdf.delete_FzPwgOptions
    m_internal = property(_mupdf.FzPwgOptions_m_internal_get, _mupdf.FzPwgOptions_m_internal_set)
    s_num_instances = property(_mupdf.FzPwgOptions_s_num_instances_get, _mupdf.FzPwgOptions_s_num_instances_set, doc=r""" Wrapped data is held by value.""")

    def to_string(self):
        r""" Returns string containing our members, labelled and inside (...), using operator<<."""
        return _mupdf.FzPwgOptions_to_string(self)

    def __eq__(self, rhs):
        r""" Comparison method."""
        return _mupdf.FzPwgOptions___eq__(self, rhs)

    def __ne__(self, rhs):
        r""" Comparison method."""
        return _mupdf.FzPwgOptions___ne__(self, rhs)

# Register FzPwgOptions in _mupdf:
_mupdf.FzPwgOptions_swigregister(FzPwgOptions)
class FzQuad(object):
    r"""
    Wrapper class for struct `fz_quad`.
    A representation for a region defined by 4 points.

    The significant difference between quads and rects is that
    the edges of quads are not axis aligned.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def fz_is_quad_inside_quad(self, haystack):
        r"""
        Class-aware wrapper for `::fz_is_quad_inside_quad()`.
        	Inclusion test for quad in quad.

        	This may break down if quads are not 'well formed'.
        """
        return _mupdf.FzQuad_fz_is_quad_inside_quad(self, haystack)

    def fz_is_quad_intersecting_quad(self, b):
        r"""
        Class-aware wrapper for `::fz_is_quad_intersecting_quad()`.
        	Intersection test for quads.

        	This may break down if quads are not 'well formed'.
        """
        return _mupdf.FzQuad_fz_is_quad_intersecting_quad(self, b)

    def fz_rect_from_quad(self):
        r"""
        Class-aware wrapper for `::fz_rect_from_quad()`.
        	Convert a quad to the smallest rect that covers it.
        """
        return _mupdf.FzQuad_fz_rect_from_quad(self)

    def fz_transform_quad(self, m):
        r"""
        Class-aware wrapper for `::fz_transform_quad()`.
        	Transform a quad by a matrix.
        """
        return _mupdf.FzQuad_fz_transform_quad(self, m)

    def __init__(self, *args):
        r"""
        *Overload 1:*
         == Constructors.  Constructor using `fz_quad_from_rect()`.
        		Convert a rect to a quad (losslessly).


        |

        *Overload 2:*
         Constructor using `fz_transform_quad()`.
        		Transform a quad by a matrix.


        |

        *Overload 3:*
         We use default copy constructor and operator=.  Default constructor, sets each member to default value.

        |

        *Overload 4:*
         Constructor using raw copy of pre-existing `::fz_quad`.

        |

        *Overload 5:*
         Constructor using raw copy of pre-existing `::fz_quad`.
        """
        _mupdf.FzQuad_swiginit(self, _mupdf.new_FzQuad(*args))

    def internal(self, *args):
        r"""
        *Overload 1:*
        Access as underlying struct.

        |

        *Overload 2:*
        Access as underlying struct.
        """
        return _mupdf.FzQuad_internal(self, *args)
    __swig_destroy__ = _mupdf.delete_FzQuad
    ul = property(_mupdf.FzQuad_ul_get, _mupdf.FzQuad_ul_set)
    ur = property(_mupdf.FzQuad_ur_get, _mupdf.FzQuad_ur_set)
    ll = property(_mupdf.FzQuad_ll_get, _mupdf.FzQuad_ll_set)
    lr = property(_mupdf.FzQuad_lr_get, _mupdf.FzQuad_lr_set)
    s_num_instances = property(_mupdf.FzQuad_s_num_instances_get, _mupdf.FzQuad_s_num_instances_set)

    def to_string(self):
        r""" Returns string containing our members, labelled and inside (...), using operator<<."""
        return _mupdf.FzQuad_to_string(self)

    def __eq__(self, rhs):
        r""" Comparison method."""
        return _mupdf.FzQuad___eq__(self, rhs)

    def __ne__(self, rhs):
        r""" Comparison method."""
        return _mupdf.FzQuad___ne__(self, rhs)

# Register FzQuad in _mupdf:
_mupdf.FzQuad_swigregister(FzQuad)
class FzRange(object):
    r""" Wrapper class for struct `fz_range`. Not copyable or assignable."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::fz_range`.
        """
        _mupdf.FzRange_swiginit(self, _mupdf.new_FzRange(*args))
    __swig_destroy__ = _mupdf.delete_FzRange

    def m_internal_value(self):
        r""" Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.FzRange_m_internal_value(self)
    m_internal = property(_mupdf.FzRange_m_internal_get, _mupdf.FzRange_m_internal_set, doc=r""" Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.FzRange_s_num_instances_get, _mupdf.FzRange_s_num_instances_set)

# Register FzRange in _mupdf:
_mupdf.FzRange_swigregister(FzRange)
class FzRect(object):
    r""" Wrapper class for struct `fz_rect`."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    Fixed_UNIT = _mupdf.FzRect_Fixed_UNIT
    Fixed_EMPTY = _mupdf.FzRect_Fixed_EMPTY
    Fixed_INFINITE = _mupdf.FzRect_Fixed_INFINITE

    def fz_adjust_rect_for_stroke(self, stroke, ctm):
        r"""
        Class-aware wrapper for `::fz_adjust_rect_for_stroke()`.
        	Given a rectangle (assumed to be the bounding box for a path),
        	expand it to allow for the expansion of the bbox that would be
        	seen by stroking the path with the given stroke state and
        	transform.
        """
        return _mupdf.FzRect_fz_adjust_rect_for_stroke(self, stroke, ctm)

    def fz_contains_rect(self, b):
        r"""
        Class-aware wrapper for `::fz_contains_rect()`.
        	Test rectangle inclusion.

        	Return true if a entirely contains b.
        """
        return _mupdf.FzRect_fz_contains_rect(self, b)

    def fz_expand_rect(self, expand):
        r"""
        Class-aware wrapper for `::fz_expand_rect()`.
        	Expand a bbox by a given amount in all directions.
        """
        return _mupdf.FzRect_fz_expand_rect(self, expand)

    def fz_include_point_in_rect(self, p):
        r"""
        Class-aware wrapper for `::fz_include_point_in_rect()`.
        	Expand a bbox to include a given point.
        	To create a rectangle that encompasses a sequence of points, the
        	rectangle must first be set to be the empty rectangle at one of
        	the points before including the others.
        """
        return _mupdf.FzRect_fz_include_point_in_rect(self, p)

    def fz_intersect_rect(self, *args):
        r"""
        *Overload 1:*
         Class-aware wrapper for `::fz_intersect_rect()`.
        		Compute intersection of two rectangles.

        		Given two rectangles, update the first to be the smallest
        		axis-aligned rectangle that covers the area covered by both
        		given rectangles. If either rectangle is empty then the
        		intersection is also empty. If either rectangle is infinite
        		then the intersection is simply the non-infinite rectangle.
        		Should both rectangles be infinite, then the intersection is
        		also infinite.


        |

        *Overload 2:*
         Class-aware wrapper for `::fz_intersect_rect()`.
        		Compute intersection of two rectangles.

        		Given two rectangles, update the first to be the smallest
        		axis-aligned rectangle that covers the area covered by both
        		given rectangles. If either rectangle is empty then the
        		intersection is also empty. If either rectangle is infinite
        		then the intersection is simply the non-infinite rectangle.
        		Should both rectangles be infinite, then the intersection is
        		also infinite.
        """
        return _mupdf.FzRect_fz_intersect_rect(self, *args)

    def fz_irect_from_rect(self):
        r"""
        Class-aware wrapper for `::fz_irect_from_rect()`.
        	Convert a rect into the minimal bounding box
        	that covers the rectangle.

        	Coordinates in a bounding box are integers, so rounding of the
        	rects coordinates takes place. The top left corner is rounded
        	upwards and left while the bottom right corner is rounded
        	downwards and to the right.
        """
        return _mupdf.FzRect_fz_irect_from_rect(self)

    def fz_is_empty_rect(self):
        r"""
        Class-aware wrapper for `::fz_is_empty_rect()`.
        	Check if rectangle is empty.

        	An empty rectangle is defined as one whose area is zero.
        	All invalid rectangles are empty.
        """
        return _mupdf.FzRect_fz_is_empty_rect(self)

    def fz_is_infinite_rect(self):
        r"""
        Class-aware wrapper for `::fz_is_infinite_rect()`.
        	Check if rectangle is infinite.
        """
        return _mupdf.FzRect_fz_is_infinite_rect(self)

    def fz_is_valid_rect(self):
        r"""
        Class-aware wrapper for `::fz_is_valid_rect()`.
        	Check if rectangle is valid.
        """
        return _mupdf.FzRect_fz_is_valid_rect(self)

    def fz_new_bbox_device(self):
        r"""
        Class-aware wrapper for `::fz_new_bbox_device()`.
        	Create a device to compute the bounding
        	box of all marks on a page.

        	The returned bounding box will be the union of all bounding
        	boxes of all objects on a page.
        """
        return _mupdf.FzRect_fz_new_bbox_device(self)

    def fz_new_display_list(self):
        r"""
        Class-aware wrapper for `::fz_new_display_list()`.
        	Create an empty display list.

        	A display list contains drawing commands (text, images, etc.).
        	Use fz_new_list_device for populating the list.

        	mediabox: Bounds of the page (in points) represented by the
        	display list.
        """
        return _mupdf.FzRect_fz_new_display_list(self)

    def fz_quad_from_rect(self):
        r"""
        Class-aware wrapper for `::fz_quad_from_rect()`.
        	Convert a rect to a quad (losslessly).
        """
        return _mupdf.FzRect_fz_quad_from_rect(self)

    def fz_round_rect(self):
        r"""
        Class-aware wrapper for `::fz_round_rect()`.
        	Round rectangle coordinates.

        	Coordinates in a bounding box are integers, so rounding of the
        	rects coordinates takes place. The top left corner is rounded
        	upwards and left while the bottom right corner is rounded
        	downwards and to the right.

        	This differs from fz_irect_from_rect, in that fz_irect_from_rect
        	slavishly follows the numbers (i.e any slight over/under
        	calculations can cause whole extra pixels to be added).
        	fz_round_rect allows for a small amount of rounding error when
        	calculating the bbox.
        """
        return _mupdf.FzRect_fz_round_rect(self)

    def fz_transform_page(self, resolution, rotate):
        r"""
        Class-aware wrapper for `::fz_transform_page()`.
        	Create transform matrix to draw page
        	at a given resolution and rotation. Adjusts the scaling
        	factors so that the page covers whole number of
        	pixels and adjust the page origin to be at 0,0.
        """
        return _mupdf.FzRect_fz_transform_page(self, resolution, rotate)

    def fz_transform_rect(self, m):
        r"""
        Class-aware wrapper for `::fz_transform_rect()`.
        	Apply a transform to a rectangle.

        	After the four corner points of the axis-aligned rectangle
        	have been transformed it may not longer be axis-aligned. So a
        	new axis-aligned rectangle is created covering at least the
        	area of the transformed rectangle.

        	transform: Transformation matrix to apply. See fz_concat,
        	fz_scale and fz_rotate for how to create a matrix.

        	rect: Rectangle to be transformed. The two special cases
        	fz_empty_rect and fz_infinite_rect, may be used but are
        	returned unchanged as expected.
        """
        return _mupdf.FzRect_fz_transform_rect(self, m)

    def fz_translate_rect(self, xoff, yoff):
        r"""
        Class-aware wrapper for `::fz_translate_rect()`.
        	Translate bounding box.

        	Translate a bbox by a given x and y offset. Allows for overflow.
        """
        return _mupdf.FzRect_fz_translate_rect(self, xoff, yoff)

    def fz_union_rect(self, *args):
        r"""
        *Overload 1:*
         Class-aware wrapper for `::fz_union_rect()`.
        		Compute union of two rectangles.

        		Given two rectangles, update the first to be the smallest
        		axis-aligned rectangle that encompasses both given rectangles.
        		If either rectangle is infinite then the union is also infinite.
        		If either rectangle is empty then the union is simply the
        		non-empty rectangle. Should both rectangles be empty, then the
        		union is also empty.


        |

        *Overload 2:*
         Class-aware wrapper for `::fz_union_rect()`.
        		Compute union of two rectangles.

        		Given two rectangles, update the first to be the smallest
        		axis-aligned rectangle that encompasses both given rectangles.
        		If either rectangle is infinite then the union is also infinite.
        		If either rectangle is empty then the union is simply the
        		non-empty rectangle. Should both rectangles be empty, then the
        		union is also empty.
        """
        return _mupdf.FzRect_fz_union_rect(self, *args)

    def pdf_signature_appearance_signed(self, lang, img, left_text, right_text, include_logo):
        r""" Class-aware wrapper for `::pdf_signature_appearance_signed()`."""
        return _mupdf.FzRect_pdf_signature_appearance_signed(self, lang, img, left_text, right_text, include_logo)

    def pdf_signature_appearance_unsigned(self, lang):
        r""" Class-aware wrapper for `::pdf_signature_appearance_unsigned()`."""
        return _mupdf.FzRect_pdf_signature_appearance_unsigned(self, lang)

    def transform(self, m):
        r""" Transforms *this using fz_transform_rect() with <m>."""
        return _mupdf.FzRect_transform(self, m)

    def contains(self, *args):
        r"""
        *Overload 1:*
        Convenience method using fz_contains_rect().

        |

        *Overload 2:*
        Uses fz_contains_rect(*this, rhs).
        """
        return _mupdf.FzRect_contains(self, *args)

    def is_empty(self):
        r""" Uses fz_is_empty_rect()."""
        return _mupdf.FzRect_is_empty(self)

    def union_(self, rhs):
        r""" Updates *this using fz_union_rect()."""
        return _mupdf.FzRect_union_(self, rhs)

    def __init__(self, *args):
        r"""
        *Overload 1:*
         == Constructors.  Constructor using `fz_bound_display_list()`.
        		Return the bounding box of the page recorded in a display list.


        |

        *Overload 2:*
         Constructor using `fz_rect_from_irect()`.
        		Convert a bbox into a rect.

        		For our purposes, a rect can represent all the values we meet in
        		a bbox, so nothing can go wrong.

        		rect: A place to store the generated rectangle.

        		bbox: The bbox to convert.

        		Returns rect (updated).


        |

        *Overload 3:*
         Constructor using `fz_rect_from_quad()`.
        		Convert a quad to the smallest rect that covers it.


        |

        *Overload 4:*
         Constructor using `fz_transform_rect()`.
        		Apply a transform to a rectangle.

        		After the four corner points of the axis-aligned rectangle
        		have been transformed it may not longer be axis-aligned. So a
        		new axis-aligned rectangle is created covering at least the
        		area of the transformed rectangle.

        		transform: Transformation matrix to apply. See fz_concat,
        		fz_scale and fz_rotate for how to create a matrix.

        		rect: Rectangle to be transformed. The two special cases
        		fz_empty_rect and fz_infinite_rect, may be used but are
        		returned unchanged as expected.


        |

        *Overload 5:*
         Construct from specified values.

        |

        *Overload 6:*
         Copy constructor using plain copy.

        |

        *Overload 7:*
         Construct from fz_unit_rect, fz_empty_rect or fz_infinite_rect.

        |

        *Overload 8:*
         We use default copy constructor and operator=.  Default constructor, sets each member to default value.

        |

        *Overload 9:*
         Constructor using raw copy of pre-existing `::fz_rect`.

        |

        *Overload 10:*
         Constructor using raw copy of pre-existing `::fz_rect`.
        """
        _mupdf.FzRect_swiginit(self, _mupdf.new_FzRect(*args))

    def internal(self, *args):
        r"""
        *Overload 1:*
        Access as underlying struct.

        |

        *Overload 2:*
        Access as underlying struct.
        """
        return _mupdf.FzRect_internal(self, *args)
    __swig_destroy__ = _mupdf.delete_FzRect
    x0 = property(_mupdf.FzRect_x0_get, _mupdf.FzRect_x0_set)
    y0 = property(_mupdf.FzRect_y0_get, _mupdf.FzRect_y0_set)
    x1 = property(_mupdf.FzRect_x1_get, _mupdf.FzRect_x1_set)
    y1 = property(_mupdf.FzRect_y1_get, _mupdf.FzRect_y1_set)
    s_num_instances = property(_mupdf.FzRect_s_num_instances_get, _mupdf.FzRect_s_num_instances_set)

    def to_string(self):
        r""" Returns string containing our members, labelled and inside (...), using operator<<."""
        return _mupdf.FzRect_to_string(self)

    def __eq__(self, rhs):
        r""" Comparison method."""
        return _mupdf.FzRect___eq__(self, rhs)

    def __ne__(self, rhs):
        r""" Comparison method."""
        return _mupdf.FzRect___ne__(self, rhs)

# Register FzRect in _mupdf:
_mupdf.FzRect_swigregister(FzRect)
class FzSeparations(object):
    r""" Wrapper class for struct `fz_separations`."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def fz_add_separation(self, name, cs, cs_channel):
        r"""
        Class-aware wrapper for `::fz_add_separation()`.
        	Add a separation (null terminated name, colorspace)
        """
        return _mupdf.FzSeparations_fz_add_separation(self, name, cs, cs_channel)

    def fz_add_separation_equivalents(self, rgba, cmyk, name):
        r"""
        Class-aware wrapper for `::fz_add_separation_equivalents()`.
        	Add a separation with equivalents (null terminated name,
        	colorspace)

        	(old, deprecated)
        """
        return _mupdf.FzSeparations_fz_add_separation_equivalents(self, rgba, cmyk, name)

    def fz_clone_separations_for_overprint(self):
        r"""
        Class-aware wrapper for `::fz_clone_separations_for_overprint()`.
        	Return a separations object with all the spots in the input
        	separations object that are set to composite, reset to be
        	enabled. If there ARE no spots in the object, this returns
        	NULL. If the object already has all its spots enabled, then
        	just returns another handle on the same object.
        """
        return _mupdf.FzSeparations_fz_clone_separations_for_overprint(self)

    def fz_compare_separations(self, sep2):
        r"""
        Class-aware wrapper for `::fz_compare_separations()`.
        	Compare 2 separations structures (or NULLs).

        	Return 0 if identical, non-zero if not identical.
        """
        return _mupdf.FzSeparations_fz_compare_separations(self, sep2)

    def fz_count_active_separations(self):
        r"""
        Class-aware wrapper for `::fz_count_active_separations()`.
        	Return the number of active separations.
        """
        return _mupdf.FzSeparations_fz_count_active_separations(self)

    def fz_count_separations(self):
        r""" Class-aware wrapper for `::fz_count_separations()`."""
        return _mupdf.FzSeparations_fz_count_separations(self)

    def fz_separation_equivalent(self, idx, dst_cs, dst_color, prf, color_params):
        r"""
        Class-aware wrapper for `::fz_separation_equivalent()`.

        This method has out-params. Python/C# wrappers look like:
        	`fz_separation_equivalent(int idx, ::fz_colorspace *dst_cs, ::fz_colorspace *prf, ::fz_color_params color_params)` => float dst_color

        	Get the equivalent separation color in a given colorspace.
        """
        return _mupdf.FzSeparations_fz_separation_equivalent(self, idx, dst_cs, dst_color, prf, color_params)

    def fz_separation_name(self, separation):
        r""" Class-aware wrapper for `::fz_separation_name()`."""
        return _mupdf.FzSeparations_fz_separation_name(self, separation)

    def fz_set_separation_behavior(self, separation, behavior):
        r"""
        Class-aware wrapper for `::fz_set_separation_behavior()`.
        	Control the rendering of a given separation.
        """
        return _mupdf.FzSeparations_fz_set_separation_behavior(self, separation, behavior)

    def __init__(self, *args):
        r"""
        *Overload 1:*
         == Constructors.  Constructor using `fz_new_separations()`.
        		Create a new separations structure (initially empty)


        |

        *Overload 2:*
         Copy constructor using `fz_keep_separations()`.

        |

        *Overload 3:*
         Constructor using raw copy of pre-existing `::fz_separations`.

        |

        *Overload 4:*
         Constructor using raw copy of pre-existing `::fz_separations`.
        """
        _mupdf.FzSeparations_swiginit(self, _mupdf.new_FzSeparations(*args))
    __swig_destroy__ = _mupdf.delete_FzSeparations

    def m_internal_value(self):
        r""" Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.FzSeparations_m_internal_value(self)
    m_internal = property(_mupdf.FzSeparations_m_internal_get, _mupdf.FzSeparations_m_internal_set, doc=r""" Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.FzSeparations_s_num_instances_get, _mupdf.FzSeparations_s_num_instances_set)

# Register FzSeparations in _mupdf:
_mupdf.FzSeparations_swigregister(FzSeparations)
class FzSha256(object):
    r"""
    Wrapper class for struct `fz_sha256`. Not copyable or assignable.
    Structure definition is public to enable stack
    based allocation. Do not access the members directly.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def fz_sha256_final(self, digest):
        r"""
        Class-aware wrapper for `::fz_sha256_final()`.
        	MD5 finalization. Ends an MD5 message-digest operation, writing
        	the message digest and zeroizing the context.

        	Never throws an exception.
        """
        return _mupdf.FzSha256_fz_sha256_final(self, digest)

    def fz_sha256_init(self):
        r"""
        Class-aware wrapper for `::fz_sha256_init()`.
        	SHA256 initialization. Begins an SHA256 operation, initialising
        	the supplied context.

        	Never throws an exception.
        """
        return _mupdf.FzSha256_fz_sha256_init(self)

    def fz_sha256_update(self, input, inlen):
        r"""
        Class-aware wrapper for `::fz_sha256_update()`.
        	SHA256 block update operation. Continues an SHA256 message-
        	digest operation, processing another message block, and updating
        	the context.

        	Never throws an exception.
        """
        return _mupdf.FzSha256_fz_sha256_update(self, input, inlen)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::fz_sha256`.
        """
        _mupdf.FzSha256_swiginit(self, _mupdf.new_FzSha256(*args))
    __swig_destroy__ = _mupdf.delete_FzSha256

    def m_internal_value(self):
        r""" Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.FzSha256_m_internal_value(self)
    m_internal = property(_mupdf.FzSha256_m_internal_get, _mupdf.FzSha256_m_internal_set, doc=r""" Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.FzSha256_s_num_instances_get, _mupdf.FzSha256_s_num_instances_set)

# Register FzSha256 in _mupdf:
_mupdf.FzSha256_swigregister(FzSha256)
class FzSha384(object):
    r""" Wrapper class for struct `fz_sha384`. Not copyable or assignable."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::fz_sha384`.
        """
        _mupdf.FzSha384_swiginit(self, _mupdf.new_FzSha384(*args))
    __swig_destroy__ = _mupdf.delete_FzSha384

    def m_internal_value(self):
        r""" Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.FzSha384_m_internal_value(self)
    m_internal = property(_mupdf.FzSha384_m_internal_get, _mupdf.FzSha384_m_internal_set, doc=r""" Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.FzSha384_s_num_instances_get, _mupdf.FzSha384_s_num_instances_set)

# Register FzSha384 in _mupdf:
_mupdf.FzSha384_swigregister(FzSha384)
class FzSha512(object):
    r"""
    Wrapper class for struct `fz_sha512`. Not copyable or assignable.
    Structure definition is public to enable stack
    based allocation. Do not access the members directly.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def fz_sha384_final(self, digest):
        r"""
        Class-aware wrapper for `::fz_sha384_final()`.
        	SHA384 finalization. Ends an SHA384 message-digest operation,
        	writing the message digest and zeroizing the context.

        	Never throws an exception.
        """
        return _mupdf.FzSha512_fz_sha384_final(self, digest)

    def fz_sha384_init(self):
        r"""
        Class-aware wrapper for `::fz_sha384_init()`.
        	SHA384 initialization. Begins an SHA384 operation, initialising
        	the supplied context.

        	Never throws an exception.
        """
        return _mupdf.FzSha512_fz_sha384_init(self)

    def fz_sha384_update(self, input, inlen):
        r"""
        Class-aware wrapper for `::fz_sha384_update()`.
        	SHA384 block update operation. Continues an SHA384 message-
        	digest operation, processing another message block, and updating
        	the context.

        	Never throws an exception.
        """
        return _mupdf.FzSha512_fz_sha384_update(self, input, inlen)

    def fz_sha512_final(self, digest):
        r"""
        Class-aware wrapper for `::fz_sha512_final()`.
        	SHA512 finalization. Ends an SHA512 message-digest operation,
        	writing the message digest and zeroizing the context.

        	Never throws an exception.
        """
        return _mupdf.FzSha512_fz_sha512_final(self, digest)

    def fz_sha512_init(self):
        r"""
        Class-aware wrapper for `::fz_sha512_init()`.
        	SHA512 initialization. Begins an SHA512 operation, initialising
        	the supplied context.

        	Never throws an exception.
        """
        return _mupdf.FzSha512_fz_sha512_init(self)

    def fz_sha512_update(self, input, inlen):
        r"""
        Class-aware wrapper for `::fz_sha512_update()`.
        	SHA512 block update operation. Continues an SHA512 message-
        	digest operation, processing another message block, and updating
        	the context.

        	Never throws an exception.
        """
        return _mupdf.FzSha512_fz_sha512_update(self, input, inlen)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::fz_sha512`.
        """
        _mupdf.FzSha512_swiginit(self, _mupdf.new_FzSha512(*args))
    __swig_destroy__ = _mupdf.delete_FzSha512

    def m_internal_value(self):
        r""" Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.FzSha512_m_internal_value(self)
    m_internal = property(_mupdf.FzSha512_m_internal_get, _mupdf.FzSha512_m_internal_set, doc=r""" Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.FzSha512_s_num_instances_get, _mupdf.FzSha512_s_num_instances_set)

# Register FzSha512 in _mupdf:
_mupdf.FzSha512_swigregister(FzSha512)
class FzShade(object):
    r"""
    Wrapper class for struct `fz_shade`.
    Structure is public to allow derived classes. Do not
    access the members directly.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def fz_bound_shade(self, ctm):
        r"""
        Class-aware wrapper for `::fz_bound_shade()`.
        	Bound a given shading.

        	shade: The shade to bound.

        	ctm: The transform to apply to the shade before bounding.

        	r: Pointer to storage to put the bounds in.

        	Returns r, updated to contain the bounds for the shading.
        """
        return _mupdf.FzShade_fz_bound_shade(self, ctm)

    def fz_paint_shade(self, override_cs, ctm, dest, color_params, bbox, eop, cache):
        r"""
        Class-aware wrapper for `::fz_paint_shade()`.

        This method has out-params. Python/C# wrappers look like:
        	`fz_paint_shade(::fz_colorspace *override_cs, ::fz_matrix ctm, ::fz_pixmap *dest, ::fz_color_params color_params, ::fz_irect bbox, const ::fz_overprint *eop, ::fz_shade_color_cache **cache)` =>

        	Render a shade to a given pixmap.

        	shade: The shade to paint.

        	override_cs: NULL, or colorspace to override the shades
        	inbuilt colorspace.

        	ctm: The transform to apply.

        	dest: The pixmap to render into.

        	color_params: The color rendering settings

        	bbox: Pointer to a bounding box to limit the rendering
        	of the shade.

        	eop: NULL, or pointer to overprint bitmap.

        	cache: *cache is used to cache color information. If *cache is NULL it
        	is set to point to a new fz_shade_color_cache. If cache is NULL it is
        	ignored.
        """
        return _mupdf.FzShade_fz_paint_shade(self, override_cs, ctm, dest, color_params, bbox, eop, cache)

    def fz_process_shade(self, ctm, scissor, prepare, process, process_arg):
        r"""
        Class-aware wrapper for `::fz_process_shade()`.
        	Process a shade, using supplied callback functions. This
        	decomposes the shading to a mesh (even ones that are not
        	natively meshes, such as linear or radial shadings), and
        	processes triangles from those meshes.

        	shade: The shade to process.

        	ctm: The transform to use

        	prepare: Callback function to 'prepare' each vertex.
        	This function is passed an array of floats, and populates
        	a fz_vertex structure.

        	process: This function is passed 3 pointers to vertex
        	structures, and actually performs the processing (typically
        	filling the area between the vertexes).

        	process_arg: An opaque argument passed through from caller
        	to callback functions.
        """
        return _mupdf.FzShade_fz_process_shade(self, ctm, scissor, prepare, process, process_arg)

    def fz_paint_shade_no_cache(self, override_cs, ctm, dest, color_params, bbox, eop):
        r""" Extra wrapper for fz_paint_shade(), passing cache=NULL."""
        return _mupdf.FzShade_fz_paint_shade_no_cache(self, override_cs, ctm, dest, color_params, bbox, eop)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Copy constructor using `fz_keep_shade()`.

        |

        *Overload 2:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 3:*
        Constructor using raw copy of pre-existing `::fz_shade`.
        """
        _mupdf.FzShade_swiginit(self, _mupdf.new_FzShade(*args))
    __swig_destroy__ = _mupdf.delete_FzShade

    def m_internal_value(self):
        r""" Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.FzShade_m_internal_value(self)
    m_internal = property(_mupdf.FzShade_m_internal_get, _mupdf.FzShade_m_internal_set, doc=r""" Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.FzShade_s_num_instances_get, _mupdf.FzShade_s_num_instances_set)

# Register FzShade in _mupdf:
_mupdf.FzShade_swigregister(FzShade)
class FzShadeColorCache(object):
    r""" Wrapper class for struct `fz_shade_color_cache`. Not copyable or assignable."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::fz_shade_color_cache`.
        """
        _mupdf.FzShadeColorCache_swiginit(self, _mupdf.new_FzShadeColorCache(*args))
    __swig_destroy__ = _mupdf.delete_FzShadeColorCache

    def m_internal_value(self):
        r""" Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.FzShadeColorCache_m_internal_value(self)
    m_internal = property(_mupdf.FzShadeColorCache_m_internal_get, _mupdf.FzShadeColorCache_m_internal_set, doc=r""" Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.FzShadeColorCache_s_num_instances_get, _mupdf.FzShadeColorCache_s_num_instances_set)

# Register FzShadeColorCache in _mupdf:
_mupdf.FzShadeColorCache_swigregister(FzShadeColorCache)
class FzShaperDataT(object):
    r"""
    Wrapper class for struct `fz_shaper_data_t`. Not copyable or assignable.
    In order to shape a given font, we need to
    declare it to a shaper library (harfbuzz, by default, but others
    are possible). To avoid redeclaring it every time we need to
    shape, we hold a shaper handle and the destructor for it within
    the font itself. The handle is initialised by the caller when
    first required and the destructor is called when the fz_font is
    destroyed.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::fz_shaper_data_t`.
        """
        _mupdf.FzShaperDataT_swiginit(self, _mupdf.new_FzShaperDataT(*args))
    __swig_destroy__ = _mupdf.delete_FzShaperDataT

    def m_internal_value(self):
        r""" Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.FzShaperDataT_m_internal_value(self)
    m_internal = property(_mupdf.FzShaperDataT_m_internal_get, _mupdf.FzShaperDataT_m_internal_set, doc=r""" Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.FzShaperDataT_s_num_instances_get, _mupdf.FzShaperDataT_s_num_instances_set)

# Register FzShaperDataT in _mupdf:
_mupdf.FzShaperDataT_swigregister(FzShaperDataT)
class FzStextBlock(object):
    r""" Wrapper class for struct `fz_stext_block`."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def i_transform(self):
        r""" Returns m_internal.u.i.transform if m_internal->type is FZ_STEXT_BLOCK_IMAGE, else throws."""
        return _mupdf.FzStextBlock_i_transform(self)

    def i_image(self):
        r""" Returns m_internal.u.i.image if m_internal->type is FZ_STEXT_BLOCK_IMAGE, else throws."""
        return _mupdf.FzStextBlock_i_image(self)

    def begin(self):
        r""" Used for iteration over linked list of FzStextLine items starting at fz_stext_line::u.t.first_line."""
        return _mupdf.FzStextBlock_begin(self)

    def end(self):
        r""" Used for iteration over linked list of FzStextLine items starting at fz_stext_line::u.t.first_line."""
        return _mupdf.FzStextBlock_end(self)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        We use default copy constructor and operator=.  Default constructor, sets `m_internal` to null.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::fz_stext_block`.
        """
        _mupdf.FzStextBlock_swiginit(self, _mupdf.new_FzStextBlock(*args))
    __swig_destroy__ = _mupdf.delete_FzStextBlock

    def m_internal_value(self):
        r""" Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.FzStextBlock_m_internal_value(self)
    m_internal = property(_mupdf.FzStextBlock_m_internal_get, _mupdf.FzStextBlock_m_internal_set, doc=r""" Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.FzStextBlock_s_num_instances_get, _mupdf.FzStextBlock_s_num_instances_set)

# Register FzStextBlock in _mupdf:
_mupdf.FzStextBlock_swigregister(FzStextBlock)
class FzStextChar(object):
    r"""
    Wrapper class for struct `fz_stext_char`.
    Text extraction device: Used for searching, format conversion etc.

    (In development - Subject to change in future versions)
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        We use default copy constructor and operator=.  Default constructor, sets `m_internal` to null.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::fz_stext_char`.
        """
        _mupdf.FzStextChar_swiginit(self, _mupdf.new_FzStextChar(*args))
    __swig_destroy__ = _mupdf.delete_FzStextChar

    def m_internal_value(self):
        r""" Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.FzStextChar_m_internal_value(self)
    m_internal = property(_mupdf.FzStextChar_m_internal_get, _mupdf.FzStextChar_m_internal_set, doc=r""" Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.FzStextChar_s_num_instances_get, _mupdf.FzStextChar_s_num_instances_set)

# Register FzStextChar in _mupdf:
_mupdf.FzStextChar_swigregister(FzStextChar)
class FzStextLine(object):
    r""" Wrapper class for struct `fz_stext_line`."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def begin(self):
        r""" Used for iteration over linked list of FzStextChar items starting at fz_stext_char::first_char."""
        return _mupdf.FzStextLine_begin(self)

    def end(self):
        r""" Used for iteration over linked list of FzStextChar items starting at fz_stext_char::first_char."""
        return _mupdf.FzStextLine_end(self)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        We use default copy constructor and operator=.  Default constructor, sets `m_internal` to null.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::fz_stext_line`.
        """
        _mupdf.FzStextLine_swiginit(self, _mupdf.new_FzStextLine(*args))
    __swig_destroy__ = _mupdf.delete_FzStextLine

    def m_internal_value(self):
        r""" Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.FzStextLine_m_internal_value(self)
    m_internal = property(_mupdf.FzStextLine_m_internal_get, _mupdf.FzStextLine_m_internal_set, doc=r""" Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.FzStextLine_s_num_instances_get, _mupdf.FzStextLine_s_num_instances_set)

# Register FzStextLine in _mupdf:
_mupdf.FzStextLine_swigregister(FzStextLine)
class FzStextOptions(object):
    r"""
    Wrapper class for struct `fz_stext_options`.
    Options for creating structured text.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def fz_parse_stext_options(self, string):
        r"""
        Class-aware wrapper for `::fz_parse_stext_options()`.
        	Parse stext device options from a comma separated key-value
        	string.
        """
        return _mupdf.FzStextOptions_fz_parse_stext_options(self, string)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Construct with .flags set to <flags>.

        |

        *Overload 2:*
        We use default copy constructor and operator=.  Default constructor, sets each member to default value.

        |

        *Overload 3:*
        Constructor using raw copy of pre-existing `::fz_stext_options`.

        |

        *Overload 4:*
        Constructor using raw copy of pre-existing `::fz_stext_options`.
        """
        _mupdf.FzStextOptions_swiginit(self, _mupdf.new_FzStextOptions(*args))

    def internal(self, *args):
        r"""
        *Overload 1:*
        Access as underlying struct.

        |

        *Overload 2:*
        Access as underlying struct.
        """
        return _mupdf.FzStextOptions_internal(self, *args)
    __swig_destroy__ = _mupdf.delete_FzStextOptions
    flags = property(_mupdf.FzStextOptions_flags_get, _mupdf.FzStextOptions_flags_set)
    scale = property(_mupdf.FzStextOptions_scale_get, _mupdf.FzStextOptions_scale_set)
    s_num_instances = property(_mupdf.FzStextOptions_s_num_instances_get, _mupdf.FzStextOptions_s_num_instances_set)

    def to_string(self):
        r""" Returns string containing our members, labelled and inside (...), using operator<<."""
        return _mupdf.FzStextOptions_to_string(self)

    def __eq__(self, rhs):
        r""" Comparison method."""
        return _mupdf.FzStextOptions___eq__(self, rhs)

    def __ne__(self, rhs):
        r""" Comparison method."""
        return _mupdf.FzStextOptions___ne__(self, rhs)

# Register FzStextOptions in _mupdf:
_mupdf.FzStextOptions_swigregister(FzStextOptions)
class FzStextPage(object):
    r"""
    Wrapper class for struct `fz_stext_page`. Not copyable or assignable.
    A text page is a list of blocks, together with an overall
    bounding box.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def fz_highlight_selection(self, a, b, quads, max_quads):
        r"""
        Class-aware wrapper for `::fz_highlight_selection()`.
        	Return a list of quads to highlight lines inside the selection
        	points.
        """
        return _mupdf.FzStextPage_fz_highlight_selection(self, a, b, quads, max_quads)

    def fz_highlight_selection2(self, a, b, max_quads):
        r"""
        Class-aware wrapper for `::fz_highlight_selection2()`.
        C++ alternative to fz_highlight_selection() that returns quads in a
        std::vector.
        """
        return _mupdf.FzStextPage_fz_highlight_selection2(self, a, b, max_quads)

    def fz_new_buffer_from_stext_page(self):
        r"""
        Class-aware wrapper for `::fz_new_buffer_from_stext_page()`.
        	Convert structured text into plain text.
        """
        return _mupdf.FzStextPage_fz_new_buffer_from_stext_page(self)

    def fz_new_stext_device(self, options):
        r"""
        Class-aware wrapper for `::fz_new_stext_device()`.
        	Create a device to extract the text on a page.

        	Gather the text on a page into blocks and lines.

        	The reading order is taken from the order the text is drawn in
        	the source file, so may not be accurate.

        	page: The text page to which content should be added. This will
        	usually be a newly created (empty) text page, but it can be one
        	containing data already (for example when merging multiple
        	pages, or watermarking).

        	options: Options to configure the stext device.
        """
        return _mupdf.FzStextPage_fz_new_stext_device(self, options)

    def fz_search_stext_page(self, needle, hit_mark, hit_bbox, hit_max):
        r"""
        Class-aware wrapper for `::fz_search_stext_page()`.

        This method has out-params. Python/C# wrappers look like:
        	`fz_search_stext_page(const char *needle, ::fz_quad *hit_bbox, int hit_max)` => `(int, int hit_mark)`

        	Search for occurrence of 'needle' in text page.

        	Return the number of hits and store hit quads in the passed in
        	array.

        	NOTE: This is an experimental interface and subject to change
        	without notice.
        """
        return _mupdf.FzStextPage_fz_search_stext_page(self, needle, hit_mark, hit_bbox, hit_max)

    def fz_snap_selection(self, ap, bp, mode):
        r""" Class-aware wrapper for `::fz_snap_selection()`."""
        return _mupdf.FzStextPage_fz_snap_selection(self, ap, bp, mode)

    def fz_copy_selection(self, a, b, crlf):
        r""" Wrapper for fz_copy_selection() that returns std::string."""
        return _mupdf.FzStextPage_fz_copy_selection(self, a, b, crlf)

    def fz_copy_rectangle(self, area, crlf):
        r""" Wrapper for fz_copy_rectangle() that returns a std::string."""
        return _mupdf.FzStextPage_fz_copy_rectangle(self, area, crlf)

    def search_stext_page(self, needle, hit_mark, max_quads):
        r""" Wrapper for fz_search_stext_page() that returns std::vector of Quads."""
        return _mupdf.FzStextPage_search_stext_page(self, needle, hit_mark, max_quads)

    def begin(self):
        r""" Used for iteration over linked list of FzStextBlock items starting at fz_stext_block::first_block."""
        return _mupdf.FzStextPage_begin(self)

    def end(self):
        r""" Used for iteration over linked list of FzStextBlock items starting at fz_stext_block::first_block."""
        return _mupdf.FzStextPage_end(self)

    def __init__(self, *args):
        r"""
        *Overload 1:*
         == Constructors.  Constructor using `fz_new_stext_page()`.
        		Create an empty text page.

        		The text page is filled out by the text device to contain the
        		blocks and lines of text on the page.

        		mediabox: optional mediabox information.


        |

        *Overload 2:*
         Constructor using `fz_new_stext_page_from_chapter_page_number()`.

        |

        *Overload 3:*
         Constructor using `fz_new_stext_page_from_display_list()`.

        |

        *Overload 4:*
         Constructor using `fz_new_stext_page_from_page()`.
        		Extract text from page.

        		Ownership of the fz_stext_page is returned to the caller.


        |

        *Overload 5:*
         Constructor using `fz_new_stext_page_from_page_number()`.

        |

        *Overload 6:*
         Constructor using `pdf_new_stext_page_from_annot()`.

        |

        *Overload 7:*
         Default constructor, sets `m_internal` to null.

        |

        *Overload 8:*
         Constructor using raw copy of pre-existing `::fz_stext_page`.
        """
        _mupdf.FzStextPage_swiginit(self, _mupdf.new_FzStextPage(*args))
    __swig_destroy__ = _mupdf.delete_FzStextPage

    def m_internal_value(self):
        r""" Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.FzStextPage_m_internal_value(self)
    m_internal = property(_mupdf.FzStextPage_m_internal_get, _mupdf.FzStextPage_m_internal_set, doc=r""" Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.FzStextPage_s_num_instances_get, _mupdf.FzStextPage_s_num_instances_set)

# Register FzStextPage in _mupdf:
_mupdf.FzStextPage_swigregister(FzStextPage)
class FzStorable(object):
    r"""
    Wrapper class for struct `fz_storable`.
    Resource store

    MuPDF stores decoded "objects" into a store for potential reuse.
    If the size of the store gets too big, objects stored within it
    can be evicted and freed to recover space. When MuPDF comes to
    decode such an object, it will check to see if a version of this
    object is already in the store - if it is, it will simply reuse
    it. If not, it will decode it and place it into the store.

    All objects that can be placed into the store are derived from
    the fz_storable type (i.e. this should be the first component of
    the objects structure). This allows for consistent (thread safe)
    reference counting, and includes a function that will be called
    to free the object as soon as the reference count reaches zero.

    Most objects offer fz_keep_XXXX/fz_drop_XXXX functions derived
    from fz_keep_storable/fz_drop_storable. Creation of such objects
    includes a call to FZ_INIT_STORABLE to set up the fz_storable
    header.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Copy constructor using `fz_keep_storable()`.

        |

        *Overload 2:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 3:*
        Constructor using raw copy of pre-existing `::fz_storable`.
        """
        _mupdf.FzStorable_swiginit(self, _mupdf.new_FzStorable(*args))
    __swig_destroy__ = _mupdf.delete_FzStorable

    def m_internal_value(self):
        r""" Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.FzStorable_m_internal_value(self)
    m_internal = property(_mupdf.FzStorable_m_internal_get, _mupdf.FzStorable_m_internal_set, doc=r""" Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.FzStorable_s_num_instances_get, _mupdf.FzStorable_s_num_instances_set)

# Register FzStorable in _mupdf:
_mupdf.FzStorable_swigregister(FzStorable)
class FzStore(object):
    r""" Wrapper class for struct `fz_store`. Not copyable or assignable."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::fz_store`.
        """
        _mupdf.FzStore_swiginit(self, _mupdf.new_FzStore(*args))
    __swig_destroy__ = _mupdf.delete_FzStore

    def m_internal_value(self):
        r""" Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.FzStore_m_internal_value(self)
    m_internal = property(_mupdf.FzStore_m_internal_get, _mupdf.FzStore_m_internal_set, doc=r""" Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.FzStore_s_num_instances_get, _mupdf.FzStore_s_num_instances_set)

# Register FzStore in _mupdf:
_mupdf.FzStore_swigregister(FzStore)
class FzStoreHash(object):
    r"""
    Wrapper class for struct `fz_store_hash`. Not copyable or assignable.
    The store can be seen as a dictionary that maps keys to
    fz_storable values. In order to allow keys of different types to
    be stored, we have a structure full of functions for each key
    'type'; this fz_store_type pointer is stored with each key, and
    tells the store how to perform certain operations (like taking/
    dropping a reference, comparing two keys, outputting details for
    debugging etc).

    The store uses a hash table internally for speed where possible.
    In order for this to work, we need a mechanism for turning a
    generic 'key' into 'a hashable string'. For this purpose the
    type structure contains a make_hash_key function pointer that
    maps from a void * to a fz_store_hash structure. If
    make_hash_key function returns 0, then the key is determined not
    to be hashable, and the value is not stored in the hash table.

    Some objects can be used both as values within the store, and as
    a component of keys within the store. We refer to these objects
    as "key storable" objects. In this case, we need to take
    additional care to ensure that we do not end up keeping an item
    within the store, purely because its value is referred to by
    another key in the store.

    An example of this are fz_images in PDF files. Each fz_image is
    placed into the	store to enable it to be easily reused. When the
    image is rendered, a pixmap is generated from the image, and the
    pixmap is placed into the store so it can be reused on
    subsequent renders. The image forms part of the key for the
    pixmap.

    When we close the pdf document (and any associated pages/display
    lists etc), we drop the images from the store. This may leave us
    in the position of the images having non-zero reference counts
    purely because they are used as part of the keys for the
    pixmaps.

    We therefore use special reference counting functions to keep
    track of these "key storable" items, and hence store the number
    of references to these items that are used in keys.

    When the number of references to an object == the number of
    references to an object from keys in the store, we know that we
    can remove all the items which have that object as part of the
    key. This is done by running a pass over the store, 'reaping'
    those items.

    Reap passes are slower than we would like as they touch every
    item in the store. We therefore provide a way to 'batch' such
    reap passes together, using fz_defer_reap_start/
    fz_defer_reap_end to bracket a region in which many may be
    triggered.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::fz_store_hash`.
        """
        _mupdf.FzStoreHash_swiginit(self, _mupdf.new_FzStoreHash(*args))
    __swig_destroy__ = _mupdf.delete_FzStoreHash

    def m_internal_value(self):
        r""" Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.FzStoreHash_m_internal_value(self)
    m_internal = property(_mupdf.FzStoreHash_m_internal_get, _mupdf.FzStoreHash_m_internal_set, doc=r""" Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.FzStoreHash_s_num_instances_get, _mupdf.FzStoreHash_s_num_instances_set)

# Register FzStoreHash in _mupdf:
_mupdf.FzStoreHash_swigregister(FzStoreHash)
class FzStoreType(object):
    r"""
    Wrapper class for struct `fz_store_type`. Not copyable or assignable.
    Every type of object to be placed into the store defines an
    fz_store_type. This contains the pointers to functions to
    make hashes, manipulate keys, and check for needing reaping.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::fz_store_type`.
        """
        _mupdf.FzStoreType_swiginit(self, _mupdf.new_FzStoreType(*args))
    __swig_destroy__ = _mupdf.delete_FzStoreType

    def m_internal_value(self):
        r""" Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.FzStoreType_m_internal_value(self)
    m_internal = property(_mupdf.FzStoreType_m_internal_get, _mupdf.FzStoreType_m_internal_set, doc=r""" Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.FzStoreType_s_num_instances_get, _mupdf.FzStoreType_s_num_instances_set)

# Register FzStoreType in _mupdf:
_mupdf.FzStoreType_swigregister(FzStoreType)
class FzStory(object):
    r""" Wrapper class for struct `fz_story`. Not copyable or assignable."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def fz_draw_story(self, dev, ctm):
        r""" Class-aware wrapper for `::fz_draw_story()`."""
        return _mupdf.FzStory_fz_draw_story(self, dev, ctm)

    def fz_place_story(self, where, filled):
        r""" Class-aware wrapper for `::fz_place_story()`."""
        return _mupdf.FzStory_fz_place_story(self, where, filled)

    def fz_place_story_flags(self, where, filled, flags):
        r""" Class-aware wrapper for `::fz_place_story_flags()`."""
        return _mupdf.FzStory_fz_place_story_flags(self, where, filled, flags)

    def fz_reset_story(self):
        r""" Class-aware wrapper for `::fz_reset_story()`."""
        return _mupdf.FzStory_fz_reset_story(self)

    def fz_story_document(self):
        r""" Class-aware wrapper for `::fz_story_document()`."""
        return _mupdf.FzStory_fz_story_document(self)

    def fz_story_positions(self, cb, arg):
        r""" Class-aware wrapper for `::fz_story_positions()`."""
        return _mupdf.FzStory_fz_story_positions(self, cb, arg)

    def fz_story_warnings(self):
        r""" Class-aware wrapper for `::fz_story_warnings()`."""
        return _mupdf.FzStory_fz_story_warnings(self)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        == Constructors.  Constructor using `fz_new_story()`.

        |

        *Overload 2:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 3:*
        Constructor using raw copy of pre-existing `::fz_story`.
        """
        _mupdf.FzStory_swiginit(self, _mupdf.new_FzStory(*args))
    __swig_destroy__ = _mupdf.delete_FzStory

    def m_internal_value(self):
        r""" Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.FzStory_m_internal_value(self)
    m_internal = property(_mupdf.FzStory_m_internal_get, _mupdf.FzStory_m_internal_set, doc=r""" Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.FzStory_s_num_instances_get, _mupdf.FzStory_s_num_instances_set)

# Register FzStory in _mupdf:
_mupdf.FzStory_swigregister(FzStory)
class FzStoryElementPosition(object):
    r""" Wrapper class for struct `fz_story_element_position`."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        We use default copy constructor and operator=.  Default constructor, sets each member to default value.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::fz_story_element_position`.

        |

        *Overload 3:*
        Constructor using raw copy of pre-existing `::fz_story_element_position`.
        """
        _mupdf.FzStoryElementPosition_swiginit(self, _mupdf.new_FzStoryElementPosition(*args))

    def internal(self, *args):
        r"""
        *Overload 1:*
        Access as underlying struct.

        |

        *Overload 2:*
        Access as underlying struct.
        """
        return _mupdf.FzStoryElementPosition_internal(self, *args)
    __swig_destroy__ = _mupdf.delete_FzStoryElementPosition
    depth = property(_mupdf.FzStoryElementPosition_depth_get, _mupdf.FzStoryElementPosition_depth_set)
    heading = property(_mupdf.FzStoryElementPosition_heading_get, _mupdf.FzStoryElementPosition_heading_set)
    id = property(_mupdf.FzStoryElementPosition_id_get, _mupdf.FzStoryElementPosition_id_set)
    href = property(_mupdf.FzStoryElementPosition_href_get, _mupdf.FzStoryElementPosition_href_set)
    rect = property(_mupdf.FzStoryElementPosition_rect_get, _mupdf.FzStoryElementPosition_rect_set)
    text = property(_mupdf.FzStoryElementPosition_text_get, _mupdf.FzStoryElementPosition_text_set)
    open_close = property(_mupdf.FzStoryElementPosition_open_close_get, _mupdf.FzStoryElementPosition_open_close_set)
    rectangle_num = property(_mupdf.FzStoryElementPosition_rectangle_num_get, _mupdf.FzStoryElementPosition_rectangle_num_set)
    s_num_instances = property(_mupdf.FzStoryElementPosition_s_num_instances_get, _mupdf.FzStoryElementPosition_s_num_instances_set)

    def to_string(self):
        r""" Returns string containing our members, labelled and inside (...), using operator<<."""
        return _mupdf.FzStoryElementPosition_to_string(self)

    def __eq__(self, rhs):
        r""" Comparison method."""
        return _mupdf.FzStoryElementPosition___eq__(self, rhs)

    def __ne__(self, rhs):
        r""" Comparison method."""
        return _mupdf.FzStoryElementPosition___ne__(self, rhs)

# Register FzStoryElementPosition in _mupdf:
_mupdf.FzStoryElementPosition_swigregister(FzStoryElementPosition)
class FzStream(object):
    r"""
    Wrapper class for struct `fz_stream`.
    fz_stream is a buffered reader capable of seeking in both
    directions.

    Streams are reference counted, so references must be dropped
    by a call to fz_drop_stream.

    Only the data between rp and wp is valid.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def fz_available(self, max):
        r"""
        Class-aware wrapper for `::fz_available()`.
        	Ask how many bytes are available immediately from
        	a given stream.

        	stm: The stream to read from.

        	max: A hint for the underlying stream; the maximum number of
        	bytes that we are sure we will want to read. If you do not know
        	this number, give 1.

        	Returns the number of bytes immediately available between the
        	read and write pointers. This number is guaranteed only to be 0
        	if we have hit EOF. The number of bytes returned here need have
        	no relation to max (could be larger, could be smaller).
        """
        return _mupdf.FzStream_fz_available(self, max)

    def fz_decomp_image_from_stream(self, image, subarea, indexed, l2factor, l2extra):
        r"""
        Class-aware wrapper for `::fz_decomp_image_from_stream()`.

        This method has out-params. Python/C# wrappers look like:
        	`fz_decomp_image_from_stream(::fz_compressed_image *image, ::fz_irect *subarea, int indexed, int l2factor)` => `(fz_pixmap *, int l2extra)`

        	Decode a subarea of a compressed image. l2factor is the amount
        	of subsampling inbuilt to the stream (i.e. performed by the
        	decoder). If non NULL, l2extra is the extra amount of
        	subsampling that should be performed by this routine. This will
        	be updated on exit to the amount of subsampling that is still
        	required to be done.

        	Returns a kept reference.
        """
        return _mupdf.FzStream_fz_decomp_image_from_stream(self, image, subarea, indexed, l2factor, l2extra)

    def fz_is_cfb_archive(self):
        r"""
        Class-aware wrapper for `::fz_is_cfb_archive()`.
        	Detect if stream object is a cfb archive.

        	Assumes that the stream object is seekable.
        """
        return _mupdf.FzStream_fz_is_cfb_archive(self)

    def fz_is_eof(self):
        r"""
        Class-aware wrapper for `::fz_is_eof()`.
        	Query if the stream has reached EOF (during normal bytewise
        	reading).

        	See fz_is_eof_bits for the equivalent function for bitwise
        	reading.
        """
        return _mupdf.FzStream_fz_is_eof(self)

    def fz_is_eof_bits(self):
        r"""
        Class-aware wrapper for `::fz_is_eof_bits()`.
        	Query if the stream has reached EOF (during bitwise
        	reading).

        	See fz_is_eof for the equivalent function for bytewise
        	reading.
        """
        return _mupdf.FzStream_fz_is_eof_bits(self)

    def fz_is_libarchive_archive(self):
        r"""
        Class-aware wrapper for `::fz_is_libarchive_archive()`.
        	Detect if stream object is an archive supported by libarchive.

        	Assumes that the stream object is seekable.
        """
        return _mupdf.FzStream_fz_is_libarchive_archive(self)

    def fz_is_tar_archive(self):
        r"""
        Class-aware wrapper for `::fz_is_tar_archive()`.
        	Detect if stream object is a tar archive.

        	Assumes that the stream object is seekable.
        """
        return _mupdf.FzStream_fz_is_tar_archive(self)

    def fz_is_zip_archive(self):
        r"""
        Class-aware wrapper for `::fz_is_zip_archive()`.
        	Detect if stream object is a zip archive.

        	Assumes that the stream object is seekable.
        """
        return _mupdf.FzStream_fz_is_zip_archive(self)

    def fz_new_archive_of_size(self, size):
        r""" Class-aware wrapper for `::fz_new_archive_of_size()`."""
        return _mupdf.FzStream_fz_new_archive_of_size(self, size)

    def fz_open_a85d(self):
        r"""
        Class-aware wrapper for `::fz_open_a85d()`.
        	a85d filter performs ASCII 85 Decoding of data read
        	from the chained filter.
        """
        return _mupdf.FzStream_fz_open_a85d(self)

    def fz_open_aesd(self, key, keylen):
        r"""
        Class-aware wrapper for `::fz_open_aesd()`.
        	aesd filter performs AES decoding of data read from the chained
        	filter using the supplied key.
        """
        return _mupdf.FzStream_fz_open_aesd(self, key, keylen)

    def fz_open_ahxd(self):
        r"""
        Class-aware wrapper for `::fz_open_ahxd()`.
        	ahxd filter performs ASCII Hex decoding of data read
        	from the chained filter.
        """
        return _mupdf.FzStream_fz_open_ahxd(self)

    def fz_open_arc4(self, key, keylen):
        r"""
        Class-aware wrapper for `::fz_open_arc4()`.
        	arc4 filter performs RC4 decoding of data read from the chained
        	filter using the supplied key.
        """
        return _mupdf.FzStream_fz_open_arc4(self, key, keylen)

    def fz_open_archive_with_stream(self):
        r"""
        Class-aware wrapper for `::fz_open_archive_with_stream()`.
        	Open zip or tar archive stream.

        	Open an archive using a seekable stream object rather than
        	opening a file or directory on disk.
        """
        return _mupdf.FzStream_fz_open_archive_with_stream(self)

    def fz_open_cfb_archive_with_stream(self):
        r"""
        Class-aware wrapper for `::fz_open_cfb_archive_with_stream()`.
        	Open a cfb file as an archive.

        	Open an archive using a seekable stream object rather than
        	opening a file or directory on disk.

        	An exception is thrown if the file is not recognised as a chm.
        """
        return _mupdf.FzStream_fz_open_cfb_archive_with_stream(self)

    def fz_open_dctd(self, color_transform, invert_cmyk, l2factor, jpegtables):
        r"""
        Class-aware wrapper for `::fz_open_dctd()`.
        	dctd filter performs DCT (JPEG) decoding of data read
        	from the chained filter.

        	color_transform implements the PDF color_transform option
        		use -1 for default behavior
        		use 0 to disable YUV-RGB / YCCK-CMYK transforms
        		use 1 to enable YUV-RGB / YCCK-CMYK transforms

        	invert_cmyk implements the necessary inversion for Photoshop CMYK images
        		use 0 if embedded in PDF
        		use 1 if not embedded in PDF

        	For subsampling on decode, set l2factor to the log2 of the
        	reduction required (therefore 0 = full size decode).

        	jpegtables is an optional stream from which the JPEG tables
        	can be read. Use NULL if not required.
        """
        return _mupdf.FzStream_fz_open_dctd(self, color_transform, invert_cmyk, l2factor, jpegtables)

    def fz_open_endstream_filter(self, len, offset):
        r"""
        Class-aware wrapper for `::fz_open_endstream_filter()`.
        	The endstream filter reads a PDF substream, and starts to look
        	for an 'endstream' token after the specified length.
        """
        return _mupdf.FzStream_fz_open_endstream_filter(self, len, offset)

    def fz_open_faxd(self, k, end_of_line, encoded_byte_align, columns, rows, end_of_block, black_is_1):
        r"""
        Class-aware wrapper for `::fz_open_faxd()`.
        	faxd filter performs FAX decoding of data read from
        	the chained filter.

        	k: see fax specification (fax default is 0).

        	end_of_line: whether we expect end of line markers (fax default
        	is 0).

        	encoded_byte_align: whether we align to bytes after each line
        	(fax default is 0).

        	columns: how many columns in the image (fax default is 1728).

        	rows: 0 for unspecified or the number of rows of data to expect.

        	end_of_block: whether we expect end of block markers (fax
        	default is 1).

        	black_is_1: determines the polarity of the image (fax default is
        	0).
        """
        return _mupdf.FzStream_fz_open_faxd(self, k, end_of_line, encoded_byte_align, columns, rows, end_of_block, black_is_1)

    def fz_open_flated(self, window_bits):
        r"""
        Class-aware wrapper for `::fz_open_flated()`.
        	flated filter performs LZ77 decoding (inflating) of data read
        	from the chained filter.

        	window_bits: How large a decompression window to use. Typically
        	15. A negative number, -n, means to use n bits, but to expect
        	raw data with no header.
        """
        return _mupdf.FzStream_fz_open_flated(self, window_bits)

    def fz_open_image_decomp_stream(self, arg_1, l2factor):
        r"""
        Class-aware wrapper for `::fz_open_image_decomp_stream()`.

        This method has out-params. Python/C# wrappers look like:
        	`fz_open_image_decomp_stream(::fz_compression_params *arg_1)` => `(fz_stream *, int l2factor)`

        	Open a stream to read the decompressed version of another stream
        	with optional log2 subsampling.
        """
        return _mupdf.FzStream_fz_open_image_decomp_stream(self, arg_1, l2factor)

    def fz_open_jbig2d(self, globals, embedded):
        r"""
        Class-aware wrapper for `::fz_open_jbig2d()`.
        	Open a filter that performs jbig2 decompression on the chained
        	stream, using the optional globals record.
        """
        return _mupdf.FzStream_fz_open_jbig2d(self, globals, embedded)

    def fz_open_leecher(self, buf):
        r"""
        Class-aware wrapper for `::fz_open_leecher()`.
        	Attach a filter to a stream that will store any
        	characters read from the stream into the supplied buffer.

        	chain: The underlying stream to leech from.

        	buf: The buffer into which the read data should be appended.
        	The buffer will be resized as required.

        	Returns pointer to newly created stream. May throw exceptions on
        	failure to allocate.
        """
        return _mupdf.FzStream_fz_open_leecher(self, buf)

    def fz_open_libarchive_archive_with_stream(self):
        r"""
        Class-aware wrapper for `::fz_open_libarchive_archive_with_stream()`.
        	Open an archive using libarchive.

        	Open an archive using a seekable stream object rather than
        	opening a file or directory on disk.

        	An exception is thrown if the stream is not supported by libarchive.
        """
        return _mupdf.FzStream_fz_open_libarchive_archive_with_stream(self)

    def fz_open_libarchived(self):
        r"""
        Class-aware wrapper for `::fz_open_libarchived()`.
        	libarchived filter performs generic compressed decoding of data
        	in any format understood by libarchive from the chained filter.

        	This will throw an exception if libarchive is not built in, or
        	if the compression format is not recognised.
        """
        return _mupdf.FzStream_fz_open_libarchived(self)

    def fz_open_lzwd(self, early_change, min_bits, reverse_bits, old_tiff):
        r"""
        Class-aware wrapper for `::fz_open_lzwd()`.
        	lzwd filter performs LZW decoding of data read from the chained
        	filter.

        	early_change: (Default 1) specifies whether to change codes 1
        	bit early.

        	min_bits: (Default 9) specifies the minimum number of bits to
        	use.

        	reverse_bits: (Default 0) allows for compatibility with gif and
        	old style tiffs (1).

        	old_tiff: (Default 0) allows for different handling of the clear
        	code, as found in old style tiffs.
        """
        return _mupdf.FzStream_fz_open_lzwd(self, early_change, min_bits, reverse_bits, old_tiff)

    def fz_open_null_filter(self, len, offset):
        r"""
        Class-aware wrapper for `::fz_open_null_filter()`.
        	The null filter reads a specified amount of data from the
        	substream.
        """
        return _mupdf.FzStream_fz_open_null_filter(self, len, offset)

    def fz_open_predict(self, predictor, columns, colors, bpc):
        r"""
        Class-aware wrapper for `::fz_open_predict()`.
        	predict filter performs pixel prediction on data read from
        	the chained filter.

        	predictor: 1 = copy, 2 = tiff, other = inline PNG predictor

        	columns: width of image in pixels

        	colors: number of components.

        	bpc: bits per component (typically 8)
        """
        return _mupdf.FzStream_fz_open_predict(self, predictor, columns, colors, bpc)

    def fz_open_range_filter(self, ranges, nranges):
        r"""
        Class-aware wrapper for `::fz_open_range_filter()`.
        	The range filter copies data from specified ranges of the
        	chained stream.
        """
        return _mupdf.FzStream_fz_open_range_filter(self, ranges, nranges)

    def fz_open_rld(self):
        r"""
        Class-aware wrapper for `::fz_open_rld()`.
        	rld filter performs Run Length Decoding of data read
        	from the chained filter.
        """
        return _mupdf.FzStream_fz_open_rld(self)

    def fz_open_sgilog16(self, w):
        r"""
        Class-aware wrapper for `::fz_open_sgilog16()`.
        	SGI Log 16bit (greyscale) decode from the chained filter.
        	Decodes lines of w pixels to 8bpp greyscale.
        """
        return _mupdf.FzStream_fz_open_sgilog16(self, w)

    def fz_open_sgilog24(self, w):
        r"""
        Class-aware wrapper for `::fz_open_sgilog24()`.
        	SGI Log 24bit (LUV) decode from the chained filter.
        	Decodes lines of w pixels to 8bpc rgb.
        """
        return _mupdf.FzStream_fz_open_sgilog24(self, w)

    def fz_open_sgilog32(self, w):
        r"""
        Class-aware wrapper for `::fz_open_sgilog32()`.
        	SGI Log 32bit (LUV) decode from the chained filter.
        	Decodes lines of w pixels to 8bpc rgb.
        """
        return _mupdf.FzStream_fz_open_sgilog32(self, w)

    def fz_open_tar_archive_with_stream(self):
        r"""
        Class-aware wrapper for `::fz_open_tar_archive_with_stream()`.
        	Open a tar archive stream.

        	Open an archive using a seekable stream object rather than
        	opening a file or directory on disk.

        	An exception is thrown if the stream is not a tar archive as
        	indicated by the presence of a tar signature.

        """
        return _mupdf.FzStream_fz_open_tar_archive_with_stream(self)

    def fz_open_thunder(self, w):
        r"""
        Class-aware wrapper for `::fz_open_thunder()`.
        	4bit greyscale Thunderscan decoding from the chained filter.
        	Decodes lines of w pixels to 8bpp greyscale.
        """
        return _mupdf.FzStream_fz_open_thunder(self, w)

    def fz_open_zip_archive_with_stream(self):
        r"""
        Class-aware wrapper for `::fz_open_zip_archive_with_stream()`.
        	Open a zip archive stream.

        	Open an archive using a seekable stream object rather than
        	opening a file or directory on disk.

        	An exception is thrown if the stream is not a zip archive as
        	indicated by the presence of a zip signature.

        """
        return _mupdf.FzStream_fz_open_zip_archive_with_stream(self)

    def fz_parse_xml_stream(self, preserve_white):
        r"""
        Class-aware wrapper for `::fz_parse_xml_stream()`.
        	Parse the contents of buffer into a tree of xml nodes.

        	preserve_white: whether to keep or delete all-whitespace nodes.
        """
        return _mupdf.FzStream_fz_parse_xml_stream(self, preserve_white)

    def fz_peek_byte(self):
        r"""
        Class-aware wrapper for `::fz_peek_byte()`.
        	Peek at the next byte in a stream.

        	stm: The stream to peek at.

        	Returns -1 for EOF, or the next byte that will be read.
        """
        return _mupdf.FzStream_fz_peek_byte(self)

    def fz_read(self, data, len):
        r"""
        Class-aware wrapper for `::fz_read()`.
        	Read from a stream into a given data block.

        	stm: The stream to read from.

        	data: The data block to read into.

        	len: The length of the data block (in bytes).

        	Returns the number of bytes read. May throw exceptions.
        """
        return _mupdf.FzStream_fz_read(self, data, len)

    def fz_read_all(self, initial):
        r"""
        Class-aware wrapper for `::fz_read_all()`.
        	Read all of a stream into a buffer.

        	stm: The stream to read from

        	initial: Suggested initial size for the buffer.

        	Returns a buffer created from reading from the stream. May throw
        	exceptions on failure to allocate.
        """
        return _mupdf.FzStream_fz_read_all(self, initial)

    def fz_read_best(self, initial, truncated, worst_case):
        r"""
        Class-aware wrapper for `::fz_read_best()`.

        This method has out-params. Python/C# wrappers look like:
        	`fz_read_best(size_t initial, size_t worst_case)` => `(fz_buffer *, int truncated)`

        	Attempt to read a stream into a buffer. If truncated
        	is NULL behaves as fz_read_all, sets a truncated flag in case of
        	error.

        	stm: The stream to read from.

        	initial: Suggested initial size for the buffer.

        	truncated: Flag to store success/failure indication in.

        	worst_case: 0 for unknown, otherwise an upper bound for the
        	size of the stream.

        	Returns a buffer created from reading from the stream.
        """
        return _mupdf.FzStream_fz_read_best(self, initial, truncated, worst_case)

    def fz_read_bits(self, n):
        r"""
        Class-aware wrapper for `::fz_read_bits()`.
        	Read the next n bits from a stream (assumed to
        	be packed most significant bit first).

        	stm: The stream to read from.

        	n: The number of bits to read, between 1 and 8*sizeof(int)
        	inclusive.

        	Returns -1 for EOF, or the required number of bits.
        """
        return _mupdf.FzStream_fz_read_bits(self, n)

    def fz_read_byte(self):
        r"""
        Class-aware wrapper for `::fz_read_byte()`.
        	Read the next byte from a stream.

        	stm: The stream t read from.

        	Returns -1 for end of stream, or the next byte. May
        	throw exceptions.
        """
        return _mupdf.FzStream_fz_read_byte(self)

    def fz_read_float(self):
        r""" Class-aware wrapper for `::fz_read_float()`."""
        return _mupdf.FzStream_fz_read_float(self)

    def fz_read_float_le(self):
        r""" Class-aware wrapper for `::fz_read_float_le()`."""
        return _mupdf.FzStream_fz_read_float_le(self)

    def fz_read_int16(self):
        r""" Class-aware wrapper for `::fz_read_int16()`."""
        return _mupdf.FzStream_fz_read_int16(self)

    def fz_read_int16_le(self):
        r""" Class-aware wrapper for `::fz_read_int16_le()`."""
        return _mupdf.FzStream_fz_read_int16_le(self)

    def fz_read_int32(self):
        r""" Class-aware wrapper for `::fz_read_int32()`."""
        return _mupdf.FzStream_fz_read_int32(self)

    def fz_read_int32_le(self):
        r""" Class-aware wrapper for `::fz_read_int32_le()`."""
        return _mupdf.FzStream_fz_read_int32_le(self)

    def fz_read_int64(self):
        r""" Class-aware wrapper for `::fz_read_int64()`."""
        return _mupdf.FzStream_fz_read_int64(self)

    def fz_read_int64_le(self):
        r""" Class-aware wrapper for `::fz_read_int64_le()`."""
        return _mupdf.FzStream_fz_read_int64_le(self)

    def fz_read_line(self, buf, max):
        r"""
        Class-aware wrapper for `::fz_read_line()`.
        	Read a line from stream into the buffer until either a
        	terminating newline or EOF, which it replaces with a null byte
        	('').

        	Returns buf on success, and NULL when end of file occurs while
        	no characters have been read.
        """
        return _mupdf.FzStream_fz_read_line(self, buf, max)

    def fz_read_rbits(self, n):
        r"""
        Class-aware wrapper for `::fz_read_rbits()`.
        	Read the next n bits from a stream (assumed to
        	be packed least significant bit first).

        	stm: The stream to read from.

        	n: The number of bits to read, between 1 and 8*sizeof(int)
        	inclusive.

        	Returns (unsigned int)-1 for EOF, or the required number of bits.
        """
        return _mupdf.FzStream_fz_read_rbits(self, n)

    def fz_read_rune(self):
        r"""
        Class-aware wrapper for `::fz_read_rune()`.
        	Read a utf-8 rune from a stream.

        	In the event of encountering badly formatted utf-8 codes
        	(such as a leading code with an unexpected number of following
        	codes) no error/exception is given, but undefined values may be
        	returned.
        """
        return _mupdf.FzStream_fz_read_rune(self)

    def fz_read_string(self, buffer, len):
        r"""
        Class-aware wrapper for `::fz_read_string()`.
        	Read a null terminated string from the stream into
        	a buffer of a given length. The buffer will be null terminated.
        	Throws on failure (including the failure to fit the entire
        	string including the terminator into the buffer).
        """
        return _mupdf.FzStream_fz_read_string(self, buffer, len)

    def fz_read_uint16(self):
        r"""
        Class-aware wrapper for `::fz_read_uint16()`.
        	fz_read_[u]int(16|24|32|64)(_le)?

        	Read a 16/32/64 bit signed/unsigned integer from stream,
        	in big or little-endian byte orders.

        	Throws an exception if EOF is encountered.
        """
        return _mupdf.FzStream_fz_read_uint16(self)

    def fz_read_uint16_le(self):
        r""" Class-aware wrapper for `::fz_read_uint16_le()`."""
        return _mupdf.FzStream_fz_read_uint16_le(self)

    def fz_read_uint24(self):
        r""" Class-aware wrapper for `::fz_read_uint24()`."""
        return _mupdf.FzStream_fz_read_uint24(self)

    def fz_read_uint24_le(self):
        r""" Class-aware wrapper for `::fz_read_uint24_le()`."""
        return _mupdf.FzStream_fz_read_uint24_le(self)

    def fz_read_uint32(self):
        r""" Class-aware wrapper for `::fz_read_uint32()`."""
        return _mupdf.FzStream_fz_read_uint32(self)

    def fz_read_uint32_le(self):
        r""" Class-aware wrapper for `::fz_read_uint32_le()`."""
        return _mupdf.FzStream_fz_read_uint32_le(self)

    def fz_read_uint64(self):
        r""" Class-aware wrapper for `::fz_read_uint64()`."""
        return _mupdf.FzStream_fz_read_uint64(self)

    def fz_read_uint64_le(self):
        r""" Class-aware wrapper for `::fz_read_uint64_le()`."""
        return _mupdf.FzStream_fz_read_uint64_le(self)

    def fz_read_utf16_be(self):
        r""" Class-aware wrapper for `::fz_read_utf16_be()`."""
        return _mupdf.FzStream_fz_read_utf16_be(self)

    def fz_read_utf16_le(self):
        r"""
        Class-aware wrapper for `::fz_read_utf16_le()`.
        	Read a utf-16 rune from a stream. (little endian and
        	big endian respectively).

        	In the event of encountering badly formatted utf-16 codes
        	(mismatched surrogates) no error/exception is given, but
        	undefined values may be returned.
        """
        return _mupdf.FzStream_fz_read_utf16_le(self)

    def fz_seek(self, offset, whence):
        r"""
        Class-aware wrapper for `::fz_seek()`.
        	Seek within a stream.

        	stm: The stream to seek within.

        	offset: The offset to seek to.

        	whence: From where the offset is measured (see fseek).
        	SEEK_SET - start of stream.
        	SEEK_CUR - current position.
        	SEEK_END - end of stream.

        """
        return _mupdf.FzStream_fz_seek(self, offset, whence)

    def fz_skip(self, len):
        r"""
        Class-aware wrapper for `::fz_skip()`.
        	Read from a stream discarding data.

        	stm: The stream to read from.

        	len: The number of bytes to read.

        	Returns the number of bytes read. May throw exceptions.
        """
        return _mupdf.FzStream_fz_skip(self, len)

    def fz_skip_space(self):
        r"""
        Class-aware wrapper for `::fz_skip_space()`.
        	Skip over whitespace (bytes <= 32) in a stream.
        """
        return _mupdf.FzStream_fz_skip_space(self)

    def fz_skip_string(self, str):
        r"""
        Class-aware wrapper for `::fz_skip_string()`.
        	Skip over a given string in a stream. Return 0 if successfully
        	skipped, non-zero otherwise. As many characters will be skipped
        	over as matched in the string.
        """
        return _mupdf.FzStream_fz_skip_string(self, str)

    def fz_sync_bits(self):
        r"""
        Class-aware wrapper for `::fz_sync_bits()`.
        	Called after reading bits to tell the stream
        	that we are about to return to reading bytewise. Resyncs
        	the stream to whole byte boundaries.
        """
        return _mupdf.FzStream_fz_sync_bits(self)

    def fz_tell(self):
        r"""
        Class-aware wrapper for `::fz_tell()`.
        	return the current reading position within a stream
        """
        return _mupdf.FzStream_fz_tell(self)

    def fz_try_open_archive_with_stream(self):
        r"""
        Class-aware wrapper for `::fz_try_open_archive_with_stream()`.
        	Open zip or tar archive stream.

        	Does the same as fz_open_archive_with_stream, but will not throw
        	an error in the event of failing to recognise the format. Will
        	still throw errors in other cases though!
        """
        return _mupdf.FzStream_fz_try_open_archive_with_stream(self)

    def fz_unpack_stream(self, depth, w, h, n, indexed, pad, skip):
        r""" Class-aware wrapper for `::fz_unpack_stream()`."""
        return _mupdf.FzStream_fz_unpack_stream(self, depth, w, h, n, indexed, pad, skip)

    def fz_unread_byte(self):
        r"""
        Class-aware wrapper for `::fz_unread_byte()`.
        	Unread the single last byte successfully
        	read from a stream. Do not call this without having
        	successfully read a byte.

        	stm: The stream to operate upon.
        """
        return _mupdf.FzStream_fz_unread_byte(self)

    def pdf_load_cmap(self):
        r""" Class-aware wrapper for `::pdf_load_cmap()`."""
        return _mupdf.FzStream_pdf_load_cmap(self)

    def pdf_open_crypt(self, crypt, num, gen):
        r""" Class-aware wrapper for `::pdf_open_crypt()`."""
        return _mupdf.FzStream_pdf_open_crypt(self, crypt, num, gen)

    def pdf_open_crypt_with_filter(self, crypt, name, num, gen):
        r""" Class-aware wrapper for `::pdf_open_crypt_with_filter()`."""
        return _mupdf.FzStream_pdf_open_crypt_with_filter(self, crypt, name, num, gen)

    def pdf_open_document_with_stream(self):
        r""" Class-aware wrapper for `::pdf_open_document_with_stream()`."""
        return _mupdf.FzStream_pdf_open_document_with_stream(self)

    def __init__(self, *args):
        r"""
        *Overload 1:*
         == Constructors.  Constructor using `fz_new_stream()`.
        		Create a new stream object with the given
        		internal state and function pointers.

        		state: Internal state (opaque to everything but implementation).

        		next: Should provide the next set of bytes (up to max) of stream
        		data. Return the number of bytes read, or EOF when there is no
        		more data.

        		drop: Should clean up and free the internal state. May not
        		throw exceptions.


        |

        *Overload 2:*
         Constructor using `fz_open_file()`.
        		Open the named file and wrap it in a stream.

        		filename: Path to a file. On non-Windows machines the filename
        		should be exactly as it would be passed to fopen(2). On Windows
        		machines, the path should be UTF-8 encoded so that non-ASCII
        		characters can be represented. Other platforms do the encoding
        		as standard anyway (and in most cases, particularly for MacOS
        		and Linux, the encoding they use is UTF-8 anyway).


        |

        *Overload 3:*
         Constructor using `fz_open_file_ptr_no_close()`.
        		Create a stream from a FILE * that will not be closed
        		when the stream is dropped.


        |

        *Overload 4:*
         Constructor using `fz_open_memory()`.
        		Open a block of memory as a stream.

        		data: Pointer to start of data block. Ownership of the data
        		block is NOT passed in.

        		len: Number of bytes in data block.

        		Returns pointer to newly created stream. May throw exceptions on
        		failure to allocate.


        |

        *Overload 5:*
         Construct using fz_open_file().

        |

        *Overload 6:*
         Copy constructor using `fz_keep_stream()`.

        |

        *Overload 7:*
         Default constructor, sets `m_internal` to null.

        |

        *Overload 8:*
         Constructor using raw copy of pre-existing `::fz_stream`.
        """
        _mupdf.FzStream_swiginit(self, _mupdf.new_FzStream(*args))
    __swig_destroy__ = _mupdf.delete_FzStream

    def m_internal_value(self):
        r""" Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.FzStream_m_internal_value(self)
    m_internal = property(_mupdf.FzStream_m_internal_get, _mupdf.FzStream_m_internal_set, doc=r""" Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.FzStream_s_num_instances_get, _mupdf.FzStream_s_num_instances_set)

# Register FzStream in _mupdf:
_mupdf.FzStream_swigregister(FzStream)
class FzString(object):
    r""" Wrapper class for struct `fz_string`."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        == Constructors.  Constructor using `fz_new_string()`.

        |

        *Overload 2:*
        Copy constructor using `fz_keep_string()`.

        |

        *Overload 3:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 4:*
        Constructor using raw copy of pre-existing `::fz_string`.
        """
        _mupdf.FzString_swiginit(self, _mupdf.new_FzString(*args))
    __swig_destroy__ = _mupdf.delete_FzString

    def m_internal_value(self):
        r""" Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.FzString_m_internal_value(self)
    m_internal = property(_mupdf.FzString_m_internal_get, _mupdf.FzString_m_internal_set, doc=r""" Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.FzString_s_num_instances_get, _mupdf.FzString_s_num_instances_set)

# Register FzString in _mupdf:
_mupdf.FzString_swigregister(FzString)
class FzStrokeState(object):
    r""" Wrapper class for struct `fz_stroke_state`."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def fz_clone_stroke_state(self):
        r"""
        Class-aware wrapper for `::fz_clone_stroke_state()`.
        	Create an identical stroke_state structure and return a
        	reference to it.

        	stroke: The stroke state reference to clone.

        	Exceptions may be thrown in the event of a failure to
        	allocate.
        """
        return _mupdf.FzStrokeState_fz_clone_stroke_state(self)

    def fz_unshare_stroke_state(self):
        r"""
        Class-aware wrapper for `::fz_unshare_stroke_state()`.
        	Given a reference to a (possibly) shared stroke_state structure,
        	return a reference to an equivalent stroke_state structure
        	that is guaranteed to be unshared (i.e. one that can
        	safely be modified).

        	shared: The reference to a (possibly) shared structure
        	to unshare. Ownership of this reference is passed in
        	to this function, even in the case of exceptions being
        	thrown.

        	Exceptions may be thrown in the event of failure to
        	allocate if required.
        """
        return _mupdf.FzStrokeState_fz_unshare_stroke_state(self)

    def fz_unshare_stroke_state_with_dash_len(self, len):
        r"""
        Class-aware wrapper for `::fz_unshare_stroke_state_with_dash_len()`.
        	Given a reference to a (possibly) shared stroke_state structure,
        	return a reference to a stroke_state structure (with room for a
        	given amount of dash data) that is guaranteed to be unshared
        	(i.e. one that can safely be modified).

        	shared: The reference to a (possibly) shared structure
        	to unshare. Ownership of this reference is passed in
        	to this function, even in the case of exceptions being
        	thrown.

        	Exceptions may be thrown in the event of failure to
        	allocate if required.
        """
        return _mupdf.FzStrokeState_fz_unshare_stroke_state_with_dash_len(self, len)

    def __init__(self, *args):
        r"""
        *Overload 1:*
         == Constructors.  Constructor using `fz_new_stroke_state()`.
        		Create a new (empty) stroke state structure (with no dash
        		data) and return a reference to it.

        		Throws exception on failure to allocate.


        |

        *Overload 2:*
         Constructor using `fz_new_stroke_state_with_dash_len()`.
        		Create a new (empty) stroke state structure, with room for
        		dash data of the given length, and return a reference to it.

        		len: The number of dash elements to allow room for.

        		Throws exception on failure to allocate.


        |

        *Overload 3:*
         Copy constructor using `fz_keep_stroke_state()`.

        |

        *Overload 4:*
         Constructor using raw copy of pre-existing `::fz_stroke_state`.
        """
        _mupdf.FzStrokeState_swiginit(self, _mupdf.new_FzStrokeState(*args))
    __swig_destroy__ = _mupdf.delete_FzStrokeState

    def m_internal_value(self):
        r""" Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.FzStrokeState_m_internal_value(self)
    m_internal = property(_mupdf.FzStrokeState_m_internal_get, _mupdf.FzStrokeState_m_internal_set, doc=r""" Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.FzStrokeState_s_num_instances_get, _mupdf.FzStrokeState_s_num_instances_set)

# Register FzStrokeState in _mupdf:
_mupdf.FzStrokeState_swigregister(FzStrokeState)
class FzStyleContext(object):
    r""" Wrapper class for struct `fz_style_context`. Not copyable or assignable."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::fz_style_context`.
        """
        _mupdf.FzStyleContext_swiginit(self, _mupdf.new_FzStyleContext(*args))
    __swig_destroy__ = _mupdf.delete_FzStyleContext

    def m_internal_value(self):
        r""" Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.FzStyleContext_m_internal_value(self)
    m_internal = property(_mupdf.FzStyleContext_m_internal_get, _mupdf.FzStyleContext_m_internal_set, doc=r""" Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.FzStyleContext_s_num_instances_get, _mupdf.FzStyleContext_s_num_instances_set)

# Register FzStyleContext in _mupdf:
_mupdf.FzStyleContext_swigregister(FzStyleContext)
class FzText(object):
    r""" Wrapper class for struct `fz_text`."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def fz_bound_text(self, stroke, ctm):
        r"""
        Class-aware wrapper for `::fz_bound_text()`.
        	Find the bounds of a given text object.

        	text: The text object to find the bounds of.

        	stroke: Pointer to the stroke attributes (for stroked
        	text), or NULL (for filled text).

        	ctm: The matrix in use.

        	r: pointer to storage for the bounds.

        	Returns a pointer to r, which is updated to contain the
        	bounding box for the text object.
        """
        return _mupdf.FzText_fz_bound_text(self, stroke, ctm)

    def fz_show_glyph(self, font, trm, glyph, unicode, wmode, bidi_level, markup_dir, language):
        r"""
        Class-aware wrapper for `::fz_show_glyph()`.
        	Add a glyph/unicode value to a text object.

        	text: Text object to add to.

        	font: The font the glyph should be added in.

        	trm: The transform to use for the glyph.

        	glyph: The glyph id to add.

        	unicode: The unicode character for the glyph.

        	cid: The CJK CID value or raw character code.

        	wmode: 1 for vertical mode, 0 for horizontal.

        	bidi_level: The bidirectional level for this glyph.

        	markup_dir: The direction of the text as specified in the
        	markup.

        	language: The language in use (if known, 0 otherwise)
        	(e.g. FZ_LANG_zh_Hans).

        	Throws exception on failure to allocate.
        """
        return _mupdf.FzText_fz_show_glyph(self, font, trm, glyph, unicode, wmode, bidi_level, markup_dir, language)

    def fz_show_glyph_aux(self, font, trm, glyph, unicode, cid, wmode, bidi_level, markup_dir, lang):
        r""" Class-aware wrapper for `::fz_show_glyph_aux()`."""
        return _mupdf.FzText_fz_show_glyph_aux(self, font, trm, glyph, unicode, cid, wmode, bidi_level, markup_dir, lang)

    def fz_show_string(self, font, trm, s, wmode, bidi_level, markup_dir, language):
        r"""
        Class-aware wrapper for `::fz_show_string()`.
        	Add a UTF8 string to a text object.

        	text: Text object to add to.

        	font: The font the string should be added in.

        	trm: The transform to use.

        	s: The utf-8 string to add.

        	wmode: 1 for vertical mode, 0 for horizontal.

        	bidi_level: The bidirectional level for this glyph.

        	markup_dir: The direction of the text as specified in the markup.

        	language: The language in use (if known, 0 otherwise)
        		(e.g. FZ_LANG_zh_Hans).

        	Returns the transform updated with the advance width of the
        	string.
        """
        return _mupdf.FzText_fz_show_string(self, font, trm, s, wmode, bidi_level, markup_dir, language)

    def __init__(self, *args):
        r"""
        *Overload 1:*
         == Constructors.  Constructor using `fz_new_text()`.
        		Create a new empty fz_text object.

        		Throws exception on failure to allocate.


        |

        *Overload 2:*
         Copy constructor using `fz_keep_text()`.

        |

        *Overload 3:*
         Constructor using raw copy of pre-existing `::fz_text`.
        """
        _mupdf.FzText_swiginit(self, _mupdf.new_FzText(*args))
    __swig_destroy__ = _mupdf.delete_FzText

    def m_internal_value(self):
        r""" Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.FzText_m_internal_value(self)
    m_internal = property(_mupdf.FzText_m_internal_get, _mupdf.FzText_m_internal_set, doc=r""" Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.FzText_s_num_instances_get, _mupdf.FzText_s_num_instances_set)

# Register FzText in _mupdf:
_mupdf.FzText_swigregister(FzText)
class FzTextDecoder(object):
    r"""
     Wrapper class for struct `fz_text_decoder`. Not copyable or assignable.
    A text decoder (to read arbitrary encodings and convert to unicode).
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def fz_init_text_decoder(self, encoding):
        r""" Class-aware wrapper for `::fz_init_text_decoder()`."""
        return _mupdf.FzTextDecoder_fz_init_text_decoder(self, encoding)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::fz_text_decoder`.
        """
        _mupdf.FzTextDecoder_swiginit(self, _mupdf.new_FzTextDecoder(*args))
    __swig_destroy__ = _mupdf.delete_FzTextDecoder

    def m_internal_value(self):
        r""" Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.FzTextDecoder_m_internal_value(self)
    m_internal = property(_mupdf.FzTextDecoder_m_internal_get, _mupdf.FzTextDecoder_m_internal_set, doc=r""" Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.FzTextDecoder_s_num_instances_get, _mupdf.FzTextDecoder_s_num_instances_set)

# Register FzTextDecoder in _mupdf:
_mupdf.FzTextDecoder_swigregister(FzTextDecoder)
class FzTextItem(object):
    r"""
    Wrapper class for struct `fz_text_item`. Not copyable or assignable.
    Text buffer.

    The trm field contains the a, b, c and d coefficients.
    The e and f coefficients come from the individual elements,
    together they form the transform matrix for the glyph.

    Glyphs are referenced by glyph ID.
    The Unicode text equivalent is kept in a separate array
    with indexes into the glyph array.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::fz_text_item`.
        """
        _mupdf.FzTextItem_swiginit(self, _mupdf.new_FzTextItem(*args))
    __swig_destroy__ = _mupdf.delete_FzTextItem

    def m_internal_value(self):
        r""" Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.FzTextItem_m_internal_value(self)
    m_internal = property(_mupdf.FzTextItem_m_internal_get, _mupdf.FzTextItem_m_internal_set, doc=r""" Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.FzTextItem_s_num_instances_get, _mupdf.FzTextItem_s_num_instances_set)

# Register FzTextItem in _mupdf:
_mupdf.FzTextItem_swigregister(FzTextItem)
class FzTextSpan(object):
    r""" Wrapper class for struct `fz_text_span`. Not copyable or assignable."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def font(self):
        r""" Gives class-aware access to m_internal->font."""
        return _mupdf.FzTextSpan_font(self)

    def trm(self):
        r""" Gives class-aware access to m_internal->trm."""
        return _mupdf.FzTextSpan_trm(self)

    def items(self, i):
        r"""
        Gives access to m_internal->items[i].
        						Returned reference is only valid as long as `this`.
        						Provided mainly for use by SWIG bindings.
        """
        return _mupdf.FzTextSpan_items(self, i)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::fz_text_span`.
        """
        _mupdf.FzTextSpan_swiginit(self, _mupdf.new_FzTextSpan(*args))
    __swig_destroy__ = _mupdf.delete_FzTextSpan

    def m_internal_value(self):
        r""" Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.FzTextSpan_m_internal_value(self)
    m_internal = property(_mupdf.FzTextSpan_m_internal_get, _mupdf.FzTextSpan_m_internal_set, doc=r""" Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.FzTextSpan_s_num_instances_get, _mupdf.FzTextSpan_s_num_instances_set)

# Register FzTextSpan in _mupdf:
_mupdf.FzTextSpan_swigregister(FzTextSpan)
class FzTransition(object):
    r""" Wrapper class for struct `fz_transition`."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        We use default copy constructor and operator=.  Default constructor, sets each member to default value.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::fz_transition`.

        |

        *Overload 3:*
        Constructor using raw copy of pre-existing `::fz_transition`.
        """
        _mupdf.FzTransition_swiginit(self, _mupdf.new_FzTransition(*args))

    def internal(self, *args):
        r"""
        *Overload 1:*
        Access as underlying struct.

        |

        *Overload 2:*
        Access as underlying struct.
        """
        return _mupdf.FzTransition_internal(self, *args)
    __swig_destroy__ = _mupdf.delete_FzTransition
    type = property(_mupdf.FzTransition_type_get, _mupdf.FzTransition_type_set)
    duration = property(_mupdf.FzTransition_duration_get, _mupdf.FzTransition_duration_set)
    vertical = property(_mupdf.FzTransition_vertical_get, _mupdf.FzTransition_vertical_set)
    outwards = property(_mupdf.FzTransition_outwards_get, _mupdf.FzTransition_outwards_set)
    direction = property(_mupdf.FzTransition_direction_get, _mupdf.FzTransition_direction_set)
    state0 = property(_mupdf.FzTransition_state0_get, _mupdf.FzTransition_state0_set)
    state1 = property(_mupdf.FzTransition_state1_get, _mupdf.FzTransition_state1_set)
    s_num_instances = property(_mupdf.FzTransition_s_num_instances_get, _mupdf.FzTransition_s_num_instances_set)

    def to_string(self):
        r""" Returns string containing our members, labelled and inside (...), using operator<<."""
        return _mupdf.FzTransition_to_string(self)

    def __eq__(self, rhs):
        r""" Comparison method."""
        return _mupdf.FzTransition___eq__(self, rhs)

    def __ne__(self, rhs):
        r""" Comparison method."""
        return _mupdf.FzTransition___ne__(self, rhs)

# Register FzTransition in _mupdf:
_mupdf.FzTransition_swigregister(FzTransition)
class FzTree(object):
    r"""
    Wrapper class for struct `fz_tree`. Not copyable or assignable.
    AA-tree to look up things by strings.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def fz_new_tree_archive(self):
        r"""
        Class-aware wrapper for `::fz_new_tree_archive()`.
        	Create an archive that holds named buffers.

        	tree can either be a preformed tree with fz_buffers as values,
        	or it can be NULL for an empty tree.
        """
        return _mupdf.FzTree_fz_new_tree_archive(self)

    def fz_tree_lookup(self, key):
        r"""
        Class-aware wrapper for `::fz_tree_lookup()`.
        	Look for the value of a node in the tree with the given key.

        	Simple pointer equivalence is used for key.

        	Returns NULL for no match.
        """
        return _mupdf.FzTree_fz_tree_lookup(self, key)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::fz_tree`.
        """
        _mupdf.FzTree_swiginit(self, _mupdf.new_FzTree(*args))
    __swig_destroy__ = _mupdf.delete_FzTree

    def m_internal_value(self):
        r""" Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.FzTree_m_internal_value(self)
    m_internal = property(_mupdf.FzTree_m_internal_get, _mupdf.FzTree_m_internal_set, doc=r""" Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.FzTree_s_num_instances_get, _mupdf.FzTree_s_num_instances_set)

# Register FzTree in _mupdf:
_mupdf.FzTree_swigregister(FzTree)
class FzTuningContext(object):
    r""" Wrapper class for struct `fz_tuning_context`. Not copyable or assignable."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::fz_tuning_context`.
        """
        _mupdf.FzTuningContext_swiginit(self, _mupdf.new_FzTuningContext(*args))
    __swig_destroy__ = _mupdf.delete_FzTuningContext

    def m_internal_value(self):
        r""" Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.FzTuningContext_m_internal_value(self)
    m_internal = property(_mupdf.FzTuningContext_m_internal_get, _mupdf.FzTuningContext_m_internal_set, doc=r""" Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.FzTuningContext_s_num_instances_get, _mupdf.FzTuningContext_s_num_instances_set)

# Register FzTuningContext in _mupdf:
_mupdf.FzTuningContext_swigregister(FzTuningContext)
class FzVertex(object):
    r"""
    Wrapper class for struct `fz_vertex`. Not copyable or assignable.
    Handy routine for processing mesh based shades
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::fz_vertex`.
        """
        _mupdf.FzVertex_swiginit(self, _mupdf.new_FzVertex(*args))
    __swig_destroy__ = _mupdf.delete_FzVertex

    def m_internal_value(self):
        r""" Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.FzVertex_m_internal_value(self)
    m_internal = property(_mupdf.FzVertex_m_internal_get, _mupdf.FzVertex_m_internal_set, doc=r""" Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.FzVertex_s_num_instances_get, _mupdf.FzVertex_s_num_instances_set)

# Register FzVertex in _mupdf:
_mupdf.FzVertex_swigregister(FzVertex)
class FzWarnContext(object):
    r""" Wrapper class for struct `fz_warn_context`. Not copyable or assignable."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::fz_warn_context`.
        """
        _mupdf.FzWarnContext_swiginit(self, _mupdf.new_FzWarnContext(*args))
    __swig_destroy__ = _mupdf.delete_FzWarnContext

    def m_internal_value(self):
        r""" Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.FzWarnContext_m_internal_value(self)
    m_internal = property(_mupdf.FzWarnContext_m_internal_get, _mupdf.FzWarnContext_m_internal_set, doc=r""" Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.FzWarnContext_s_num_instances_get, _mupdf.FzWarnContext_s_num_instances_set)

# Register FzWarnContext in _mupdf:
_mupdf.FzWarnContext_swigregister(FzWarnContext)
class FzWriteStoryPosition(object):
    r""" Wrapper class for struct `fz_write_story_position`. Not copyable or assignable."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::fz_write_story_position`.
        """
        _mupdf.FzWriteStoryPosition_swiginit(self, _mupdf.new_FzWriteStoryPosition(*args))
    __swig_destroy__ = _mupdf.delete_FzWriteStoryPosition

    def m_internal_value(self):
        r""" Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.FzWriteStoryPosition_m_internal_value(self)
    m_internal = property(_mupdf.FzWriteStoryPosition_m_internal_get, _mupdf.FzWriteStoryPosition_m_internal_set, doc=r""" Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.FzWriteStoryPosition_s_num_instances_get, _mupdf.FzWriteStoryPosition_s_num_instances_set)

# Register FzWriteStoryPosition in _mupdf:
_mupdf.FzWriteStoryPosition_swigregister(FzWriteStoryPosition)
class FzWriteStoryPositions(object):
    r""" Wrapper class for struct `fz_write_story_positions`. Not copyable or assignable."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::fz_write_story_positions`.
        """
        _mupdf.FzWriteStoryPositions_swiginit(self, _mupdf.new_FzWriteStoryPositions(*args))
    __swig_destroy__ = _mupdf.delete_FzWriteStoryPositions

    def m_internal_value(self):
        r""" Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.FzWriteStoryPositions_m_internal_value(self)
    m_internal = property(_mupdf.FzWriteStoryPositions_m_internal_get, _mupdf.FzWriteStoryPositions_m_internal_set, doc=r""" Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.FzWriteStoryPositions_s_num_instances_get, _mupdf.FzWriteStoryPositions_s_num_instances_set)

# Register FzWriteStoryPositions in _mupdf:
_mupdf.FzWriteStoryPositions_swigregister(FzWriteStoryPositions)
class FzXml(object):
    r"""
    Wrapper class for struct `fz_xml`.
    XML document model
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def fz_debug_xml(self, level):
        r"""
        Class-aware wrapper for `::fz_debug_xml()`.
        	Pretty-print an XML tree to stdout. (Deprecated, use
        	fz_output_xml in preference).
        """
        return _mupdf.FzXml_fz_debug_xml(self, level)

    def fz_detach_xml(self):
        r"""
        Class-aware wrapper for `::fz_detach_xml()`.
        	Detach a node from the tree, unlinking it from its parent,
        	and setting the document root to the node.
        """
        return _mupdf.FzXml_fz_detach_xml(self)

    def fz_dom_add_attribute(self, att, value):
        r"""
        Class-aware wrapper for `::fz_dom_add_attribute()`.
        	Add an attribute to an element.

        	Ownership of att and value remain with the caller.
        """
        return _mupdf.FzXml_fz_dom_add_attribute(self, att, value)

    def fz_dom_append_child(self, child):
        r"""
        Class-aware wrapper for `::fz_dom_append_child()`.
        	Insert an element as the last child of a parent, unlinking the
        	child from its current position if required.
        """
        return _mupdf.FzXml_fz_dom_append_child(self, child)

    def fz_dom_attribute(self, att):
        r"""
        Class-aware wrapper for `::fz_dom_attribute()`.
        	Retrieve the value of a given attribute from a given element.

        	Returns a borrowed pointer to the value or NULL if not found.
        """
        return _mupdf.FzXml_fz_dom_attribute(self, att)

    def fz_dom_body(self):
        r"""
        Class-aware wrapper for `::fz_dom_body()`.
        	Return a borrowed reference for the 'body' element of
        	the given DOM.
        """
        return _mupdf.FzXml_fz_dom_body(self)

    def fz_dom_clone(self):
        r"""
        Class-aware wrapper for `::fz_dom_clone()`.
        	Clone an element (and its children).

        	A borrowed reference to the clone is returned. The clone is not
        	yet linked into the DOM.
        """
        return _mupdf.FzXml_fz_dom_clone(self)

    def fz_dom_create_element(self, tag):
        r"""
        Class-aware wrapper for `::fz_dom_create_element()`.
        	Create an element of a given tag type for the given DOM.

        	The element is not linked into the DOM yet.
        """
        return _mupdf.FzXml_fz_dom_create_element(self, tag)

    def fz_dom_create_text_node(self, text):
        r"""
        Class-aware wrapper for `::fz_dom_create_text_node()`.
        	Create a text node for the given DOM.

        	The element is not linked into the DOM yet.
        """
        return _mupdf.FzXml_fz_dom_create_text_node(self, text)

    def fz_dom_document_element(self):
        r"""
        Class-aware wrapper for `::fz_dom_document_element()`.
        	Return a borrowed reference for the document (the top
        	level element) of the DOM.
        """
        return _mupdf.FzXml_fz_dom_document_element(self)

    def fz_dom_find(self, tag, att, match):
        r"""
        Class-aware wrapper for `::fz_dom_find()`.
        	Find the first element matching the requirements in a depth first traversal from elt.

        	The tagname must match tag, unless tag is NULL, when all tag names are considered to match.

        	If att is NULL, then all tags match.
        	Otherwise:
        		If match is NULL, then only nodes that have an att attribute match.
        		If match is non-NULL, then only nodes that have an att attribute that matches match match.

        	Returns NULL (if no match found), or a borrowed reference to the first matching element.
        """
        return _mupdf.FzXml_fz_dom_find(self, tag, att, match)

    def fz_dom_find_next(self, tag, att, match):
        r"""
        Class-aware wrapper for `::fz_dom_find_next()`.
        	Find the next element matching the requirements.
        """
        return _mupdf.FzXml_fz_dom_find_next(self, tag, att, match)

    def fz_dom_first_child(self):
        r"""
        Class-aware wrapper for `::fz_dom_first_child()`.
        	Return a borrowed reference to the first child of a node,
        	or NULL if there isn't one.
        """
        return _mupdf.FzXml_fz_dom_first_child(self)

    def fz_dom_get_attribute(self, i, att):
        r"""
        Class-aware wrapper for `::fz_dom_get_attribute()`.

        This method has out-params. Python/C# wrappers look like:
        	`fz_dom_get_attribute(int i)` => `(const char *, const char *att)`

        	Enumerate through the attributes of an element.

        	Call with i=0,1,2,3... to enumerate attributes.

        	On return *att and the return value will be NULL if there are not
        	that many attributes to read. Otherwise, *att will be filled in
        	with a borrowed pointer to the attribute name, and the return
        	value will be a borrowed pointer to the value.
        """
        return _mupdf.FzXml_fz_dom_get_attribute(self, i, att)

    def fz_dom_insert_after(self, new_elt):
        r"""
        Class-aware wrapper for `::fz_dom_insert_after()`.
        	Insert an element (new_elt), after another element (node),
        	unlinking the new_elt from its current position if required.
        """
        return _mupdf.FzXml_fz_dom_insert_after(self, new_elt)

    def fz_dom_insert_before(self, new_elt):
        r"""
        Class-aware wrapper for `::fz_dom_insert_before()`.
        	Insert an element (new_elt), before another element (node),
        	unlinking the new_elt from its current position if required.
        """
        return _mupdf.FzXml_fz_dom_insert_before(self, new_elt)

    def fz_dom_next(self):
        r"""
        Class-aware wrapper for `::fz_dom_next()`.
        	Return a borrowed reference to the next sibling of a node,
        	or NULL if there isn't one.
        """
        return _mupdf.FzXml_fz_dom_next(self)

    def fz_dom_parent(self):
        r"""
        Class-aware wrapper for `::fz_dom_parent()`.
        	Return a borrowed reference to the parent of a node,
        	or NULL if there isn't one.
        """
        return _mupdf.FzXml_fz_dom_parent(self)

    def fz_dom_previous(self):
        r"""
        Class-aware wrapper for `::fz_dom_previous()`.
        	Return a borrowed reference to the previous sibling of a node,
        	or NULL if there isn't one.
        """
        return _mupdf.FzXml_fz_dom_previous(self)

    def fz_dom_remove(self):
        r"""
        Class-aware wrapper for `::fz_dom_remove()`.
        	Remove an element from the DOM. The element can be added back elsewhere
        	if required.

        	No reference counting changes for the element.
        """
        return _mupdf.FzXml_fz_dom_remove(self)

    def fz_dom_remove_attribute(self, att):
        r"""
        Class-aware wrapper for `::fz_dom_remove_attribute()`.
        	Remove an attribute from an element.
        """
        return _mupdf.FzXml_fz_dom_remove_attribute(self, att)

    def fz_new_display_list_from_svg_xml(self, xml, base_uri, dir, w, h):
        r"""
        Class-aware wrapper for `::fz_new_display_list_from_svg_xml()`.

        This method has out-params. Python/C# wrappers look like:
        	`fz_new_display_list_from_svg_xml(::fz_xml *xml, const char *base_uri, ::fz_archive *dir)` => `(fz_display_list *, float w, float h)`

        	Parse an SVG document into a display-list.
        """
        return _mupdf.FzXml_fz_new_display_list_from_svg_xml(self, xml, base_uri, dir, w, h)

    def fz_new_image_from_svg_xml(self, xml, base_uri, dir):
        r"""
        Class-aware wrapper for `::fz_new_image_from_svg_xml()`.
        	Create a scalable image from an SVG document.
        """
        return _mupdf.FzXml_fz_new_image_from_svg_xml(self, xml, base_uri, dir)

    def fz_xml_att(self, att):
        r"""
        Class-aware wrapper for `::fz_xml_att()`.
        	Return the value of an attribute of an XML node.
        	NULL if the attribute doesn't exist.
        """
        return _mupdf.FzXml_fz_xml_att(self, att)

    def fz_xml_att_alt(self, one, two):
        r"""
        Class-aware wrapper for `::fz_xml_att_alt()`.
        	Return the value of an attribute of an XML node.
        	If the first attribute doesn't exist, try the second.
        	NULL if neither attribute exists.
        """
        return _mupdf.FzXml_fz_xml_att_alt(self, one, two)

    def fz_xml_att_eq(self, name, match):
        r"""
        Class-aware wrapper for `::fz_xml_att_eq()`.
        	Check for a matching attribute on an XML node.

        	If the node has the requested attribute (name), and the value
        	matches (match) then return 1. Otherwise, 0.
        """
        return _mupdf.FzXml_fz_xml_att_eq(self, name, match)

    def fz_xml_down(self):
        r"""
        Class-aware wrapper for `::fz_xml_down()`.
        	Return first child of XML node.
        """
        return _mupdf.FzXml_fz_xml_down(self)

    def fz_xml_find(self, tag):
        r"""
        Class-aware wrapper for `::fz_xml_find()`.
        	Search the siblings of XML nodes starting with item looking for
        	the first with the given tag.

        	Return NULL if none found.
        """
        return _mupdf.FzXml_fz_xml_find(self, tag)

    def fz_xml_find_dfs(self, tag, att, match):
        r"""
        Class-aware wrapper for `::fz_xml_find_dfs()`.
        	Perform a depth first search from item, returning the first
        	child that matches the given tag (or any tag if tag is NULL),
        	with the given attribute (if att is non NULL), that matches
        	match (if match is non NULL).
        """
        return _mupdf.FzXml_fz_xml_find_dfs(self, tag, att, match)

    def fz_xml_find_dfs_top(self, tag, att, match, top):
        r"""
        Class-aware wrapper for `::fz_xml_find_dfs_top()`.
        	Perform a depth first search from item, returning the first
        	child that matches the given tag (or any tag if tag is NULL),
        	with the given attribute (if att is non NULL), that matches
        	match (if match is non NULL). The search stops if it ever
        	reaches the top of the tree, or the declared 'top' item.
        """
        return _mupdf.FzXml_fz_xml_find_dfs_top(self, tag, att, match, top)

    def fz_xml_find_down(self, tag):
        r"""
        Class-aware wrapper for `::fz_xml_find_down()`.
        	Search the siblings of XML nodes starting with the first child
        	of item looking for the first with the given tag.

        	Return NULL if none found.
        """
        return _mupdf.FzXml_fz_xml_find_down(self, tag)

    def fz_xml_find_down_match(self, tag, att, match):
        r"""
        Class-aware wrapper for `::fz_xml_find_down_match()`.
        	Search the siblings of XML nodes starting with the first child
        	of item looking for the first with the given tag (or any tag if
        	tag is NULL), and with a matching attribute.

        	Return NULL if none found.
        """
        return _mupdf.FzXml_fz_xml_find_down_match(self, tag, att, match)

    def fz_xml_find_match(self, tag, att, match):
        r"""
        Class-aware wrapper for `::fz_xml_find_match()`.
        	Search the siblings of XML nodes starting with item looking for
        	the first with the given tag (or any tag if tag is NULL), and
        	with a matching attribute.

        	Return NULL if none found.
        """
        return _mupdf.FzXml_fz_xml_find_match(self, tag, att, match)

    def fz_xml_find_next(self, tag):
        r"""
        Class-aware wrapper for `::fz_xml_find_next()`.
        	Search the siblings of XML nodes starting with the first sibling
        	of item looking for the first with the given tag.

        	Return NULL if none found.
        """
        return _mupdf.FzXml_fz_xml_find_next(self, tag)

    def fz_xml_find_next_dfs(self, tag, att, match):
        r"""
        Class-aware wrapper for `::fz_xml_find_next_dfs()`.
        	Perform a depth first search onwards from item, returning the first
        	child that matches the given tag (or any tag if tag is NULL),
        	with the given attribute (if att is non NULL), that matches
        	match (if match is non NULL).
        """
        return _mupdf.FzXml_fz_xml_find_next_dfs(self, tag, att, match)

    def fz_xml_find_next_dfs_top(self, tag, att, match, top):
        r"""
        Class-aware wrapper for `::fz_xml_find_next_dfs_top()`.
        	Perform a depth first search onwards from item, returning the first
        	child that matches the given tag (or any tag if tag is NULL),
        	with the given attribute (if att is non NULL), that matches
        	match (if match is non NULL). The search stops if it ever reaches
        	the top of the tree, or the declared 'top' item.
        """
        return _mupdf.FzXml_fz_xml_find_next_dfs_top(self, tag, att, match, top)

    def fz_xml_find_next_match(self, tag, att, match):
        r"""
        Class-aware wrapper for `::fz_xml_find_next_match()`.
        	Search the siblings of XML nodes starting with the first sibling
        	of item looking for the first with the given tag (or any tag if tag
        	is NULL), and with a matching attribute.

        	Return NULL if none found.
        """
        return _mupdf.FzXml_fz_xml_find_next_match(self, tag, att, match)

    def fz_xml_is_tag(self, name):
        r"""
        Class-aware wrapper for `::fz_xml_is_tag()`.
        	Return true if the tag name matches.
        """
        return _mupdf.FzXml_fz_xml_is_tag(self, name)

    def fz_xml_next(self):
        r"""
        Class-aware wrapper for `::fz_xml_next()`.
        	Return next sibling of XML node.
        """
        return _mupdf.FzXml_fz_xml_next(self)

    def fz_xml_prev(self):
        r"""
        Class-aware wrapper for `::fz_xml_prev()`.
        	Return previous sibling of XML node.
        """
        return _mupdf.FzXml_fz_xml_prev(self)

    def fz_xml_root(self):
        r"""
        Class-aware wrapper for `::fz_xml_root()`.
        	Return the topmost XML node of a document.
        """
        return _mupdf.FzXml_fz_xml_root(self)

    def fz_xml_tag(self):
        r"""
        Class-aware wrapper for `::fz_xml_tag()`.
        	Return tag of XML node. Return NULL for text nodes.
        """
        return _mupdf.FzXml_fz_xml_tag(self)

    def fz_xml_text(self):
        r"""
        Class-aware wrapper for `::fz_xml_text()`.
        	Return the text content of an XML node.
        	Return NULL if the node is a tag.
        """
        return _mupdf.FzXml_fz_xml_text(self)

    def fz_xml_up(self):
        r"""
        Class-aware wrapper for `::fz_xml_up()`.
        	Return parent of XML node.
        """
        return _mupdf.FzXml_fz_xml_up(self)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Copy constructor using `fz_keep_xml()`.

        |

        *Overload 2:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 3:*
        Constructor using raw copy of pre-existing `::fz_xml`.
        """
        _mupdf.FzXml_swiginit(self, _mupdf.new_FzXml(*args))
    __swig_destroy__ = _mupdf.delete_FzXml

    def m_internal_value(self):
        r""" Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.FzXml_m_internal_value(self)
    m_internal = property(_mupdf.FzXml_m_internal_get, _mupdf.FzXml_m_internal_set, doc=r""" Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.FzXml_s_num_instances_get, _mupdf.FzXml_s_num_instances_set)

# Register FzXml in _mupdf:
_mupdf.FzXml_swigregister(FzXml)
class FzXmlDoc(object):
    r""" Wrapper class for struct `fz_xml_doc`. Not copyable or assignable."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::fz_xml_doc`.
        """
        _mupdf.FzXmlDoc_swiginit(self, _mupdf.new_FzXmlDoc(*args))
    __swig_destroy__ = _mupdf.delete_FzXmlDoc

    def m_internal_value(self):
        r""" Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.FzXmlDoc_m_internal_value(self)
    m_internal = property(_mupdf.FzXmlDoc_m_internal_get, _mupdf.FzXmlDoc_m_internal_set, doc=r""" Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.FzXmlDoc_s_num_instances_get, _mupdf.FzXmlDoc_s_num_instances_set)

# Register FzXmlDoc in _mupdf:
_mupdf.FzXmlDoc_swigregister(FzXmlDoc)
class FzZipWriter(object):
    r"""
    Wrapper class for struct `fz_zip_writer`. Not copyable or assignable.
    fz_zip_writer offers methods for creating and writing zip files.
    It can be seen as the reverse of the fz_archive zip
    implementation.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def fz_close_zip_writer(self):
        r"""
        Class-aware wrapper for `::fz_close_zip_writer()`.
        	Close the zip file for writing.

        	This flushes any pending data to the file. This can throw
        	exceptions.
        """
        return _mupdf.FzZipWriter_fz_close_zip_writer(self)

    def fz_write_zip_entry(self, name, buf, compress):
        r"""
        Class-aware wrapper for `::fz_write_zip_entry()`.
        	Given a buffer of data, (optionally) compress it, and add it to
        	the zip file with the given name.
        """
        return _mupdf.FzZipWriter_fz_write_zip_entry(self, name, buf, compress)

    def __init__(self, *args):
        r"""
        *Overload 1:*
         == Constructors.  Constructor using `fz_new_zip_writer()`.
        		Create a new zip writer that writes to a given file.

        		Open an archive using a seekable stream object rather than
        		opening a file or directory on disk.


        |

        *Overload 2:*
         Constructor using `fz_new_zip_writer_with_output()`.
        		Create a new zip writer that writes to a given output stream.

        		Ownership of out passes in immediately upon calling this function.
        		The caller should never drop the fz_output, even if this function throws
        		an exception.


        |

        *Overload 3:*
         Default constructor, sets `m_internal` to null.

        |

        *Overload 4:*
         Constructor using raw copy of pre-existing `::fz_zip_writer`.
        """
        _mupdf.FzZipWriter_swiginit(self, _mupdf.new_FzZipWriter(*args))
    __swig_destroy__ = _mupdf.delete_FzZipWriter

    def m_internal_value(self):
        r""" Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.FzZipWriter_m_internal_value(self)
    m_internal = property(_mupdf.FzZipWriter_m_internal_get, _mupdf.FzZipWriter_m_internal_set, doc=r""" Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.FzZipWriter_s_num_instances_get, _mupdf.FzZipWriter_s_num_instances_set)

# Register FzZipWriter in _mupdf:
_mupdf.FzZipWriter_swigregister(FzZipWriter)
class PdfAlertEvent(object):
    r""" Wrapper class for struct `pdf_alert_event`. Not copyable or assignable."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::pdf_alert_event`.
        """
        _mupdf.PdfAlertEvent_swiginit(self, _mupdf.new_PdfAlertEvent(*args))
    __swig_destroy__ = _mupdf.delete_PdfAlertEvent

    def m_internal_value(self):
        r""" Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.PdfAlertEvent_m_internal_value(self)
    m_internal = property(_mupdf.PdfAlertEvent_m_internal_get, _mupdf.PdfAlertEvent_m_internal_set, doc=r""" Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.PdfAlertEvent_s_num_instances_get, _mupdf.PdfAlertEvent_s_num_instances_set)

# Register PdfAlertEvent in _mupdf:
_mupdf.PdfAlertEvent_swigregister(PdfAlertEvent)
class PdfAnnot(object):
    r""" Wrapper class for struct `pdf_annot`."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def pdf_add_annot_border_dash_item(self, length):
        r""" Class-aware wrapper for `::pdf_add_annot_border_dash_item()`."""
        return _mupdf.PdfAnnot_pdf_add_annot_border_dash_item(self, length)

    def pdf_add_annot_ink_list_stroke(self):
        r""" Class-aware wrapper for `::pdf_add_annot_ink_list_stroke()`."""
        return _mupdf.PdfAnnot_pdf_add_annot_ink_list_stroke(self)

    def pdf_add_annot_ink_list_stroke_vertex(self, p):
        r""" Class-aware wrapper for `::pdf_add_annot_ink_list_stroke_vertex()`."""
        return _mupdf.PdfAnnot_pdf_add_annot_ink_list_stroke_vertex(self, p)

    def pdf_add_annot_quad_point(self, quad):
        r""" Class-aware wrapper for `::pdf_add_annot_quad_point()`."""
        return _mupdf.PdfAnnot_pdf_add_annot_quad_point(self, quad)

    def pdf_add_annot_vertex(self, p):
        r""" Class-aware wrapper for `::pdf_add_annot_vertex()`."""
        return _mupdf.PdfAnnot_pdf_add_annot_vertex(self, p)

    def pdf_annot_MK_BC(self, n, color):
        r"""
        Class-aware wrapper for `::pdf_annot_MK_BC()`.

        This method has out-params. Python/C# wrappers look like:
        	`pdf_annot_MK_BC(float color[4])` => int n
        """
        return _mupdf.PdfAnnot_pdf_annot_MK_BC(self, n, color)

    def pdf_annot_MK_BC_rgb(self, rgb):
        r""" Class-aware wrapper for `::pdf_annot_MK_BC_rgb()`."""
        return _mupdf.PdfAnnot_pdf_annot_MK_BC_rgb(self, rgb)

    def pdf_annot_MK_BG(self, n, color):
        r"""
        Class-aware wrapper for `::pdf_annot_MK_BG()`.

        This method has out-params. Python/C# wrappers look like:
        	`pdf_annot_MK_BG(float color[4])` => int n
        """
        return _mupdf.PdfAnnot_pdf_annot_MK_BG(self, n, color)

    def pdf_annot_MK_BG_rgb(self, rgb):
        r""" Class-aware wrapper for `::pdf_annot_MK_BG_rgb()`."""
        return _mupdf.PdfAnnot_pdf_annot_MK_BG_rgb(self, rgb)

    def pdf_annot_active(self):
        r""" Class-aware wrapper for `::pdf_annot_active()`."""
        return _mupdf.PdfAnnot_pdf_annot_active(self)

    def pdf_annot_ap(self):
        r""" Class-aware wrapper for `::pdf_annot_ap()`."""
        return _mupdf.PdfAnnot_pdf_annot_ap(self)

    def pdf_annot_author(self):
        r""" Class-aware wrapper for `::pdf_annot_author()`."""
        return _mupdf.PdfAnnot_pdf_annot_author(self)

    def pdf_annot_border(self):
        r""" Class-aware wrapper for `::pdf_annot_border()`."""
        return _mupdf.PdfAnnot_pdf_annot_border(self)

    def pdf_annot_border_dash_count(self):
        r""" Class-aware wrapper for `::pdf_annot_border_dash_count()`."""
        return _mupdf.PdfAnnot_pdf_annot_border_dash_count(self)

    def pdf_annot_border_dash_item(self, i):
        r""" Class-aware wrapper for `::pdf_annot_border_dash_item()`."""
        return _mupdf.PdfAnnot_pdf_annot_border_dash_item(self, i)

    def pdf_annot_border_effect(self):
        r""" Class-aware wrapper for `::pdf_annot_border_effect()`."""
        return _mupdf.PdfAnnot_pdf_annot_border_effect(self)

    def pdf_annot_border_effect_intensity(self):
        r""" Class-aware wrapper for `::pdf_annot_border_effect_intensity()`."""
        return _mupdf.PdfAnnot_pdf_annot_border_effect_intensity(self)

    def pdf_annot_border_style(self):
        r""" Class-aware wrapper for `::pdf_annot_border_style()`."""
        return _mupdf.PdfAnnot_pdf_annot_border_style(self)

    def pdf_annot_border_width(self):
        r""" Class-aware wrapper for `::pdf_annot_border_width()`."""
        return _mupdf.PdfAnnot_pdf_annot_border_width(self)

    def pdf_annot_color(self, n, color):
        r"""
        Class-aware wrapper for `::pdf_annot_color()`.

        This method has out-params. Python/C# wrappers look like:
        	`pdf_annot_color(float color[4])` => int n
        """
        return _mupdf.PdfAnnot_pdf_annot_color(self, n, color)

    def pdf_annot_contents(self):
        r""" Class-aware wrapper for `::pdf_annot_contents()`."""
        return _mupdf.PdfAnnot_pdf_annot_contents(self)

    def pdf_annot_creation_date(self):
        r""" Class-aware wrapper for `::pdf_annot_creation_date()`."""
        return _mupdf.PdfAnnot_pdf_annot_creation_date(self)

    def pdf_annot_default_appearance(self, font, size, n, color):
        r"""
        Class-aware wrapper for `::pdf_annot_default_appearance()`.

        This method has out-params. Python/C# wrappers look like:
        	`pdf_annot_default_appearance(float color[4])` => `(const char *font, float size, int n)`
        """
        return _mupdf.PdfAnnot_pdf_annot_default_appearance(self, font, size, n, color)

    def pdf_annot_ensure_local_xref(self):
        r""" Class-aware wrapper for `::pdf_annot_ensure_local_xref()`."""
        return _mupdf.PdfAnnot_pdf_annot_ensure_local_xref(self)

    def pdf_annot_event_blur(self):
        r""" Class-aware wrapper for `::pdf_annot_event_blur()`."""
        return _mupdf.PdfAnnot_pdf_annot_event_blur(self)

    def pdf_annot_event_down(self):
        r""" Class-aware wrapper for `::pdf_annot_event_down()`."""
        return _mupdf.PdfAnnot_pdf_annot_event_down(self)

    def pdf_annot_event_enter(self):
        r""" Class-aware wrapper for `::pdf_annot_event_enter()`."""
        return _mupdf.PdfAnnot_pdf_annot_event_enter(self)

    def pdf_annot_event_exit(self):
        r""" Class-aware wrapper for `::pdf_annot_event_exit()`."""
        return _mupdf.PdfAnnot_pdf_annot_event_exit(self)

    def pdf_annot_event_focus(self):
        r""" Class-aware wrapper for `::pdf_annot_event_focus()`."""
        return _mupdf.PdfAnnot_pdf_annot_event_focus(self)

    def pdf_annot_event_page_close(self):
        r""" Class-aware wrapper for `::pdf_annot_event_page_close()`."""
        return _mupdf.PdfAnnot_pdf_annot_event_page_close(self)

    def pdf_annot_event_page_invisible(self):
        r""" Class-aware wrapper for `::pdf_annot_event_page_invisible()`."""
        return _mupdf.PdfAnnot_pdf_annot_event_page_invisible(self)

    def pdf_annot_event_page_open(self):
        r""" Class-aware wrapper for `::pdf_annot_event_page_open()`."""
        return _mupdf.PdfAnnot_pdf_annot_event_page_open(self)

    def pdf_annot_event_page_visible(self):
        r""" Class-aware wrapper for `::pdf_annot_event_page_visible()`."""
        return _mupdf.PdfAnnot_pdf_annot_event_page_visible(self)

    def pdf_annot_event_up(self):
        r""" Class-aware wrapper for `::pdf_annot_event_up()`."""
        return _mupdf.PdfAnnot_pdf_annot_event_up(self)

    def pdf_annot_field_flags(self):
        r""" Class-aware wrapper for `::pdf_annot_field_flags()`."""
        return _mupdf.PdfAnnot_pdf_annot_field_flags(self)

    def pdf_annot_field_label(self):
        r""" Class-aware wrapper for `::pdf_annot_field_label()`."""
        return _mupdf.PdfAnnot_pdf_annot_field_label(self)

    def pdf_annot_field_value(self):
        r""" Class-aware wrapper for `::pdf_annot_field_value()`."""
        return _mupdf.PdfAnnot_pdf_annot_field_value(self)

    def pdf_annot_filespec(self):
        r""" Class-aware wrapper for `::pdf_annot_filespec()`."""
        return _mupdf.PdfAnnot_pdf_annot_filespec(self)

    def pdf_annot_flags(self):
        r""" Class-aware wrapper for `::pdf_annot_flags()`."""
        return _mupdf.PdfAnnot_pdf_annot_flags(self)

    def pdf_annot_has_author(self):
        r""" Class-aware wrapper for `::pdf_annot_has_author()`."""
        return _mupdf.PdfAnnot_pdf_annot_has_author(self)

    def pdf_annot_has_border(self):
        r""" Class-aware wrapper for `::pdf_annot_has_border()`."""
        return _mupdf.PdfAnnot_pdf_annot_has_border(self)

    def pdf_annot_has_border_effect(self):
        r""" Class-aware wrapper for `::pdf_annot_has_border_effect()`."""
        return _mupdf.PdfAnnot_pdf_annot_has_border_effect(self)

    def pdf_annot_has_filespec(self):
        r""" Class-aware wrapper for `::pdf_annot_has_filespec()`."""
        return _mupdf.PdfAnnot_pdf_annot_has_filespec(self)

    def pdf_annot_has_icon_name(self):
        r""" Class-aware wrapper for `::pdf_annot_has_icon_name()`."""
        return _mupdf.PdfAnnot_pdf_annot_has_icon_name(self)

    def pdf_annot_has_ink_list(self):
        r""" Class-aware wrapper for `::pdf_annot_has_ink_list()`."""
        return _mupdf.PdfAnnot_pdf_annot_has_ink_list(self)

    def pdf_annot_has_interior_color(self):
        r""" Class-aware wrapper for `::pdf_annot_has_interior_color()`."""
        return _mupdf.PdfAnnot_pdf_annot_has_interior_color(self)

    def pdf_annot_has_line(self):
        r""" Class-aware wrapper for `::pdf_annot_has_line()`."""
        return _mupdf.PdfAnnot_pdf_annot_has_line(self)

    def pdf_annot_has_line_ending_styles(self):
        r""" Class-aware wrapper for `::pdf_annot_has_line_ending_styles()`."""
        return _mupdf.PdfAnnot_pdf_annot_has_line_ending_styles(self)

    def pdf_annot_has_open(self):
        r""" Class-aware wrapper for `::pdf_annot_has_open()`."""
        return _mupdf.PdfAnnot_pdf_annot_has_open(self)

    def pdf_annot_has_quad_points(self):
        r""" Class-aware wrapper for `::pdf_annot_has_quad_points()`."""
        return _mupdf.PdfAnnot_pdf_annot_has_quad_points(self)

    def pdf_annot_has_quadding(self):
        r""" Class-aware wrapper for `::pdf_annot_has_quadding()`."""
        return _mupdf.PdfAnnot_pdf_annot_has_quadding(self)

    def pdf_annot_has_rect(self):
        r""" Class-aware wrapper for `::pdf_annot_has_rect()`."""
        return _mupdf.PdfAnnot_pdf_annot_has_rect(self)

    def pdf_annot_has_vertices(self):
        r""" Class-aware wrapper for `::pdf_annot_has_vertices()`."""
        return _mupdf.PdfAnnot_pdf_annot_has_vertices(self)

    def pdf_annot_hidden_for_editing(self):
        r""" Class-aware wrapper for `::pdf_annot_hidden_for_editing()`."""
        return _mupdf.PdfAnnot_pdf_annot_hidden_for_editing(self)

    def pdf_annot_hot(self):
        r""" Class-aware wrapper for `::pdf_annot_hot()`."""
        return _mupdf.PdfAnnot_pdf_annot_hot(self)

    def pdf_annot_icon_name(self):
        r""" Class-aware wrapper for `::pdf_annot_icon_name()`."""
        return _mupdf.PdfAnnot_pdf_annot_icon_name(self)

    def pdf_annot_ink_list_count(self):
        r""" Class-aware wrapper for `::pdf_annot_ink_list_count()`."""
        return _mupdf.PdfAnnot_pdf_annot_ink_list_count(self)

    def pdf_annot_ink_list_stroke_count(self, i):
        r""" Class-aware wrapper for `::pdf_annot_ink_list_stroke_count()`."""
        return _mupdf.PdfAnnot_pdf_annot_ink_list_stroke_count(self, i)

    def pdf_annot_ink_list_stroke_vertex(self, i, k):
        r""" Class-aware wrapper for `::pdf_annot_ink_list_stroke_vertex()`."""
        return _mupdf.PdfAnnot_pdf_annot_ink_list_stroke_vertex(self, i, k)

    def pdf_annot_interior_color(self, n, color):
        r"""
        Class-aware wrapper for `::pdf_annot_interior_color()`.

        This method has out-params. Python/C# wrappers look like:
        	`pdf_annot_interior_color(float color[4])` => int n
        """
        return _mupdf.PdfAnnot_pdf_annot_interior_color(self, n, color)

    def pdf_annot_is_open(self):
        r""" Class-aware wrapper for `::pdf_annot_is_open()`."""
        return _mupdf.PdfAnnot_pdf_annot_is_open(self)

    def pdf_annot_is_standard_stamp(self):
        r""" Class-aware wrapper for `::pdf_annot_is_standard_stamp()`."""
        return _mupdf.PdfAnnot_pdf_annot_is_standard_stamp(self)

    def pdf_annot_line(self, a, b):
        r""" Class-aware wrapper for `::pdf_annot_line()`."""
        return _mupdf.PdfAnnot_pdf_annot_line(self, a, b)

    def pdf_annot_line_end_style(self):
        r""" Class-aware wrapper for `::pdf_annot_line_end_style()`."""
        return _mupdf.PdfAnnot_pdf_annot_line_end_style(self)

    def pdf_annot_line_ending_styles(self, start_style, end_style):
        r"""
        Class-aware wrapper for `::pdf_annot_line_ending_styles()`.

        This method has out-params. Python/C# wrappers look like:
        	`pdf_annot_line_ending_styles()` => `(enum pdf_line_ending start_style, enum pdf_line_ending end_style)`
        """
        return _mupdf.PdfAnnot_pdf_annot_line_ending_styles(self, start_style, end_style)

    def pdf_annot_line_start_style(self):
        r""" Class-aware wrapper for `::pdf_annot_line_start_style()`."""
        return _mupdf.PdfAnnot_pdf_annot_line_start_style(self)

    def pdf_annot_modification_date(self):
        r""" Class-aware wrapper for `::pdf_annot_modification_date()`."""
        return _mupdf.PdfAnnot_pdf_annot_modification_date(self)

    def pdf_annot_needs_resynthesis(self):
        r""" Class-aware wrapper for `::pdf_annot_needs_resynthesis()`."""
        return _mupdf.PdfAnnot_pdf_annot_needs_resynthesis(self)

    def pdf_annot_obj(self):
        r""" Class-aware wrapper for `::pdf_annot_obj()`."""
        return _mupdf.PdfAnnot_pdf_annot_obj(self)

    def pdf_annot_opacity(self):
        r""" Class-aware wrapper for `::pdf_annot_opacity()`."""
        return _mupdf.PdfAnnot_pdf_annot_opacity(self)

    def pdf_annot_page(self):
        r""" Class-aware wrapper for `::pdf_annot_page()`."""
        return _mupdf.PdfAnnot_pdf_annot_page(self)

    def pdf_annot_pop_and_discard_local_xref(self):
        r""" Class-aware wrapper for `::pdf_annot_pop_and_discard_local_xref()`."""
        return _mupdf.PdfAnnot_pdf_annot_pop_and_discard_local_xref(self)

    def pdf_annot_pop_local_xref(self):
        r""" Class-aware wrapper for `::pdf_annot_pop_local_xref()`."""
        return _mupdf.PdfAnnot_pdf_annot_pop_local_xref(self)

    def pdf_annot_popup(self):
        r""" Class-aware wrapper for `::pdf_annot_popup()`."""
        return _mupdf.PdfAnnot_pdf_annot_popup(self)

    def pdf_annot_push_local_xref(self):
        r""" Class-aware wrapper for `::pdf_annot_push_local_xref()`."""
        return _mupdf.PdfAnnot_pdf_annot_push_local_xref(self)

    def pdf_annot_quad_point(self, i):
        r""" Class-aware wrapper for `::pdf_annot_quad_point()`."""
        return _mupdf.PdfAnnot_pdf_annot_quad_point(self, i)

    def pdf_annot_quad_point_count(self):
        r""" Class-aware wrapper for `::pdf_annot_quad_point_count()`."""
        return _mupdf.PdfAnnot_pdf_annot_quad_point_count(self)

    def pdf_annot_quadding(self):
        r""" Class-aware wrapper for `::pdf_annot_quadding()`."""
        return _mupdf.PdfAnnot_pdf_annot_quadding(self)

    def pdf_annot_rect(self):
        r""" Class-aware wrapper for `::pdf_annot_rect()`."""
        return _mupdf.PdfAnnot_pdf_annot_rect(self)

    def pdf_annot_request_resynthesis(self):
        r""" Class-aware wrapper for `::pdf_annot_request_resynthesis()`."""
        return _mupdf.PdfAnnot_pdf_annot_request_resynthesis(self)

    def pdf_annot_request_synthesis(self):
        r""" Class-aware wrapper for `::pdf_annot_request_synthesis()`."""
        return _mupdf.PdfAnnot_pdf_annot_request_synthesis(self)

    def pdf_annot_transform(self):
        r""" Class-aware wrapper for `::pdf_annot_transform()`."""
        return _mupdf.PdfAnnot_pdf_annot_transform(self)

    def pdf_annot_type(self):
        r""" Class-aware wrapper for `::pdf_annot_type()`."""
        return _mupdf.PdfAnnot_pdf_annot_type(self)

    def pdf_annot_vertex(self, i):
        r""" Class-aware wrapper for `::pdf_annot_vertex()`."""
        return _mupdf.PdfAnnot_pdf_annot_vertex(self, i)

    def pdf_annot_vertex_count(self):
        r""" Class-aware wrapper for `::pdf_annot_vertex_count()`."""
        return _mupdf.PdfAnnot_pdf_annot_vertex_count(self)

    def pdf_apply_redaction(self, opts):
        r""" Class-aware wrapper for `::pdf_apply_redaction()`."""
        return _mupdf.PdfAnnot_pdf_apply_redaction(self, opts)

    def pdf_bound_annot(self):
        r""" Class-aware wrapper for `::pdf_bound_annot()`."""
        return _mupdf.PdfAnnot_pdf_bound_annot(self)

    def pdf_bound_widget(self):
        r""" Class-aware wrapper for `::pdf_bound_widget()`."""
        return _mupdf.PdfAnnot_pdf_bound_widget(self)

    def pdf_choice_widget_is_multiselect(self):
        r""" Class-aware wrapper for `::pdf_choice_widget_is_multiselect()`."""
        return _mupdf.PdfAnnot_pdf_choice_widget_is_multiselect(self)

    def pdf_choice_widget_options(self, exportval, opts):
        r""" Class-aware wrapper for `::pdf_choice_widget_options()`."""
        return _mupdf.PdfAnnot_pdf_choice_widget_options(self, exportval, opts)

    def pdf_choice_widget_options2(self, exportval):
        r"""
        Class-aware wrapper for `::pdf_choice_widget_options2()`.   Swig-friendly wrapper for pdf_choice_widget_options(), returns the
        options directly in a vector.
        """
        return _mupdf.PdfAnnot_pdf_choice_widget_options2(self, exportval)

    def pdf_choice_widget_set_value(self, n, opts):
        r""" Class-aware wrapper for `::pdf_choice_widget_set_value()`."""
        return _mupdf.PdfAnnot_pdf_choice_widget_set_value(self, n, opts)

    def pdf_choice_widget_value(self, opts):
        r""" Class-aware wrapper for `::pdf_choice_widget_value()`."""
        return _mupdf.PdfAnnot_pdf_choice_widget_value(self, opts)

    def pdf_clear_annot_border_dash(self):
        r""" Class-aware wrapper for `::pdf_clear_annot_border_dash()`."""
        return _mupdf.PdfAnnot_pdf_clear_annot_border_dash(self)

    def pdf_clear_annot_ink_list(self):
        r""" Class-aware wrapper for `::pdf_clear_annot_ink_list()`."""
        return _mupdf.PdfAnnot_pdf_clear_annot_ink_list(self)

    def pdf_clear_annot_quad_points(self):
        r""" Class-aware wrapper for `::pdf_clear_annot_quad_points()`."""
        return _mupdf.PdfAnnot_pdf_clear_annot_quad_points(self)

    def pdf_clear_annot_vertices(self):
        r""" Class-aware wrapper for `::pdf_clear_annot_vertices()`."""
        return _mupdf.PdfAnnot_pdf_clear_annot_vertices(self)

    def pdf_clear_signature(self):
        r""" Class-aware wrapper for `::pdf_clear_signature()`."""
        return _mupdf.PdfAnnot_pdf_clear_signature(self)

    def pdf_dirty_annot(self):
        r""" Class-aware wrapper for `::pdf_dirty_annot()`."""
        return _mupdf.PdfAnnot_pdf_dirty_annot(self)

    def pdf_edit_text_field_value(self, value, change, selStart, selEnd, newvalue):
        r"""
        Class-aware wrapper for `::pdf_edit_text_field_value()`.

        This method has out-params. Python/C# wrappers look like:
        	`pdf_edit_text_field_value(const char *value, const char *change)` => `(int, int selStart, int selEnd, char *newvalue)`
        """
        return _mupdf.PdfAnnot_pdf_edit_text_field_value(self, value, change, selStart, selEnd, newvalue)

    def pdf_get_widget_editing_state(self):
        r""" Class-aware wrapper for `::pdf_get_widget_editing_state()`."""
        return _mupdf.PdfAnnot_pdf_get_widget_editing_state(self)

    def pdf_new_display_list_from_annot(self):
        r""" Class-aware wrapper for `::pdf_new_display_list_from_annot()`."""
        return _mupdf.PdfAnnot_pdf_new_display_list_from_annot(self)

    def pdf_new_pixmap_from_annot(self, ctm, cs, seps, alpha):
        r""" Class-aware wrapper for `::pdf_new_pixmap_from_annot()`."""
        return _mupdf.PdfAnnot_pdf_new_pixmap_from_annot(self, ctm, cs, seps, alpha)

    def pdf_next_annot(self):
        r""" Class-aware wrapper for `::pdf_next_annot()`."""
        return _mupdf.PdfAnnot_pdf_next_annot(self)

    def pdf_next_widget(self):
        r""" Class-aware wrapper for `::pdf_next_widget()`."""
        return _mupdf.PdfAnnot_pdf_next_widget(self)

    def pdf_run_annot(self, dev, ctm, cookie):
        r""" Class-aware wrapper for `::pdf_run_annot()`."""
        return _mupdf.PdfAnnot_pdf_run_annot(self, dev, ctm, cookie)

    def pdf_set_annot_active(self, active):
        r""" Class-aware wrapper for `::pdf_set_annot_active()`."""
        return _mupdf.PdfAnnot_pdf_set_annot_active(self, active)

    def pdf_set_annot_appearance(self, appearance, state, ctm, bbox, res, contents):
        r""" Class-aware wrapper for `::pdf_set_annot_appearance()`."""
        return _mupdf.PdfAnnot_pdf_set_annot_appearance(self, appearance, state, ctm, bbox, res, contents)

    def pdf_set_annot_appearance_from_display_list(self, appearance, state, ctm, list):
        r""" Class-aware wrapper for `::pdf_set_annot_appearance_from_display_list()`."""
        return _mupdf.PdfAnnot_pdf_set_annot_appearance_from_display_list(self, appearance, state, ctm, list)

    def pdf_set_annot_author(self, author):
        r""" Class-aware wrapper for `::pdf_set_annot_author()`."""
        return _mupdf.PdfAnnot_pdf_set_annot_author(self, author)

    def pdf_set_annot_border(self, width):
        r""" Class-aware wrapper for `::pdf_set_annot_border()`."""
        return _mupdf.PdfAnnot_pdf_set_annot_border(self, width)

    def pdf_set_annot_border_effect(self, effect):
        r""" Class-aware wrapper for `::pdf_set_annot_border_effect()`."""
        return _mupdf.PdfAnnot_pdf_set_annot_border_effect(self, effect)

    def pdf_set_annot_border_effect_intensity(self, intensity):
        r""" Class-aware wrapper for `::pdf_set_annot_border_effect_intensity()`."""
        return _mupdf.PdfAnnot_pdf_set_annot_border_effect_intensity(self, intensity)

    def pdf_set_annot_border_style(self, style):
        r""" Class-aware wrapper for `::pdf_set_annot_border_style()`."""
        return _mupdf.PdfAnnot_pdf_set_annot_border_style(self, style)

    def pdf_set_annot_border_width(self, width):
        r""" Class-aware wrapper for `::pdf_set_annot_border_width()`."""
        return _mupdf.PdfAnnot_pdf_set_annot_border_width(self, width)

    def pdf_set_annot_color(self, n, color):
        r""" Class-aware wrapper for `::pdf_set_annot_color()`."""
        return _mupdf.PdfAnnot_pdf_set_annot_color(self, n, color)

    def pdf_set_annot_contents(self, text):
        r""" Class-aware wrapper for `::pdf_set_annot_contents()`."""
        return _mupdf.PdfAnnot_pdf_set_annot_contents(self, text)

    def pdf_set_annot_creation_date(self, time):
        r""" Class-aware wrapper for `::pdf_set_annot_creation_date()`."""
        return _mupdf.PdfAnnot_pdf_set_annot_creation_date(self, time)

    def pdf_set_annot_default_appearance(self, font, size, n, color):
        r""" Class-aware wrapper for `::pdf_set_annot_default_appearance()`."""
        return _mupdf.PdfAnnot_pdf_set_annot_default_appearance(self, font, size, n, color)

    def pdf_set_annot_filespec(self, obj):
        r""" Class-aware wrapper for `::pdf_set_annot_filespec()`."""
        return _mupdf.PdfAnnot_pdf_set_annot_filespec(self, obj)

    def pdf_set_annot_flags(self, flags):
        r""" Class-aware wrapper for `::pdf_set_annot_flags()`."""
        return _mupdf.PdfAnnot_pdf_set_annot_flags(self, flags)

    def pdf_set_annot_hidden_for_editing(self, hidden):
        r""" Class-aware wrapper for `::pdf_set_annot_hidden_for_editing()`."""
        return _mupdf.PdfAnnot_pdf_set_annot_hidden_for_editing(self, hidden)

    def pdf_set_annot_hot(self, hot):
        r""" Class-aware wrapper for `::pdf_set_annot_hot()`."""
        return _mupdf.PdfAnnot_pdf_set_annot_hot(self, hot)

    def pdf_set_annot_icon_name(self, name):
        r""" Class-aware wrapper for `::pdf_set_annot_icon_name()`."""
        return _mupdf.PdfAnnot_pdf_set_annot_icon_name(self, name)

    def pdf_set_annot_ink_list(self, n, count, v):
        r""" Class-aware wrapper for `::pdf_set_annot_ink_list()`."""
        return _mupdf.PdfAnnot_pdf_set_annot_ink_list(self, n, count, v)

    def pdf_set_annot_interior_color(self, n, color):
        r""" Class-aware wrapper for `::pdf_set_annot_interior_color()`."""
        return _mupdf.PdfAnnot_pdf_set_annot_interior_color(self, n, color)

    def pdf_set_annot_is_open(self, is_open):
        r""" Class-aware wrapper for `::pdf_set_annot_is_open()`."""
        return _mupdf.PdfAnnot_pdf_set_annot_is_open(self, is_open)

    def pdf_set_annot_language(self, lang):
        r""" Class-aware wrapper for `::pdf_set_annot_language()`."""
        return _mupdf.PdfAnnot_pdf_set_annot_language(self, lang)

    def pdf_set_annot_line(self, a, b):
        r""" Class-aware wrapper for `::pdf_set_annot_line()`."""
        return _mupdf.PdfAnnot_pdf_set_annot_line(self, a, b)

    def pdf_set_annot_line_end_style(self, e):
        r""" Class-aware wrapper for `::pdf_set_annot_line_end_style()`."""
        return _mupdf.PdfAnnot_pdf_set_annot_line_end_style(self, e)

    def pdf_set_annot_line_ending_styles(self, start_style, end_style):
        r""" Class-aware wrapper for `::pdf_set_annot_line_ending_styles()`."""
        return _mupdf.PdfAnnot_pdf_set_annot_line_ending_styles(self, start_style, end_style)

    def pdf_set_annot_line_start_style(self, s):
        r""" Class-aware wrapper for `::pdf_set_annot_line_start_style()`."""
        return _mupdf.PdfAnnot_pdf_set_annot_line_start_style(self, s)

    def pdf_set_annot_modification_date(self, time):
        r""" Class-aware wrapper for `::pdf_set_annot_modification_date()`."""
        return _mupdf.PdfAnnot_pdf_set_annot_modification_date(self, time)

    def pdf_set_annot_opacity(self, opacity):
        r""" Class-aware wrapper for `::pdf_set_annot_opacity()`."""
        return _mupdf.PdfAnnot_pdf_set_annot_opacity(self, opacity)

    def pdf_set_annot_popup(self, rect):
        r""" Class-aware wrapper for `::pdf_set_annot_popup()`."""
        return _mupdf.PdfAnnot_pdf_set_annot_popup(self, rect)

    def pdf_set_annot_quad_points(self, n, qv):
        r""" Class-aware wrapper for `::pdf_set_annot_quad_points()`."""
        return _mupdf.PdfAnnot_pdf_set_annot_quad_points(self, n, qv)

    def pdf_set_annot_quadding(self, q):
        r""" Class-aware wrapper for `::pdf_set_annot_quadding()`."""
        return _mupdf.PdfAnnot_pdf_set_annot_quadding(self, q)

    def pdf_set_annot_rect(self, rect):
        r""" Class-aware wrapper for `::pdf_set_annot_rect()`."""
        return _mupdf.PdfAnnot_pdf_set_annot_rect(self, rect)

    def pdf_set_annot_resynthesised(self):
        r""" Class-aware wrapper for `::pdf_set_annot_resynthesised()`."""
        return _mupdf.PdfAnnot_pdf_set_annot_resynthesised(self)

    def pdf_set_annot_stamp_image(self, image):
        r""" Class-aware wrapper for `::pdf_set_annot_stamp_image()`."""
        return _mupdf.PdfAnnot_pdf_set_annot_stamp_image(self, image)

    def pdf_set_annot_vertex(self, i, p):
        r""" Class-aware wrapper for `::pdf_set_annot_vertex()`."""
        return _mupdf.PdfAnnot_pdf_set_annot_vertex(self, i, p)

    def pdf_set_annot_vertices(self, n, v):
        r""" Class-aware wrapper for `::pdf_set_annot_vertices()`."""
        return _mupdf.PdfAnnot_pdf_set_annot_vertices(self, n, v)

    def pdf_set_choice_field_value(self, value):
        r""" Class-aware wrapper for `::pdf_set_choice_field_value()`."""
        return _mupdf.PdfAnnot_pdf_set_choice_field_value(self, value)

    def pdf_set_text_field_value(self, value):
        r""" Class-aware wrapper for `::pdf_set_text_field_value()`."""
        return _mupdf.PdfAnnot_pdf_set_text_field_value(self, value)

    def pdf_set_widget_editing_state(self, editing):
        r""" Class-aware wrapper for `::pdf_set_widget_editing_state()`."""
        return _mupdf.PdfAnnot_pdf_set_widget_editing_state(self, editing)

    def pdf_sign_signature(self, signer, appearance_flags, graphic, reason, location):
        r""" Class-aware wrapper for `::pdf_sign_signature()`."""
        return _mupdf.PdfAnnot_pdf_sign_signature(self, signer, appearance_flags, graphic, reason, location)

    def pdf_sign_signature_with_appearance(self, signer, date, disp_list):
        r""" Class-aware wrapper for `::pdf_sign_signature_with_appearance()`."""
        return _mupdf.PdfAnnot_pdf_sign_signature_with_appearance(self, signer, date, disp_list)

    def pdf_text_widget_format(self):
        r""" Class-aware wrapper for `::pdf_text_widget_format()`."""
        return _mupdf.PdfAnnot_pdf_text_widget_format(self)

    def pdf_text_widget_max_len(self):
        r""" Class-aware wrapper for `::pdf_text_widget_max_len()`."""
        return _mupdf.PdfAnnot_pdf_text_widget_max_len(self)

    def pdf_toggle_widget(self):
        r""" Class-aware wrapper for `::pdf_toggle_widget()`."""
        return _mupdf.PdfAnnot_pdf_toggle_widget(self)

    def pdf_update_annot(self):
        r""" Class-aware wrapper for `::pdf_update_annot()`."""
        return _mupdf.PdfAnnot_pdf_update_annot(self)

    def pdf_update_widget(self):
        r""" Class-aware wrapper for `::pdf_update_widget()`."""
        return _mupdf.PdfAnnot_pdf_update_widget(self)

    def pdf_validate_signature(self):
        r""" Class-aware wrapper for `::pdf_validate_signature()`."""
        return _mupdf.PdfAnnot_pdf_validate_signature(self)

    def pdf_widget_is_readonly(self):
        r""" Class-aware wrapper for `::pdf_widget_is_readonly()`."""
        return _mupdf.PdfAnnot_pdf_widget_is_readonly(self)

    def pdf_widget_is_signed(self):
        r""" Class-aware wrapper for `::pdf_widget_is_signed()`."""
        return _mupdf.PdfAnnot_pdf_widget_is_signed(self)

    def pdf_widget_type(self):
        r""" Class-aware wrapper for `::pdf_widget_type()`."""
        return _mupdf.PdfAnnot_pdf_widget_type(self)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Copy constructor using `pdf_keep_annot()`.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::pdf_annot`.

        |

        *Overload 3:*
        Constructor using raw copy of pre-existing `::pdf_annot`.
        """
        _mupdf.PdfAnnot_swiginit(self, _mupdf.new_PdfAnnot(*args))
    __swig_destroy__ = _mupdf.delete_PdfAnnot

    def m_internal_value(self):
        r""" Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.PdfAnnot_m_internal_value(self)
    m_internal = property(_mupdf.PdfAnnot_m_internal_get, _mupdf.PdfAnnot_m_internal_set, doc=r""" Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.PdfAnnot_s_num_instances_get, _mupdf.PdfAnnot_s_num_instances_set)

# Register PdfAnnot in _mupdf:
_mupdf.PdfAnnot_swigregister(PdfAnnot)
class PdfCleanOptions(object):
    r""" Wrapper class for struct `pdf_clean_options`."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def write_opwd_utf8_set(self, text):
        r""" Copies <text> into write.opwd_utf8[]."""
        return _mupdf.PdfCleanOptions_write_opwd_utf8_set(self, text)

    def write_upwd_utf8_set(self, text):
        r""" Copies <text> into upwd_utf8[]."""
        return _mupdf.PdfCleanOptions_write_upwd_utf8_set(self, text)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor, makes copy of pdf_default_write_options.

        |

        *Overload 2:*
        Copy constructor using raw memcopy().

        |

        *Overload 3:*
        Constructor using raw copy of pre-existing `::pdf_clean_options`.

        |

        *Overload 4:*
        Constructor using raw copy of pre-existing `::pdf_clean_options`.
        """
        _mupdf.PdfCleanOptions_swiginit(self, _mupdf.new_PdfCleanOptions(*args))

    def internal(self, *args):
        r"""
        *Overload 1:*
        Access as underlying struct.

        |

        *Overload 2:*
        Access as underlying struct.
        """
        return _mupdf.PdfCleanOptions_internal(self, *args)
    __swig_destroy__ = _mupdf.delete_PdfCleanOptions
    write = property(_mupdf.PdfCleanOptions_write_get, _mupdf.PdfCleanOptions_write_set)
    image = property(_mupdf.PdfCleanOptions_image_get, _mupdf.PdfCleanOptions_image_set)
    subset_fonts = property(_mupdf.PdfCleanOptions_subset_fonts_get, _mupdf.PdfCleanOptions_subset_fonts_set)
    s_num_instances = property(_mupdf.PdfCleanOptions_s_num_instances_get, _mupdf.PdfCleanOptions_s_num_instances_set)

    def to_string(self):
        r""" Returns string containing our members, labelled and inside (...), using operator<<."""
        return _mupdf.PdfCleanOptions_to_string(self)

    def __eq__(self, rhs):
        r""" Comparison method."""
        return _mupdf.PdfCleanOptions___eq__(self, rhs)

    def __ne__(self, rhs):
        r""" Comparison method."""
        return _mupdf.PdfCleanOptions___ne__(self, rhs)

# Register PdfCleanOptions in _mupdf:
_mupdf.PdfCleanOptions_swigregister(PdfCleanOptions)
class PdfCmap(object):
    r""" Wrapper class for struct `pdf_cmap`."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def pdf_add_codespace(self, low, high, n):
        r""" Class-aware wrapper for `::pdf_add_codespace()`."""
        return _mupdf.PdfCmap_pdf_add_codespace(self, low, high, n)

    def pdf_cmap_size(self):
        r""" Class-aware wrapper for `::pdf_cmap_size()`."""
        return _mupdf.PdfCmap_pdf_cmap_size(self)

    def pdf_cmap_wmode(self):
        r""" Class-aware wrapper for `::pdf_cmap_wmode()`."""
        return _mupdf.PdfCmap_pdf_cmap_wmode(self)

    def pdf_decode_cmap(self, s, e, cpt):
        r"""
        Class-aware wrapper for `::pdf_decode_cmap()`.

        This method has out-params. Python/C# wrappers look like:
        	`pdf_decode_cmap(unsigned char *s, unsigned char *e)` => `(int, unsigned int cpt)`
        """
        return _mupdf.PdfCmap_pdf_decode_cmap(self, s, e, cpt)

    def pdf_lookup_cmap(self, cpt):
        r""" Class-aware wrapper for `::pdf_lookup_cmap()`."""
        return _mupdf.PdfCmap_pdf_lookup_cmap(self, cpt)

    def pdf_lookup_cmap_full(self, cpt, out):
        r"""
        Class-aware wrapper for `::pdf_lookup_cmap_full()`.

        This method has out-params. Python/C# wrappers look like:
        	`pdf_lookup_cmap_full(unsigned int cpt)` => `(int, int out)`
        """
        return _mupdf.PdfCmap_pdf_lookup_cmap_full(self, cpt, out)

    def pdf_map_one_to_many(self, one, many, len):
        r"""
        Class-aware wrapper for `::pdf_map_one_to_many()`.

        This method has out-params. Python/C# wrappers look like:
        	`pdf_map_one_to_many(unsigned int one, size_t len)` => int many
        """
        return _mupdf.PdfCmap_pdf_map_one_to_many(self, one, many, len)

    def pdf_map_range_to_range(self, srclo, srchi, dstlo):
        r""" Class-aware wrapper for `::pdf_map_range_to_range()`."""
        return _mupdf.PdfCmap_pdf_map_range_to_range(self, srclo, srchi, dstlo)

    def pdf_set_cmap_wmode(self, wmode):
        r""" Class-aware wrapper for `::pdf_set_cmap_wmode()`."""
        return _mupdf.PdfCmap_pdf_set_cmap_wmode(self, wmode)

    def pdf_set_usecmap(self, usecmap):
        r""" Class-aware wrapper for `::pdf_set_usecmap()`."""
        return _mupdf.PdfCmap_pdf_set_usecmap(self, usecmap)

    def pdf_sort_cmap(self):
        r""" Class-aware wrapper for `::pdf_sort_cmap()`."""
        return _mupdf.PdfCmap_pdf_sort_cmap(self)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        == Constructors.  Constructor using `pdf_new_cmap()`.

        |

        *Overload 2:*
        Constructor using `pdf_new_identity_cmap()`.

        |

        *Overload 3:*
        Copy constructor using `pdf_keep_cmap()`.

        |

        *Overload 4:*
        Constructor using raw copy of pre-existing `::pdf_cmap`.
        """
        _mupdf.PdfCmap_swiginit(self, _mupdf.new_PdfCmap(*args))
    __swig_destroy__ = _mupdf.delete_PdfCmap

    def m_internal_value(self):
        r""" Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.PdfCmap_m_internal_value(self)
    m_internal = property(_mupdf.PdfCmap_m_internal_get, _mupdf.PdfCmap_m_internal_set, doc=r""" Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.PdfCmap_s_num_instances_get, _mupdf.PdfCmap_s_num_instances_set)

# Register PdfCmap in _mupdf:
_mupdf.PdfCmap_swigregister(PdfCmap)
class PdfColorFilterOptions(object):
    r""" Wrapper class for struct `pdf_color_filter_options`. Not copyable or assignable."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::pdf_color_filter_options`.
        """
        _mupdf.PdfColorFilterOptions_swiginit(self, _mupdf.new_PdfColorFilterOptions(*args))
    __swig_destroy__ = _mupdf.delete_PdfColorFilterOptions

    def m_internal_value(self):
        r""" Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.PdfColorFilterOptions_m_internal_value(self)
    m_internal = property(_mupdf.PdfColorFilterOptions_m_internal_get, _mupdf.PdfColorFilterOptions_m_internal_set, doc=r""" Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.PdfColorFilterOptions_s_num_instances_get, _mupdf.PdfColorFilterOptions_s_num_instances_set)

# Register PdfColorFilterOptions in _mupdf:
_mupdf.PdfColorFilterOptions_swigregister(PdfColorFilterOptions)
class PdfCrypt(object):
    r""" Wrapper class for struct `pdf_crypt`. Not copyable or assignable."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def pdf_crypt_encrypt_metadata(self):
        r""" Class-aware wrapper for `::pdf_crypt_encrypt_metadata()`."""
        return _mupdf.PdfCrypt_pdf_crypt_encrypt_metadata(self)

    def pdf_crypt_key(self):
        r""" Class-aware wrapper for `::pdf_crypt_key()`."""
        return _mupdf.PdfCrypt_pdf_crypt_key(self)

    def pdf_crypt_length(self):
        r""" Class-aware wrapper for `::pdf_crypt_length()`."""
        return _mupdf.PdfCrypt_pdf_crypt_length(self)

    def pdf_crypt_method(self):
        r""" Class-aware wrapper for `::pdf_crypt_method()`."""
        return _mupdf.PdfCrypt_pdf_crypt_method(self)

    def pdf_crypt_obj(self, obj, num, gen):
        r""" Class-aware wrapper for `::pdf_crypt_obj()`."""
        return _mupdf.PdfCrypt_pdf_crypt_obj(self, obj, num, gen)

    def pdf_crypt_owner_encryption(self):
        r""" Class-aware wrapper for `::pdf_crypt_owner_encryption()`."""
        return _mupdf.PdfCrypt_pdf_crypt_owner_encryption(self)

    def pdf_crypt_owner_password(self):
        r""" Class-aware wrapper for `::pdf_crypt_owner_password()`."""
        return _mupdf.PdfCrypt_pdf_crypt_owner_password(self)

    def pdf_crypt_permissions(self):
        r""" Class-aware wrapper for `::pdf_crypt_permissions()`."""
        return _mupdf.PdfCrypt_pdf_crypt_permissions(self)

    def pdf_crypt_permissions_encryption(self):
        r""" Class-aware wrapper for `::pdf_crypt_permissions_encryption()`."""
        return _mupdf.PdfCrypt_pdf_crypt_permissions_encryption(self)

    def pdf_crypt_revision(self):
        r""" Class-aware wrapper for `::pdf_crypt_revision()`."""
        return _mupdf.PdfCrypt_pdf_crypt_revision(self)

    def pdf_crypt_stream_method(self):
        r""" Class-aware wrapper for `::pdf_crypt_stream_method()`."""
        return _mupdf.PdfCrypt_pdf_crypt_stream_method(self)

    def pdf_crypt_string_method(self):
        r""" Class-aware wrapper for `::pdf_crypt_string_method()`."""
        return _mupdf.PdfCrypt_pdf_crypt_string_method(self)

    def pdf_crypt_user_encryption(self):
        r""" Class-aware wrapper for `::pdf_crypt_user_encryption()`."""
        return _mupdf.PdfCrypt_pdf_crypt_user_encryption(self)

    def pdf_crypt_user_password(self):
        r""" Class-aware wrapper for `::pdf_crypt_user_password()`."""
        return _mupdf.PdfCrypt_pdf_crypt_user_password(self)

    def pdf_crypt_version(self):
        r""" Class-aware wrapper for `::pdf_crypt_version()`."""
        return _mupdf.PdfCrypt_pdf_crypt_version(self)

    def pdf_encrypt_data(self, num, gen, fmt_str_out, arg, s, n):
        r""" Class-aware wrapper for `::pdf_encrypt_data()`."""
        return _mupdf.PdfCrypt_pdf_encrypt_data(self, num, gen, fmt_str_out, arg, s, n)

    def pdf_encrypted_len(self, num, gen, len):
        r""" Class-aware wrapper for `::pdf_encrypted_len()`."""
        return _mupdf.PdfCrypt_pdf_encrypted_len(self, num, gen, len)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        == Constructors.  Constructor using `pdf_new_crypt()`.

        |

        *Overload 2:*
        Constructor using `pdf_new_encrypt()`.

        |

        *Overload 3:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 4:*
        Constructor using raw copy of pre-existing `::pdf_crypt`.
        """
        _mupdf.PdfCrypt_swiginit(self, _mupdf.new_PdfCrypt(*args))
    __swig_destroy__ = _mupdf.delete_PdfCrypt

    def m_internal_value(self):
        r""" Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.PdfCrypt_m_internal_value(self)
    m_internal = property(_mupdf.PdfCrypt_m_internal_get, _mupdf.PdfCrypt_m_internal_set, doc=r""" Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.PdfCrypt_s_num_instances_get, _mupdf.PdfCrypt_s_num_instances_set)

# Register PdfCrypt in _mupdf:
_mupdf.PdfCrypt_swigregister(PdfCrypt)
class PdfCsi(object):
    r""" Wrapper class for struct `pdf_csi`. Not copyable or assignable."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::pdf_csi`.
        """
        _mupdf.PdfCsi_swiginit(self, _mupdf.new_PdfCsi(*args))
    __swig_destroy__ = _mupdf.delete_PdfCsi

    def m_internal_value(self):
        r""" Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.PdfCsi_m_internal_value(self)
    m_internal = property(_mupdf.PdfCsi_m_internal_get, _mupdf.PdfCsi_m_internal_set, doc=r""" Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.PdfCsi_s_num_instances_get, _mupdf.PdfCsi_s_num_instances_set)

# Register PdfCsi in _mupdf:
_mupdf.PdfCsi_swigregister(PdfCsi)
class PdfCycleList(object):
    r""" Wrapper class for struct `pdf_cycle_list`. Not copyable or assignable."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def pdf_cycle(self, prev, obj):
        r""" Class-aware wrapper for `::pdf_cycle()`."""
        return _mupdf.PdfCycleList_pdf_cycle(self, prev, obj)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::pdf_cycle_list`.
        """
        _mupdf.PdfCycleList_swiginit(self, _mupdf.new_PdfCycleList(*args))
    __swig_destroy__ = _mupdf.delete_PdfCycleList

    def m_internal_value(self):
        r""" Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.PdfCycleList_m_internal_value(self)
    m_internal = property(_mupdf.PdfCycleList_m_internal_get, _mupdf.PdfCycleList_m_internal_set, doc=r""" Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.PdfCycleList_s_num_instances_get, _mupdf.PdfCycleList_s_num_instances_set)

# Register PdfCycleList in _mupdf:
_mupdf.PdfCycleList_swigregister(PdfCycleList)
class PdfDocEvent(object):
    r""" Wrapper class for struct `pdf_doc_event`. Not copyable or assignable."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def pdf_access_exec_menu_item_event(self):
        r""" Class-aware wrapper for `::pdf_access_exec_menu_item_event()`."""
        return _mupdf.PdfDocEvent_pdf_access_exec_menu_item_event(self)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::pdf_doc_event`.
        """
        _mupdf.PdfDocEvent_swiginit(self, _mupdf.new_PdfDocEvent(*args))
    __swig_destroy__ = _mupdf.delete_PdfDocEvent

    def m_internal_value(self):
        r""" Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.PdfDocEvent_m_internal_value(self)
    m_internal = property(_mupdf.PdfDocEvent_m_internal_get, _mupdf.PdfDocEvent_m_internal_set, doc=r""" Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.PdfDocEvent_s_num_instances_get, _mupdf.PdfDocEvent_s_num_instances_set)

# Register PdfDocEvent in _mupdf:
_mupdf.PdfDocEvent_swigregister(PdfDocEvent)
class PdfDocument(object):
    r""" Wrapper class for struct `pdf_document`."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def pdf_abandon_operation(self):
        r""" Class-aware wrapper for `::pdf_abandon_operation()`."""
        return _mupdf.PdfDocument_pdf_abandon_operation(self)

    def pdf_add_cid_font(self, font):
        r""" Class-aware wrapper for `::pdf_add_cid_font()`."""
        return _mupdf.PdfDocument_pdf_add_cid_font(self, font)

    def pdf_add_cjk_font(self, font, script, wmode, serif):
        r""" Class-aware wrapper for `::pdf_add_cjk_font()`."""
        return _mupdf.PdfDocument_pdf_add_cjk_font(self, font, script, wmode, serif)

    def pdf_add_embedded_file(self, filename, mimetype, contents, created, modifed, add_checksum):
        r""" Class-aware wrapper for `::pdf_add_embedded_file()`."""
        return _mupdf.PdfDocument_pdf_add_embedded_file(self, filename, mimetype, contents, created, modifed, add_checksum)

    def pdf_add_image(self, image):
        r""" Class-aware wrapper for `::pdf_add_image()`."""
        return _mupdf.PdfDocument_pdf_add_image(self, image)

    def pdf_add_journal_fragment(self, parent, copy, copy_stream, newobj):
        r""" Class-aware wrapper for `::pdf_add_journal_fragment()`."""
        return _mupdf.PdfDocument_pdf_add_journal_fragment(self, parent, copy, copy_stream, newobj)

    def pdf_add_new_array(self, initial):
        r""" Class-aware wrapper for `::pdf_add_new_array()`."""
        return _mupdf.PdfDocument_pdf_add_new_array(self, initial)

    def pdf_add_new_dict(self, initial):
        r""" Class-aware wrapper for `::pdf_add_new_dict()`."""
        return _mupdf.PdfDocument_pdf_add_new_dict(self, initial)

    def pdf_add_object(self, obj):
        r""" Class-aware wrapper for `::pdf_add_object()`."""
        return _mupdf.PdfDocument_pdf_add_object(self, obj)

    def pdf_add_page(self, mediabox, rotate, resources, contents):
        r""" Class-aware wrapper for `::pdf_add_page()`."""
        return _mupdf.PdfDocument_pdf_add_page(self, mediabox, rotate, resources, contents)

    def pdf_add_simple_font(self, font, encoding):
        r""" Class-aware wrapper for `::pdf_add_simple_font()`."""
        return _mupdf.PdfDocument_pdf_add_simple_font(self, font, encoding)

    def pdf_add_stream(self, buf, obj, compressed):
        r""" Class-aware wrapper for `::pdf_add_stream()`."""
        return _mupdf.PdfDocument_pdf_add_stream(self, buf, obj, compressed)

    def pdf_add_substitute_font(self, font):
        r""" Class-aware wrapper for `::pdf_add_substitute_font()`."""
        return _mupdf.PdfDocument_pdf_add_substitute_font(self, font)

    def pdf_annot_field_event_keystroke(self, annot, evt):
        r""" Class-aware wrapper for `::pdf_annot_field_event_keystroke()`."""
        return _mupdf.PdfDocument_pdf_annot_field_event_keystroke(self, annot, evt)

    def pdf_authenticate_password(self, pw):
        r""" Class-aware wrapper for `::pdf_authenticate_password()`."""
        return _mupdf.PdfDocument_pdf_authenticate_password(self, pw)

    def pdf_bake_document(self, bake_annots, bake_widgets):
        r""" Class-aware wrapper for `::pdf_bake_document()`."""
        return _mupdf.PdfDocument_pdf_bake_document(self, bake_annots, bake_widgets)

    def pdf_begin_implicit_operation(self):
        r""" Class-aware wrapper for `::pdf_begin_implicit_operation()`."""
        return _mupdf.PdfDocument_pdf_begin_implicit_operation(self)

    def pdf_begin_operation(self, operation):
        r""" Class-aware wrapper for `::pdf_begin_operation()`."""
        return _mupdf.PdfDocument_pdf_begin_operation(self, operation)

    def pdf_calculate_form(self):
        r""" Class-aware wrapper for `::pdf_calculate_form()`."""
        return _mupdf.PdfDocument_pdf_calculate_form(self)

    def pdf_can_be_saved_incrementally(self):
        r""" Class-aware wrapper for `::pdf_can_be_saved_incrementally()`."""
        return _mupdf.PdfDocument_pdf_can_be_saved_incrementally(self)

    def pdf_can_redo(self):
        r""" Class-aware wrapper for `::pdf_can_redo()`."""
        return _mupdf.PdfDocument_pdf_can_redo(self)

    def pdf_can_undo(self):
        r""" Class-aware wrapper for `::pdf_can_undo()`."""
        return _mupdf.PdfDocument_pdf_can_undo(self)

    def pdf_clear_xref(self):
        r""" Class-aware wrapper for `::pdf_clear_xref()`."""
        return _mupdf.PdfDocument_pdf_clear_xref(self)

    def pdf_clear_xref_to_mark(self):
        r""" Class-aware wrapper for `::pdf_clear_xref_to_mark()`."""
        return _mupdf.PdfDocument_pdf_clear_xref_to_mark(self)

    def pdf_count_layer_config_ui(self):
        r""" Class-aware wrapper for `::pdf_count_layer_config_ui()`."""
        return _mupdf.PdfDocument_pdf_count_layer_config_ui(self)

    def pdf_count_layer_configs(self):
        r""" Class-aware wrapper for `::pdf_count_layer_configs()`."""
        return _mupdf.PdfDocument_pdf_count_layer_configs(self)

    def pdf_count_layers(self):
        r""" Class-aware wrapper for `::pdf_count_layers()`."""
        return _mupdf.PdfDocument_pdf_count_layers(self)

    def pdf_count_objects(self):
        r""" Class-aware wrapper for `::pdf_count_objects()`."""
        return _mupdf.PdfDocument_pdf_count_objects(self)

    def pdf_count_pages(self):
        r""" Class-aware wrapper for `::pdf_count_pages()`."""
        return _mupdf.PdfDocument_pdf_count_pages(self)

    def pdf_count_q_balance(self, res, stm, prepend, append):
        r"""
        Class-aware wrapper for `::pdf_count_q_balance()`.

        This method has out-params. Python/C# wrappers look like:
        	`pdf_count_q_balance(::pdf_obj *res, ::pdf_obj *stm)` => `(int prepend, int append)`
        """
        return _mupdf.PdfDocument_pdf_count_q_balance(self, res, stm, prepend, append)

    def pdf_count_signatures(self):
        r""" Class-aware wrapper for `::pdf_count_signatures()`."""
        return _mupdf.PdfDocument_pdf_count_signatures(self)

    def pdf_count_unsaved_versions(self):
        r""" Class-aware wrapper for `::pdf_count_unsaved_versions()`."""
        return _mupdf.PdfDocument_pdf_count_unsaved_versions(self)

    def pdf_count_versions(self):
        r""" Class-aware wrapper for `::pdf_count_versions()`."""
        return _mupdf.PdfDocument_pdf_count_versions(self)

    def pdf_create_field_name(self, prefix, buf, len):
        r""" Class-aware wrapper for `::pdf_create_field_name()`."""
        return _mupdf.PdfDocument_pdf_create_field_name(self, prefix, buf, len)

    def pdf_create_object(self):
        r""" Class-aware wrapper for `::pdf_create_object()`."""
        return _mupdf.PdfDocument_pdf_create_object(self)

    def pdf_debug_doc_changes(self):
        r""" Class-aware wrapper for `::pdf_debug_doc_changes()`."""
        return _mupdf.PdfDocument_pdf_debug_doc_changes(self)

    def pdf_delete_object(self, num):
        r""" Class-aware wrapper for `::pdf_delete_object()`."""
        return _mupdf.PdfDocument_pdf_delete_object(self, num)

    def pdf_delete_page(self, number):
        r""" Class-aware wrapper for `::pdf_delete_page()`."""
        return _mupdf.PdfDocument_pdf_delete_page(self, number)

    def pdf_delete_page_labels(self, index):
        r""" Class-aware wrapper for `::pdf_delete_page_labels()`."""
        return _mupdf.PdfDocument_pdf_delete_page_labels(self, index)

    def pdf_delete_page_range(self, start, end):
        r""" Class-aware wrapper for `::pdf_delete_page_range()`."""
        return _mupdf.PdfDocument_pdf_delete_page_range(self, start, end)

    def pdf_deselect_layer_config_ui(self, ui):
        r""" Class-aware wrapper for `::pdf_deselect_layer_config_ui()`."""
        return _mupdf.PdfDocument_pdf_deselect_layer_config_ui(self, ui)

    def pdf_deserialise_journal(self, stm):
        r""" Class-aware wrapper for `::pdf_deserialise_journal()`."""
        return _mupdf.PdfDocument_pdf_deserialise_journal(self, stm)

    def pdf_disable_js(self):
        r""" Class-aware wrapper for `::pdf_disable_js()`."""
        return _mupdf.PdfDocument_pdf_disable_js(self)

    def pdf_doc_was_linearized(self):
        r""" Class-aware wrapper for `::pdf_doc_was_linearized()`."""
        return _mupdf.PdfDocument_pdf_doc_was_linearized(self)

    def pdf_document_event_did_print(self):
        r""" Class-aware wrapper for `::pdf_document_event_did_print()`."""
        return _mupdf.PdfDocument_pdf_document_event_did_print(self)

    def pdf_document_event_did_save(self):
        r""" Class-aware wrapper for `::pdf_document_event_did_save()`."""
        return _mupdf.PdfDocument_pdf_document_event_did_save(self)

    def pdf_document_event_will_close(self):
        r""" Class-aware wrapper for `::pdf_document_event_will_close()`."""
        return _mupdf.PdfDocument_pdf_document_event_will_close(self)

    def pdf_document_event_will_print(self):
        r""" Class-aware wrapper for `::pdf_document_event_will_print()`."""
        return _mupdf.PdfDocument_pdf_document_event_will_print(self)

    def pdf_document_event_will_save(self):
        r""" Class-aware wrapper for `::pdf_document_event_will_save()`."""
        return _mupdf.PdfDocument_pdf_document_event_will_save(self)

    def pdf_document_output_intent(self):
        r""" Class-aware wrapper for `::pdf_document_output_intent()`."""
        return _mupdf.PdfDocument_pdf_document_output_intent(self)

    def pdf_document_permissions(self):
        r""" Class-aware wrapper for `::pdf_document_permissions()`."""
        return _mupdf.PdfDocument_pdf_document_permissions(self)

    def pdf_empty_store(self):
        r""" Class-aware wrapper for `::pdf_empty_store()`."""
        return _mupdf.PdfDocument_pdf_empty_store(self)

    def pdf_enable_journal(self):
        r""" Class-aware wrapper for `::pdf_enable_journal()`."""
        return _mupdf.PdfDocument_pdf_enable_journal(self)

    def pdf_enable_js(self):
        r""" Class-aware wrapper for `::pdf_enable_js()`."""
        return _mupdf.PdfDocument_pdf_enable_js(self)

    def pdf_enable_layer(self, layer, enabled):
        r""" Class-aware wrapper for `::pdf_enable_layer()`."""
        return _mupdf.PdfDocument_pdf_enable_layer(self, layer, enabled)

    def pdf_end_operation(self):
        r""" Class-aware wrapper for `::pdf_end_operation()`."""
        return _mupdf.PdfDocument_pdf_end_operation(self)

    def pdf_ensure_solid_xref(self, num):
        r""" Class-aware wrapper for `::pdf_ensure_solid_xref()`."""
        return _mupdf.PdfDocument_pdf_ensure_solid_xref(self, num)

    def pdf_event_issue_alert(self, evt):
        r""" Class-aware wrapper for `::pdf_event_issue_alert()`."""
        return _mupdf.PdfDocument_pdf_event_issue_alert(self, evt)

    def pdf_event_issue_exec_menu_item(self, item):
        r""" Class-aware wrapper for `::pdf_event_issue_exec_menu_item()`."""
        return _mupdf.PdfDocument_pdf_event_issue_exec_menu_item(self, item)

    def pdf_event_issue_launch_url(self, url, new_frame):
        r""" Class-aware wrapper for `::pdf_event_issue_launch_url()`."""
        return _mupdf.PdfDocument_pdf_event_issue_launch_url(self, url, new_frame)

    def pdf_event_issue_mail_doc(self, evt):
        r""" Class-aware wrapper for `::pdf_event_issue_mail_doc()`."""
        return _mupdf.PdfDocument_pdf_event_issue_mail_doc(self, evt)

    def pdf_event_issue_print(self):
        r""" Class-aware wrapper for `::pdf_event_issue_print()`."""
        return _mupdf.PdfDocument_pdf_event_issue_print(self)

    def pdf_field_event_calculate(self, field):
        r""" Class-aware wrapper for `::pdf_field_event_calculate()`."""
        return _mupdf.PdfDocument_pdf_field_event_calculate(self, field)

    def pdf_field_event_format(self, field):
        r""" Class-aware wrapper for `::pdf_field_event_format()`."""
        return _mupdf.PdfDocument_pdf_field_event_format(self, field)

    def pdf_field_event_keystroke(self, field, evt):
        r""" Class-aware wrapper for `::pdf_field_event_keystroke()`."""
        return _mupdf.PdfDocument_pdf_field_event_keystroke(self, field, evt)

    def pdf_field_event_validate(self, field, value, newvalue):
        r"""
        Class-aware wrapper for `::pdf_field_event_validate()`.

        This method has out-params. Python/C# wrappers look like:
        	`pdf_field_event_validate(::pdf_obj *field, const char *value)` => `(int, char *newvalue)`
        """
        return _mupdf.PdfDocument_pdf_field_event_validate(self, field, value, newvalue)

    def pdf_field_reset(self, field):
        r""" Class-aware wrapper for `::pdf_field_reset()`."""
        return _mupdf.PdfDocument_pdf_field_reset(self, field)

    def pdf_filter_annot_contents(self, annot, options):
        r""" Class-aware wrapper for `::pdf_filter_annot_contents()`."""
        return _mupdf.PdfDocument_pdf_filter_annot_contents(self, annot, options)

    def pdf_filter_page_contents(self, page, options):
        r""" Class-aware wrapper for `::pdf_filter_page_contents()`."""
        return _mupdf.PdfDocument_pdf_filter_page_contents(self, page, options)

    def pdf_find_font_resource(self, type, encoding, item, key):
        r""" Class-aware wrapper for `::pdf_find_font_resource()`."""
        return _mupdf.PdfDocument_pdf_find_font_resource(self, type, encoding, item, key)

    def pdf_find_version_for_obj(self, obj):
        r""" Class-aware wrapper for `::pdf_find_version_for_obj()`."""
        return _mupdf.PdfDocument_pdf_find_version_for_obj(self, obj)

    def pdf_forget_xref(self):
        r""" Class-aware wrapper for `::pdf_forget_xref()`."""
        return _mupdf.PdfDocument_pdf_forget_xref(self)

    def pdf_get_doc_event_callback_data(self):
        r""" Class-aware wrapper for `::pdf_get_doc_event_callback_data()`."""
        return _mupdf.PdfDocument_pdf_get_doc_event_callback_data(self)

    def pdf_graft_object(self, obj):
        r""" Class-aware wrapper for `::pdf_graft_object()`."""
        return _mupdf.PdfDocument_pdf_graft_object(self, obj)

    def pdf_graft_page(self, page_to, src, page_from):
        r""" Class-aware wrapper for `::pdf_graft_page()`."""
        return _mupdf.PdfDocument_pdf_graft_page(self, page_to, src, page_from)

    def pdf_has_permission(self, p):
        r""" Class-aware wrapper for `::pdf_has_permission()`."""
        return _mupdf.PdfDocument_pdf_has_permission(self, p)

    def pdf_has_unsaved_changes(self):
        r""" Class-aware wrapper for `::pdf_has_unsaved_changes()`."""
        return _mupdf.PdfDocument_pdf_has_unsaved_changes(self)

    def pdf_has_unsaved_sigs(self):
        r""" Class-aware wrapper for `::pdf_has_unsaved_sigs()`."""
        return _mupdf.PdfDocument_pdf_has_unsaved_sigs(self)

    def pdf_insert_font_resource(self, key, obj):
        r""" Class-aware wrapper for `::pdf_insert_font_resource()`."""
        return _mupdf.PdfDocument_pdf_insert_font_resource(self, key, obj)

    def pdf_insert_page(self, at, page):
        r""" Class-aware wrapper for `::pdf_insert_page()`."""
        return _mupdf.PdfDocument_pdf_insert_page(self, at, page)

    def pdf_invalidate_xfa(self):
        r""" Class-aware wrapper for `::pdf_invalidate_xfa()`."""
        return _mupdf.PdfDocument_pdf_invalidate_xfa(self)

    def pdf_is_local_object(self, obj):
        r""" Class-aware wrapper for `::pdf_is_local_object()`."""
        return _mupdf.PdfDocument_pdf_is_local_object(self, obj)

    def pdf_is_ocg_hidden(self, rdb, usage, ocg):
        r""" Class-aware wrapper for `::pdf_is_ocg_hidden()`."""
        return _mupdf.PdfDocument_pdf_is_ocg_hidden(self, rdb, usage, ocg)

    def pdf_js_set_console(self, console, user):
        r""" Class-aware wrapper for `::pdf_js_set_console()`."""
        return _mupdf.PdfDocument_pdf_js_set_console(self, console, user)

    def pdf_js_supported(self):
        r""" Class-aware wrapper for `::pdf_js_supported()`."""
        return _mupdf.PdfDocument_pdf_js_supported(self)

    def pdf_layer_config_info(self, config_num, info):
        r""" Class-aware wrapper for `::pdf_layer_config_info()`."""
        return _mupdf.PdfDocument_pdf_layer_config_info(self, config_num, info)

    def pdf_layer_config_ui_info(self, ui, info):
        r""" Class-aware wrapper for `::pdf_layer_config_ui_info()`."""
        return _mupdf.PdfDocument_pdf_layer_config_ui_info(self, ui, info)

    def pdf_layer_is_enabled(self, layer):
        r""" Class-aware wrapper for `::pdf_layer_is_enabled()`."""
        return _mupdf.PdfDocument_pdf_layer_is_enabled(self, layer)

    def pdf_layer_name(self, layer):
        r""" Class-aware wrapper for `::pdf_layer_name()`."""
        return _mupdf.PdfDocument_pdf_layer_name(self, layer)

    def pdf_load_compressed_inline_image(self, dict, length, cstm, indexed, image):
        r""" Class-aware wrapper for `::pdf_load_compressed_inline_image()`."""
        return _mupdf.PdfDocument_pdf_load_compressed_inline_image(self, dict, length, cstm, indexed, image)

    def pdf_load_compressed_stream(self, num, worst_case):
        r""" Class-aware wrapper for `::pdf_load_compressed_stream()`."""
        return _mupdf.PdfDocument_pdf_load_compressed_stream(self, num, worst_case)

    def pdf_load_default_colorspaces(self, page):
        r""" Class-aware wrapper for `::pdf_load_default_colorspaces()`."""
        return _mupdf.PdfDocument_pdf_load_default_colorspaces(self, page)

    def pdf_load_embedded_cmap(self, ref):
        r""" Class-aware wrapper for `::pdf_load_embedded_cmap()`."""
        return _mupdf.PdfDocument_pdf_load_embedded_cmap(self, ref)

    def pdf_load_image(self, obj):
        r""" Class-aware wrapper for `::pdf_load_image()`."""
        return _mupdf.PdfDocument_pdf_load_image(self, obj)

    def pdf_load_inline_image(self, rdb, dict, file):
        r""" Class-aware wrapper for `::pdf_load_inline_image()`."""
        return _mupdf.PdfDocument_pdf_load_inline_image(self, rdb, dict, file)

    def pdf_load_journal(self, filename):
        r""" Class-aware wrapper for `::pdf_load_journal()`."""
        return _mupdf.PdfDocument_pdf_load_journal(self, filename)

    def pdf_load_link_annots(self, arg_1, annots, pagenum, page_ctm):
        r""" Class-aware wrapper for `::pdf_load_link_annots()`."""
        return _mupdf.PdfDocument_pdf_load_link_annots(self, arg_1, annots, pagenum, page_ctm)

    def pdf_load_name_tree(self, which):
        r""" Class-aware wrapper for `::pdf_load_name_tree()`."""
        return _mupdf.PdfDocument_pdf_load_name_tree(self, which)

    def pdf_load_object(self, num):
        r"""
        Class-aware wrapper for `::pdf_load_object()`.
        	Load a given object.

        	This can cause xref reorganisations (solidifications etc) due to
        	repairs, so all held pdf_xref_entries should be considered
        	invalid after this call (other than the returned one).
        """
        return _mupdf.PdfDocument_pdf_load_object(self, num)

    def pdf_load_outline(self):
        r""" Class-aware wrapper for `::pdf_load_outline()`."""
        return _mupdf.PdfDocument_pdf_load_outline(self)

    def pdf_load_page(self, number):
        r""" Class-aware wrapper for `::pdf_load_page()`."""
        return _mupdf.PdfDocument_pdf_load_page(self, number)

    def pdf_load_page_tree(self):
        r""" Class-aware wrapper for `::pdf_load_page_tree()`."""
        return _mupdf.PdfDocument_pdf_load_page_tree(self)

    def pdf_load_pattern(self, obj):
        r""" Class-aware wrapper for `::pdf_load_pattern()`."""
        return _mupdf.PdfDocument_pdf_load_pattern(self, obj)

    def pdf_load_raw_stream_number(self, num):
        r""" Class-aware wrapper for `::pdf_load_raw_stream_number()`."""
        return _mupdf.PdfDocument_pdf_load_raw_stream_number(self, num)

    def pdf_load_shading(self, obj):
        r""" Class-aware wrapper for `::pdf_load_shading()`."""
        return _mupdf.PdfDocument_pdf_load_shading(self, obj)

    def pdf_load_stream_number(self, num):
        r""" Class-aware wrapper for `::pdf_load_stream_number()`."""
        return _mupdf.PdfDocument_pdf_load_stream_number(self, num)

    def pdf_load_to_unicode(self, font, strings, collection, cmapstm):
        r"""
        Class-aware wrapper for `::pdf_load_to_unicode()`.

        This method has out-params. Python/C# wrappers look like:
        	`pdf_load_to_unicode(::pdf_font_desc *font, char *collection, ::pdf_obj *cmapstm)` => const char *strings
        """
        return _mupdf.PdfDocument_pdf_load_to_unicode(self, font, strings, collection, cmapstm)

    def pdf_load_type3_glyphs(self, fontdesc):
        r""" Class-aware wrapper for `::pdf_load_type3_glyphs()`."""
        return _mupdf.PdfDocument_pdf_load_type3_glyphs(self, fontdesc)

    def pdf_load_unencrypted_object(self, num):
        r""" Class-aware wrapper for `::pdf_load_unencrypted_object()`."""
        return _mupdf.PdfDocument_pdf_load_unencrypted_object(self, num)

    def pdf_lookup_dest(self, needle):
        r""" Class-aware wrapper for `::pdf_lookup_dest()`."""
        return _mupdf.PdfDocument_pdf_lookup_dest(self, needle)

    def pdf_lookup_metadata(self, key, ptr, size):
        r""" Class-aware wrapper for `::pdf_lookup_metadata()`."""
        return _mupdf.PdfDocument_pdf_lookup_metadata(self, key, ptr, size)

    def pdf_lookup_metadata2(self, key):
        r"""
        Class-aware wrapper for `::pdf_lookup_metadata2()`.
        C++ alternative to `pdf_lookup_metadata()` that returns a `std::string`
        or calls `fz_throw()` if not found.
        """
        return _mupdf.PdfDocument_pdf_lookup_metadata2(self, key)

    def pdf_lookup_name(self, which, needle):
        r""" Class-aware wrapper for `::pdf_lookup_name()`."""
        return _mupdf.PdfDocument_pdf_lookup_name(self, which, needle)

    def pdf_lookup_page_loc(self, needle, parentp, indexp):
        r"""
        Class-aware wrapper for `::pdf_lookup_page_loc()`.

        This method has out-params. Python/C# wrappers look like:
        	`pdf_lookup_page_loc(int needle, ::pdf_obj **parentp)` => `(pdf_obj *, int indexp)`
        """
        return _mupdf.PdfDocument_pdf_lookup_page_loc(self, needle, parentp, indexp)

    def pdf_lookup_page_number(self, pageobj):
        r""" Class-aware wrapper for `::pdf_lookup_page_number()`."""
        return _mupdf.PdfDocument_pdf_lookup_page_number(self, pageobj)

    def pdf_lookup_page_obj(self, needle):
        r""" Class-aware wrapper for `::pdf_lookup_page_obj()`."""
        return _mupdf.PdfDocument_pdf_lookup_page_obj(self, needle)

    def pdf_mark_xref(self):
        r""" Class-aware wrapper for `::pdf_mark_xref()`."""
        return _mupdf.PdfDocument_pdf_mark_xref(self)

    def pdf_metadata(self):
        r""" Class-aware wrapper for `::pdf_metadata()`."""
        return _mupdf.PdfDocument_pdf_metadata(self)

    def pdf_minimize_document(self):
        r""" Class-aware wrapper for `::pdf_minimize_document()`."""
        return _mupdf.PdfDocument_pdf_minimize_document(self)

    def pdf_needs_password(self):
        r""" Class-aware wrapper for `::pdf_needs_password()`."""
        return _mupdf.PdfDocument_pdf_needs_password(self)

    def pdf_new_action_from_link(self, uri):
        r""" Class-aware wrapper for `::pdf_new_action_from_link()`."""
        return _mupdf.PdfDocument_pdf_new_action_from_link(self, uri)

    def pdf_new_array(self, initialcap):
        r""" Class-aware wrapper for `::pdf_new_array()`."""
        return _mupdf.PdfDocument_pdf_new_array(self, initialcap)

    def pdf_new_color_filter(self, chain, struct_parents, transform, options, copts):
        r""" Class-aware wrapper for `::pdf_new_color_filter()`."""
        return _mupdf.PdfDocument_pdf_new_color_filter(self, chain, struct_parents, transform, options, copts)

    def pdf_new_date(self, time):
        r""" Class-aware wrapper for `::pdf_new_date()`."""
        return _mupdf.PdfDocument_pdf_new_date(self, time)

    def pdf_new_dest_from_link(self, uri, is_remote):
        r""" Class-aware wrapper for `::pdf_new_dest_from_link()`."""
        return _mupdf.PdfDocument_pdf_new_dest_from_link(self, uri, is_remote)

    def pdf_new_dict(self, initialcap):
        r""" Class-aware wrapper for `::pdf_new_dict()`."""
        return _mupdf.PdfDocument_pdf_new_dict(self, initialcap)

    def pdf_new_graft_map(self):
        r""" Class-aware wrapper for `::pdf_new_graft_map()`."""
        return _mupdf.PdfDocument_pdf_new_graft_map(self)

    def pdf_new_indirect(self, num, gen):
        r""" Class-aware wrapper for `::pdf_new_indirect()`."""
        return _mupdf.PdfDocument_pdf_new_indirect(self, num, gen)

    def pdf_new_matrix(self, mtx):
        r""" Class-aware wrapper for `::pdf_new_matrix()`."""
        return _mupdf.PdfDocument_pdf_new_matrix(self, mtx)

    def pdf_new_pdf_device(self, topctm, resources, contents):
        r""" Class-aware wrapper for `::pdf_new_pdf_device()`."""
        return _mupdf.PdfDocument_pdf_new_pdf_device(self, topctm, resources, contents)

    def pdf_new_rect(self, rect):
        r""" Class-aware wrapper for `::pdf_new_rect()`."""
        return _mupdf.PdfDocument_pdf_new_rect(self, rect)

    def pdf_new_run_processor(self, dev, ctm, struct_parent, usage, gstate, default_cs, cookie):
        r""" Class-aware wrapper for `::pdf_new_run_processor()`."""
        return _mupdf.PdfDocument_pdf_new_run_processor(self, dev, ctm, struct_parent, usage, gstate, default_cs, cookie)

    def pdf_new_sanitize_filter(self, chain, struct_parents, transform, options, sopts):
        r""" Class-aware wrapper for `::pdf_new_sanitize_filter()`."""
        return _mupdf.PdfDocument_pdf_new_sanitize_filter(self, chain, struct_parents, transform, options, sopts)

    def pdf_new_xobject(self, bbox, matrix, res, buffer):
        r""" Class-aware wrapper for `::pdf_new_xobject()`."""
        return _mupdf.PdfDocument_pdf_new_xobject(self, bbox, matrix, res, buffer)

    def pdf_obj_num_is_stream(self, num):
        r""" Class-aware wrapper for `::pdf_obj_num_is_stream()`."""
        return _mupdf.PdfDocument_pdf_obj_num_is_stream(self, num)

    def pdf_open_contents_stream(self, obj):
        r""" Class-aware wrapper for `::pdf_open_contents_stream()`."""
        return _mupdf.PdfDocument_pdf_open_contents_stream(self, obj)

    def pdf_open_inline_stream(self, stmobj, length, chain, params):
        r""" Class-aware wrapper for `::pdf_open_inline_stream()`."""
        return _mupdf.PdfDocument_pdf_open_inline_stream(self, stmobj, length, chain, params)

    def pdf_open_raw_stream_number(self, num):
        r""" Class-aware wrapper for `::pdf_open_raw_stream_number()`."""
        return _mupdf.PdfDocument_pdf_open_raw_stream_number(self, num)

    def pdf_open_stream_number(self, num):
        r""" Class-aware wrapper for `::pdf_open_stream_number()`."""
        return _mupdf.PdfDocument_pdf_open_stream_number(self, num)

    def pdf_open_stream_with_offset(self, num, dict, stm_ofs):
        r""" Class-aware wrapper for `::pdf_open_stream_with_offset()`."""
        return _mupdf.PdfDocument_pdf_open_stream_with_offset(self, num, dict, stm_ofs)

    def pdf_page_label(self, page, buf, size):
        r""" Class-aware wrapper for `::pdf_page_label()`."""
        return _mupdf.PdfDocument_pdf_page_label(self, page, buf, size)

    def pdf_page_write(self, mediabox, presources, pcontents):
        r"""
        Class-aware wrapper for `::pdf_page_write()`.

        This method has out-params. Python/C# wrappers look like:
        	`pdf_page_write(::fz_rect mediabox, ::pdf_obj **presources, ::fz_buffer **pcontents)` => `(fz_device *)`
        """
        return _mupdf.PdfDocument_pdf_page_write(self, mediabox, presources, pcontents)

    def pdf_parse_array(self, f, buf):
        r""" Class-aware wrapper for `::pdf_parse_array()`."""
        return _mupdf.PdfDocument_pdf_parse_array(self, f, buf)

    def pdf_parse_dict(self, f, buf):
        r""" Class-aware wrapper for `::pdf_parse_dict()`."""
        return _mupdf.PdfDocument_pdf_parse_dict(self, f, buf)

    def pdf_parse_ind_obj(self, f, num, gen, stm_ofs, try_repair):
        r"""
        Class-aware wrapper for `::pdf_parse_ind_obj()`.

        This method has out-params. Python/C# wrappers look like:
        	`pdf_parse_ind_obj(::fz_stream *f)` => `(pdf_obj *, int num, int gen, int64_t stm_ofs, int try_repair)`
        """
        return _mupdf.PdfDocument_pdf_parse_ind_obj(self, f, num, gen, stm_ofs, try_repair)

    def pdf_parse_journal_obj(self, stm, onum, ostm, newobj):
        r"""
        Class-aware wrapper for `::pdf_parse_journal_obj()`.

        This method has out-params. Python/C# wrappers look like:
        	`pdf_parse_journal_obj(::fz_stream *stm, ::fz_buffer **ostm)` => `(pdf_obj *, int onum, int newobj)`
        """
        return _mupdf.PdfDocument_pdf_parse_journal_obj(self, stm, onum, ostm, newobj)

    def pdf_parse_stm_obj(self, f, buf):
        r""" Class-aware wrapper for `::pdf_parse_stm_obj()`."""
        return _mupdf.PdfDocument_pdf_parse_stm_obj(self, f, buf)

    def pdf_progressive_advance(self, pagenum):
        r""" Class-aware wrapper for `::pdf_progressive_advance()`."""
        return _mupdf.PdfDocument_pdf_progressive_advance(self, pagenum)

    def pdf_purge_local_font_resources(self):
        r""" Class-aware wrapper for `::pdf_purge_local_font_resources()`."""
        return _mupdf.PdfDocument_pdf_purge_local_font_resources(self)

    def pdf_purge_locals_from_store(self):
        r""" Class-aware wrapper for `::pdf_purge_locals_from_store()`."""
        return _mupdf.PdfDocument_pdf_purge_locals_from_store(self)

    def pdf_read_journal(self, stm):
        r""" Class-aware wrapper for `::pdf_read_journal()`."""
        return _mupdf.PdfDocument_pdf_read_journal(self, stm)

    def pdf_rearrange_pages(self, count, pages):
        r""" Class-aware wrapper for `::pdf_rearrange_pages()`."""
        return _mupdf.PdfDocument_pdf_rearrange_pages(self, count, pages)

    def pdf_rearrange_pages2(self, pages):
        r""" Class-aware wrapper for `::pdf_rearrange_pages2()`.   Swig-friendly wrapper for pdf_rearrange_pages()."""
        return _mupdf.PdfDocument_pdf_rearrange_pages2(self, pages)

    def pdf_redact_page(self, page, opts):
        r""" Class-aware wrapper for `::pdf_redact_page()`."""
        return _mupdf.PdfDocument_pdf_redact_page(self, page, opts)

    def pdf_redo(self):
        r""" Class-aware wrapper for `::pdf_redo()`."""
        return _mupdf.PdfDocument_pdf_redo(self)

    def pdf_repair_obj(self, buf, stmofsp, stmlenp, encrypt, id, page, tmpofs, root):
        r"""
        Class-aware wrapper for `::pdf_repair_obj()`.

        This method has out-params. Python/C# wrappers look like:
        	`pdf_repair_obj(::pdf_lexbuf *buf, ::pdf_obj **encrypt, ::pdf_obj **id, ::pdf_obj **page, ::pdf_obj **root)` => `(int, int64_t stmofsp, int64_t stmlenp, int64_t tmpofs)`
        """
        return _mupdf.PdfDocument_pdf_repair_obj(self, buf, stmofsp, stmlenp, encrypt, id, page, tmpofs, root)

    def pdf_repair_obj_stms(self):
        r""" Class-aware wrapper for `::pdf_repair_obj_stms()`."""
        return _mupdf.PdfDocument_pdf_repair_obj_stms(self)

    def pdf_repair_trailer(self):
        r""" Class-aware wrapper for `::pdf_repair_trailer()`."""
        return _mupdf.PdfDocument_pdf_repair_trailer(self)

    def pdf_repair_xref(self):
        r""" Class-aware wrapper for `::pdf_repair_xref()`."""
        return _mupdf.PdfDocument_pdf_repair_xref(self)

    def pdf_replace_xref(self, entries, n):
        r""" Class-aware wrapper for `::pdf_replace_xref()`."""
        return _mupdf.PdfDocument_pdf_replace_xref(self, entries, n)

    def pdf_reset_form(self, fields, exclude):
        r""" Class-aware wrapper for `::pdf_reset_form()`."""
        return _mupdf.PdfDocument_pdf_reset_form(self, fields, exclude)

    def pdf_resolve_link(self, uri, xp, yp):
        r"""
        Class-aware wrapper for `::pdf_resolve_link()`.

        This method has out-params. Python/C# wrappers look like:
        	`pdf_resolve_link(const char *uri)` => `(int, float xp, float yp)`
        """
        return _mupdf.PdfDocument_pdf_resolve_link(self, uri, xp, yp)

    def pdf_rewrite_images(self, opts):
        r""" Class-aware wrapper for `::pdf_rewrite_images()`."""
        return _mupdf.PdfDocument_pdf_rewrite_images(self, opts)

    def pdf_run_document_structure(self, dev, cookie):
        r""" Class-aware wrapper for `::pdf_run_document_structure()`."""
        return _mupdf.PdfDocument_pdf_run_document_structure(self, dev, cookie)

    def pdf_run_glyph(self, resources, contents, dev, ctm, gstate, default_cs):
        r""" Class-aware wrapper for `::pdf_run_glyph()`."""
        return _mupdf.PdfDocument_pdf_run_glyph(self, resources, contents, dev, ctm, gstate, default_cs)

    def pdf_save_document(self, filename, opts):
        r""" Class-aware wrapper for `::pdf_save_document()`."""
        return _mupdf.PdfDocument_pdf_save_document(self, filename, opts)

    def pdf_save_journal(self, filename):
        r""" Class-aware wrapper for `::pdf_save_journal()`."""
        return _mupdf.PdfDocument_pdf_save_journal(self, filename)

    def pdf_save_snapshot(self, filename):
        r""" Class-aware wrapper for `::pdf_save_snapshot()`."""
        return _mupdf.PdfDocument_pdf_save_snapshot(self, filename)

    def pdf_select_layer_config(self, config_num):
        r""" Class-aware wrapper for `::pdf_select_layer_config()`."""
        return _mupdf.PdfDocument_pdf_select_layer_config(self, config_num)

    def pdf_select_layer_config_ui(self, ui):
        r""" Class-aware wrapper for `::pdf_select_layer_config_ui()`."""
        return _mupdf.PdfDocument_pdf_select_layer_config_ui(self, ui)

    def pdf_serialise_journal(self, out):
        r""" Class-aware wrapper for `::pdf_serialise_journal()`."""
        return _mupdf.PdfDocument_pdf_serialise_journal(self, out)

    def pdf_set_annot_field_value(self, widget, text, ignore_trigger_events):
        r""" Class-aware wrapper for `::pdf_set_annot_field_value()`."""
        return _mupdf.PdfDocument_pdf_set_annot_field_value(self, widget, text, ignore_trigger_events)

    def pdf_set_doc_event_callback(self, event_cb, free_event_data_cb, data):
        r""" Class-aware wrapper for `::pdf_set_doc_event_callback()`."""
        return _mupdf.PdfDocument_pdf_set_doc_event_callback(self, event_cb, free_event_data_cb, data)

    def pdf_set_document_language(self, lang):
        r""" Class-aware wrapper for `::pdf_set_document_language()`."""
        return _mupdf.PdfDocument_pdf_set_document_language(self, lang)

    def pdf_set_field_value(self, field, text, ignore_trigger_events):
        r""" Class-aware wrapper for `::pdf_set_field_value()`."""
        return _mupdf.PdfDocument_pdf_set_field_value(self, field, text, ignore_trigger_events)

    def pdf_set_layer_config_as_default(self):
        r""" Class-aware wrapper for `::pdf_set_layer_config_as_default()`."""
        return _mupdf.PdfDocument_pdf_set_layer_config_as_default(self)

    def pdf_set_page_labels(self, index, style, prefix, start):
        r""" Class-aware wrapper for `::pdf_set_page_labels()`."""
        return _mupdf.PdfDocument_pdf_set_page_labels(self, index, style, prefix, start)

    def pdf_set_populating_xref_trailer(self, trailer):
        r""" Class-aware wrapper for `::pdf_set_populating_xref_trailer()`."""
        return _mupdf.PdfDocument_pdf_set_populating_xref_trailer(self, trailer)

    def pdf_signature_byte_range(self, signature, byte_range):
        r""" Class-aware wrapper for `::pdf_signature_byte_range()`."""
        return _mupdf.PdfDocument_pdf_signature_byte_range(self, signature, byte_range)

    def pdf_signature_contents(self, signature, contents):
        r"""
        Class-aware wrapper for `::pdf_signature_contents()`.

        This method has out-params. Python/C# wrappers look like:
        	`pdf_signature_contents(::pdf_obj *signature)` => `(size_t, char *contents)`
        """
        return _mupdf.PdfDocument_pdf_signature_contents(self, signature, contents)

    def pdf_signature_hash_bytes(self, signature):
        r""" Class-aware wrapper for `::pdf_signature_hash_bytes()`."""
        return _mupdf.PdfDocument_pdf_signature_hash_bytes(self, signature)

    def pdf_signature_incremental_change_since_signing(self, signature):
        r""" Class-aware wrapper for `::pdf_signature_incremental_change_since_signing()`."""
        return _mupdf.PdfDocument_pdf_signature_incremental_change_since_signing(self, signature)

    def pdf_signature_is_signed(self, field):
        r""" Class-aware wrapper for `::pdf_signature_is_signed()`."""
        return _mupdf.PdfDocument_pdf_signature_is_signed(self, field)

    def pdf_signature_set_value(self, field, signer, stime):
        r""" Class-aware wrapper for `::pdf_signature_set_value()`."""
        return _mupdf.PdfDocument_pdf_signature_set_value(self, field, signer, stime)

    def pdf_subset_fonts(self, pages_len, pages):
        r""" Class-aware wrapper for `::pdf_subset_fonts()`."""
        return _mupdf.PdfDocument_pdf_subset_fonts(self, pages_len, pages)

    def pdf_subset_fonts2(self, pages):
        r""" Class-aware wrapper for `::pdf_subset_fonts2()`.   Swig-friendly wrapper for pdf_subset_fonts()."""
        return _mupdf.PdfDocument_pdf_subset_fonts2(self, pages)

    def pdf_toggle_layer_config_ui(self, ui):
        r""" Class-aware wrapper for `::pdf_toggle_layer_config_ui()`."""
        return _mupdf.PdfDocument_pdf_toggle_layer_config_ui(self, ui)

    def pdf_trailer(self):
        r""" Class-aware wrapper for `::pdf_trailer()`."""
        return _mupdf.PdfDocument_pdf_trailer(self)

    def pdf_undo(self):
        r""" Class-aware wrapper for `::pdf_undo()`."""
        return _mupdf.PdfDocument_pdf_undo(self)

    def pdf_undoredo_state(self, steps):
        r"""
        Class-aware wrapper for `::pdf_undoredo_state()`.

        This method has out-params. Python/C# wrappers look like:
        	`pdf_undoredo_state()` => `(int, int steps)`
        """
        return _mupdf.PdfDocument_pdf_undoredo_state(self, steps)

    def pdf_undoredo_step(self, step):
        r""" Class-aware wrapper for `::pdf_undoredo_step()`."""
        return _mupdf.PdfDocument_pdf_undoredo_step(self, step)

    def pdf_update_object(self, num, obj):
        r""" Class-aware wrapper for `::pdf_update_object()`."""
        return _mupdf.PdfDocument_pdf_update_object(self, num, obj)

    def pdf_update_stream(self, ref, buf, compressed):
        r""" Class-aware wrapper for `::pdf_update_stream()`."""
        return _mupdf.PdfDocument_pdf_update_stream(self, ref, buf, compressed)

    def pdf_update_xobject(self, xobj, bbox, mat, res, buffer):
        r""" Class-aware wrapper for `::pdf_update_xobject()`."""
        return _mupdf.PdfDocument_pdf_update_xobject(self, xobj, bbox, mat, res, buffer)

    def pdf_validate_change_history(self):
        r""" Class-aware wrapper for `::pdf_validate_change_history()`."""
        return _mupdf.PdfDocument_pdf_validate_change_history(self)

    def pdf_validate_changes(self, version):
        r""" Class-aware wrapper for `::pdf_validate_changes()`."""
        return _mupdf.PdfDocument_pdf_validate_changes(self, version)

    def pdf_version(self):
        r""" Class-aware wrapper for `::pdf_version()`."""
        return _mupdf.PdfDocument_pdf_version(self)

    def pdf_was_pure_xfa(self):
        r""" Class-aware wrapper for `::pdf_was_pure_xfa()`."""
        return _mupdf.PdfDocument_pdf_was_pure_xfa(self)

    def pdf_was_repaired(self):
        r""" Class-aware wrapper for `::pdf_was_repaired()`."""
        return _mupdf.PdfDocument_pdf_was_repaired(self)

    def pdf_write_document(self, out, opts):
        r""" Class-aware wrapper for `::pdf_write_document()`."""
        return _mupdf.PdfDocument_pdf_write_document(self, out, opts)

    def pdf_write_journal(self, out):
        r""" Class-aware wrapper for `::pdf_write_journal()`."""
        return _mupdf.PdfDocument_pdf_write_journal(self, out)

    def pdf_write_snapshot(self, out):
        r""" Class-aware wrapper for `::pdf_write_snapshot()`."""
        return _mupdf.PdfDocument_pdf_write_snapshot(self, out)

    def pdf_xref_ensure_incremental_object(self, num):
        r""" Class-aware wrapper for `::pdf_xref_ensure_incremental_object()`."""
        return _mupdf.PdfDocument_pdf_xref_ensure_incremental_object(self, num)

    def pdf_xref_ensure_local_object(self, num):
        r""" Class-aware wrapper for `::pdf_xref_ensure_local_object()`."""
        return _mupdf.PdfDocument_pdf_xref_ensure_local_object(self, num)

    def pdf_xref_entry_map(self, fn, arg):
        r""" Class-aware wrapper for `::pdf_xref_entry_map()`."""
        return _mupdf.PdfDocument_pdf_xref_entry_map(self, fn, arg)

    def pdf_xref_is_incremental(self, num):
        r""" Class-aware wrapper for `::pdf_xref_is_incremental()`."""
        return _mupdf.PdfDocument_pdf_xref_is_incremental(self, num)

    def pdf_xref_len(self):
        r""" Class-aware wrapper for `::pdf_xref_len()`."""
        return _mupdf.PdfDocument_pdf_xref_len(self)

    def pdf_xref_obj_is_unsaved_signature(self, obj):
        r""" Class-aware wrapper for `::pdf_xref_obj_is_unsaved_signature()`."""
        return _mupdf.PdfDocument_pdf_xref_obj_is_unsaved_signature(self, obj)

    def pdf_xref_remove_unsaved_signature(self, field):
        r""" Class-aware wrapper for `::pdf_xref_remove_unsaved_signature()`."""
        return _mupdf.PdfDocument_pdf_xref_remove_unsaved_signature(self, field)

    def pdf_xref_store_unsaved_signature(self, field, signer):
        r""" Class-aware wrapper for `::pdf_xref_store_unsaved_signature()`."""
        return _mupdf.PdfDocument_pdf_xref_store_unsaved_signature(self, field, signer)

    def super(self):
        r""" Returns wrapper for .super member."""
        return _mupdf.PdfDocument_super(self)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        == Constructors.  Constructor using `pdf_create_document()`.

        |

        *Overload 2:*
        Constructor using `pdf_document_from_fz_document()`.

        |

        *Overload 3:*
        Constructor using `pdf_open_document()`.

        |

        *Overload 4:*
        Constructor using `pdf_open_document_with_stream()`.

        |

        *Overload 5:*
        Copy constructor using `pdf_keep_document()`.

        |

        *Overload 6:*
        Constructor using raw copy of pre-existing `::pdf_document`.
        """
        _mupdf.PdfDocument_swiginit(self, _mupdf.new_PdfDocument(*args))
    __swig_destroy__ = _mupdf.delete_PdfDocument

    def m_internal_value(self):
        r""" Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.PdfDocument_m_internal_value(self)
    m_internal = property(_mupdf.PdfDocument_m_internal_get, _mupdf.PdfDocument_m_internal_set, doc=r""" Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.PdfDocument_s_num_instances_get, _mupdf.PdfDocument_s_num_instances_set)

# Register PdfDocument in _mupdf:
_mupdf.PdfDocument_swigregister(PdfDocument)
class PdfEmbeddedFileParams(object):
    r""" Wrapper class for struct `pdf_embedded_file_params`. Not copyable or assignable."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::pdf_embedded_file_params`.
        """
        _mupdf.PdfEmbeddedFileParams_swiginit(self, _mupdf.new_PdfEmbeddedFileParams(*args))
    __swig_destroy__ = _mupdf.delete_PdfEmbeddedFileParams

    def m_internal_value(self):
        r""" Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.PdfEmbeddedFileParams_m_internal_value(self)
    m_internal = property(_mupdf.PdfEmbeddedFileParams_m_internal_get, _mupdf.PdfEmbeddedFileParams_m_internal_set, doc=r""" Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.PdfEmbeddedFileParams_s_num_instances_get, _mupdf.PdfEmbeddedFileParams_s_num_instances_set)

# Register PdfEmbeddedFileParams in _mupdf:
_mupdf.PdfEmbeddedFileParams_swigregister(PdfEmbeddedFileParams)
class PdfFilterFactory(object):
    r""" Wrapper class for struct `pdf_filter_factory`."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        We use default copy constructor and operator=.  Default constructor, sets each member to default value.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::pdf_filter_factory`.

        |

        *Overload 3:*
        Constructor using raw copy of pre-existing `::pdf_filter_factory`.
        """
        _mupdf.PdfFilterFactory_swiginit(self, _mupdf.new_PdfFilterFactory(*args))

    def internal(self, *args):
        r"""
        *Overload 1:*
        Access as underlying struct.

        |

        *Overload 2:*
        Access as underlying struct.
        """
        return _mupdf.PdfFilterFactory_internal(self, *args)
    __swig_destroy__ = _mupdf.delete_PdfFilterFactory
    filter = property(_mupdf.PdfFilterFactory_filter_get, _mupdf.PdfFilterFactory_filter_set)
    options = property(_mupdf.PdfFilterFactory_options_get, _mupdf.PdfFilterFactory_options_set)
    s_num_instances = property(_mupdf.PdfFilterFactory_s_num_instances_get, _mupdf.PdfFilterFactory_s_num_instances_set)

    def to_string(self):
        r""" Returns string containing our members, labelled and inside (...), using operator<<."""
        return _mupdf.PdfFilterFactory_to_string(self)

    def __eq__(self, rhs):
        r""" Comparison method."""
        return _mupdf.PdfFilterFactory___eq__(self, rhs)

    def __ne__(self, rhs):
        r""" Comparison method."""
        return _mupdf.PdfFilterFactory___ne__(self, rhs)

# Register PdfFilterFactory in _mupdf:
_mupdf.PdfFilterFactory_swigregister(PdfFilterFactory)
class PdfFilterFactory2(PdfFilterFactory):
    r""" Wrapper class for struct pdf_filter_factory with virtual fns for each fnptr; this is for use as a SWIG Director class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r""" == Constructor."""
        if self.__class__ == PdfFilterFactory2:
            _self = None
        else:
            _self = self
        _mupdf.PdfFilterFactory2_swiginit(self, _mupdf.new_PdfFilterFactory2(_self, ))

    def use_virtual_filter(self, use=True):
        r"""
        These methods set the function pointers in *m_internal
        to point to internal callbacks that call our virtual methods.
        """
        return _mupdf.PdfFilterFactory2_use_virtual_filter(self, use)

    def filter(self, arg_0, arg_1, arg_2, arg_3, arg_4, arg_5):
        r""" Default virtual method implementations; these all throw an exception."""
        return _mupdf.PdfFilterFactory2_filter(self, arg_0, arg_1, arg_2, arg_3, arg_4, arg_5)
    __swig_destroy__ = _mupdf.delete_PdfFilterFactory2
    def __disown__(self):
        self.this.disown()
        _mupdf.disown_PdfFilterFactory2(self)
        return weakref.proxy(self)

# Register PdfFilterFactory2 in _mupdf:
_mupdf.PdfFilterFactory2_swigregister(PdfFilterFactory2)
class PdfFilterOptions(object):
    r""" Wrapper class for struct `pdf_filter_options`."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def add_factory(self, factory):
        r""" We use default copy constructor and operator=.  Appends `factory` to internal vector and updates this->filters."""
        return _mupdf.PdfFilterOptions_add_factory(self, factory)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor initialises all fields to null/zero.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::pdf_filter_options`.

        |

        *Overload 3:*
        Constructor using raw copy of pre-existing `::pdf_filter_options`.
        """
        _mupdf.PdfFilterOptions_swiginit(self, _mupdf.new_PdfFilterOptions(*args))

    def internal(self, *args):
        r"""
        *Overload 1:*
        Access as underlying struct.

        |

        *Overload 2:*
        Access as underlying struct.
        """
        return _mupdf.PdfFilterOptions_internal(self, *args)
    __swig_destroy__ = _mupdf.delete_PdfFilterOptions
    recurse = property(_mupdf.PdfFilterOptions_recurse_get, _mupdf.PdfFilterOptions_recurse_set)
    instance_forms = property(_mupdf.PdfFilterOptions_instance_forms_get, _mupdf.PdfFilterOptions_instance_forms_set)
    ascii = property(_mupdf.PdfFilterOptions_ascii_get, _mupdf.PdfFilterOptions_ascii_set)
    no_update = property(_mupdf.PdfFilterOptions_no_update_get, _mupdf.PdfFilterOptions_no_update_set)
    opaque = property(_mupdf.PdfFilterOptions_opaque_get, _mupdf.PdfFilterOptions_opaque_set)
    complete = property(_mupdf.PdfFilterOptions_complete_get, _mupdf.PdfFilterOptions_complete_set)
    filters = property(_mupdf.PdfFilterOptions_filters_get, _mupdf.PdfFilterOptions_filters_set)
    newlines = property(_mupdf.PdfFilterOptions_newlines_get, _mupdf.PdfFilterOptions_newlines_set)
    s_num_instances = property(_mupdf.PdfFilterOptions_s_num_instances_get, _mupdf.PdfFilterOptions_s_num_instances_set)

    def to_string(self):
        r""" Returns string containing our members, labelled and inside (...), using operator<<."""
        return _mupdf.PdfFilterOptions_to_string(self)

    def __eq__(self, rhs):
        r""" Comparison method."""
        return _mupdf.PdfFilterOptions___eq__(self, rhs)

    def __ne__(self, rhs):
        r""" Comparison method."""
        return _mupdf.PdfFilterOptions___ne__(self, rhs)
    m_filters = property(_mupdf.PdfFilterOptions_m_filters_get, _mupdf.PdfFilterOptions_m_filters_set)

# Register PdfFilterOptions in _mupdf:
_mupdf.PdfFilterOptions_swigregister(PdfFilterOptions)
class PdfFilterOptions2(PdfFilterOptions):
    r""" Wrapper class for struct pdf_filter_options with virtual fns for each fnptr; this is for use as a SWIG Director class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r""" == Constructor."""
        if self.__class__ == PdfFilterOptions2:
            _self = None
        else:
            _self = self
        _mupdf.PdfFilterOptions2_swiginit(self, _mupdf.new_PdfFilterOptions2(_self, ))

    def use_virtual_complete(self, use=True):
        r"""
        These methods set the function pointers in *m_internal
        to point to internal callbacks that call our virtual methods.
        """
        return _mupdf.PdfFilterOptions2_use_virtual_complete(self, use)

    def complete(self, arg_0, arg_1):
        r""" Default virtual method implementations; these all throw an exception."""
        return _mupdf.PdfFilterOptions2_complete(self, arg_0, arg_1)
    __swig_destroy__ = _mupdf.delete_PdfFilterOptions2
    def __disown__(self):
        self.this.disown()
        _mupdf.disown_PdfFilterOptions2(self)
        return weakref.proxy(self)

# Register PdfFilterOptions2 in _mupdf:
_mupdf.PdfFilterOptions2_swigregister(PdfFilterOptions2)
class PdfFontDesc(object):
    r""" Wrapper class for struct `pdf_font_desc`. Not copyable or assignable."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def pdf_add_hmtx(self, lo, hi, w):
        r""" Class-aware wrapper for `::pdf_add_hmtx()`."""
        return _mupdf.PdfFontDesc_pdf_add_hmtx(self, lo, hi, w)

    def pdf_add_vmtx(self, lo, hi, x, y, w):
        r""" Class-aware wrapper for `::pdf_add_vmtx()`."""
        return _mupdf.PdfFontDesc_pdf_add_vmtx(self, lo, hi, x, y, w)

    def pdf_end_hmtx(self):
        r""" Class-aware wrapper for `::pdf_end_hmtx()`."""
        return _mupdf.PdfFontDesc_pdf_end_hmtx(self)

    def pdf_end_vmtx(self):
        r""" Class-aware wrapper for `::pdf_end_vmtx()`."""
        return _mupdf.PdfFontDesc_pdf_end_vmtx(self)

    def pdf_font_cid_to_gid(self, cid):
        r""" Class-aware wrapper for `::pdf_font_cid_to_gid()`."""
        return _mupdf.PdfFontDesc_pdf_font_cid_to_gid(self, cid)

    def pdf_set_default_hmtx(self, w):
        r""" Class-aware wrapper for `::pdf_set_default_hmtx()`."""
        return _mupdf.PdfFontDesc_pdf_set_default_hmtx(self, w)

    def pdf_set_default_vmtx(self, y, w):
        r""" Class-aware wrapper for `::pdf_set_default_vmtx()`."""
        return _mupdf.PdfFontDesc_pdf_set_default_vmtx(self, y, w)

    def pdf_set_font_wmode(self, wmode):
        r""" Class-aware wrapper for `::pdf_set_font_wmode()`."""
        return _mupdf.PdfFontDesc_pdf_set_font_wmode(self, wmode)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        == Constructors.  Constructor using `pdf_new_font_desc()`.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::pdf_font_desc`.
        """
        _mupdf.PdfFontDesc_swiginit(self, _mupdf.new_PdfFontDesc(*args))
    __swig_destroy__ = _mupdf.delete_PdfFontDesc

    def m_internal_value(self):
        r""" Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.PdfFontDesc_m_internal_value(self)
    m_internal = property(_mupdf.PdfFontDesc_m_internal_get, _mupdf.PdfFontDesc_m_internal_set, doc=r""" Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.PdfFontDesc_s_num_instances_get, _mupdf.PdfFontDesc_s_num_instances_set)

# Register PdfFontDesc in _mupdf:
_mupdf.PdfFontDesc_swigregister(PdfFontDesc)
class PdfFontResourceKey(object):
    r""" Wrapper class for struct `pdf_font_resource_key`. Not copyable or assignable."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::pdf_font_resource_key`.
        """
        _mupdf.PdfFontResourceKey_swiginit(self, _mupdf.new_PdfFontResourceKey(*args))
    __swig_destroy__ = _mupdf.delete_PdfFontResourceKey

    def m_internal_value(self):
        r""" Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.PdfFontResourceKey_m_internal_value(self)
    m_internal = property(_mupdf.PdfFontResourceKey_m_internal_get, _mupdf.PdfFontResourceKey_m_internal_set, doc=r""" Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.PdfFontResourceKey_s_num_instances_get, _mupdf.PdfFontResourceKey_s_num_instances_set)

# Register PdfFontResourceKey in _mupdf:
_mupdf.PdfFontResourceKey_swigregister(PdfFontResourceKey)
class PdfFunction(object):
    r""" Wrapper class for struct `pdf_function`."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def pdf_eval_function(self, _in, inlen, out, outlen):
        r"""
        Class-aware wrapper for `::pdf_eval_function()`.

        This method has out-params. Python/C# wrappers look like:
        	`pdf_eval_function(const float *in, int inlen, int outlen)` => float out
        """
        return _mupdf.PdfFunction_pdf_eval_function(self, _in, inlen, out, outlen)

    def pdf_function_size(self):
        r""" Class-aware wrapper for `::pdf_function_size()`."""
        return _mupdf.PdfFunction_pdf_function_size(self)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Copy constructor using `pdf_keep_function()`.

        |

        *Overload 2:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 3:*
        Constructor using raw copy of pre-existing `::pdf_function`.
        """
        _mupdf.PdfFunction_swiginit(self, _mupdf.new_PdfFunction(*args))
    __swig_destroy__ = _mupdf.delete_PdfFunction

    def m_internal_value(self):
        r""" Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.PdfFunction_m_internal_value(self)
    m_internal = property(_mupdf.PdfFunction_m_internal_get, _mupdf.PdfFunction_m_internal_set, doc=r""" Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.PdfFunction_s_num_instances_get, _mupdf.PdfFunction_s_num_instances_set)

# Register PdfFunction in _mupdf:
_mupdf.PdfFunction_swigregister(PdfFunction)
class PdfGraftMap(object):
    r""" Wrapper class for struct `pdf_graft_map`."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def pdf_graft_mapped_object(self, obj):
        r""" Class-aware wrapper for `::pdf_graft_mapped_object()`."""
        return _mupdf.PdfGraftMap_pdf_graft_mapped_object(self, obj)

    def pdf_graft_mapped_page(self, page_to, src, page_from):
        r""" Class-aware wrapper for `::pdf_graft_mapped_page()`."""
        return _mupdf.PdfGraftMap_pdf_graft_mapped_page(self, page_to, src, page_from)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        == Constructors.  Constructor using `pdf_new_graft_map()`.

        |

        *Overload 2:*
        Copy constructor using `pdf_keep_graft_map()`.

        |

        *Overload 3:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 4:*
        Constructor using raw copy of pre-existing `::pdf_graft_map`.
        """
        _mupdf.PdfGraftMap_swiginit(self, _mupdf.new_PdfGraftMap(*args))
    __swig_destroy__ = _mupdf.delete_PdfGraftMap

    def m_internal_value(self):
        r""" Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.PdfGraftMap_m_internal_value(self)
    m_internal = property(_mupdf.PdfGraftMap_m_internal_get, _mupdf.PdfGraftMap_m_internal_set, doc=r""" Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.PdfGraftMap_s_num_instances_get, _mupdf.PdfGraftMap_s_num_instances_set)

# Register PdfGraftMap in _mupdf:
_mupdf.PdfGraftMap_swigregister(PdfGraftMap)
class PdfGstate(object):
    r""" Wrapper class for struct `pdf_gstate`. Not copyable or assignable."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::pdf_gstate`.
        """
        _mupdf.PdfGstate_swiginit(self, _mupdf.new_PdfGstate(*args))
    __swig_destroy__ = _mupdf.delete_PdfGstate

    def m_internal_value(self):
        r""" Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.PdfGstate_m_internal_value(self)
    m_internal = property(_mupdf.PdfGstate_m_internal_get, _mupdf.PdfGstate_m_internal_set, doc=r""" Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.PdfGstate_s_num_instances_get, _mupdf.PdfGstate_s_num_instances_set)

# Register PdfGstate in _mupdf:
_mupdf.PdfGstate_swigregister(PdfGstate)
class PdfHintPage(object):
    r""" Wrapper class for struct `pdf_hint_page`. Not copyable or assignable."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::pdf_hint_page`.
        """
        _mupdf.PdfHintPage_swiginit(self, _mupdf.new_PdfHintPage(*args))
    __swig_destroy__ = _mupdf.delete_PdfHintPage

    def m_internal_value(self):
        r""" Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.PdfHintPage_m_internal_value(self)
    m_internal = property(_mupdf.PdfHintPage_m_internal_get, _mupdf.PdfHintPage_m_internal_set, doc=r""" Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.PdfHintPage_s_num_instances_get, _mupdf.PdfHintPage_s_num_instances_set)

# Register PdfHintPage in _mupdf:
_mupdf.PdfHintPage_swigregister(PdfHintPage)
class PdfHintShared(object):
    r""" Wrapper class for struct `pdf_hint_shared`. Not copyable or assignable."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::pdf_hint_shared`.
        """
        _mupdf.PdfHintShared_swiginit(self, _mupdf.new_PdfHintShared(*args))
    __swig_destroy__ = _mupdf.delete_PdfHintShared

    def m_internal_value(self):
        r""" Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.PdfHintShared_m_internal_value(self)
    m_internal = property(_mupdf.PdfHintShared_m_internal_get, _mupdf.PdfHintShared_m_internal_set, doc=r""" Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.PdfHintShared_s_num_instances_get, _mupdf.PdfHintShared_s_num_instances_set)

# Register PdfHintShared in _mupdf:
_mupdf.PdfHintShared_swigregister(PdfHintShared)
class PdfHmtx(object):
    r""" Wrapper class for struct `pdf_hmtx`. Not copyable or assignable."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::pdf_hmtx`.
        """
        _mupdf.PdfHmtx_swiginit(self, _mupdf.new_PdfHmtx(*args))
    __swig_destroy__ = _mupdf.delete_PdfHmtx

    def m_internal_value(self):
        r""" Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.PdfHmtx_m_internal_value(self)
    m_internal = property(_mupdf.PdfHmtx_m_internal_get, _mupdf.PdfHmtx_m_internal_set, doc=r""" Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.PdfHmtx_s_num_instances_get, _mupdf.PdfHmtx_s_num_instances_set)

# Register PdfHmtx in _mupdf:
_mupdf.PdfHmtx_swigregister(PdfHmtx)
class PdfImageRewriterOptions(object):
    r""" Wrapper class for struct `pdf_image_rewriter_options`."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        We use default copy constructor and operator=.  Default constructor, sets each member to default value.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::pdf_image_rewriter_options`.

        |

        *Overload 3:*
        Constructor using raw copy of pre-existing `::pdf_image_rewriter_options`.
        """
        _mupdf.PdfImageRewriterOptions_swiginit(self, _mupdf.new_PdfImageRewriterOptions(*args))

    def internal(self, *args):
        r"""
        *Overload 1:*
        Access as underlying struct.

        |

        *Overload 2:*
        Access as underlying struct.
        """
        return _mupdf.PdfImageRewriterOptions_internal(self, *args)
    __swig_destroy__ = _mupdf.delete_PdfImageRewriterOptions
    color_lossless_image_subsample_method = property(_mupdf.PdfImageRewriterOptions_color_lossless_image_subsample_method_get, _mupdf.PdfImageRewriterOptions_color_lossless_image_subsample_method_set)
    color_lossy_image_subsample_method = property(_mupdf.PdfImageRewriterOptions_color_lossy_image_subsample_method_get, _mupdf.PdfImageRewriterOptions_color_lossy_image_subsample_method_set)
    color_lossless_image_subsample_threshold = property(_mupdf.PdfImageRewriterOptions_color_lossless_image_subsample_threshold_get, _mupdf.PdfImageRewriterOptions_color_lossless_image_subsample_threshold_set)
    color_lossless_image_subsample_to = property(_mupdf.PdfImageRewriterOptions_color_lossless_image_subsample_to_get, _mupdf.PdfImageRewriterOptions_color_lossless_image_subsample_to_set)
    color_lossy_image_subsample_threshold = property(_mupdf.PdfImageRewriterOptions_color_lossy_image_subsample_threshold_get, _mupdf.PdfImageRewriterOptions_color_lossy_image_subsample_threshold_set)
    color_lossy_image_subsample_to = property(_mupdf.PdfImageRewriterOptions_color_lossy_image_subsample_to_get, _mupdf.PdfImageRewriterOptions_color_lossy_image_subsample_to_set)
    color_lossless_image_recompress_method = property(_mupdf.PdfImageRewriterOptions_color_lossless_image_recompress_method_get, _mupdf.PdfImageRewriterOptions_color_lossless_image_recompress_method_set)
    color_lossy_image_recompress_method = property(_mupdf.PdfImageRewriterOptions_color_lossy_image_recompress_method_get, _mupdf.PdfImageRewriterOptions_color_lossy_image_recompress_method_set)
    color_lossy_image_recompress_quality = property(_mupdf.PdfImageRewriterOptions_color_lossy_image_recompress_quality_get, _mupdf.PdfImageRewriterOptions_color_lossy_image_recompress_quality_set)
    color_lossless_image_recompress_quality = property(_mupdf.PdfImageRewriterOptions_color_lossless_image_recompress_quality_get, _mupdf.PdfImageRewriterOptions_color_lossless_image_recompress_quality_set)
    gray_lossless_image_subsample_method = property(_mupdf.PdfImageRewriterOptions_gray_lossless_image_subsample_method_get, _mupdf.PdfImageRewriterOptions_gray_lossless_image_subsample_method_set)
    gray_lossy_image_subsample_method = property(_mupdf.PdfImageRewriterOptions_gray_lossy_image_subsample_method_get, _mupdf.PdfImageRewriterOptions_gray_lossy_image_subsample_method_set)
    gray_lossless_image_subsample_threshold = property(_mupdf.PdfImageRewriterOptions_gray_lossless_image_subsample_threshold_get, _mupdf.PdfImageRewriterOptions_gray_lossless_image_subsample_threshold_set)
    gray_lossless_image_subsample_to = property(_mupdf.PdfImageRewriterOptions_gray_lossless_image_subsample_to_get, _mupdf.PdfImageRewriterOptions_gray_lossless_image_subsample_to_set)
    gray_lossy_image_subsample_threshold = property(_mupdf.PdfImageRewriterOptions_gray_lossy_image_subsample_threshold_get, _mupdf.PdfImageRewriterOptions_gray_lossy_image_subsample_threshold_set)
    gray_lossy_image_subsample_to = property(_mupdf.PdfImageRewriterOptions_gray_lossy_image_subsample_to_get, _mupdf.PdfImageRewriterOptions_gray_lossy_image_subsample_to_set)
    gray_lossless_image_recompress_method = property(_mupdf.PdfImageRewriterOptions_gray_lossless_image_recompress_method_get, _mupdf.PdfImageRewriterOptions_gray_lossless_image_recompress_method_set)
    gray_lossy_image_recompress_method = property(_mupdf.PdfImageRewriterOptions_gray_lossy_image_recompress_method_get, _mupdf.PdfImageRewriterOptions_gray_lossy_image_recompress_method_set)
    gray_lossy_image_recompress_quality = property(_mupdf.PdfImageRewriterOptions_gray_lossy_image_recompress_quality_get, _mupdf.PdfImageRewriterOptions_gray_lossy_image_recompress_quality_set)
    gray_lossless_image_recompress_quality = property(_mupdf.PdfImageRewriterOptions_gray_lossless_image_recompress_quality_get, _mupdf.PdfImageRewriterOptions_gray_lossless_image_recompress_quality_set)
    bitonal_image_subsample_method = property(_mupdf.PdfImageRewriterOptions_bitonal_image_subsample_method_get, _mupdf.PdfImageRewriterOptions_bitonal_image_subsample_method_set)
    bitonal_image_subsample_threshold = property(_mupdf.PdfImageRewriterOptions_bitonal_image_subsample_threshold_get, _mupdf.PdfImageRewriterOptions_bitonal_image_subsample_threshold_set)
    bitonal_image_subsample_to = property(_mupdf.PdfImageRewriterOptions_bitonal_image_subsample_to_get, _mupdf.PdfImageRewriterOptions_bitonal_image_subsample_to_set)
    bitonal_image_recompress_method = property(_mupdf.PdfImageRewriterOptions_bitonal_image_recompress_method_get, _mupdf.PdfImageRewriterOptions_bitonal_image_recompress_method_set)
    bitonal_image_recompress_quality = property(_mupdf.PdfImageRewriterOptions_bitonal_image_recompress_quality_get, _mupdf.PdfImageRewriterOptions_bitonal_image_recompress_quality_set)
    s_num_instances = property(_mupdf.PdfImageRewriterOptions_s_num_instances_get, _mupdf.PdfImageRewriterOptions_s_num_instances_set)

    def to_string(self):
        r""" Returns string containing our members, labelled and inside (...), using operator<<."""
        return _mupdf.PdfImageRewriterOptions_to_string(self)

    def __eq__(self, rhs):
        r""" Comparison method."""
        return _mupdf.PdfImageRewriterOptions___eq__(self, rhs)

    def __ne__(self, rhs):
        r""" Comparison method."""
        return _mupdf.PdfImageRewriterOptions___ne__(self, rhs)

# Register PdfImageRewriterOptions in _mupdf:
_mupdf.PdfImageRewriterOptions_swigregister(PdfImageRewriterOptions)
class PdfJournal(object):
    r""" Wrapper class for struct `pdf_journal`. Not copyable or assignable."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def pdf_discard_journal(self):
        r""" Class-aware wrapper for `::pdf_discard_journal()`."""
        return _mupdf.PdfJournal_pdf_discard_journal(self)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::pdf_journal`.
        """
        _mupdf.PdfJournal_swiginit(self, _mupdf.new_PdfJournal(*args))
    __swig_destroy__ = _mupdf.delete_PdfJournal

    def m_internal_value(self):
        r""" Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.PdfJournal_m_internal_value(self)
    m_internal = property(_mupdf.PdfJournal_m_internal_get, _mupdf.PdfJournal_m_internal_set, doc=r""" Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.PdfJournal_s_num_instances_get, _mupdf.PdfJournal_s_num_instances_set)

# Register PdfJournal in _mupdf:
_mupdf.PdfJournal_swigregister(PdfJournal)
class PdfJs(object):
    r""" Wrapper class for struct `pdf_js`. Not copyable or assignable."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def pdf_js_event_init(self, target, value, willCommit):
        r""" Class-aware wrapper for `::pdf_js_event_init()`."""
        return _mupdf.PdfJs_pdf_js_event_init(self, target, value, willCommit)

    def pdf_js_event_init_keystroke(self, target, evt):
        r""" Class-aware wrapper for `::pdf_js_event_init_keystroke()`."""
        return _mupdf.PdfJs_pdf_js_event_init_keystroke(self, target, evt)

    def pdf_js_event_result(self):
        r""" Class-aware wrapper for `::pdf_js_event_result()`."""
        return _mupdf.PdfJs_pdf_js_event_result(self)

    def pdf_js_event_result_keystroke(self, evt):
        r""" Class-aware wrapper for `::pdf_js_event_result_keystroke()`."""
        return _mupdf.PdfJs_pdf_js_event_result_keystroke(self, evt)

    def pdf_js_event_result_validate(self, newvalue):
        r"""
        Class-aware wrapper for `::pdf_js_event_result_validate()`.

        This method has out-params. Python/C# wrappers look like:
        	`pdf_js_event_result_validate()` => `(int, char *newvalue)`
        """
        return _mupdf.PdfJs_pdf_js_event_result_validate(self, newvalue)

    def pdf_js_event_value(self):
        r""" Class-aware wrapper for `::pdf_js_event_value()`."""
        return _mupdf.PdfJs_pdf_js_event_value(self)

    def pdf_js_execute(self, name, code, result):
        r"""
        Class-aware wrapper for `::pdf_js_execute()`.

        This method has out-params. Python/C# wrappers look like:
        	`pdf_js_execute(const char *name, const char *code)` => char *result
        """
        return _mupdf.PdfJs_pdf_js_execute(self, name, code, result)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::pdf_js`.
        """
        _mupdf.PdfJs_swiginit(self, _mupdf.new_PdfJs(*args))
    __swig_destroy__ = _mupdf.delete_PdfJs

    def m_internal_value(self):
        r""" Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.PdfJs_m_internal_value(self)
    m_internal = property(_mupdf.PdfJs_m_internal_get, _mupdf.PdfJs_m_internal_set, doc=r""" Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.PdfJs_s_num_instances_get, _mupdf.PdfJs_s_num_instances_set)

# Register PdfJs in _mupdf:
_mupdf.PdfJs_swigregister(PdfJs)
class PdfJsConsole(object):
    r""" Wrapper class for struct `pdf_js_console`. Not copyable or assignable."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::pdf_js_console`.
        """
        _mupdf.PdfJsConsole_swiginit(self, _mupdf.new_PdfJsConsole(*args))
    __swig_destroy__ = _mupdf.delete_PdfJsConsole

    def m_internal_value(self):
        r""" Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.PdfJsConsole_m_internal_value(self)
    m_internal = property(_mupdf.PdfJsConsole_m_internal_get, _mupdf.PdfJsConsole_m_internal_set, doc=r""" Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.PdfJsConsole_s_num_instances_get, _mupdf.PdfJsConsole_s_num_instances_set)

# Register PdfJsConsole in _mupdf:
_mupdf.PdfJsConsole_swigregister(PdfJsConsole)
class PdfKeystrokeEvent(object):
    r""" Wrapper class for struct `pdf_keystroke_event`. Not copyable or assignable."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::pdf_keystroke_event`.
        """
        _mupdf.PdfKeystrokeEvent_swiginit(self, _mupdf.new_PdfKeystrokeEvent(*args))
    __swig_destroy__ = _mupdf.delete_PdfKeystrokeEvent

    def m_internal_value(self):
        r""" Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.PdfKeystrokeEvent_m_internal_value(self)
    m_internal = property(_mupdf.PdfKeystrokeEvent_m_internal_get, _mupdf.PdfKeystrokeEvent_m_internal_set, doc=r""" Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.PdfKeystrokeEvent_s_num_instances_get, _mupdf.PdfKeystrokeEvent_s_num_instances_set)

# Register PdfKeystrokeEvent in _mupdf:
_mupdf.PdfKeystrokeEvent_swigregister(PdfKeystrokeEvent)
class PdfLaunchUrlEvent(object):
    r""" Wrapper class for struct `pdf_launch_url_event`. Not copyable or assignable."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::pdf_launch_url_event`.
        """
        _mupdf.PdfLaunchUrlEvent_swiginit(self, _mupdf.new_PdfLaunchUrlEvent(*args))
    __swig_destroy__ = _mupdf.delete_PdfLaunchUrlEvent

    def m_internal_value(self):
        r""" Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.PdfLaunchUrlEvent_m_internal_value(self)
    m_internal = property(_mupdf.PdfLaunchUrlEvent_m_internal_get, _mupdf.PdfLaunchUrlEvent_m_internal_set, doc=r""" Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.PdfLaunchUrlEvent_s_num_instances_get, _mupdf.PdfLaunchUrlEvent_s_num_instances_set)

# Register PdfLaunchUrlEvent in _mupdf:
_mupdf.PdfLaunchUrlEvent_swigregister(PdfLaunchUrlEvent)
class PdfLayerConfig(object):
    r""" Wrapper class for struct `pdf_layer_config`."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        We use default copy constructor and operator=.  Default constructor, sets each member to default value.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::pdf_layer_config`.

        |

        *Overload 3:*
        Constructor using raw copy of pre-existing `::pdf_layer_config`.
        """
        _mupdf.PdfLayerConfig_swiginit(self, _mupdf.new_PdfLayerConfig(*args))

    def internal(self, *args):
        r"""
        *Overload 1:*
        Access as underlying struct.

        |

        *Overload 2:*
        Access as underlying struct.
        """
        return _mupdf.PdfLayerConfig_internal(self, *args)
    __swig_destroy__ = _mupdf.delete_PdfLayerConfig
    name = property(_mupdf.PdfLayerConfig_name_get, _mupdf.PdfLayerConfig_name_set)
    creator = property(_mupdf.PdfLayerConfig_creator_get, _mupdf.PdfLayerConfig_creator_set)
    s_num_instances = property(_mupdf.PdfLayerConfig_s_num_instances_get, _mupdf.PdfLayerConfig_s_num_instances_set)

    def to_string(self):
        r""" Returns string containing our members, labelled and inside (...), using operator<<."""
        return _mupdf.PdfLayerConfig_to_string(self)

    def __eq__(self, rhs):
        r""" Comparison method."""
        return _mupdf.PdfLayerConfig___eq__(self, rhs)

    def __ne__(self, rhs):
        r""" Comparison method."""
        return _mupdf.PdfLayerConfig___ne__(self, rhs)

# Register PdfLayerConfig in _mupdf:
_mupdf.PdfLayerConfig_swigregister(PdfLayerConfig)
class PdfLayerConfigUi(object):
    r""" Wrapper class for struct `pdf_layer_config_ui`."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor sets .text to null, .type to PDF_LAYER_UI_LABEL, and other fields to zero.

        |

        *Overload 2:*
        We use default copy constructor and operator=.  Constructor using raw copy of pre-existing `::pdf_layer_config_ui`.

        |

        *Overload 3:*
        Constructor using raw copy of pre-existing `::pdf_layer_config_ui`.
        """
        _mupdf.PdfLayerConfigUi_swiginit(self, _mupdf.new_PdfLayerConfigUi(*args))

    def internal(self, *args):
        r"""
        *Overload 1:*
        Access as underlying struct.

        |

        *Overload 2:*
        Access as underlying struct.
        """
        return _mupdf.PdfLayerConfigUi_internal(self, *args)
    __swig_destroy__ = _mupdf.delete_PdfLayerConfigUi
    text = property(_mupdf.PdfLayerConfigUi_text_get, _mupdf.PdfLayerConfigUi_text_set)
    depth = property(_mupdf.PdfLayerConfigUi_depth_get, _mupdf.PdfLayerConfigUi_depth_set)
    type = property(_mupdf.PdfLayerConfigUi_type_get, _mupdf.PdfLayerConfigUi_type_set)
    selected = property(_mupdf.PdfLayerConfigUi_selected_get, _mupdf.PdfLayerConfigUi_selected_set)
    locked = property(_mupdf.PdfLayerConfigUi_locked_get, _mupdf.PdfLayerConfigUi_locked_set)
    s_num_instances = property(_mupdf.PdfLayerConfigUi_s_num_instances_get, _mupdf.PdfLayerConfigUi_s_num_instances_set)

    def to_string(self):
        r""" Returns string containing our members, labelled and inside (...), using operator<<."""
        return _mupdf.PdfLayerConfigUi_to_string(self)

    def __eq__(self, rhs):
        r""" Comparison method."""
        return _mupdf.PdfLayerConfigUi___eq__(self, rhs)

    def __ne__(self, rhs):
        r""" Comparison method."""
        return _mupdf.PdfLayerConfigUi___ne__(self, rhs)

# Register PdfLayerConfigUi in _mupdf:
_mupdf.PdfLayerConfigUi_swigregister(PdfLayerConfigUi)
class PdfLexbuf(object):
    r""" Wrapper class for struct `pdf_lexbuf`. Not copyable or assignable."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def pdf_lexbuf_fin(self):
        r""" Class-aware wrapper for `::pdf_lexbuf_fin()`."""
        return _mupdf.PdfLexbuf_pdf_lexbuf_fin(self)

    def pdf_lexbuf_grow(self):
        r""" Class-aware wrapper for `::pdf_lexbuf_grow()`."""
        return _mupdf.PdfLexbuf_pdf_lexbuf_grow(self)

    def pdf_lexbuf_init(self, size):
        r""" Class-aware wrapper for `::pdf_lexbuf_init()`."""
        return _mupdf.PdfLexbuf_pdf_lexbuf_init(self, size)
    __swig_destroy__ = _mupdf.delete_PdfLexbuf

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Constructor that calls pdf_lexbuf_init(size).

        |

        *Overload 2:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 3:*
        Constructor using raw copy of pre-existing `::pdf_lexbuf`.
        """
        _mupdf.PdfLexbuf_swiginit(self, _mupdf.new_PdfLexbuf(*args))

    def m_internal_value(self):
        r""" Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.PdfLexbuf_m_internal_value(self)
    m_internal = property(_mupdf.PdfLexbuf_m_internal_get, _mupdf.PdfLexbuf_m_internal_set, doc=r""" Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.PdfLexbuf_s_num_instances_get, _mupdf.PdfLexbuf_s_num_instances_set)

# Register PdfLexbuf in _mupdf:
_mupdf.PdfLexbuf_swigregister(PdfLexbuf)
class PdfLexbufLarge(object):
    r""" Wrapper class for struct `pdf_lexbuf_large`. Not copyable or assignable."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::pdf_lexbuf_large`.
        """
        _mupdf.PdfLexbufLarge_swiginit(self, _mupdf.new_PdfLexbufLarge(*args))
    __swig_destroy__ = _mupdf.delete_PdfLexbufLarge

    def m_internal_value(self):
        r""" Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.PdfLexbufLarge_m_internal_value(self)
    m_internal = property(_mupdf.PdfLexbufLarge_m_internal_get, _mupdf.PdfLexbufLarge_m_internal_set, doc=r""" Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.PdfLexbufLarge_s_num_instances_get, _mupdf.PdfLexbufLarge_s_num_instances_set)

# Register PdfLexbufLarge in _mupdf:
_mupdf.PdfLexbufLarge_swigregister(PdfLexbufLarge)
class PdfLockedFields(object):
    r""" Wrapper class for struct `pdf_locked_fields`. Not copyable or assignable."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def pdf_is_field_locked(self, name):
        r""" Class-aware wrapper for `::pdf_is_field_locked()`."""
        return _mupdf.PdfLockedFields_pdf_is_field_locked(self, name)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::pdf_locked_fields`.
        """
        _mupdf.PdfLockedFields_swiginit(self, _mupdf.new_PdfLockedFields(*args))
    __swig_destroy__ = _mupdf.delete_PdfLockedFields

    def m_internal_value(self):
        r""" Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.PdfLockedFields_m_internal_value(self)
    m_internal = property(_mupdf.PdfLockedFields_m_internal_get, _mupdf.PdfLockedFields_m_internal_set, doc=r""" Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.PdfLockedFields_s_num_instances_get, _mupdf.PdfLockedFields_s_num_instances_set)

# Register PdfLockedFields in _mupdf:
_mupdf.PdfLockedFields_swigregister(PdfLockedFields)
class PdfMailDocEvent(object):
    r""" Wrapper class for struct `pdf_mail_doc_event`. Not copyable or assignable."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::pdf_mail_doc_event`.
        """
        _mupdf.PdfMailDocEvent_swiginit(self, _mupdf.new_PdfMailDocEvent(*args))
    __swig_destroy__ = _mupdf.delete_PdfMailDocEvent

    def m_internal_value(self):
        r""" Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.PdfMailDocEvent_m_internal_value(self)
    m_internal = property(_mupdf.PdfMailDocEvent_m_internal_get, _mupdf.PdfMailDocEvent_m_internal_set, doc=r""" Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.PdfMailDocEvent_s_num_instances_get, _mupdf.PdfMailDocEvent_s_num_instances_set)

# Register PdfMailDocEvent in _mupdf:
_mupdf.PdfMailDocEvent_swigregister(PdfMailDocEvent)
class PdfMarkBits(object):
    r""" Wrapper class for struct `pdf_mark_bits`. Not copyable or assignable."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def pdf_mark_bits_reset(self):
        r""" Class-aware wrapper for `::pdf_mark_bits_reset()`."""
        return _mupdf.PdfMarkBits_pdf_mark_bits_reset(self)

    def pdf_mark_bits_set(self, obj):
        r""" Class-aware wrapper for `::pdf_mark_bits_set()`."""
        return _mupdf.PdfMarkBits_pdf_mark_bits_set(self, obj)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        == Constructors.  Constructor using `pdf_new_mark_bits()`.

        |

        *Overload 2:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 3:*
        Constructor using raw copy of pre-existing `::pdf_mark_bits`.
        """
        _mupdf.PdfMarkBits_swiginit(self, _mupdf.new_PdfMarkBits(*args))
    __swig_destroy__ = _mupdf.delete_PdfMarkBits

    def m_internal_value(self):
        r""" Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.PdfMarkBits_m_internal_value(self)
    m_internal = property(_mupdf.PdfMarkBits_m_internal_get, _mupdf.PdfMarkBits_m_internal_set, doc=r""" Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.PdfMarkBits_s_num_instances_get, _mupdf.PdfMarkBits_s_num_instances_set)

# Register PdfMarkBits in _mupdf:
_mupdf.PdfMarkBits_swigregister(PdfMarkBits)
class PdfMarkList(object):
    r""" Wrapper class for struct `pdf_mark_list`. Not copyable or assignable."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def pdf_mark_list_check(self, obj):
        r""" Class-aware wrapper for `::pdf_mark_list_check()`."""
        return _mupdf.PdfMarkList_pdf_mark_list_check(self, obj)

    def pdf_mark_list_free(self):
        r""" Class-aware wrapper for `::pdf_mark_list_free()`."""
        return _mupdf.PdfMarkList_pdf_mark_list_free(self)

    def pdf_mark_list_init(self):
        r""" Class-aware wrapper for `::pdf_mark_list_init()`."""
        return _mupdf.PdfMarkList_pdf_mark_list_init(self)

    def pdf_mark_list_pop(self):
        r""" Class-aware wrapper for `::pdf_mark_list_pop()`."""
        return _mupdf.PdfMarkList_pdf_mark_list_pop(self)

    def pdf_mark_list_push(self, obj):
        r""" Class-aware wrapper for `::pdf_mark_list_push()`."""
        return _mupdf.PdfMarkList_pdf_mark_list_push(self, obj)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::pdf_mark_list`.
        """
        _mupdf.PdfMarkList_swiginit(self, _mupdf.new_PdfMarkList(*args))
    __swig_destroy__ = _mupdf.delete_PdfMarkList

    def m_internal_value(self):
        r""" Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.PdfMarkList_m_internal_value(self)
    m_internal = property(_mupdf.PdfMarkList_m_internal_get, _mupdf.PdfMarkList_m_internal_set, doc=r""" Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.PdfMarkList_s_num_instances_get, _mupdf.PdfMarkList_s_num_instances_set)

# Register PdfMarkList in _mupdf:
_mupdf.PdfMarkList_swigregister(PdfMarkList)
class PdfMrange(object):
    r""" Wrapper class for struct `pdf_mrange`. Not copyable or assignable."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::pdf_mrange`.
        """
        _mupdf.PdfMrange_swiginit(self, _mupdf.new_PdfMrange(*args))
    __swig_destroy__ = _mupdf.delete_PdfMrange

    def m_internal_value(self):
        r""" Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.PdfMrange_m_internal_value(self)
    m_internal = property(_mupdf.PdfMrange_m_internal_get, _mupdf.PdfMrange_m_internal_set, doc=r""" Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.PdfMrange_s_num_instances_get, _mupdf.PdfMrange_s_num_instances_set)

# Register PdfMrange in _mupdf:
_mupdf.PdfMrange_swigregister(PdfMrange)
class PdfObj(object):
    r""" Wrapper class for struct `pdf_obj`."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def pdf_new_text_string(s):
        r""" Class-aware wrapper for `::pdf_new_text_string()`."""
        return _mupdf.PdfObj_pdf_new_text_string(s)

    @staticmethod
    def pdf_new_dict(doc, initialcap):
        r""" Class-aware wrapper for `::pdf_new_dict()`."""
        return _mupdf.PdfObj_pdf_new_dict(doc, initialcap)

    def pdf_array_contains(self, obj):
        r""" Class-aware wrapper for `::pdf_array_contains()`."""
        return _mupdf.PdfObj_pdf_array_contains(self, obj)

    def pdf_array_delete(self, index):
        r""" Class-aware wrapper for `::pdf_array_delete()`."""
        return _mupdf.PdfObj_pdf_array_delete(self, index)

    def pdf_array_find(self, obj):
        r""" Class-aware wrapper for `::pdf_array_find()`."""
        return _mupdf.PdfObj_pdf_array_find(self, obj)

    def pdf_array_get(self, i):
        r""" Class-aware wrapper for `::pdf_array_get()`."""
        return _mupdf.PdfObj_pdf_array_get(self, i)

    def pdf_array_get_bool(self, index):
        r""" Class-aware wrapper for `::pdf_array_get_bool()`."""
        return _mupdf.PdfObj_pdf_array_get_bool(self, index)

    def pdf_array_get_int(self, index):
        r""" Class-aware wrapper for `::pdf_array_get_int()`."""
        return _mupdf.PdfObj_pdf_array_get_int(self, index)

    def pdf_array_get_matrix(self, index):
        r""" Class-aware wrapper for `::pdf_array_get_matrix()`."""
        return _mupdf.PdfObj_pdf_array_get_matrix(self, index)

    def pdf_array_get_name(self, index):
        r""" Class-aware wrapper for `::pdf_array_get_name()`."""
        return _mupdf.PdfObj_pdf_array_get_name(self, index)

    def pdf_array_get_real(self, index):
        r""" Class-aware wrapper for `::pdf_array_get_real()`."""
        return _mupdf.PdfObj_pdf_array_get_real(self, index)

    def pdf_array_get_rect(self, index):
        r""" Class-aware wrapper for `::pdf_array_get_rect()`."""
        return _mupdf.PdfObj_pdf_array_get_rect(self, index)

    def pdf_array_get_string(self, index, sizep):
        r"""
        Class-aware wrapper for `::pdf_array_get_string()`.

        This method has out-params. Python/C# wrappers look like:
        	`pdf_array_get_string(int index)` => `(const char *, size_t sizep)`
        """
        return _mupdf.PdfObj_pdf_array_get_string(self, index, sizep)

    def pdf_array_get_text_string(self, index):
        r""" Class-aware wrapper for `::pdf_array_get_text_string()`."""
        return _mupdf.PdfObj_pdf_array_get_text_string(self, index)

    def pdf_array_insert(self, obj, index):
        r""" Class-aware wrapper for `::pdf_array_insert()`."""
        return _mupdf.PdfObj_pdf_array_insert(self, obj, index)

    def pdf_array_len(self):
        r""" Class-aware wrapper for `::pdf_array_len()`."""
        return _mupdf.PdfObj_pdf_array_len(self)

    def pdf_array_push(self, obj):
        r""" Class-aware wrapper for `::pdf_array_push()`."""
        return _mupdf.PdfObj_pdf_array_push(self, obj)

    def pdf_array_push_array(self, initial):
        r""" Class-aware wrapper for `::pdf_array_push_array()`."""
        return _mupdf.PdfObj_pdf_array_push_array(self, initial)

    def pdf_array_push_bool(self, x):
        r""" Class-aware wrapper for `::pdf_array_push_bool()`."""
        return _mupdf.PdfObj_pdf_array_push_bool(self, x)

    def pdf_array_push_dict(self, initial):
        r""" Class-aware wrapper for `::pdf_array_push_dict()`."""
        return _mupdf.PdfObj_pdf_array_push_dict(self, initial)

    def pdf_array_push_int(self, x):
        r""" Class-aware wrapper for `::pdf_array_push_int()`."""
        return _mupdf.PdfObj_pdf_array_push_int(self, x)

    def pdf_array_push_name(self, x):
        r""" Class-aware wrapper for `::pdf_array_push_name()`."""
        return _mupdf.PdfObj_pdf_array_push_name(self, x)

    def pdf_array_push_real(self, x):
        r""" Class-aware wrapper for `::pdf_array_push_real()`."""
        return _mupdf.PdfObj_pdf_array_push_real(self, x)

    def pdf_array_push_string(self, x, n):
        r""" Class-aware wrapper for `::pdf_array_push_string()`."""
        return _mupdf.PdfObj_pdf_array_push_string(self, x, n)

    def pdf_array_push_text_string(self, x):
        r""" Class-aware wrapper for `::pdf_array_push_text_string()`."""
        return _mupdf.PdfObj_pdf_array_push_text_string(self, x)

    def pdf_array_put(self, i, obj):
        r""" Class-aware wrapper for `::pdf_array_put()`."""
        return _mupdf.PdfObj_pdf_array_put(self, i, obj)

    def pdf_array_put_array(self, i, initial):
        r""" Class-aware wrapper for `::pdf_array_put_array()`."""
        return _mupdf.PdfObj_pdf_array_put_array(self, i, initial)

    def pdf_array_put_bool(self, i, x):
        r""" Class-aware wrapper for `::pdf_array_put_bool()`."""
        return _mupdf.PdfObj_pdf_array_put_bool(self, i, x)

    def pdf_array_put_dict(self, i, initial):
        r""" Class-aware wrapper for `::pdf_array_put_dict()`."""
        return _mupdf.PdfObj_pdf_array_put_dict(self, i, initial)

    def pdf_array_put_int(self, i, x):
        r""" Class-aware wrapper for `::pdf_array_put_int()`."""
        return _mupdf.PdfObj_pdf_array_put_int(self, i, x)

    def pdf_array_put_name(self, i, x):
        r""" Class-aware wrapper for `::pdf_array_put_name()`."""
        return _mupdf.PdfObj_pdf_array_put_name(self, i, x)

    def pdf_array_put_real(self, i, x):
        r""" Class-aware wrapper for `::pdf_array_put_real()`."""
        return _mupdf.PdfObj_pdf_array_put_real(self, i, x)

    def pdf_array_put_string(self, i, x, n):
        r""" Class-aware wrapper for `::pdf_array_put_string()`."""
        return _mupdf.PdfObj_pdf_array_put_string(self, i, x, n)

    def pdf_array_put_text_string(self, i, x):
        r""" Class-aware wrapper for `::pdf_array_put_text_string()`."""
        return _mupdf.PdfObj_pdf_array_put_text_string(self, i, x)

    def pdf_button_field_on_state(self):
        r""" Class-aware wrapper for `::pdf_button_field_on_state()`."""
        return _mupdf.PdfObj_pdf_button_field_on_state(self)

    def pdf_choice_field_option(self, exportval, i):
        r""" Class-aware wrapper for `::pdf_choice_field_option()`."""
        return _mupdf.PdfObj_pdf_choice_field_option(self, exportval, i)

    def pdf_choice_field_option_count(self):
        r""" Class-aware wrapper for `::pdf_choice_field_option_count()`."""
        return _mupdf.PdfObj_pdf_choice_field_option_count(self)

    def pdf_clean_obj(self):
        r""" Class-aware wrapper for `::pdf_clean_obj()`."""
        return _mupdf.PdfObj_pdf_clean_obj(self)

    def pdf_copy_array(self):
        r""" Class-aware wrapper for `::pdf_copy_array()`."""
        return _mupdf.PdfObj_pdf_copy_array(self)

    def pdf_copy_dict(self):
        r""" Class-aware wrapper for `::pdf_copy_dict()`."""
        return _mupdf.PdfObj_pdf_copy_dict(self)

    def pdf_debug_obj(self):
        r""" Class-aware wrapper for `::pdf_debug_obj()`."""
        return _mupdf.PdfObj_pdf_debug_obj(self)

    def pdf_debug_ref(self):
        r""" Class-aware wrapper for `::pdf_debug_ref()`."""
        return _mupdf.PdfObj_pdf_debug_ref(self)

    def pdf_deep_copy_obj(self):
        r""" Class-aware wrapper for `::pdf_deep_copy_obj()`."""
        return _mupdf.PdfObj_pdf_deep_copy_obj(self)

    def pdf_dict_del(self, key):
        r""" Class-aware wrapper for `::pdf_dict_del()`."""
        return _mupdf.PdfObj_pdf_dict_del(self, key)

    def pdf_dict_dels(self, key):
        r""" Class-aware wrapper for `::pdf_dict_dels()`."""
        return _mupdf.PdfObj_pdf_dict_dels(self, key)

    def pdf_dict_get_bool(self, key):
        r""" Class-aware wrapper for `::pdf_dict_get_bool()`."""
        return _mupdf.PdfObj_pdf_dict_get_bool(self, key)

    def pdf_dict_get_bool_default(self, key, _def):
        r""" Class-aware wrapper for `::pdf_dict_get_bool_default()`."""
        return _mupdf.PdfObj_pdf_dict_get_bool_default(self, key, _def)

    def pdf_dict_get_date(self, key):
        r""" Class-aware wrapper for `::pdf_dict_get_date()`."""
        return _mupdf.PdfObj_pdf_dict_get_date(self, key)

    def pdf_dict_get_inheritable(self, key):
        r""" Class-aware wrapper for `::pdf_dict_get_inheritable()`."""
        return _mupdf.PdfObj_pdf_dict_get_inheritable(self, key)

    def pdf_dict_get_inheritable_bool(self, key):
        r""" Class-aware wrapper for `::pdf_dict_get_inheritable_bool()`."""
        return _mupdf.PdfObj_pdf_dict_get_inheritable_bool(self, key)

    def pdf_dict_get_inheritable_date(self, key):
        r""" Class-aware wrapper for `::pdf_dict_get_inheritable_date()`."""
        return _mupdf.PdfObj_pdf_dict_get_inheritable_date(self, key)

    def pdf_dict_get_inheritable_int(self, key):
        r""" Class-aware wrapper for `::pdf_dict_get_inheritable_int()`."""
        return _mupdf.PdfObj_pdf_dict_get_inheritable_int(self, key)

    def pdf_dict_get_inheritable_int64(self, key):
        r""" Class-aware wrapper for `::pdf_dict_get_inheritable_int64()`."""
        return _mupdf.PdfObj_pdf_dict_get_inheritable_int64(self, key)

    def pdf_dict_get_inheritable_matrix(self, key):
        r""" Class-aware wrapper for `::pdf_dict_get_inheritable_matrix()`."""
        return _mupdf.PdfObj_pdf_dict_get_inheritable_matrix(self, key)

    def pdf_dict_get_inheritable_name(self, key):
        r""" Class-aware wrapper for `::pdf_dict_get_inheritable_name()`."""
        return _mupdf.PdfObj_pdf_dict_get_inheritable_name(self, key)

    def pdf_dict_get_inheritable_real(self, key):
        r""" Class-aware wrapper for `::pdf_dict_get_inheritable_real()`."""
        return _mupdf.PdfObj_pdf_dict_get_inheritable_real(self, key)

    def pdf_dict_get_inheritable_rect(self, key):
        r""" Class-aware wrapper for `::pdf_dict_get_inheritable_rect()`."""
        return _mupdf.PdfObj_pdf_dict_get_inheritable_rect(self, key)

    def pdf_dict_get_inheritable_string(self, key, sizep):
        r"""
        Class-aware wrapper for `::pdf_dict_get_inheritable_string()`.

        This method has out-params. Python/C# wrappers look like:
        	`pdf_dict_get_inheritable_string(::pdf_obj *key)` => `(const char *, size_t sizep)`
        """
        return _mupdf.PdfObj_pdf_dict_get_inheritable_string(self, key, sizep)

    def pdf_dict_get_inheritable_text_string(self, key):
        r""" Class-aware wrapper for `::pdf_dict_get_inheritable_text_string()`."""
        return _mupdf.PdfObj_pdf_dict_get_inheritable_text_string(self, key)

    def pdf_dict_get_int(self, key):
        r""" Class-aware wrapper for `::pdf_dict_get_int()`."""
        return _mupdf.PdfObj_pdf_dict_get_int(self, key)

    def pdf_dict_get_int64(self, key):
        r""" Class-aware wrapper for `::pdf_dict_get_int64()`."""
        return _mupdf.PdfObj_pdf_dict_get_int64(self, key)

    def pdf_dict_get_int_default(self, key, _def):
        r""" Class-aware wrapper for `::pdf_dict_get_int_default()`."""
        return _mupdf.PdfObj_pdf_dict_get_int_default(self, key, _def)

    def pdf_dict_get_key(self, idx):
        r""" Class-aware wrapper for `::pdf_dict_get_key()`."""
        return _mupdf.PdfObj_pdf_dict_get_key(self, idx)

    def pdf_dict_get_matrix(self, key):
        r""" Class-aware wrapper for `::pdf_dict_get_matrix()`."""
        return _mupdf.PdfObj_pdf_dict_get_matrix(self, key)

    def pdf_dict_get_name(self, key):
        r""" Class-aware wrapper for `::pdf_dict_get_name()`."""
        return _mupdf.PdfObj_pdf_dict_get_name(self, key)

    def pdf_dict_get_real(self, key):
        r""" Class-aware wrapper for `::pdf_dict_get_real()`."""
        return _mupdf.PdfObj_pdf_dict_get_real(self, key)

    def pdf_dict_get_real_default(self, key, _def):
        r""" Class-aware wrapper for `::pdf_dict_get_real_default()`."""
        return _mupdf.PdfObj_pdf_dict_get_real_default(self, key, _def)

    def pdf_dict_get_rect(self, key):
        r""" Class-aware wrapper for `::pdf_dict_get_rect()`."""
        return _mupdf.PdfObj_pdf_dict_get_rect(self, key)

    def pdf_dict_get_string(self, key, sizep):
        r"""
        Class-aware wrapper for `::pdf_dict_get_string()`.

        This method has out-params. Python/C# wrappers look like:
        	`pdf_dict_get_string(::pdf_obj *key)` => `(const char *, size_t sizep)`
        """
        return _mupdf.PdfObj_pdf_dict_get_string(self, key, sizep)

    def pdf_dict_get_text_string(self, key):
        r""" Class-aware wrapper for `::pdf_dict_get_text_string()`."""
        return _mupdf.PdfObj_pdf_dict_get_text_string(self, key)

    def pdf_dict_get_val(self, idx):
        r""" Class-aware wrapper for `::pdf_dict_get_val()`."""
        return _mupdf.PdfObj_pdf_dict_get_val(self, idx)

    def pdf_dict_geta(self, key, abbrev):
        r""" Class-aware wrapper for `::pdf_dict_geta()`."""
        return _mupdf.PdfObj_pdf_dict_geta(self, key, abbrev)

    def pdf_dict_getp(self, path):
        r""" Class-aware wrapper for `::pdf_dict_getp()`."""
        return _mupdf.PdfObj_pdf_dict_getp(self, path)

    def pdf_dict_getp_inheritable(self, path):
        r""" Class-aware wrapper for `::pdf_dict_getp_inheritable()`."""
        return _mupdf.PdfObj_pdf_dict_getp_inheritable(self, path)

    def pdf_dict_gets(self, key):
        r""" Class-aware wrapper for `::pdf_dict_gets()`."""
        return _mupdf.PdfObj_pdf_dict_gets(self, key)

    def pdf_dict_gets_inheritable(self, key):
        r""" Class-aware wrapper for `::pdf_dict_gets_inheritable()`."""
        return _mupdf.PdfObj_pdf_dict_gets_inheritable(self, key)

    def pdf_dict_getsa(self, key, abbrev):
        r""" Class-aware wrapper for `::pdf_dict_getsa()`."""
        return _mupdf.PdfObj_pdf_dict_getsa(self, key, abbrev)

    def pdf_dict_len(self):
        r""" Class-aware wrapper for `::pdf_dict_len()`."""
        return _mupdf.PdfObj_pdf_dict_len(self)

    def pdf_dict_put(self, key, val):
        r""" Class-aware wrapper for `::pdf_dict_put()`."""
        return _mupdf.PdfObj_pdf_dict_put(self, key, val)

    def pdf_dict_put_array(self, key, initial):
        r""" Class-aware wrapper for `::pdf_dict_put_array()`."""
        return _mupdf.PdfObj_pdf_dict_put_array(self, key, initial)

    def pdf_dict_put_bool(self, key, x):
        r""" Class-aware wrapper for `::pdf_dict_put_bool()`."""
        return _mupdf.PdfObj_pdf_dict_put_bool(self, key, x)

    def pdf_dict_put_date(self, key, time):
        r""" Class-aware wrapper for `::pdf_dict_put_date()`."""
        return _mupdf.PdfObj_pdf_dict_put_date(self, key, time)

    def pdf_dict_put_dict(self, key, initial):
        r""" Class-aware wrapper for `::pdf_dict_put_dict()`."""
        return _mupdf.PdfObj_pdf_dict_put_dict(self, key, initial)

    def pdf_dict_put_int(self, key, x):
        r""" Class-aware wrapper for `::pdf_dict_put_int()`."""
        return _mupdf.PdfObj_pdf_dict_put_int(self, key, x)

    def pdf_dict_put_matrix(self, key, x):
        r""" Class-aware wrapper for `::pdf_dict_put_matrix()`."""
        return _mupdf.PdfObj_pdf_dict_put_matrix(self, key, x)

    def pdf_dict_put_name(self, key, x):
        r""" Class-aware wrapper for `::pdf_dict_put_name()`."""
        return _mupdf.PdfObj_pdf_dict_put_name(self, key, x)

    def pdf_dict_put_real(self, key, x):
        r""" Class-aware wrapper for `::pdf_dict_put_real()`."""
        return _mupdf.PdfObj_pdf_dict_put_real(self, key, x)

    def pdf_dict_put_rect(self, key, x):
        r""" Class-aware wrapper for `::pdf_dict_put_rect()`."""
        return _mupdf.PdfObj_pdf_dict_put_rect(self, key, x)

    def pdf_dict_put_string(self, key, x, n):
        r""" Class-aware wrapper for `::pdf_dict_put_string()`."""
        return _mupdf.PdfObj_pdf_dict_put_string(self, key, x, n)

    def pdf_dict_put_text_string(self, key, x):
        r""" Class-aware wrapper for `::pdf_dict_put_text_string()`."""
        return _mupdf.PdfObj_pdf_dict_put_text_string(self, key, x)

    def pdf_dict_put_val_null(self, idx):
        r""" Class-aware wrapper for `::pdf_dict_put_val_null()`."""
        return _mupdf.PdfObj_pdf_dict_put_val_null(self, idx)

    def pdf_dict_putp(self, path, val):
        r""" Class-aware wrapper for `::pdf_dict_putp()`."""
        return _mupdf.PdfObj_pdf_dict_putp(self, path, val)

    def pdf_dict_puts(self, key, val):
        r""" Class-aware wrapper for `::pdf_dict_puts()`."""
        return _mupdf.PdfObj_pdf_dict_puts(self, key, val)

    def pdf_dict_puts_dict(self, key, initial):
        r""" Class-aware wrapper for `::pdf_dict_puts_dict()`."""
        return _mupdf.PdfObj_pdf_dict_puts_dict(self, key, initial)

    def pdf_dirty_obj(self):
        r""" Class-aware wrapper for `::pdf_dirty_obj()`."""
        return _mupdf.PdfObj_pdf_dirty_obj(self)

    def pdf_field_border_style(self):
        r""" Class-aware wrapper for `::pdf_field_border_style()`."""
        return _mupdf.PdfObj_pdf_field_border_style(self)

    def pdf_field_display(self):
        r""" Class-aware wrapper for `::pdf_field_display()`."""
        return _mupdf.PdfObj_pdf_field_display(self)

    def pdf_field_flags(self):
        r""" Class-aware wrapper for `::pdf_field_flags()`."""
        return _mupdf.PdfObj_pdf_field_flags(self)

    def pdf_field_label(self):
        r""" Class-aware wrapper for `::pdf_field_label()`."""
        return _mupdf.PdfObj_pdf_field_label(self)

    def pdf_field_set_border_style(self, text):
        r""" Class-aware wrapper for `::pdf_field_set_border_style()`."""
        return _mupdf.PdfObj_pdf_field_set_border_style(self, text)

    def pdf_field_set_button_caption(self, text):
        r""" Class-aware wrapper for `::pdf_field_set_button_caption()`."""
        return _mupdf.PdfObj_pdf_field_set_button_caption(self, text)

    def pdf_field_set_display(self, d):
        r""" Class-aware wrapper for `::pdf_field_set_display()`."""
        return _mupdf.PdfObj_pdf_field_set_display(self, d)

    def pdf_field_set_fill_color(self, col):
        r""" Class-aware wrapper for `::pdf_field_set_fill_color()`."""
        return _mupdf.PdfObj_pdf_field_set_fill_color(self, col)

    def pdf_field_set_text_color(self, col):
        r""" Class-aware wrapper for `::pdf_field_set_text_color()`."""
        return _mupdf.PdfObj_pdf_field_set_text_color(self, col)

    def pdf_field_type(self):
        r""" Class-aware wrapper for `::pdf_field_type()`."""
        return _mupdf.PdfObj_pdf_field_type(self)

    def pdf_field_type_string(self):
        r""" Class-aware wrapper for `::pdf_field_type_string()`."""
        return _mupdf.PdfObj_pdf_field_type_string(self)

    def pdf_field_value(self):
        r""" Class-aware wrapper for `::pdf_field_value()`."""
        return _mupdf.PdfObj_pdf_field_value(self)

    def pdf_filter_xobject_instance(self, page_res, ctm, options, cycle_up):
        r""" Class-aware wrapper for `::pdf_filter_xobject_instance()`."""
        return _mupdf.PdfObj_pdf_filter_xobject_instance(self, page_res, ctm, options, cycle_up)

    def pdf_flatten_inheritable_page_items(self):
        r""" Class-aware wrapper for `::pdf_flatten_inheritable_page_items()`."""
        return _mupdf.PdfObj_pdf_flatten_inheritable_page_items(self)

    def pdf_get_bound_document(self):
        r""" Class-aware wrapper for `::pdf_get_bound_document()`."""
        return _mupdf.PdfObj_pdf_get_bound_document(self)

    def pdf_get_embedded_file_params(self, out):
        r""" Class-aware wrapper for `::pdf_get_embedded_file_params()`."""
        return _mupdf.PdfObj_pdf_get_embedded_file_params(self, out)

    def pdf_get_indirect_document(self):
        r""" Class-aware wrapper for `::pdf_get_indirect_document()`."""
        return _mupdf.PdfObj_pdf_get_indirect_document(self)

    def pdf_is_array(self):
        r""" Class-aware wrapper for `::pdf_is_array()`."""
        return _mupdf.PdfObj_pdf_is_array(self)

    def pdf_is_bool(self):
        r""" Class-aware wrapper for `::pdf_is_bool()`."""
        return _mupdf.PdfObj_pdf_is_bool(self)

    def pdf_is_dict(self):
        r""" Class-aware wrapper for `::pdf_is_dict()`."""
        return _mupdf.PdfObj_pdf_is_dict(self)

    def pdf_is_embedded_file(self):
        r""" Class-aware wrapper for `::pdf_is_embedded_file()`."""
        return _mupdf.PdfObj_pdf_is_embedded_file(self)

    def pdf_is_indirect(self):
        r""" Class-aware wrapper for `::pdf_is_indirect()`."""
        return _mupdf.PdfObj_pdf_is_indirect(self)

    def pdf_is_int(self):
        r""" Class-aware wrapper for `::pdf_is_int()`."""
        return _mupdf.PdfObj_pdf_is_int(self)

    def pdf_is_jpx_image(self):
        r""" Class-aware wrapper for `::pdf_is_jpx_image()`."""
        return _mupdf.PdfObj_pdf_is_jpx_image(self)

    def pdf_is_name(self):
        r""" Class-aware wrapper for `::pdf_is_name()`."""
        return _mupdf.PdfObj_pdf_is_name(self)

    def pdf_is_null(self):
        r""" Class-aware wrapper for `::pdf_is_null()`."""
        return _mupdf.PdfObj_pdf_is_null(self)

    def pdf_is_number(self):
        r""" Class-aware wrapper for `::pdf_is_number()`."""
        return _mupdf.PdfObj_pdf_is_number(self)

    def pdf_is_real(self):
        r""" Class-aware wrapper for `::pdf_is_real()`."""
        return _mupdf.PdfObj_pdf_is_real(self)

    def pdf_is_stream(self):
        r""" Class-aware wrapper for `::pdf_is_stream()`."""
        return _mupdf.PdfObj_pdf_is_stream(self)

    def pdf_is_string(self):
        r""" Class-aware wrapper for `::pdf_is_string()`."""
        return _mupdf.PdfObj_pdf_is_string(self)

    def pdf_line_ending_from_name(self):
        r""" Class-aware wrapper for `::pdf_line_ending_from_name()`."""
        return _mupdf.PdfObj_pdf_line_ending_from_name(self)

    def pdf_load_colorspace(self):
        r""" Class-aware wrapper for `::pdf_load_colorspace()`."""
        return _mupdf.PdfObj_pdf_load_colorspace(self)

    def pdf_load_embedded_file_contents(self):
        r""" Class-aware wrapper for `::pdf_load_embedded_file_contents()`."""
        return _mupdf.PdfObj_pdf_load_embedded_file_contents(self)

    def pdf_load_field_name(self):
        r""" Class-aware wrapper for `::pdf_load_field_name()`."""
        return _mupdf.PdfObj_pdf_load_field_name(self)

    def pdf_load_function(self, _in, out):
        r""" Class-aware wrapper for `::pdf_load_function()`."""
        return _mupdf.PdfObj_pdf_load_function(self, _in, out)

    def pdf_load_raw_stream(self):
        r""" Class-aware wrapper for `::pdf_load_raw_stream()`."""
        return _mupdf.PdfObj_pdf_load_raw_stream(self)

    def pdf_load_stream(self):
        r""" Class-aware wrapper for `::pdf_load_stream()`."""
        return _mupdf.PdfObj_pdf_load_stream(self)

    def pdf_load_stream_or_string_as_utf8(self):
        r""" Class-aware wrapper for `::pdf_load_stream_or_string_as_utf8()`."""
        return _mupdf.PdfObj_pdf_load_stream_or_string_as_utf8(self)

    def pdf_lookup_field(self, name):
        r""" Class-aware wrapper for `::pdf_lookup_field()`."""
        return _mupdf.PdfObj_pdf_lookup_field(self, name)

    def pdf_lookup_number(self, needle):
        r""" Class-aware wrapper for `::pdf_lookup_number()`."""
        return _mupdf.PdfObj_pdf_lookup_number(self, needle)

    def pdf_mark_obj(self):
        r""" Class-aware wrapper for `::pdf_mark_obj()`."""
        return _mupdf.PdfObj_pdf_mark_obj(self)

    def pdf_name_eq(self, b):
        r""" Class-aware wrapper for `::pdf_name_eq()`."""
        return _mupdf.PdfObj_pdf_name_eq(self, b)

    def pdf_new_utf8_from_pdf_stream_obj(self):
        r""" Class-aware wrapper for `::pdf_new_utf8_from_pdf_stream_obj()`."""
        return _mupdf.PdfObj_pdf_new_utf8_from_pdf_stream_obj(self)

    def pdf_new_utf8_from_pdf_string_obj(self):
        r""" Class-aware wrapper for `::pdf_new_utf8_from_pdf_string_obj()`."""
        return _mupdf.PdfObj_pdf_new_utf8_from_pdf_string_obj(self)

    def pdf_obj_is_dirty(self):
        r""" Class-aware wrapper for `::pdf_obj_is_dirty()`."""
        return _mupdf.PdfObj_pdf_obj_is_dirty(self)

    def pdf_obj_is_incremental(self):
        r""" Class-aware wrapper for `::pdf_obj_is_incremental()`."""
        return _mupdf.PdfObj_pdf_obj_is_incremental(self)

    def pdf_obj_marked(self):
        r""" Class-aware wrapper for `::pdf_obj_marked()`."""
        return _mupdf.PdfObj_pdf_obj_marked(self)

    def pdf_obj_memo(self, bit, memo):
        r"""
        Class-aware wrapper for `::pdf_obj_memo()`.

        This method has out-params. Python/C# wrappers look like:
        	`pdf_obj_memo(int bit)` => `(int, int memo)`
        """
        return _mupdf.PdfObj_pdf_obj_memo(self, bit, memo)

    def pdf_obj_parent_num(self):
        r""" Class-aware wrapper for `::pdf_obj_parent_num()`."""
        return _mupdf.PdfObj_pdf_obj_parent_num(self)

    def pdf_obj_refs(self):
        r""" Class-aware wrapper for `::pdf_obj_refs()`."""
        return _mupdf.PdfObj_pdf_obj_refs(self)

    def pdf_objcmp(self, b):
        r""" Class-aware wrapper for `::pdf_objcmp()`."""
        return _mupdf.PdfObj_pdf_objcmp(self, b)

    def pdf_objcmp_deep(self, b):
        r""" Class-aware wrapper for `::pdf_objcmp_deep()`."""
        return _mupdf.PdfObj_pdf_objcmp_deep(self, b)

    def pdf_objcmp_resolve(self, b):
        r""" Class-aware wrapper for `::pdf_objcmp_resolve()`."""
        return _mupdf.PdfObj_pdf_objcmp_resolve(self, b)

    def pdf_open_raw_stream(self):
        r""" Class-aware wrapper for `::pdf_open_raw_stream()`."""
        return _mupdf.PdfObj_pdf_open_raw_stream(self)

    def pdf_open_stream(self):
        r""" Class-aware wrapper for `::pdf_open_stream()`."""
        return _mupdf.PdfObj_pdf_open_stream(self)

    def pdf_page_obj_transform(self, outbox, outctm):
        r""" Class-aware wrapper for `::pdf_page_obj_transform()`."""
        return _mupdf.PdfObj_pdf_page_obj_transform(self, outbox, outctm)

    def pdf_page_obj_transform_box(self, outbox, out, box):
        r""" Class-aware wrapper for `::pdf_page_obj_transform_box()`."""
        return _mupdf.PdfObj_pdf_page_obj_transform_box(self, outbox, out, box)

    def pdf_pin_document(self):
        r""" Class-aware wrapper for `::pdf_pin_document()`."""
        return _mupdf.PdfObj_pdf_pin_document(self)

    def pdf_recolor_shade(self, reshade, opaque):
        r"""
        Class-aware wrapper for `::pdf_recolor_shade()`.
        	Recolor a shade.
        """
        return _mupdf.PdfObj_pdf_recolor_shade(self, reshade, opaque)

    def pdf_resolve_indirect(self):
        r"""
        Class-aware wrapper for `::pdf_resolve_indirect()`.
        	Resolve an indirect object (or chain of objects).

        	This can cause xref reorganisations (solidifications etc) due to
        	repairs, so all held pdf_xref_entries should be considered
        	invalid after this call (other than the returned one).
        """
        return _mupdf.PdfObj_pdf_resolve_indirect(self)

    def pdf_resolve_indirect_chain(self):
        r""" Class-aware wrapper for `::pdf_resolve_indirect_chain()`."""
        return _mupdf.PdfObj_pdf_resolve_indirect_chain(self)

    def pdf_set_int(self, i):
        r""" Class-aware wrapper for `::pdf_set_int()`."""
        return _mupdf.PdfObj_pdf_set_int(self, i)

    def pdf_set_obj_memo(self, bit, memo):
        r""" Class-aware wrapper for `::pdf_set_obj_memo()`."""
        return _mupdf.PdfObj_pdf_set_obj_memo(self, bit, memo)

    def pdf_set_obj_parent(self, num):
        r""" Class-aware wrapper for `::pdf_set_obj_parent()`."""
        return _mupdf.PdfObj_pdf_set_obj_parent(self, num)

    def pdf_set_str_len(self, newlen):
        r""" Class-aware wrapper for `::pdf_set_str_len()`."""
        return _mupdf.PdfObj_pdf_set_str_len(self, newlen)

    def pdf_sort_dict(self):
        r""" Class-aware wrapper for `::pdf_sort_dict()`."""
        return _mupdf.PdfObj_pdf_sort_dict(self)

    def pdf_store_item(self, val, itemsize):
        r""" Class-aware wrapper for `::pdf_store_item()`."""
        return _mupdf.PdfObj_pdf_store_item(self, val, itemsize)

    def pdf_to_bool(self):
        r""" Class-aware wrapper for `::pdf_to_bool()`."""
        return _mupdf.PdfObj_pdf_to_bool(self)

    def pdf_to_bool_default(self, _def):
        r""" Class-aware wrapper for `::pdf_to_bool_default()`."""
        return _mupdf.PdfObj_pdf_to_bool_default(self, _def)

    def pdf_to_date(self):
        r""" Class-aware wrapper for `::pdf_to_date()`."""
        return _mupdf.PdfObj_pdf_to_date(self)

    def pdf_to_gen(self):
        r""" Class-aware wrapper for `::pdf_to_gen()`."""
        return _mupdf.PdfObj_pdf_to_gen(self)

    def pdf_to_int(self):
        r""" Class-aware wrapper for `::pdf_to_int()`."""
        return _mupdf.PdfObj_pdf_to_int(self)

    def pdf_to_int64(self):
        r""" Class-aware wrapper for `::pdf_to_int64()`."""
        return _mupdf.PdfObj_pdf_to_int64(self)

    def pdf_to_int_default(self, _def):
        r""" Class-aware wrapper for `::pdf_to_int_default()`."""
        return _mupdf.PdfObj_pdf_to_int_default(self, _def)

    def pdf_to_matrix(self):
        r""" Class-aware wrapper for `::pdf_to_matrix()`."""
        return _mupdf.PdfObj_pdf_to_matrix(self)

    def pdf_to_name(self):
        r""" Class-aware wrapper for `::pdf_to_name()`."""
        return _mupdf.PdfObj_pdf_to_name(self)

    def pdf_to_num(self):
        r""" Class-aware wrapper for `::pdf_to_num()`."""
        return _mupdf.PdfObj_pdf_to_num(self)

    def pdf_to_quad(self, offset):
        r""" Class-aware wrapper for `::pdf_to_quad()`."""
        return _mupdf.PdfObj_pdf_to_quad(self, offset)

    def pdf_to_real(self):
        r""" Class-aware wrapper for `::pdf_to_real()`."""
        return _mupdf.PdfObj_pdf_to_real(self)

    def pdf_to_real_default(self, _def):
        r""" Class-aware wrapper for `::pdf_to_real_default()`."""
        return _mupdf.PdfObj_pdf_to_real_default(self, _def)

    def pdf_to_rect(self):
        r""" Class-aware wrapper for `::pdf_to_rect()`."""
        return _mupdf.PdfObj_pdf_to_rect(self)

    def pdf_to_str_buf(self):
        r""" Class-aware wrapper for `::pdf_to_str_buf()`."""
        return _mupdf.PdfObj_pdf_to_str_buf(self)

    def pdf_to_str_len(self):
        r""" Class-aware wrapper for `::pdf_to_str_len()`."""
        return _mupdf.PdfObj_pdf_to_str_len(self)

    def pdf_to_string(self, sizep):
        r"""
        Class-aware wrapper for `::pdf_to_string()`.

        This method has out-params. Python/C# wrappers look like:
        	`pdf_to_string()` => `(const char *, size_t sizep)`
        """
        return _mupdf.PdfObj_pdf_to_string(self, sizep)

    def pdf_to_text_string(self):
        r""" Class-aware wrapper for `::pdf_to_text_string()`."""
        return _mupdf.PdfObj_pdf_to_text_string(self)

    def pdf_unmark_obj(self):
        r""" Class-aware wrapper for `::pdf_unmark_obj()`."""
        return _mupdf.PdfObj_pdf_unmark_obj(self)

    def pdf_verify_embedded_file_checksum(self):
        r""" Class-aware wrapper for `::pdf_verify_embedded_file_checksum()`."""
        return _mupdf.PdfObj_pdf_verify_embedded_file_checksum(self)

    def pdf_walk_tree(self, kid_name, arrive, leave, arg, names, values):
        r"""
        Class-aware wrapper for `::pdf_walk_tree()`.

        This method has out-params. Python/C# wrappers look like:
        	`pdf_walk_tree(::pdf_obj *kid_name, void (*arrive)(::fz_context *, ::pdf_obj *, void *, ::pdf_obj **), void (*leave)(::fz_context *, ::pdf_obj *, void *), void *arg, ::pdf_obj **names, ::pdf_obj **values)` => `()`
        """
        return _mupdf.PdfObj_pdf_walk_tree(self, kid_name, arrive, leave, arg, names, values)

    def pdf_xobject_bbox(self):
        r""" Class-aware wrapper for `::pdf_xobject_bbox()`."""
        return _mupdf.PdfObj_pdf_xobject_bbox(self)

    def pdf_xobject_colorspace(self):
        r""" Class-aware wrapper for `::pdf_xobject_colorspace()`."""
        return _mupdf.PdfObj_pdf_xobject_colorspace(self)

    def pdf_xobject_isolated(self):
        r""" Class-aware wrapper for `::pdf_xobject_isolated()`."""
        return _mupdf.PdfObj_pdf_xobject_isolated(self)

    def pdf_xobject_knockout(self):
        r""" Class-aware wrapper for `::pdf_xobject_knockout()`."""
        return _mupdf.PdfObj_pdf_xobject_knockout(self)

    def pdf_xobject_matrix(self):
        r""" Class-aware wrapper for `::pdf_xobject_matrix()`."""
        return _mupdf.PdfObj_pdf_xobject_matrix(self)

    def pdf_xobject_resources(self):
        r""" Class-aware wrapper for `::pdf_xobject_resources()`."""
        return _mupdf.PdfObj_pdf_xobject_resources(self)

    def pdf_xobject_transparency(self):
        r""" Class-aware wrapper for `::pdf_xobject_transparency()`."""
        return _mupdf.PdfObj_pdf_xobject_transparency(self)

    def pdf_dict_get(self, *args):
        r"""
        *Overload 1:*
        Class-aware wrapper for `::pdf_dict_get()`.

        |

        *Overload 2:*
        Typesafe wrapper for looking up things such as PDF_ENUM_NAME_Annots.
        """
        return _mupdf.PdfObj_pdf_dict_get(self, *args)

    def pdf_load_field_name2(self):
        r""" Alternative to `pdf_load_field_name()` that returns a std::string."""
        return _mupdf.PdfObj_pdf_load_field_name2(self)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        == Constructors.  Constructor using `pdf_new_action_from_link()`.

        |

        *Overload 2:*
        Constructor using `pdf_new_array()`.

        |

        *Overload 3:*
        Constructor using `pdf_new_date()`.

        |

        *Overload 4:*
        Constructor using `pdf_new_dest_from_link()`.

        |

        *Overload 5:*
        Constructor using `pdf_new_indirect()`.

        |

        *Overload 6:*
        Constructor using `pdf_new_int()`.

        |

        *Overload 7:*
        Constructor using `pdf_new_matrix()`.

        |

        *Overload 8:*
        Constructor using `pdf_new_name()`.

        |

        *Overload 9:*
        Constructor using `pdf_new_real()`.

        |

        *Overload 10:*
        Constructor using `pdf_new_rect()`.

        |

        *Overload 11:*
        Constructor using `pdf_new_string()`.

        |

        *Overload 12:*
        Constructor using `pdf_new_xobject()`.

        |

        *Overload 13:*
        Copy constructor using `pdf_keep_obj()`.

        |

        *Overload 14:*
        Constructor using raw copy of pre-existing `::pdf_obj`.

        |

        *Overload 15:*
        Constructor using raw copy of pre-existing `::pdf_obj`.
        """
        _mupdf.PdfObj_swiginit(self, _mupdf.new_PdfObj(*args))
    __swig_destroy__ = _mupdf.delete_PdfObj

    def m_internal_value(self):
        r""" Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.PdfObj_m_internal_value(self)
    m_internal = property(_mupdf.PdfObj_m_internal_get, _mupdf.PdfObj_m_internal_set, doc=r""" Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.PdfObj_s_num_instances_get, _mupdf.PdfObj_s_num_instances_set)

# Register PdfObj in _mupdf:
_mupdf.PdfObj_swigregister(PdfObj)
class PdfOcgDescriptor(object):
    r""" Wrapper class for struct `pdf_ocg_descriptor`. Not copyable or assignable."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::pdf_ocg_descriptor`.
        """
        _mupdf.PdfOcgDescriptor_swiginit(self, _mupdf.new_PdfOcgDescriptor(*args))
    __swig_destroy__ = _mupdf.delete_PdfOcgDescriptor

    def m_internal_value(self):
        r""" Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.PdfOcgDescriptor_m_internal_value(self)
    m_internal = property(_mupdf.PdfOcgDescriptor_m_internal_get, _mupdf.PdfOcgDescriptor_m_internal_set, doc=r""" Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.PdfOcgDescriptor_s_num_instances_get, _mupdf.PdfOcgDescriptor_s_num_instances_set)

# Register PdfOcgDescriptor in _mupdf:
_mupdf.PdfOcgDescriptor_swigregister(PdfOcgDescriptor)
class PdfPage(object):
    r""" Wrapper class for struct `pdf_page`."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def pdf_bound_page(self, box):
        r""" Class-aware wrapper for `::pdf_bound_page()`."""
        return _mupdf.PdfPage_pdf_bound_page(self, box)

    def pdf_create_annot(self, type):
        r""" Class-aware wrapper for `::pdf_create_annot()`."""
        return _mupdf.PdfPage_pdf_create_annot(self, type)

    def pdf_create_annot_raw(self, type):
        r""" Class-aware wrapper for `::pdf_create_annot_raw()`."""
        return _mupdf.PdfPage_pdf_create_annot_raw(self, type)

    def pdf_create_link(self, bbox, uri):
        r""" Class-aware wrapper for `::pdf_create_link()`."""
        return _mupdf.PdfPage_pdf_create_link(self, bbox, uri)

    def pdf_create_signature_widget(self, name):
        r""" Class-aware wrapper for `::pdf_create_signature_widget()`."""
        return _mupdf.PdfPage_pdf_create_signature_widget(self, name)

    def pdf_delete_annot(self, annot):
        r""" Class-aware wrapper for `::pdf_delete_annot()`."""
        return _mupdf.PdfPage_pdf_delete_annot(self, annot)

    def pdf_delete_link(self, link):
        r""" Class-aware wrapper for `::pdf_delete_link()`."""
        return _mupdf.PdfPage_pdf_delete_link(self, link)

    def pdf_first_annot(self):
        r""" Class-aware wrapper for `::pdf_first_annot()`."""
        return _mupdf.PdfPage_pdf_first_annot(self)

    def pdf_first_widget(self):
        r""" Class-aware wrapper for `::pdf_first_widget()`."""
        return _mupdf.PdfPage_pdf_first_widget(self)

    def pdf_load_links(self):
        r""" Class-aware wrapper for `::pdf_load_links()`."""
        return _mupdf.PdfPage_pdf_load_links(self)

    def pdf_new_link(self, rect, uri, obj):
        r""" Class-aware wrapper for `::pdf_new_link()`."""
        return _mupdf.PdfPage_pdf_new_link(self, rect, uri, obj)

    def pdf_new_pixmap_from_page_contents_with_separations_and_usage(self, ctm, cs, seps, alpha, usage, box):
        r""" Class-aware wrapper for `::pdf_new_pixmap_from_page_contents_with_separations_and_usage()`."""
        return _mupdf.PdfPage_pdf_new_pixmap_from_page_contents_with_separations_and_usage(self, ctm, cs, seps, alpha, usage, box)

    def pdf_new_pixmap_from_page_contents_with_usage(self, ctm, cs, alpha, usage, box):
        r""" Class-aware wrapper for `::pdf_new_pixmap_from_page_contents_with_usage()`."""
        return _mupdf.PdfPage_pdf_new_pixmap_from_page_contents_with_usage(self, ctm, cs, alpha, usage, box)

    def pdf_new_pixmap_from_page_with_separations_and_usage(self, ctm, cs, seps, alpha, usage, box):
        r""" Class-aware wrapper for `::pdf_new_pixmap_from_page_with_separations_and_usage()`."""
        return _mupdf.PdfPage_pdf_new_pixmap_from_page_with_separations_and_usage(self, ctm, cs, seps, alpha, usage, box)

    def pdf_new_pixmap_from_page_with_usage(self, ctm, cs, alpha, usage, box):
        r""" Class-aware wrapper for `::pdf_new_pixmap_from_page_with_usage()`."""
        return _mupdf.PdfPage_pdf_new_pixmap_from_page_with_usage(self, ctm, cs, alpha, usage, box)

    def pdf_page_contents(self):
        r""" Class-aware wrapper for `::pdf_page_contents()`."""
        return _mupdf.PdfPage_pdf_page_contents(self)

    def pdf_page_event_close(self):
        r""" Class-aware wrapper for `::pdf_page_event_close()`."""
        return _mupdf.PdfPage_pdf_page_event_close(self)

    def pdf_page_event_open(self):
        r""" Class-aware wrapper for `::pdf_page_event_open()`."""
        return _mupdf.PdfPage_pdf_page_event_open(self)

    def pdf_page_group(self):
        r""" Class-aware wrapper for `::pdf_page_group()`."""
        return _mupdf.PdfPage_pdf_page_group(self)

    def pdf_page_has_transparency(self):
        r""" Class-aware wrapper for `::pdf_page_has_transparency()`."""
        return _mupdf.PdfPage_pdf_page_has_transparency(self)

    def pdf_page_presentation(self, transition, duration):
        r"""
        Class-aware wrapper for `::pdf_page_presentation()`.

        This method has out-params. Python/C# wrappers look like:
        	`pdf_page_presentation(::fz_transition *transition)` => `(fz_transition *, float duration)`
        """
        return _mupdf.PdfPage_pdf_page_presentation(self, transition, duration)

    def pdf_page_resources(self):
        r""" Class-aware wrapper for `::pdf_page_resources()`."""
        return _mupdf.PdfPage_pdf_page_resources(self)

    def pdf_page_separations(self):
        r""" Class-aware wrapper for `::pdf_page_separations()`."""
        return _mupdf.PdfPage_pdf_page_separations(self)

    def pdf_page_transform(self, mediabox, ctm):
        r""" Class-aware wrapper for `::pdf_page_transform()`."""
        return _mupdf.PdfPage_pdf_page_transform(self, mediabox, ctm)

    def pdf_page_transform_box(self, mediabox, ctm, box):
        r""" Class-aware wrapper for `::pdf_page_transform_box()`."""
        return _mupdf.PdfPage_pdf_page_transform_box(self, mediabox, ctm, box)

    def pdf_run_page(self, dev, ctm, cookie):
        r""" Class-aware wrapper for `::pdf_run_page()`."""
        return _mupdf.PdfPage_pdf_run_page(self, dev, ctm, cookie)

    def pdf_run_page_annots(self, dev, ctm, cookie):
        r""" Class-aware wrapper for `::pdf_run_page_annots()`."""
        return _mupdf.PdfPage_pdf_run_page_annots(self, dev, ctm, cookie)

    def pdf_run_page_annots_with_usage(self, dev, ctm, usage, cookie):
        r""" Class-aware wrapper for `::pdf_run_page_annots_with_usage()`."""
        return _mupdf.PdfPage_pdf_run_page_annots_with_usage(self, dev, ctm, usage, cookie)

    def pdf_run_page_contents(self, dev, ctm, cookie):
        r""" Class-aware wrapper for `::pdf_run_page_contents()`."""
        return _mupdf.PdfPage_pdf_run_page_contents(self, dev, ctm, cookie)

    def pdf_run_page_contents_with_usage(self, dev, ctm, usage, cookie):
        r""" Class-aware wrapper for `::pdf_run_page_contents_with_usage()`."""
        return _mupdf.PdfPage_pdf_run_page_contents_with_usage(self, dev, ctm, usage, cookie)

    def pdf_run_page_widgets(self, dev, ctm, cookie):
        r""" Class-aware wrapper for `::pdf_run_page_widgets()`."""
        return _mupdf.PdfPage_pdf_run_page_widgets(self, dev, ctm, cookie)

    def pdf_run_page_widgets_with_usage(self, dev, ctm, usage, cookie):
        r""" Class-aware wrapper for `::pdf_run_page_widgets_with_usage()`."""
        return _mupdf.PdfPage_pdf_run_page_widgets_with_usage(self, dev, ctm, usage, cookie)

    def pdf_run_page_with_usage(self, dev, ctm, usage, cookie):
        r""" Class-aware wrapper for `::pdf_run_page_with_usage()`."""
        return _mupdf.PdfPage_pdf_run_page_with_usage(self, dev, ctm, usage, cookie)

    def pdf_set_page_box(self, box, rect):
        r""" Class-aware wrapper for `::pdf_set_page_box()`."""
        return _mupdf.PdfPage_pdf_set_page_box(self, box, rect)

    def pdf_update_page(self):
        r""" Class-aware wrapper for `::pdf_update_page()`."""
        return _mupdf.PdfPage_pdf_update_page(self)

    def super(self):
        r""" Returns wrapper for .super member."""
        return _mupdf.PdfPage_super(self)

    def doc(self):
        r""" Returns wrapper for .doc member."""
        return _mupdf.PdfPage_doc(self)

    def obj(self):
        r""" Returns wrapper for .obj member."""
        return _mupdf.PdfPage_obj(self)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Copy constructor using `pdf_keep_page()`.

        |

        *Overload 2:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 3:*
        Constructor using raw copy of pre-existing `::pdf_page`.
        """
        _mupdf.PdfPage_swiginit(self, _mupdf.new_PdfPage(*args))
    __swig_destroy__ = _mupdf.delete_PdfPage

    def m_internal_value(self):
        r""" Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.PdfPage_m_internal_value(self)
    m_internal = property(_mupdf.PdfPage_m_internal_get, _mupdf.PdfPage_m_internal_set, doc=r""" Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.PdfPage_s_num_instances_get, _mupdf.PdfPage_s_num_instances_set)

# Register PdfPage in _mupdf:
_mupdf.PdfPage_swigregister(PdfPage)
class PdfPattern(object):
    r""" Wrapper class for struct `pdf_pattern`."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Copy constructor using `pdf_keep_pattern()`.

        |

        *Overload 2:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 3:*
        Constructor using raw copy of pre-existing `::pdf_pattern`.
        """
        _mupdf.PdfPattern_swiginit(self, _mupdf.new_PdfPattern(*args))
    __swig_destroy__ = _mupdf.delete_PdfPattern

    def m_internal_value(self):
        r""" Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.PdfPattern_m_internal_value(self)
    m_internal = property(_mupdf.PdfPattern_m_internal_get, _mupdf.PdfPattern_m_internal_set, doc=r""" Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.PdfPattern_s_num_instances_get, _mupdf.PdfPattern_s_num_instances_set)

# Register PdfPattern in _mupdf:
_mupdf.PdfPattern_swigregister(PdfPattern)
class PdfPkcs7DistinguishedName(object):
    r""" Wrapper class for struct `pdf_pkcs7_distinguished_name`. Not copyable or assignable."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def pdf_signature_drop_distinguished_name(self):
        r""" Class-aware wrapper for `::pdf_signature_drop_distinguished_name()`."""
        return _mupdf.PdfPkcs7DistinguishedName_pdf_signature_drop_distinguished_name(self)

    def pdf_signature_format_distinguished_name(self):
        r""" Class-aware wrapper for `::pdf_signature_format_distinguished_name()`."""
        return _mupdf.PdfPkcs7DistinguishedName_pdf_signature_format_distinguished_name(self)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::pdf_pkcs7_distinguished_name`.
        """
        _mupdf.PdfPkcs7DistinguishedName_swiginit(self, _mupdf.new_PdfPkcs7DistinguishedName(*args))
    __swig_destroy__ = _mupdf.delete_PdfPkcs7DistinguishedName

    def m_internal_value(self):
        r""" Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.PdfPkcs7DistinguishedName_m_internal_value(self)
    m_internal = property(_mupdf.PdfPkcs7DistinguishedName_m_internal_get, _mupdf.PdfPkcs7DistinguishedName_m_internal_set, doc=r""" Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.PdfPkcs7DistinguishedName_s_num_instances_get, _mupdf.PdfPkcs7DistinguishedName_s_num_instances_set)

# Register PdfPkcs7DistinguishedName in _mupdf:
_mupdf.PdfPkcs7DistinguishedName_swigregister(PdfPkcs7DistinguishedName)
class PdfPkcs7Signer(object):
    r""" Wrapper class for struct `pdf_pkcs7_signer`. Not copyable or assignable."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::pdf_pkcs7_signer`.
        """
        _mupdf.PdfPkcs7Signer_swiginit(self, _mupdf.new_PdfPkcs7Signer(*args))
    __swig_destroy__ = _mupdf.delete_PdfPkcs7Signer

    def m_internal_value(self):
        r""" Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.PdfPkcs7Signer_m_internal_value(self)
    m_internal = property(_mupdf.PdfPkcs7Signer_m_internal_get, _mupdf.PdfPkcs7Signer_m_internal_set, doc=r""" Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.PdfPkcs7Signer_s_num_instances_get, _mupdf.PdfPkcs7Signer_s_num_instances_set)

# Register PdfPkcs7Signer in _mupdf:
_mupdf.PdfPkcs7Signer_swigregister(PdfPkcs7Signer)
class PdfPkcs7Verifier(object):
    r""" Wrapper class for struct `pdf_pkcs7_verifier`. Not copyable or assignable."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::pdf_pkcs7_verifier`.
        """
        _mupdf.PdfPkcs7Verifier_swiginit(self, _mupdf.new_PdfPkcs7Verifier(*args))
    __swig_destroy__ = _mupdf.delete_PdfPkcs7Verifier

    def m_internal_value(self):
        r""" Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.PdfPkcs7Verifier_m_internal_value(self)
    m_internal = property(_mupdf.PdfPkcs7Verifier_m_internal_get, _mupdf.PdfPkcs7Verifier_m_internal_set, doc=r""" Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.PdfPkcs7Verifier_s_num_instances_get, _mupdf.PdfPkcs7Verifier_s_num_instances_set)

# Register PdfPkcs7Verifier in _mupdf:
_mupdf.PdfPkcs7Verifier_swigregister(PdfPkcs7Verifier)
class PdfProcessor(object):
    r""" Wrapper class for struct `pdf_processor`."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def pdf_new_color_filter(doc, chain, struct_parents, transform, options, copts):
        r""" Class-aware wrapper for `::pdf_new_color_filter()`."""
        return _mupdf.PdfProcessor_pdf_new_color_filter(doc, chain, struct_parents, transform, options, copts)

    def pdf_close_processor(self):
        r""" Class-aware wrapper for `::pdf_close_processor()`."""
        return _mupdf.PdfProcessor_pdf_close_processor(self)

    def pdf_process_annot(self, annot, cookie):
        r""" Class-aware wrapper for `::pdf_process_annot()`."""
        return _mupdf.PdfProcessor_pdf_process_annot(self, annot, cookie)

    def pdf_process_contents(self, doc, res, stm, cookie, out_res):
        r"""
        Class-aware wrapper for `::pdf_process_contents()`.

        This method has out-params. Python/C# wrappers look like:
        	`pdf_process_contents(::pdf_document *doc, ::pdf_obj *res, ::pdf_obj *stm, ::fz_cookie *cookie, ::pdf_obj **out_res)` =>
        """
        return _mupdf.PdfProcessor_pdf_process_contents(self, doc, res, stm, cookie, out_res)

    def pdf_process_glyph(self, doc, resources, contents):
        r""" Class-aware wrapper for `::pdf_process_glyph()`."""
        return _mupdf.PdfProcessor_pdf_process_glyph(self, doc, resources, contents)

    def pdf_process_raw_contents(self, doc, rdb, stmobj, cookie):
        r""" Class-aware wrapper for `::pdf_process_raw_contents()`."""
        return _mupdf.PdfProcessor_pdf_process_raw_contents(self, doc, rdb, stmobj, cookie)

    def pdf_processor_pop_resources(self):
        r""" Class-aware wrapper for `::pdf_processor_pop_resources()`."""
        return _mupdf.PdfProcessor_pdf_processor_pop_resources(self)

    def pdf_processor_push_resources(self, res):
        r""" Class-aware wrapper for `::pdf_processor_push_resources()`."""
        return _mupdf.PdfProcessor_pdf_processor_push_resources(self, res)

    def pdf_reset_processor(self):
        r""" Class-aware wrapper for `::pdf_reset_processor()`."""
        return _mupdf.PdfProcessor_pdf_reset_processor(self)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        == Constructors.  Constructor using `pdf_new_buffer_processor()`.

        |

        *Overload 2:*
        Constructor using `pdf_new_output_processor()`.

        |

        *Overload 3:*
        Constructor using `pdf_new_run_processor()`.

        |

        *Overload 4:*
        Constructor using `pdf_new_sanitize_filter()`.

        |

        *Overload 5:*
        Copy constructor using `pdf_keep_processor()`.

        |

        *Overload 6:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 7:*
        Constructor using raw copy of pre-existing `::pdf_processor`.
        """
        _mupdf.PdfProcessor_swiginit(self, _mupdf.new_PdfProcessor(*args))
    __swig_destroy__ = _mupdf.delete_PdfProcessor

    def m_internal_value(self):
        r""" Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.PdfProcessor_m_internal_value(self)
    m_internal = property(_mupdf.PdfProcessor_m_internal_get, _mupdf.PdfProcessor_m_internal_set, doc=r""" Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.PdfProcessor_s_num_instances_get, _mupdf.PdfProcessor_s_num_instances_set)

# Register PdfProcessor in _mupdf:
_mupdf.PdfProcessor_swigregister(PdfProcessor)
class PdfProcessor2(PdfProcessor):
    r""" Wrapper class for struct pdf_processor with virtual fns for each fnptr; this is for use as a SWIG Director class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r""" == Constructor."""
        if self.__class__ == PdfProcessor2:
            _self = None
        else:
            _self = self
        _mupdf.PdfProcessor2_swiginit(self, _mupdf.new_PdfProcessor2(_self, ))

    def use_virtual_close_processor(self, use=True):
        r"""
        These methods set the function pointers in *m_internal
        to point to internal callbacks that call our virtual methods.
        """
        return _mupdf.PdfProcessor2_use_virtual_close_processor(self, use)

    def use_virtual_drop_processor(self, use=True):
        return _mupdf.PdfProcessor2_use_virtual_drop_processor(self, use)

    def use_virtual_reset_processor(self, use=True):
        return _mupdf.PdfProcessor2_use_virtual_reset_processor(self, use)

    def use_virtual_push_resources(self, use=True):
        return _mupdf.PdfProcessor2_use_virtual_push_resources(self, use)

    def use_virtual_pop_resources(self, use=True):
        return _mupdf.PdfProcessor2_use_virtual_pop_resources(self, use)

    def use_virtual_op_w(self, use=True):
        return _mupdf.PdfProcessor2_use_virtual_op_w(self, use)

    def use_virtual_op_j(self, use=True):
        return _mupdf.PdfProcessor2_use_virtual_op_j(self, use)

    def use_virtual_op_J(self, use=True):
        return _mupdf.PdfProcessor2_use_virtual_op_J(self, use)

    def use_virtual_op_M(self, use=True):
        return _mupdf.PdfProcessor2_use_virtual_op_M(self, use)

    def use_virtual_op_d(self, use=True):
        return _mupdf.PdfProcessor2_use_virtual_op_d(self, use)

    def use_virtual_op_ri(self, use=True):
        return _mupdf.PdfProcessor2_use_virtual_op_ri(self, use)

    def use_virtual_op_i(self, use=True):
        return _mupdf.PdfProcessor2_use_virtual_op_i(self, use)

    def use_virtual_op_gs_begin(self, use=True):
        return _mupdf.PdfProcessor2_use_virtual_op_gs_begin(self, use)

    def use_virtual_op_gs_BM(self, use=True):
        return _mupdf.PdfProcessor2_use_virtual_op_gs_BM(self, use)

    def use_virtual_op_gs_ca(self, use=True):
        return _mupdf.PdfProcessor2_use_virtual_op_gs_ca(self, use)

    def use_virtual_op_gs_CA(self, use=True):
        return _mupdf.PdfProcessor2_use_virtual_op_gs_CA(self, use)

    def use_virtual_op_gs_SMask(self, use=True):
        return _mupdf.PdfProcessor2_use_virtual_op_gs_SMask(self, use)

    def use_virtual_op_gs_end(self, use=True):
        return _mupdf.PdfProcessor2_use_virtual_op_gs_end(self, use)

    def use_virtual_op_q(self, use=True):
        return _mupdf.PdfProcessor2_use_virtual_op_q(self, use)

    def use_virtual_op_Q(self, use=True):
        return _mupdf.PdfProcessor2_use_virtual_op_Q(self, use)

    def use_virtual_op_cm(self, use=True):
        return _mupdf.PdfProcessor2_use_virtual_op_cm(self, use)

    def use_virtual_op_m(self, use=True):
        return _mupdf.PdfProcessor2_use_virtual_op_m(self, use)

    def use_virtual_op_l(self, use=True):
        return _mupdf.PdfProcessor2_use_virtual_op_l(self, use)

    def use_virtual_op_c(self, use=True):
        return _mupdf.PdfProcessor2_use_virtual_op_c(self, use)

    def use_virtual_op_v(self, use=True):
        return _mupdf.PdfProcessor2_use_virtual_op_v(self, use)

    def use_virtual_op_y(self, use=True):
        return _mupdf.PdfProcessor2_use_virtual_op_y(self, use)

    def use_virtual_op_h(self, use=True):
        return _mupdf.PdfProcessor2_use_virtual_op_h(self, use)

    def use_virtual_op_re(self, use=True):
        return _mupdf.PdfProcessor2_use_virtual_op_re(self, use)

    def use_virtual_op_S(self, use=True):
        return _mupdf.PdfProcessor2_use_virtual_op_S(self, use)

    def use_virtual_op_s(self, use=True):
        return _mupdf.PdfProcessor2_use_virtual_op_s(self, use)

    def use_virtual_op_F(self, use=True):
        return _mupdf.PdfProcessor2_use_virtual_op_F(self, use)

    def use_virtual_op_f(self, use=True):
        return _mupdf.PdfProcessor2_use_virtual_op_f(self, use)

    def use_virtual_op_fstar(self, use=True):
        return _mupdf.PdfProcessor2_use_virtual_op_fstar(self, use)

    def use_virtual_op_B(self, use=True):
        return _mupdf.PdfProcessor2_use_virtual_op_B(self, use)

    def use_virtual_op_Bstar(self, use=True):
        return _mupdf.PdfProcessor2_use_virtual_op_Bstar(self, use)

    def use_virtual_op_b(self, use=True):
        return _mupdf.PdfProcessor2_use_virtual_op_b(self, use)

    def use_virtual_op_bstar(self, use=True):
        return _mupdf.PdfProcessor2_use_virtual_op_bstar(self, use)

    def use_virtual_op_n(self, use=True):
        return _mupdf.PdfProcessor2_use_virtual_op_n(self, use)

    def use_virtual_op_W(self, use=True):
        return _mupdf.PdfProcessor2_use_virtual_op_W(self, use)

    def use_virtual_op_Wstar(self, use=True):
        return _mupdf.PdfProcessor2_use_virtual_op_Wstar(self, use)

    def use_virtual_op_BT(self, use=True):
        return _mupdf.PdfProcessor2_use_virtual_op_BT(self, use)

    def use_virtual_op_ET(self, use=True):
        return _mupdf.PdfProcessor2_use_virtual_op_ET(self, use)

    def use_virtual_op_Tc(self, use=True):
        return _mupdf.PdfProcessor2_use_virtual_op_Tc(self, use)

    def use_virtual_op_Tw(self, use=True):
        return _mupdf.PdfProcessor2_use_virtual_op_Tw(self, use)

    def use_virtual_op_Tz(self, use=True):
        return _mupdf.PdfProcessor2_use_virtual_op_Tz(self, use)

    def use_virtual_op_TL(self, use=True):
        return _mupdf.PdfProcessor2_use_virtual_op_TL(self, use)

    def use_virtual_op_Tf(self, use=True):
        return _mupdf.PdfProcessor2_use_virtual_op_Tf(self, use)

    def use_virtual_op_Tr(self, use=True):
        return _mupdf.PdfProcessor2_use_virtual_op_Tr(self, use)

    def use_virtual_op_Ts(self, use=True):
        return _mupdf.PdfProcessor2_use_virtual_op_Ts(self, use)

    def use_virtual_op_Td(self, use=True):
        return _mupdf.PdfProcessor2_use_virtual_op_Td(self, use)

    def use_virtual_op_TD(self, use=True):
        return _mupdf.PdfProcessor2_use_virtual_op_TD(self, use)

    def use_virtual_op_Tm(self, use=True):
        return _mupdf.PdfProcessor2_use_virtual_op_Tm(self, use)

    def use_virtual_op_Tstar(self, use=True):
        return _mupdf.PdfProcessor2_use_virtual_op_Tstar(self, use)

    def use_virtual_op_TJ(self, use=True):
        return _mupdf.PdfProcessor2_use_virtual_op_TJ(self, use)

    def use_virtual_op_Tj(self, use=True):
        return _mupdf.PdfProcessor2_use_virtual_op_Tj(self, use)

    def use_virtual_op_squote(self, use=True):
        return _mupdf.PdfProcessor2_use_virtual_op_squote(self, use)

    def use_virtual_op_dquote(self, use=True):
        return _mupdf.PdfProcessor2_use_virtual_op_dquote(self, use)

    def use_virtual_op_d0(self, use=True):
        return _mupdf.PdfProcessor2_use_virtual_op_d0(self, use)

    def use_virtual_op_d1(self, use=True):
        return _mupdf.PdfProcessor2_use_virtual_op_d1(self, use)

    def use_virtual_op_CS(self, use=True):
        return _mupdf.PdfProcessor2_use_virtual_op_CS(self, use)

    def use_virtual_op_cs(self, use=True):
        return _mupdf.PdfProcessor2_use_virtual_op_cs(self, use)

    def use_virtual_op_SC_pattern(self, use=True):
        return _mupdf.PdfProcessor2_use_virtual_op_SC_pattern(self, use)

    def use_virtual_op_sc_pattern(self, use=True):
        return _mupdf.PdfProcessor2_use_virtual_op_sc_pattern(self, use)

    def use_virtual_op_SC_shade(self, use=True):
        return _mupdf.PdfProcessor2_use_virtual_op_SC_shade(self, use)

    def use_virtual_op_sc_shade(self, use=True):
        return _mupdf.PdfProcessor2_use_virtual_op_sc_shade(self, use)

    def use_virtual_op_SC_color(self, use=True):
        return _mupdf.PdfProcessor2_use_virtual_op_SC_color(self, use)

    def use_virtual_op_sc_color(self, use=True):
        return _mupdf.PdfProcessor2_use_virtual_op_sc_color(self, use)

    def use_virtual_op_G(self, use=True):
        return _mupdf.PdfProcessor2_use_virtual_op_G(self, use)

    def use_virtual_op_g(self, use=True):
        return _mupdf.PdfProcessor2_use_virtual_op_g(self, use)

    def use_virtual_op_RG(self, use=True):
        return _mupdf.PdfProcessor2_use_virtual_op_RG(self, use)

    def use_virtual_op_rg(self, use=True):
        return _mupdf.PdfProcessor2_use_virtual_op_rg(self, use)

    def use_virtual_op_K(self, use=True):
        return _mupdf.PdfProcessor2_use_virtual_op_K(self, use)

    def use_virtual_op_k(self, use=True):
        return _mupdf.PdfProcessor2_use_virtual_op_k(self, use)

    def use_virtual_op_BI(self, use=True):
        return _mupdf.PdfProcessor2_use_virtual_op_BI(self, use)

    def use_virtual_op_sh(self, use=True):
        return _mupdf.PdfProcessor2_use_virtual_op_sh(self, use)

    def use_virtual_op_Do_image(self, use=True):
        return _mupdf.PdfProcessor2_use_virtual_op_Do_image(self, use)

    def use_virtual_op_Do_form(self, use=True):
        return _mupdf.PdfProcessor2_use_virtual_op_Do_form(self, use)

    def use_virtual_op_MP(self, use=True):
        return _mupdf.PdfProcessor2_use_virtual_op_MP(self, use)

    def use_virtual_op_DP(self, use=True):
        return _mupdf.PdfProcessor2_use_virtual_op_DP(self, use)

    def use_virtual_op_BMC(self, use=True):
        return _mupdf.PdfProcessor2_use_virtual_op_BMC(self, use)

    def use_virtual_op_BDC(self, use=True):
        return _mupdf.PdfProcessor2_use_virtual_op_BDC(self, use)

    def use_virtual_op_EMC(self, use=True):
        return _mupdf.PdfProcessor2_use_virtual_op_EMC(self, use)

    def use_virtual_op_BX(self, use=True):
        return _mupdf.PdfProcessor2_use_virtual_op_BX(self, use)

    def use_virtual_op_EX(self, use=True):
        return _mupdf.PdfProcessor2_use_virtual_op_EX(self, use)

    def use_virtual_op_gs_OP(self, use=True):
        return _mupdf.PdfProcessor2_use_virtual_op_gs_OP(self, use)

    def use_virtual_op_gs_op(self, use=True):
        return _mupdf.PdfProcessor2_use_virtual_op_gs_op(self, use)

    def use_virtual_op_gs_OPM(self, use=True):
        return _mupdf.PdfProcessor2_use_virtual_op_gs_OPM(self, use)

    def use_virtual_op_gs_UseBlackPtComp(self, use=True):
        return _mupdf.PdfProcessor2_use_virtual_op_gs_UseBlackPtComp(self, use)

    def use_virtual_op_END(self, use=True):
        return _mupdf.PdfProcessor2_use_virtual_op_END(self, use)

    def close_processor(self, arg_0):
        r""" Default virtual method implementations; these all throw an exception."""
        return _mupdf.PdfProcessor2_close_processor(self, arg_0)

    def drop_processor(self, arg_0):
        return _mupdf.PdfProcessor2_drop_processor(self, arg_0)

    def reset_processor(self, arg_0):
        return _mupdf.PdfProcessor2_reset_processor(self, arg_0)

    def push_resources(self, arg_0, arg_2):
        return _mupdf.PdfProcessor2_push_resources(self, arg_0, arg_2)

    def pop_resources(self, arg_0):
        return _mupdf.PdfProcessor2_pop_resources(self, arg_0)

    def op_w(self, arg_0, arg_2):
        return _mupdf.PdfProcessor2_op_w(self, arg_0, arg_2)

    def op_j(self, arg_0, arg_2):
        return _mupdf.PdfProcessor2_op_j(self, arg_0, arg_2)

    def op_J(self, arg_0, arg_2):
        return _mupdf.PdfProcessor2_op_J(self, arg_0, arg_2)

    def op_M(self, arg_0, arg_2):
        return _mupdf.PdfProcessor2_op_M(self, arg_0, arg_2)

    def op_d(self, arg_0, arg_2, arg_3):
        return _mupdf.PdfProcessor2_op_d(self, arg_0, arg_2, arg_3)

    def op_ri(self, arg_0, arg_2):
        return _mupdf.PdfProcessor2_op_ri(self, arg_0, arg_2)

    def op_i(self, arg_0, arg_2):
        return _mupdf.PdfProcessor2_op_i(self, arg_0, arg_2)

    def op_gs_begin(self, arg_0, arg_2, arg_3):
        return _mupdf.PdfProcessor2_op_gs_begin(self, arg_0, arg_2, arg_3)

    def op_gs_BM(self, arg_0, arg_2):
        return _mupdf.PdfProcessor2_op_gs_BM(self, arg_0, arg_2)

    def op_gs_ca(self, arg_0, arg_2):
        return _mupdf.PdfProcessor2_op_gs_ca(self, arg_0, arg_2)

    def op_gs_CA(self, arg_0, arg_2):
        return _mupdf.PdfProcessor2_op_gs_CA(self, arg_0, arg_2)

    def op_gs_SMask(self, arg_0, arg_2, arg_3, arg_4, arg_5):
        return _mupdf.PdfProcessor2_op_gs_SMask(self, arg_0, arg_2, arg_3, arg_4, arg_5)

    def op_gs_end(self, arg_0):
        return _mupdf.PdfProcessor2_op_gs_end(self, arg_0)

    def op_q(self, arg_0):
        return _mupdf.PdfProcessor2_op_q(self, arg_0)

    def op_Q(self, arg_0):
        return _mupdf.PdfProcessor2_op_Q(self, arg_0)

    def op_cm(self, arg_0, arg_2, arg_3, arg_4, arg_5, arg_6, arg_7):
        return _mupdf.PdfProcessor2_op_cm(self, arg_0, arg_2, arg_3, arg_4, arg_5, arg_6, arg_7)

    def op_m(self, arg_0, arg_2, arg_3):
        return _mupdf.PdfProcessor2_op_m(self, arg_0, arg_2, arg_3)

    def op_l(self, arg_0, arg_2, arg_3):
        return _mupdf.PdfProcessor2_op_l(self, arg_0, arg_2, arg_3)

    def op_c(self, arg_0, arg_2, arg_3, arg_4, arg_5, arg_6, arg_7):
        return _mupdf.PdfProcessor2_op_c(self, arg_0, arg_2, arg_3, arg_4, arg_5, arg_6, arg_7)

    def op_v(self, arg_0, arg_2, arg_3, arg_4, arg_5):
        return _mupdf.PdfProcessor2_op_v(self, arg_0, arg_2, arg_3, arg_4, arg_5)

    def op_y(self, arg_0, arg_2, arg_3, arg_4, arg_5):
        return _mupdf.PdfProcessor2_op_y(self, arg_0, arg_2, arg_3, arg_4, arg_5)

    def op_h(self, arg_0):
        return _mupdf.PdfProcessor2_op_h(self, arg_0)

    def op_re(self, arg_0, arg_2, arg_3, arg_4, arg_5):
        return _mupdf.PdfProcessor2_op_re(self, arg_0, arg_2, arg_3, arg_4, arg_5)

    def op_S(self, arg_0):
        return _mupdf.PdfProcessor2_op_S(self, arg_0)

    def op_s(self, arg_0):
        return _mupdf.PdfProcessor2_op_s(self, arg_0)

    def op_F(self, arg_0):
        return _mupdf.PdfProcessor2_op_F(self, arg_0)

    def op_f(self, arg_0):
        return _mupdf.PdfProcessor2_op_f(self, arg_0)

    def op_fstar(self, arg_0):
        return _mupdf.PdfProcessor2_op_fstar(self, arg_0)

    def op_B(self, arg_0):
        return _mupdf.PdfProcessor2_op_B(self, arg_0)

    def op_Bstar(self, arg_0):
        return _mupdf.PdfProcessor2_op_Bstar(self, arg_0)

    def op_b(self, arg_0):
        return _mupdf.PdfProcessor2_op_b(self, arg_0)

    def op_bstar(self, arg_0):
        return _mupdf.PdfProcessor2_op_bstar(self, arg_0)

    def op_n(self, arg_0):
        return _mupdf.PdfProcessor2_op_n(self, arg_0)

    def op_W(self, arg_0):
        return _mupdf.PdfProcessor2_op_W(self, arg_0)

    def op_Wstar(self, arg_0):
        return _mupdf.PdfProcessor2_op_Wstar(self, arg_0)

    def op_BT(self, arg_0):
        return _mupdf.PdfProcessor2_op_BT(self, arg_0)

    def op_ET(self, arg_0):
        return _mupdf.PdfProcessor2_op_ET(self, arg_0)

    def op_Tc(self, arg_0, arg_2):
        return _mupdf.PdfProcessor2_op_Tc(self, arg_0, arg_2)

    def op_Tw(self, arg_0, arg_2):
        return _mupdf.PdfProcessor2_op_Tw(self, arg_0, arg_2)

    def op_Tz(self, arg_0, arg_2):
        return _mupdf.PdfProcessor2_op_Tz(self, arg_0, arg_2)

    def op_TL(self, arg_0, arg_2):
        return _mupdf.PdfProcessor2_op_TL(self, arg_0, arg_2)

    def op_Tf(self, arg_0, arg_2, arg_3, arg_4):
        return _mupdf.PdfProcessor2_op_Tf(self, arg_0, arg_2, arg_3, arg_4)

    def op_Tr(self, arg_0, arg_2):
        return _mupdf.PdfProcessor2_op_Tr(self, arg_0, arg_2)

    def op_Ts(self, arg_0, arg_2):
        return _mupdf.PdfProcessor2_op_Ts(self, arg_0, arg_2)

    def op_Td(self, arg_0, arg_2, arg_3):
        return _mupdf.PdfProcessor2_op_Td(self, arg_0, arg_2, arg_3)

    def op_TD(self, arg_0, arg_2, arg_3):
        return _mupdf.PdfProcessor2_op_TD(self, arg_0, arg_2, arg_3)

    def op_Tm(self, arg_0, arg_2, arg_3, arg_4, arg_5, arg_6, arg_7):
        return _mupdf.PdfProcessor2_op_Tm(self, arg_0, arg_2, arg_3, arg_4, arg_5, arg_6, arg_7)

    def op_Tstar(self, arg_0):
        return _mupdf.PdfProcessor2_op_Tstar(self, arg_0)

    def op_TJ(self, arg_0, arg_2):
        return _mupdf.PdfProcessor2_op_TJ(self, arg_0, arg_2)

    def op_Tj(self, arg_0, arg_2, arg_3):
        return _mupdf.PdfProcessor2_op_Tj(self, arg_0, arg_2, arg_3)

    def op_squote(self, arg_0, arg_2, arg_3):
        return _mupdf.PdfProcessor2_op_squote(self, arg_0, arg_2, arg_3)

    def op_dquote(self, arg_0, arg_2, arg_3, arg_4, arg_5):
        return _mupdf.PdfProcessor2_op_dquote(self, arg_0, arg_2, arg_3, arg_4, arg_5)

    def op_d0(self, arg_0, arg_2, arg_3):
        return _mupdf.PdfProcessor2_op_d0(self, arg_0, arg_2, arg_3)

    def op_d1(self, arg_0, arg_2, arg_3, arg_4, arg_5, arg_6, arg_7):
        return _mupdf.PdfProcessor2_op_d1(self, arg_0, arg_2, arg_3, arg_4, arg_5, arg_6, arg_7)

    def op_CS(self, arg_0, arg_2, arg_3):
        return _mupdf.PdfProcessor2_op_CS(self, arg_0, arg_2, arg_3)

    def op_cs(self, arg_0, arg_2, arg_3):
        return _mupdf.PdfProcessor2_op_cs(self, arg_0, arg_2, arg_3)

    def op_SC_pattern(self, arg_0, arg_2, arg_3, arg_4, arg_5):
        return _mupdf.PdfProcessor2_op_SC_pattern(self, arg_0, arg_2, arg_3, arg_4, arg_5)

    def op_sc_pattern(self, arg_0, arg_2, arg_3, arg_4, arg_5):
        return _mupdf.PdfProcessor2_op_sc_pattern(self, arg_0, arg_2, arg_3, arg_4, arg_5)

    def op_SC_shade(self, arg_0, arg_2, arg_3):
        return _mupdf.PdfProcessor2_op_SC_shade(self, arg_0, arg_2, arg_3)

    def op_sc_shade(self, arg_0, arg_2, arg_3):
        return _mupdf.PdfProcessor2_op_sc_shade(self, arg_0, arg_2, arg_3)

    def op_SC_color(self, arg_0, arg_2, arg_3):
        return _mupdf.PdfProcessor2_op_SC_color(self, arg_0, arg_2, arg_3)

    def op_sc_color(self, arg_0, arg_2, arg_3):
        return _mupdf.PdfProcessor2_op_sc_color(self, arg_0, arg_2, arg_3)

    def op_G(self, arg_0, arg_2):
        return _mupdf.PdfProcessor2_op_G(self, arg_0, arg_2)

    def op_g(self, arg_0, arg_2):
        return _mupdf.PdfProcessor2_op_g(self, arg_0, arg_2)

    def op_RG(self, arg_0, arg_2, arg_3, arg_4):
        return _mupdf.PdfProcessor2_op_RG(self, arg_0, arg_2, arg_3, arg_4)

    def op_rg(self, arg_0, arg_2, arg_3, arg_4):
        return _mupdf.PdfProcessor2_op_rg(self, arg_0, arg_2, arg_3, arg_4)

    def op_K(self, arg_0, arg_2, arg_3, arg_4, arg_5):
        return _mupdf.PdfProcessor2_op_K(self, arg_0, arg_2, arg_3, arg_4, arg_5)

    def op_k(self, arg_0, arg_2, arg_3, arg_4, arg_5):
        return _mupdf.PdfProcessor2_op_k(self, arg_0, arg_2, arg_3, arg_4, arg_5)

    def op_BI(self, arg_0, arg_2, arg_3):
        return _mupdf.PdfProcessor2_op_BI(self, arg_0, arg_2, arg_3)

    def op_sh(self, arg_0, arg_2, arg_3):
        return _mupdf.PdfProcessor2_op_sh(self, arg_0, arg_2, arg_3)

    def op_Do_image(self, arg_0, arg_2, arg_3):
        return _mupdf.PdfProcessor2_op_Do_image(self, arg_0, arg_2, arg_3)

    def op_Do_form(self, arg_0, arg_2, arg_3):
        return _mupdf.PdfProcessor2_op_Do_form(self, arg_0, arg_2, arg_3)

    def op_MP(self, arg_0, arg_2):
        return _mupdf.PdfProcessor2_op_MP(self, arg_0, arg_2)

    def op_DP(self, arg_0, arg_2, arg_3, arg_4):
        return _mupdf.PdfProcessor2_op_DP(self, arg_0, arg_2, arg_3, arg_4)

    def op_BMC(self, arg_0, arg_2):
        return _mupdf.PdfProcessor2_op_BMC(self, arg_0, arg_2)

    def op_BDC(self, arg_0, arg_2, arg_3, arg_4):
        return _mupdf.PdfProcessor2_op_BDC(self, arg_0, arg_2, arg_3, arg_4)

    def op_EMC(self, arg_0):
        return _mupdf.PdfProcessor2_op_EMC(self, arg_0)

    def op_BX(self, arg_0):
        return _mupdf.PdfProcessor2_op_BX(self, arg_0)

    def op_EX(self, arg_0):
        return _mupdf.PdfProcessor2_op_EX(self, arg_0)

    def op_gs_OP(self, arg_0, arg_2):
        return _mupdf.PdfProcessor2_op_gs_OP(self, arg_0, arg_2)

    def op_gs_op(self, arg_0, arg_2):
        return _mupdf.PdfProcessor2_op_gs_op(self, arg_0, arg_2)

    def op_gs_OPM(self, arg_0, arg_2):
        return _mupdf.PdfProcessor2_op_gs_OPM(self, arg_0, arg_2)

    def op_gs_UseBlackPtComp(self, arg_0, arg_2):
        return _mupdf.PdfProcessor2_op_gs_UseBlackPtComp(self, arg_0, arg_2)

    def op_END(self, arg_0):
        return _mupdf.PdfProcessor2_op_END(self, arg_0)
    __swig_destroy__ = _mupdf.delete_PdfProcessor2
    def __disown__(self):
        self.this.disown()
        _mupdf.disown_PdfProcessor2(self)
        return weakref.proxy(self)

# Register PdfProcessor2 in _mupdf:
_mupdf.PdfProcessor2_swigregister(PdfProcessor2)
class PdfRange(object):
    r""" Wrapper class for struct `pdf_range`. Not copyable or assignable."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::pdf_range`.
        """
        _mupdf.PdfRange_swiginit(self, _mupdf.new_PdfRange(*args))
    __swig_destroy__ = _mupdf.delete_PdfRange

    def m_internal_value(self):
        r""" Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.PdfRange_m_internal_value(self)
    m_internal = property(_mupdf.PdfRange_m_internal_get, _mupdf.PdfRange_m_internal_set, doc=r""" Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.PdfRange_s_num_instances_get, _mupdf.PdfRange_s_num_instances_set)

# Register PdfRange in _mupdf:
_mupdf.PdfRange_swigregister(PdfRange)
class PdfRedactOptions(object):
    r""" Wrapper class for struct `pdf_redact_options`."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        We use default copy constructor and operator=.  Default constructor, sets each member to default value.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::pdf_redact_options`.

        |

        *Overload 3:*
        Constructor using raw copy of pre-existing `::pdf_redact_options`.
        """
        _mupdf.PdfRedactOptions_swiginit(self, _mupdf.new_PdfRedactOptions(*args))

    def internal(self, *args):
        r"""
        *Overload 1:*
        Access as underlying struct.

        |

        *Overload 2:*
        Access as underlying struct.
        """
        return _mupdf.PdfRedactOptions_internal(self, *args)
    __swig_destroy__ = _mupdf.delete_PdfRedactOptions
    black_boxes = property(_mupdf.PdfRedactOptions_black_boxes_get, _mupdf.PdfRedactOptions_black_boxes_set)
    image_method = property(_mupdf.PdfRedactOptions_image_method_get, _mupdf.PdfRedactOptions_image_method_set)
    line_art = property(_mupdf.PdfRedactOptions_line_art_get, _mupdf.PdfRedactOptions_line_art_set)
    text = property(_mupdf.PdfRedactOptions_text_get, _mupdf.PdfRedactOptions_text_set)
    s_num_instances = property(_mupdf.PdfRedactOptions_s_num_instances_get, _mupdf.PdfRedactOptions_s_num_instances_set)

    def to_string(self):
        r""" Returns string containing our members, labelled and inside (...), using operator<<."""
        return _mupdf.PdfRedactOptions_to_string(self)

    def __eq__(self, rhs):
        r""" Comparison method."""
        return _mupdf.PdfRedactOptions___eq__(self, rhs)

    def __ne__(self, rhs):
        r""" Comparison method."""
        return _mupdf.PdfRedactOptions___ne__(self, rhs)

# Register PdfRedactOptions in _mupdf:
_mupdf.PdfRedactOptions_swigregister(PdfRedactOptions)
class PdfRevPageMap(object):
    r""" Wrapper class for struct `pdf_rev_page_map`. Not copyable or assignable."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::pdf_rev_page_map`.
        """
        _mupdf.PdfRevPageMap_swiginit(self, _mupdf.new_PdfRevPageMap(*args))
    __swig_destroy__ = _mupdf.delete_PdfRevPageMap

    def m_internal_value(self):
        r""" Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.PdfRevPageMap_m_internal_value(self)
    m_internal = property(_mupdf.PdfRevPageMap_m_internal_get, _mupdf.PdfRevPageMap_m_internal_set, doc=r""" Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.PdfRevPageMap_s_num_instances_get, _mupdf.PdfRevPageMap_s_num_instances_set)

# Register PdfRevPageMap in _mupdf:
_mupdf.PdfRevPageMap_swigregister(PdfRevPageMap)
class PdfSanitizeFilterOptions(object):
    r""" Wrapper class for struct `pdf_sanitize_filter_options`."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        We use default copy constructor and operator=.  Default constructor, sets each member to default value.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::pdf_sanitize_filter_options`.

        |

        *Overload 3:*
        Constructor using raw copy of pre-existing `::pdf_sanitize_filter_options`.
        """
        _mupdf.PdfSanitizeFilterOptions_swiginit(self, _mupdf.new_PdfSanitizeFilterOptions(*args))

    def internal(self, *args):
        r"""
        *Overload 1:*
        Access as underlying struct.

        |

        *Overload 2:*
        Access as underlying struct.
        """
        return _mupdf.PdfSanitizeFilterOptions_internal(self, *args)
    __swig_destroy__ = _mupdf.delete_PdfSanitizeFilterOptions
    opaque = property(_mupdf.PdfSanitizeFilterOptions_opaque_get, _mupdf.PdfSanitizeFilterOptions_opaque_set)
    image_filter = property(_mupdf.PdfSanitizeFilterOptions_image_filter_get, _mupdf.PdfSanitizeFilterOptions_image_filter_set)
    text_filter = property(_mupdf.PdfSanitizeFilterOptions_text_filter_get, _mupdf.PdfSanitizeFilterOptions_text_filter_set)
    after_text_object = property(_mupdf.PdfSanitizeFilterOptions_after_text_object_get, _mupdf.PdfSanitizeFilterOptions_after_text_object_set)
    culler = property(_mupdf.PdfSanitizeFilterOptions_culler_get, _mupdf.PdfSanitizeFilterOptions_culler_set)
    s_num_instances = property(_mupdf.PdfSanitizeFilterOptions_s_num_instances_get, _mupdf.PdfSanitizeFilterOptions_s_num_instances_set)

    def to_string(self):
        r""" Returns string containing our members, labelled and inside (...), using operator<<."""
        return _mupdf.PdfSanitizeFilterOptions_to_string(self)

    def __eq__(self, rhs):
        r""" Comparison method."""
        return _mupdf.PdfSanitizeFilterOptions___eq__(self, rhs)

    def __ne__(self, rhs):
        r""" Comparison method."""
        return _mupdf.PdfSanitizeFilterOptions___ne__(self, rhs)

# Register PdfSanitizeFilterOptions in _mupdf:
_mupdf.PdfSanitizeFilterOptions_swigregister(PdfSanitizeFilterOptions)
class PdfSanitizeFilterOptions2(PdfSanitizeFilterOptions):
    r""" Wrapper class for struct pdf_sanitize_filter_options with virtual fns for each fnptr; this is for use as a SWIG Director class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        r""" == Constructor."""
        if self.__class__ == PdfSanitizeFilterOptions2:
            _self = None
        else:
            _self = self
        _mupdf.PdfSanitizeFilterOptions2_swiginit(self, _mupdf.new_PdfSanitizeFilterOptions2(_self, ))

    def use_virtual_image_filter(self, use=True):
        r"""
        These methods set the function pointers in *m_internal
        to point to internal callbacks that call our virtual methods.
        """
        return _mupdf.PdfSanitizeFilterOptions2_use_virtual_image_filter(self, use)

    def use_virtual_text_filter(self, use=True):
        return _mupdf.PdfSanitizeFilterOptions2_use_virtual_text_filter(self, use)

    def use_virtual_after_text_object(self, use=True):
        return _mupdf.PdfSanitizeFilterOptions2_use_virtual_after_text_object(self, use)

    def use_virtual_culler(self, use=True):
        return _mupdf.PdfSanitizeFilterOptions2_use_virtual_culler(self, use)

    def image_filter(self, arg_0, arg_2, arg_3, arg_4, arg_5):
        r""" Default virtual method implementations; these all throw an exception."""
        return _mupdf.PdfSanitizeFilterOptions2_image_filter(self, arg_0, arg_2, arg_3, arg_4, arg_5)

    def text_filter(self, arg_0, arg_2, arg_3, arg_4, arg_5, arg_6):
        return _mupdf.PdfSanitizeFilterOptions2_text_filter(self, arg_0, arg_2, arg_3, arg_4, arg_5, arg_6)

    def after_text_object(self, arg_0, arg_2, arg_3, arg_4):
        return _mupdf.PdfSanitizeFilterOptions2_after_text_object(self, arg_0, arg_2, arg_3, arg_4)

    def culler(self, arg_0, arg_2, arg_3):
        return _mupdf.PdfSanitizeFilterOptions2_culler(self, arg_0, arg_2, arg_3)
    __swig_destroy__ = _mupdf.delete_PdfSanitizeFilterOptions2
    def __disown__(self):
        self.this.disown()
        _mupdf.disown_PdfSanitizeFilterOptions2(self)
        return weakref.proxy(self)

# Register PdfSanitizeFilterOptions2 in _mupdf:
_mupdf.PdfSanitizeFilterOptions2_swigregister(PdfSanitizeFilterOptions2)
class PdfTextObjectState(object):
    r""" Wrapper class for struct `pdf_text_object_state`. Not copyable or assignable."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def pdf_tos_get_text(self):
        r""" Class-aware wrapper for `::pdf_tos_get_text()`."""
        return _mupdf.PdfTextObjectState_pdf_tos_get_text(self)

    def pdf_tos_make_trm(self, text, fontdesc, cid, trm):
        r""" Class-aware wrapper for `::pdf_tos_make_trm()`."""
        return _mupdf.PdfTextObjectState_pdf_tos_make_trm(self, text, fontdesc, cid, trm)

    def pdf_tos_move_after_char(self):
        r""" Class-aware wrapper for `::pdf_tos_move_after_char()`."""
        return _mupdf.PdfTextObjectState_pdf_tos_move_after_char(self)

    def pdf_tos_newline(self, leading):
        r""" Class-aware wrapper for `::pdf_tos_newline()`."""
        return _mupdf.PdfTextObjectState_pdf_tos_newline(self, leading)

    def pdf_tos_reset(self, render):
        r""" Class-aware wrapper for `::pdf_tos_reset()`."""
        return _mupdf.PdfTextObjectState_pdf_tos_reset(self, render)

    def pdf_tos_set_matrix(self, a, b, c, d, e, f):
        r""" Class-aware wrapper for `::pdf_tos_set_matrix()`."""
        return _mupdf.PdfTextObjectState_pdf_tos_set_matrix(self, a, b, c, d, e, f)

    def pdf_tos_translate(self, tx, ty):
        r""" Class-aware wrapper for `::pdf_tos_translate()`."""
        return _mupdf.PdfTextObjectState_pdf_tos_translate(self, tx, ty)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::pdf_text_object_state`.
        """
        _mupdf.PdfTextObjectState_swiginit(self, _mupdf.new_PdfTextObjectState(*args))
    __swig_destroy__ = _mupdf.delete_PdfTextObjectState

    def m_internal_value(self):
        r""" Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.PdfTextObjectState_m_internal_value(self)
    m_internal = property(_mupdf.PdfTextObjectState_m_internal_get, _mupdf.PdfTextObjectState_m_internal_set, doc=r""" Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.PdfTextObjectState_s_num_instances_get, _mupdf.PdfTextObjectState_s_num_instances_set)

# Register PdfTextObjectState in _mupdf:
_mupdf.PdfTextObjectState_swigregister(PdfTextObjectState)
class PdfTextState(object):
    r""" Wrapper class for struct `pdf_text_state`. Not copyable or assignable."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::pdf_text_state`.
        """
        _mupdf.PdfTextState_swiginit(self, _mupdf.new_PdfTextState(*args))
    __swig_destroy__ = _mupdf.delete_PdfTextState

    def m_internal_value(self):
        r""" Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.PdfTextState_m_internal_value(self)
    m_internal = property(_mupdf.PdfTextState_m_internal_get, _mupdf.PdfTextState_m_internal_set, doc=r""" Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.PdfTextState_s_num_instances_get, _mupdf.PdfTextState_s_num_instances_set)

# Register PdfTextState in _mupdf:
_mupdf.PdfTextState_swigregister(PdfTextState)
class PdfUnsavedSig(object):
    r""" Wrapper class for struct `pdf_unsaved_sig`. Not copyable or assignable."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::pdf_unsaved_sig`.
        """
        _mupdf.PdfUnsavedSig_swiginit(self, _mupdf.new_PdfUnsavedSig(*args))
    __swig_destroy__ = _mupdf.delete_PdfUnsavedSig

    def m_internal_value(self):
        r""" Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.PdfUnsavedSig_m_internal_value(self)
    m_internal = property(_mupdf.PdfUnsavedSig_m_internal_get, _mupdf.PdfUnsavedSig_m_internal_set, doc=r""" Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.PdfUnsavedSig_s_num_instances_get, _mupdf.PdfUnsavedSig_s_num_instances_set)

# Register PdfUnsavedSig in _mupdf:
_mupdf.PdfUnsavedSig_swigregister(PdfUnsavedSig)
class PdfVmtx(object):
    r""" Wrapper class for struct `pdf_vmtx`. Not copyable or assignable."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::pdf_vmtx`.
        """
        _mupdf.PdfVmtx_swiginit(self, _mupdf.new_PdfVmtx(*args))
    __swig_destroy__ = _mupdf.delete_PdfVmtx

    def m_internal_value(self):
        r""" Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.PdfVmtx_m_internal_value(self)
    m_internal = property(_mupdf.PdfVmtx_m_internal_get, _mupdf.PdfVmtx_m_internal_set, doc=r""" Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.PdfVmtx_s_num_instances_get, _mupdf.PdfVmtx_s_num_instances_set)

# Register PdfVmtx in _mupdf:
_mupdf.PdfVmtx_swigregister(PdfVmtx)
class PdfWriteOptions(object):
    r""" Wrapper class for struct `pdf_write_options`."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def pdf_parse_write_options(self, args):
        r""" We use default copy constructor and operator=.  Class-aware wrapper for `::pdf_parse_write_options()`."""
        return _mupdf.PdfWriteOptions_pdf_parse_write_options(self, args)

    def opwd_utf8_set_value(self, text):
        r""" Copies <text> into opwd_utf8[]."""
        return _mupdf.PdfWriteOptions_opwd_utf8_set_value(self, text)

    def upwd_utf8_set_value(self, text):
        r""" Copies <text> into upwd_utf8[]."""
        return _mupdf.PdfWriteOptions_upwd_utf8_set_value(self, text)

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor, makes copy of pdf_default_write_options.

        |

        *Overload 2:*
        Copy constructor using raw memcopy().

        |

        *Overload 3:*
        Constructor using raw copy of pre-existing `::pdf_write_options`.

        |

        *Overload 4:*
        Constructor using raw copy of pre-existing `::pdf_write_options`.
        """
        _mupdf.PdfWriteOptions_swiginit(self, _mupdf.new_PdfWriteOptions(*args))

    def internal(self, *args):
        r"""
        *Overload 1:*
        Access as underlying struct.

        |

        *Overload 2:*
        Access as underlying struct.
        """
        return _mupdf.PdfWriteOptions_internal(self, *args)
    __swig_destroy__ = _mupdf.delete_PdfWriteOptions
    do_incremental = property(_mupdf.PdfWriteOptions_do_incremental_get, _mupdf.PdfWriteOptions_do_incremental_set)
    do_pretty = property(_mupdf.PdfWriteOptions_do_pretty_get, _mupdf.PdfWriteOptions_do_pretty_set)
    do_ascii = property(_mupdf.PdfWriteOptions_do_ascii_get, _mupdf.PdfWriteOptions_do_ascii_set)
    do_compress = property(_mupdf.PdfWriteOptions_do_compress_get, _mupdf.PdfWriteOptions_do_compress_set)
    do_compress_images = property(_mupdf.PdfWriteOptions_do_compress_images_get, _mupdf.PdfWriteOptions_do_compress_images_set)
    do_compress_fonts = property(_mupdf.PdfWriteOptions_do_compress_fonts_get, _mupdf.PdfWriteOptions_do_compress_fonts_set)
    do_decompress = property(_mupdf.PdfWriteOptions_do_decompress_get, _mupdf.PdfWriteOptions_do_decompress_set)
    do_garbage = property(_mupdf.PdfWriteOptions_do_garbage_get, _mupdf.PdfWriteOptions_do_garbage_set)
    do_linear = property(_mupdf.PdfWriteOptions_do_linear_get, _mupdf.PdfWriteOptions_do_linear_set)
    do_clean = property(_mupdf.PdfWriteOptions_do_clean_get, _mupdf.PdfWriteOptions_do_clean_set)
    do_sanitize = property(_mupdf.PdfWriteOptions_do_sanitize_get, _mupdf.PdfWriteOptions_do_sanitize_set)
    do_appearance = property(_mupdf.PdfWriteOptions_do_appearance_get, _mupdf.PdfWriteOptions_do_appearance_set)
    do_encrypt = property(_mupdf.PdfWriteOptions_do_encrypt_get, _mupdf.PdfWriteOptions_do_encrypt_set)
    dont_regenerate_id = property(_mupdf.PdfWriteOptions_dont_regenerate_id_get, _mupdf.PdfWriteOptions_dont_regenerate_id_set)
    permissions = property(_mupdf.PdfWriteOptions_permissions_get, _mupdf.PdfWriteOptions_permissions_set)
    opwd_utf8 = property(_mupdf.PdfWriteOptions_opwd_utf8_get, _mupdf.PdfWriteOptions_opwd_utf8_set)
    upwd_utf8 = property(_mupdf.PdfWriteOptions_upwd_utf8_get, _mupdf.PdfWriteOptions_upwd_utf8_set)
    do_snapshot = property(_mupdf.PdfWriteOptions_do_snapshot_get, _mupdf.PdfWriteOptions_do_snapshot_set)
    do_preserve_metadata = property(_mupdf.PdfWriteOptions_do_preserve_metadata_get, _mupdf.PdfWriteOptions_do_preserve_metadata_set)
    do_use_objstms = property(_mupdf.PdfWriteOptions_do_use_objstms_get, _mupdf.PdfWriteOptions_do_use_objstms_set)
    compression_effort = property(_mupdf.PdfWriteOptions_compression_effort_get, _mupdf.PdfWriteOptions_compression_effort_set)
    s_num_instances = property(_mupdf.PdfWriteOptions_s_num_instances_get, _mupdf.PdfWriteOptions_s_num_instances_set)

    def to_string(self):
        r""" Returns string containing our members, labelled and inside (...), using operator<<."""
        return _mupdf.PdfWriteOptions_to_string(self)

    def __eq__(self, rhs):
        r""" Comparison method."""
        return _mupdf.PdfWriteOptions___eq__(self, rhs)

    def __ne__(self, rhs):
        r""" Comparison method."""
        return _mupdf.PdfWriteOptions___ne__(self, rhs)

# Register PdfWriteOptions in _mupdf:
_mupdf.PdfWriteOptions_swigregister(PdfWriteOptions)
class PdfXrange(object):
    r""" Wrapper class for struct `pdf_xrange`. Not copyable or assignable."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::pdf_xrange`.
        """
        _mupdf.PdfXrange_swiginit(self, _mupdf.new_PdfXrange(*args))
    __swig_destroy__ = _mupdf.delete_PdfXrange

    def m_internal_value(self):
        r""" Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.PdfXrange_m_internal_value(self)
    m_internal = property(_mupdf.PdfXrange_m_internal_get, _mupdf.PdfXrange_m_internal_set, doc=r""" Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.PdfXrange_s_num_instances_get, _mupdf.PdfXrange_s_num_instances_set)

# Register PdfXrange in _mupdf:
_mupdf.PdfXrange_swigregister(PdfXrange)
class PdfXref(object):
    r""" Wrapper class for struct `pdf_xref`. Not copyable or assignable."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        == Constructors.  Constructor using `pdf_new_local_xref()`.

        |

        *Overload 2:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 3:*
        Constructor using raw copy of pre-existing `::pdf_xref`.
        """
        _mupdf.PdfXref_swiginit(self, _mupdf.new_PdfXref(*args))
    __swig_destroy__ = _mupdf.delete_PdfXref

    def m_internal_value(self):
        r""" Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.PdfXref_m_internal_value(self)
    m_internal = property(_mupdf.PdfXref_m_internal_get, _mupdf.PdfXref_m_internal_set, doc=r""" Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.PdfXref_s_num_instances_get, _mupdf.PdfXref_s_num_instances_set)

# Register PdfXref in _mupdf:
_mupdf.PdfXref_swigregister(PdfXref)
class PdfXrefEntry(object):
    r""" Wrapper class for struct `pdf_xref_entry`. Not copyable or assignable."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::pdf_xref_entry`.
        """
        _mupdf.PdfXrefEntry_swiginit(self, _mupdf.new_PdfXrefEntry(*args))
    __swig_destroy__ = _mupdf.delete_PdfXrefEntry

    def m_internal_value(self):
        r""" Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.PdfXrefEntry_m_internal_value(self)
    m_internal = property(_mupdf.PdfXrefEntry_m_internal_get, _mupdf.PdfXrefEntry_m_internal_set, doc=r""" Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.PdfXrefEntry_s_num_instances_get, _mupdf.PdfXrefEntry_s_num_instances_set)

# Register PdfXrefEntry in _mupdf:
_mupdf.PdfXrefEntry_swigregister(PdfXrefEntry)
class PdfXrefSubsec(object):
    r""" Wrapper class for struct `pdf_xref_subsec`. Not copyable or assignable."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Default constructor, sets `m_internal` to null.

        |

        *Overload 2:*
        Constructor using raw copy of pre-existing `::pdf_xref_subsec`.
        """
        _mupdf.PdfXrefSubsec_swiginit(self, _mupdf.new_PdfXrefSubsec(*args))
    __swig_destroy__ = _mupdf.delete_PdfXrefSubsec

    def m_internal_value(self):
        r""" Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.PdfXrefSubsec_m_internal_value(self)
    m_internal = property(_mupdf.PdfXrefSubsec_m_internal_get, _mupdf.PdfXrefSubsec_m_internal_set, doc=r""" Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.PdfXrefSubsec_s_num_instances_get, _mupdf.PdfXrefSubsec_s_num_instances_set)

# Register PdfXrefSubsec in _mupdf:
_mupdf.PdfXrefSubsec_swigregister(PdfXrefSubsec)

def num_instances():
    r""" Returns map from class name (for example FzDocument) to s_num_instances."""
    return _mupdf.num_instances()
class FzLinkIterator(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, item):
        _mupdf.FzLinkIterator_swiginit(self, _mupdf.new_FzLinkIterator(item))

    def __increment__(self):
        return _mupdf.FzLinkIterator___increment__(self)

    def __eq__(self, rhs):
        return _mupdf.FzLinkIterator___eq__(self, rhs)

    def __ne__(self, rhs):
        return _mupdf.FzLinkIterator___ne__(self, rhs)

    def __ref__(self):
        return _mupdf.FzLinkIterator___ref__(self)

    def __deref__(self):
        return _mupdf.FzLinkIterator___deref__(self)
    __swig_destroy__ = _mupdf.delete_FzLinkIterator

    def fz_set_link_rect(self, rect):
        r""" Class-aware wrapper for `::fz_set_link_rect()`."""
        return _mupdf.FzLinkIterator_fz_set_link_rect(self, rect)

    def fz_set_link_uri(self, uri):
        r""" Class-aware wrapper for `::fz_set_link_uri()`."""
        return _mupdf.FzLinkIterator_fz_set_link_uri(self, uri)

    def begin(self):
        r""" Used for iteration over linked list of FzLink items starting at fz_link::."""
        return _mupdf.FzLinkIterator_begin(self)

    def end(self):
        r""" Used for iteration over linked list of FzLink items starting at fz_link::."""
        return _mupdf.FzLinkIterator_end(self)

    def refs(self):
        return _mupdf.FzLinkIterator_refs(self)

    def next(self):
        return _mupdf.FzLinkIterator_next(self)

    def rect(self):
        return _mupdf.FzLinkIterator_rect(self)

    def uri(self):
        return _mupdf.FzLinkIterator_uri(self)

    def m_internal_value(self):
        r""" Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.FzLinkIterator_m_internal_value(self)
    m_internal = property(_mupdf.FzLinkIterator_m_internal_get, _mupdf.FzLinkIterator_m_internal_set, doc=r""" Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.FzLinkIterator_s_num_instances_get, _mupdf.FzLinkIterator_s_num_instances_set)

# Register FzLinkIterator in _mupdf:
_mupdf.FzLinkIterator_swigregister(FzLinkIterator)
class FzStextBlockIterator(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, item):
        _mupdf.FzStextBlockIterator_swiginit(self, _mupdf.new_FzStextBlockIterator(item))

    def __increment__(self):
        return _mupdf.FzStextBlockIterator___increment__(self)

    def __eq__(self, rhs):
        return _mupdf.FzStextBlockIterator___eq__(self, rhs)

    def __ne__(self, rhs):
        return _mupdf.FzStextBlockIterator___ne__(self, rhs)

    def __ref__(self):
        return _mupdf.FzStextBlockIterator___ref__(self)

    def __deref__(self):
        return _mupdf.FzStextBlockIterator___deref__(self)
    __swig_destroy__ = _mupdf.delete_FzStextBlockIterator

    def begin(self):
        r""" Used for iteration over linked list of FzStextChar items starting at fz_stext_char::first_char."""
        return _mupdf.FzStextBlockIterator_begin(self)

    def end(self):
        r""" Used for iteration over linked list of FzStextChar items starting at fz_stext_char::first_char."""
        return _mupdf.FzStextBlockIterator_end(self)

    def m_internal_value(self):
        r""" Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.FzStextBlockIterator_m_internal_value(self)
    m_internal = property(_mupdf.FzStextBlockIterator_m_internal_get, _mupdf.FzStextBlockIterator_m_internal_set, doc=r""" Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.FzStextBlockIterator_s_num_instances_get, _mupdf.FzStextBlockIterator_s_num_instances_set)

# Register FzStextBlockIterator in _mupdf:
_mupdf.FzStextBlockIterator_swigregister(FzStextBlockIterator)
class FzStextLineIterator(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, item):
        _mupdf.FzStextLineIterator_swiginit(self, _mupdf.new_FzStextLineIterator(item))

    def __increment__(self):
        return _mupdf.FzStextLineIterator___increment__(self)

    def __eq__(self, rhs):
        return _mupdf.FzStextLineIterator___eq__(self, rhs)

    def __ne__(self, rhs):
        return _mupdf.FzStextLineIterator___ne__(self, rhs)

    def __ref__(self):
        return _mupdf.FzStextLineIterator___ref__(self)

    def __deref__(self):
        return _mupdf.FzStextLineIterator___deref__(self)
    __swig_destroy__ = _mupdf.delete_FzStextLineIterator

    def m_internal_value(self):
        r""" Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.FzStextLineIterator_m_internal_value(self)
    m_internal = property(_mupdf.FzStextLineIterator_m_internal_get, _mupdf.FzStextLineIterator_m_internal_set, doc=r""" Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.FzStextLineIterator_s_num_instances_get, _mupdf.FzStextLineIterator_s_num_instances_set)

# Register FzStextLineIterator in _mupdf:
_mupdf.FzStextLineIterator_swigregister(FzStextLineIterator)
class FzStextPageIterator(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, item):
        _mupdf.FzStextPageIterator_swiginit(self, _mupdf.new_FzStextPageIterator(item))

    def __increment__(self):
        return _mupdf.FzStextPageIterator___increment__(self)

    def __eq__(self, rhs):
        return _mupdf.FzStextPageIterator___eq__(self, rhs)

    def __ne__(self, rhs):
        return _mupdf.FzStextPageIterator___ne__(self, rhs)

    def __ref__(self):
        return _mupdf.FzStextPageIterator___ref__(self)

    def __deref__(self):
        return _mupdf.FzStextPageIterator___deref__(self)
    __swig_destroy__ = _mupdf.delete_FzStextPageIterator

    def i_transform(self):
        r""" Returns m_internal.u.i.transform if m_internal->type is FZ_STEXT_BLOCK_IMAGE, else throws."""
        return _mupdf.FzStextPageIterator_i_transform(self)

    def i_image(self):
        r""" Returns m_internal.u.i.image if m_internal->type is FZ_STEXT_BLOCK_IMAGE, else throws."""
        return _mupdf.FzStextPageIterator_i_image(self)

    def begin(self):
        r""" Used for iteration over linked list of FzStextLine items starting at fz_stext_line::u.t.first_line."""
        return _mupdf.FzStextPageIterator_begin(self)

    def end(self):
        r""" Used for iteration over linked list of FzStextLine items starting at fz_stext_line::u.t.first_line."""
        return _mupdf.FzStextPageIterator_end(self)

    def m_internal_value(self):
        r""" Return numerical value of .m_internal; helps with Python debugging."""
        return _mupdf.FzStextPageIterator_m_internal_value(self)
    m_internal = property(_mupdf.FzStextPageIterator_m_internal_get, _mupdf.FzStextPageIterator_m_internal_set, doc=r""" Pointer to wrapped data.""")
    s_num_instances = property(_mupdf.FzStextPageIterator_s_num_instances_get, _mupdf.FzStextPageIterator_s_num_instances_set)

# Register FzStextPageIterator in _mupdf:
_mupdf.FzStextPageIterator_swigregister(FzStextPageIterator)

def fz_aa_level():
    r"""
    Class-aware wrapper for `::fz_aa_level()`.
    	Get the number of bits of antialiasing we are
    	using (for graphics). Between 0 and 8.
    """
    return _mupdf.fz_aa_level()

def fz_abs(f):
    r"""
    Class-aware wrapper for `::fz_abs()`.
    	Some standard math functions, done as static inlines for speed.
    	People with compilers that do not adequately implement inline
    	may like to reimplement these using macros.
    """
    return _mupdf.fz_abs(f)

def fz_absi(i):
    r""" Class-aware wrapper for `::fz_absi()`."""
    return _mupdf.fz_absi(i)

def fz_add_layout_char(block, x, w, p):
    r"""
    Class-aware wrapper for `::fz_add_layout_char()`.
    	Add a new char to the line at the end of the layout block.
    """
    return _mupdf.fz_add_layout_char(block, x, w, p)

def fz_add_layout_line(block, x, y, h, p):
    r"""
    Class-aware wrapper for `::fz_add_layout_line()`.
    	Add a new line to the end of the layout block.
    """
    return _mupdf.fz_add_layout_line(block, x, y, h, p)

def fz_add_separation(sep, name, cs, cs_channel):
    r"""
    Class-aware wrapper for `::fz_add_separation()`.
    	Add a separation (null terminated name, colorspace)
    """
    return _mupdf.fz_add_separation(sep, name, cs, cs_channel)

def fz_add_separation_equivalents(sep, rgba, cmyk, name):
    r"""
    Class-aware wrapper for `::fz_add_separation_equivalents()`.
    	Add a separation with equivalents (null terminated name,
    	colorspace)

    	(old, deprecated)
    """
    return _mupdf.fz_add_separation_equivalents(sep, rgba, cmyk, name)

def fz_adjust_rect_for_stroke(rect, stroke, ctm):
    r"""
    Class-aware wrapper for `::fz_adjust_rect_for_stroke()`.
    	Given a rectangle (assumed to be the bounding box for a path),
    	expand it to allow for the expansion of the bbox that would be
    	seen by stroking the path with the given stroke state and
    	transform.
    """
    return _mupdf.fz_adjust_rect_for_stroke(rect, stroke, ctm)

def fz_advance_glyph(font, glyph, wmode):
    r"""
    Class-aware wrapper for `::fz_advance_glyph()`.
    	Return the advance for a given glyph.

    	font: The font to look for the glyph in.

    	glyph: The glyph to find the advance for.

    	wmode: 1 for vertical mode, 0 for horizontal.

    	Returns the advance for the glyph.
    """
    return _mupdf.fz_advance_glyph(font, glyph, wmode)

def fz_aes_crypt_cbc(ctx, mode, length, iv, input, output):
    r"""
    Class-aware wrapper for `::fz_aes_crypt_cbc()`.
    	AES block processing. Encrypts or Decrypts (according to mode,
    	which must match what was initially set up) length bytes (which
    	must be a multiple of 16), using (and modifying) the insertion
    	vector iv, reading from input, and writing to output.

    	Never throws an exception.
    """
    return _mupdf.fz_aes_crypt_cbc(ctx, mode, length, iv, input, output)

def fz_aes_setkey_dec(ctx, key, keysize):
    r"""
    Class-aware wrapper for `::fz_aes_setkey_dec()`.
    	AES decryption intialisation. Fills in the supplied context
    	and prepares for decryption using the given key.

    	Returns non-zero for error (key size other than 128/192/256).

    	Never throws an exception.
    """
    return _mupdf.fz_aes_setkey_dec(ctx, key, keysize)

def fz_aes_setkey_enc(ctx, key, keysize):
    r"""
    Class-aware wrapper for `::fz_aes_setkey_enc()`.
    	AES encryption intialisation. Fills in the supplied context
    	and prepares for encryption using the given key.

    	Returns non-zero for error (key size other than 128/192/256).

    	Never throws an exception.
    """
    return _mupdf.fz_aes_setkey_enc(ctx, key, keysize)

def fz_alpha_from_gray(gray):
    r""" Class-aware wrapper for `::fz_alpha_from_gray()`."""
    return _mupdf.fz_alpha_from_gray(gray)

def fz_append_base64(out, data, size, newline):
    r"""
    Class-aware wrapper for `::fz_append_base64()`.
    	Write a base64 encoded data block, optionally with periodic newlines.
    """
    return _mupdf.fz_append_base64(out, data, size, newline)

def fz_append_base64_buffer(out, data, newline):
    r"""
    Class-aware wrapper for `::fz_append_base64_buffer()`.
    	Append a base64 encoded fz_buffer, optionally with periodic newlines.
    """
    return _mupdf.fz_append_base64_buffer(out, data, newline)

def fz_append_bits(buf, value, count):
    r""" Class-aware wrapper for `::fz_append_bits()`."""
    return _mupdf.fz_append_bits(buf, value, count)

def fz_append_bits_pad(buf):
    r""" Class-aware wrapper for `::fz_append_bits_pad()`."""
    return _mupdf.fz_append_bits_pad(buf)

def fz_append_buffer(destination, source):
    r"""
    Class-aware wrapper for `::fz_append_buffer()`.
    	Append the contents of the source buffer onto the end of the
    	destination buffer, extending automatically as required.

    	Ownership of buffers does not change.
    """
    return _mupdf.fz_append_buffer(destination, source)

def fz_append_byte(buf, c):
    r""" Class-aware wrapper for `::fz_append_byte()`."""
    return _mupdf.fz_append_byte(buf, c)

def fz_append_data(buf, data, len):
    r"""
    Class-aware wrapper for `::fz_append_data()`.
    	fz_append_*: Append data to a buffer.

    	The buffer will automatically grow as required.
    """
    return _mupdf.fz_append_data(buf, data, len)

def fz_append_image_as_data_uri(out, image):
    r""" Class-aware wrapper for `::fz_append_image_as_data_uri()`."""
    return _mupdf.fz_append_image_as_data_uri(out, image)

def fz_append_int16_be(buf, x):
    r""" Class-aware wrapper for `::fz_append_int16_be()`."""
    return _mupdf.fz_append_int16_be(buf, x)

def fz_append_int16_le(buf, x):
    r""" Class-aware wrapper for `::fz_append_int16_le()`."""
    return _mupdf.fz_append_int16_le(buf, x)

def fz_append_int32_be(buf, x):
    r""" Class-aware wrapper for `::fz_append_int32_be()`."""
    return _mupdf.fz_append_int32_be(buf, x)

def fz_append_int32_le(buf, x):
    r""" Class-aware wrapper for `::fz_append_int32_le()`."""
    return _mupdf.fz_append_int32_le(buf, x)

def fz_append_pdf_string(buffer, text):
    r"""
    Class-aware wrapper for `::fz_append_pdf_string()`.
    	fz_append_pdf_string: Append a string with PDF syntax quotes and
    	escapes.

    	The buffer will automatically grow as required.
    """
    return _mupdf.fz_append_pdf_string(buffer, text)

def fz_append_pixmap_as_data_uri(out, pixmap):
    r""" Class-aware wrapper for `::fz_append_pixmap_as_data_uri()`."""
    return _mupdf.fz_append_pixmap_as_data_uri(out, pixmap)

def fz_append_rune(buf, c):
    r""" Class-aware wrapper for `::fz_append_rune()`."""
    return _mupdf.fz_append_rune(buf, c)

def fz_append_string(buf, data):
    r""" Class-aware wrapper for `::fz_append_string()`."""
    return _mupdf.fz_append_string(buf, data)

def fz_arc4_encrypt(state, dest, src, len):
    r"""
    Class-aware wrapper for `::fz_arc4_encrypt()`.
    	RC4 block encrypt operation; encrypt src into dst (both of
    	length len) updating the RC4 state as we go.

    	Never throws an exception.
    """
    return _mupdf.fz_arc4_encrypt(state, dest, src, len)

def fz_arc4_final(state):
    r"""
    Class-aware wrapper for `::fz_arc4_final()`.
    	RC4 finalization. Zero the context.

    	Never throws an exception.
    """
    return _mupdf.fz_arc4_final(state)

def fz_arc4_init(state, key, len):
    r"""
    Class-aware wrapper for `::fz_arc4_init()`.
    	RC4 initialization. Begins an RC4 operation, writing a new
    	context.

    	Never throws an exception.
    """
    return _mupdf.fz_arc4_init(state, key, len)

def fz_archive_format(arch):
    r"""
    Class-aware wrapper for `::fz_archive_format()`.
    	Return a pointer to a string describing the format of the
    	archive.

    	The lifetime of the string is unspecified (in current
    	implementations the string will persist until the archive
    	is closed, but this is not guaranteed).
    """
    return _mupdf.fz_archive_format(arch)

def fz_atof(s):
    r"""
    Class-aware wrapper for `::fz_atof()`.
    	Range checking atof
    """
    return _mupdf.fz_atof(s)

def fz_atoi(s):
    r"""
    Class-aware wrapper for `::fz_atoi()`.
    	atoi that copes with NULL
    """
    return _mupdf.fz_atoi(s)

def fz_atoi64(s):
    r"""
    Class-aware wrapper for `::fz_atoi64()`.
    	64bit atoi that copes with NULL
    """
    return _mupdf.fz_atoi64(s)

def fz_authenticate_password(doc, password):
    r"""
    Class-aware wrapper for `::fz_authenticate_password()`.
    	Test if the given password can decrypt the document.

    	password: The password string to be checked. Some document
    	specifications do not specify any particular text encoding, so
    	neither do we.

    	Returns 0 for failure to authenticate, non-zero for success.

    	For PDF documents, further information can be given by examining
    	the bits in the return code.

    		Bit 0 => No password required
    		Bit 1 => User password authenticated
    		Bit 2 => Owner password authenticated
    """
    return _mupdf.fz_authenticate_password(doc, password)

def fz_available(stm, max):
    r"""
    Class-aware wrapper for `::fz_available()`.
    	Ask how many bytes are available immediately from
    	a given stream.

    	stm: The stream to read from.

    	max: A hint for the underlying stream; the maximum number of
    	bytes that we are sure we will want to read. If you do not know
    	this number, give 1.

    	Returns the number of bytes immediately available between the
    	read and write pointers. This number is guaranteed only to be 0
    	if we have hit EOF. The number of bytes returned here need have
    	no relation to max (could be larger, could be smaller).
    """
    return _mupdf.fz_available(stm, max)

def fz_base_colorspace(cs):
    r"""
    Class-aware wrapper for `::fz_base_colorspace()`.
    	Get the 'base' colorspace for a colorspace.

    	For indexed colorspaces, this is the colorspace the index
    	decodes into. For all other colorspaces, it is the colorspace
    	itself.

    	The returned colorspace is 'borrowed' (i.e. no additional
    	references are taken or dropped).
    """
    return _mupdf.fz_base_colorspace(cs)

def fz_basename(path):
    r"""
    Class-aware wrapper for `::fz_basename()`.
    	Find the filename component in a path.
    """
    return _mupdf.fz_basename(path)

def fz_begin_group(dev, area, cs, isolated, knockout, blendmode, alpha):
    r""" Class-aware wrapper for `::fz_begin_group()`."""
    return _mupdf.fz_begin_group(dev, area, cs, isolated, knockout, blendmode, alpha)

def fz_begin_layer(dev, layer_name):
    r""" Class-aware wrapper for `::fz_begin_layer()`."""
    return _mupdf.fz_begin_layer(dev, layer_name)

def fz_begin_mask(dev, area, luminosity, colorspace, bc, color_params):
    r""" Class-aware wrapper for `::fz_begin_mask()`."""
    return _mupdf.fz_begin_mask(dev, area, luminosity, colorspace, bc, color_params)

def fz_begin_metatext(dev, meta, text):
    r""" Class-aware wrapper for `::fz_begin_metatext()`."""
    return _mupdf.fz_begin_metatext(dev, meta, text)

def fz_begin_page(wri, mediabox):
    r"""
    Class-aware wrapper for `::fz_begin_page()`.
    	Called to start the process of writing a page to
    	a document.

    	mediabox: page size rectangle in points.

    	Returns a borrowed fz_device to write page contents to. This
    	should be kept if required, and only dropped if it was kept.
    """
    return _mupdf.fz_begin_page(wri, mediabox)

def fz_begin_structure(dev, standard, raw, idx):
    r""" Class-aware wrapper for `::fz_begin_structure()`."""
    return _mupdf.fz_begin_structure(dev, standard, raw, idx)

def fz_begin_tile(dev, area, view, xstep, ystep, ctm):
    r""" Class-aware wrapper for `::fz_begin_tile()`."""
    return _mupdf.fz_begin_tile(dev, area, view, xstep, ystep, ctm)

def fz_begin_tile_id(dev, area, view, xstep, ystep, ctm, id):
    r""" Class-aware wrapper for `::fz_begin_tile_id()`."""
    return _mupdf.fz_begin_tile_id(dev, area, view, xstep, ystep, ctm, id)

def fz_bidi_fragment_text(text, textlen, baseDir, callback, arg, flags):
    r"""
     Class-aware wrapper for `::fz_bidi_fragment_text()`.

    	This function has out-params. Python/C# wrappers look like:
    		`fz_bidi_fragment_text(const uint32_t *text, size_t textlen, ::fz_bidi_fragment_fn *callback, void *arg, int flags)` => ::fz_bidi_direction baseDir

    		Partitions the given Unicode sequence into one or more
    		unidirectional fragments and invokes the given callback
    		function for each fragment.

    		For example, if directionality of text is:
    				0123456789
    				rrlllrrrrr,
    		we'll invoke callback with:
    				&text[0], length == 2
    				&text[2], length == 3
    				&text[5], length == 5

    		:type text: int, in
    :param text:	start of Unicode sequence
        		:type textlen: int, in
    :param textlen:   number of Unicodes to analyse
        		:type baseDir: int, in
    :param baseDir:   direction of paragraph (specify FZ_BIDI_NEUTRAL to force auto-detection)
        		:type callback: ::fz_bidi_fragment_fn, in
    :param callback:  function to be called for each fragment
        		:type arg: void, in
    :param arg:	data to be passed to the callback function
        		:type flags: int, in
    :param flags:     flags to control operation (see fz_bidi_flags above)
    """
    return _mupdf.fz_bidi_fragment_text(text, textlen, baseDir, callback, arg, flags)

def fz_bitmap_details(bitmap, w, h, n, stride):
    r"""
    Class-aware wrapper for `::fz_bitmap_details()`.

    This function has out-params. Python/C# wrappers look like:
    	`fz_bitmap_details(::fz_bitmap *bitmap)` => `(int w, int h, int n, int stride)`

    	Retrieve details of a given bitmap.

    	bitmap: The bitmap to query.

    	w: Pointer to storage to retrieve width (or NULL).

    	h: Pointer to storage to retrieve height (or NULL).

    	n: Pointer to storage to retrieve number of color components (or
    	NULL).

    	stride: Pointer to storage to retrieve bitmap stride (or NULL).
    """
    return _mupdf.fz_bitmap_details(bitmap, w, h, n, stride)

def fz_blendmode_name(blendmode):
    r"""
    Class-aware wrapper for `::fz_blendmode_name()`.
    	Map from enumeration to blend mode string.

    	The string is static, with arbitrary lifespan.
    """
    return _mupdf.fz_blendmode_name(blendmode)

def fz_bound_display_list(list):
    r"""
    Class-aware wrapper for `::fz_bound_display_list()`.
    	Return the bounding box of the page recorded in a display list.
    """
    return _mupdf.fz_bound_display_list(list)

def fz_bound_glyph(font, gid, trm):
    r"""
    Class-aware wrapper for `::fz_bound_glyph()`.
    	Return a bbox for a given glyph in a font.

    	font: The font to look for the glyph in.

    	gid: The glyph to bound.

    	trm: The matrix to apply to the glyph before bounding.

    	Returns rectangle by value containing the bounds of the given
    	glyph.
    """
    return _mupdf.fz_bound_glyph(font, gid, trm)

def fz_bound_page(page):
    r"""
    Class-aware wrapper for `::fz_bound_page()`.
    	Determine the size of a page at 72 dpi.
    """
    return _mupdf.fz_bound_page(page)

def fz_bound_page_box(page, box):
    r""" Class-aware wrapper for `::fz_bound_page_box()`."""
    return _mupdf.fz_bound_page_box(page, box)

def fz_bound_path(path, stroke, ctm):
    r"""
    Class-aware wrapper for `::fz_bound_path()`.
    	Return a bounding rectangle for a path.

    	path: The path to bound.

    	stroke: If NULL, the bounding rectangle given is for
    	the filled path. If non-NULL the bounding rectangle
    	given is for the path stroked with the given attributes.

    	ctm: The matrix to apply to the path during stroking.

    	r: Pointer to a fz_rect which will be used to hold
    	the result.

    	Returns r, updated to contain the bounding rectangle.
    """
    return _mupdf.fz_bound_path(path, stroke, ctm)

def fz_bound_shade(shade, ctm):
    r"""
    Class-aware wrapper for `::fz_bound_shade()`.
    	Bound a given shading.

    	shade: The shade to bound.

    	ctm: The transform to apply to the shade before bounding.

    	r: Pointer to storage to put the bounds in.

    	Returns r, updated to contain the bounds for the shading.
    """
    return _mupdf.fz_bound_shade(shade, ctm)

def fz_bound_text(text, stroke, ctm):
    r"""
    Class-aware wrapper for `::fz_bound_text()`.
    	Find the bounds of a given text object.

    	text: The text object to find the bounds of.

    	stroke: Pointer to the stroke attributes (for stroked
    	text), or NULL (for filled text).

    	ctm: The matrix in use.

    	r: pointer to storage for the bounds.

    	Returns a pointer to r, which is updated to contain the
    	bounding box for the text object.
    """
    return _mupdf.fz_bound_text(text, stroke, ctm)

def fz_box_type_from_string(name):
    r""" Class-aware wrapper for `::fz_box_type_from_string()`."""
    return _mupdf.fz_box_type_from_string(name)

def fz_buffer_extract(buf, data):
    r"""
    Class-aware wrapper for `::fz_buffer_extract()`.

    This function has out-params. Python/C# wrappers look like:
    	`fz_buffer_extract(::fz_buffer *buf)` => `(size_t, unsigned char *data)`

    	Take ownership of buffer contents.

    	Performs the same task as fz_buffer_storage, but ownership of
    	the data buffer returns with this call. The buffer is left
    	empty.

    	Note: Bad things may happen if this is called on a buffer with
    	multiple references that is being used from multiple threads.

    	data: Pointer to place to retrieve data pointer.

    	Returns length of stream.
    """
    return _mupdf.fz_buffer_extract(buf, data)

def fz_buffer_storage(buf, datap):
    r"""
    Class-aware wrapper for `::fz_buffer_storage()`.

    This function has out-params. Python/C# wrappers look like:
    	`fz_buffer_storage(::fz_buffer *buf)` => `(size_t, unsigned char *datap)`

    	Retrieve internal memory of buffer.

    	datap: Output parameter that will be pointed to the data.

    	Returns the current size of the data in bytes.
    """
    return _mupdf.fz_buffer_storage(buf, datap)

def fz_calloc(count, size):
    r"""
    Class-aware wrapper for `::fz_calloc()`.
    	Allocate array of memory of count entries of size bytes.
    	Clears the memory to zero.

    	Throws exception in the event of failure to allocate.
    """
    return _mupdf.fz_calloc(count, size)

def fz_calloc_no_throw(count, size):
    r"""
    Class-aware wrapper for `::fz_calloc_no_throw()`.
    	fz_calloc equivalent that returns NULL rather than throwing
    	exceptions.
    """
    return _mupdf.fz_calloc_no_throw(count, size)

def fz_caught():
    r"""
    Class-aware wrapper for `::fz_caught()`.
    	Within an fz_catch() block, retrieve the error code for
    	the current exception.

    	This assumes no intervening use of fz_try/fz_catch.
    """
    return _mupdf.fz_caught()

def fz_caught_errno():
    r""" Class-aware wrapper for `::fz_caught_errno()`."""
    return _mupdf.fz_caught_errno()

def fz_caught_message():
    r"""
    Class-aware wrapper for `::fz_caught_message()`.
    	Within an fz_catch() block, retrieve the formatted message
    	string for the current exception.

    	This assumes no intervening use of fz_try/fz_catch.
    """
    return _mupdf.fz_caught_message()

def fz_chartorune(rune, str):
    r"""
    Class-aware wrapper for `::fz_chartorune()`.

    This function has out-params. Python/C# wrappers look like:
    	`fz_chartorune(const char *str)` => `(int, int rune)`

    	UTF8 decode a single rune from a sequence of chars.

    	rune: Pointer to an int to assign the decoded 'rune' to.

    	str: Pointer to a UTF8 encoded string.

    	Returns the number of bytes consumed.
    """
    return _mupdf.fz_chartorune(rune, str)

def fz_clamp(x, min, max):
    r""" Class-aware wrapper for `::fz_clamp()`."""
    return _mupdf.fz_clamp(x, min, max)

def fz_clamp64(x, min, max):
    r""" Class-aware wrapper for `::fz_clamp64()`."""
    return _mupdf.fz_clamp64(x, min, max)

def fz_clamp_color(cs, _in, out):
    r"""
    Class-aware wrapper for `::fz_clamp_color()`.

    This function has out-params. Python/C# wrappers look like:
    	`fz_clamp_color(::fz_colorspace *cs, const float *in)` => float out

    	Clamp the samples in a color to the correct ranges for a
    	given colorspace.
    """
    return _mupdf.fz_clamp_color(cs, _in, out)

def fz_clamp_location(doc, loc):
    r"""
    Class-aware wrapper for `::fz_clamp_location()`.
    	Clamps a location into valid chapter/page range. (First clamps
    	the chapter into range, then the page into range).
    """
    return _mupdf.fz_clamp_location(doc, loc)

def fz_clampd(x, min, max):
    r""" Class-aware wrapper for `::fz_clampd()`."""
    return _mupdf.fz_clampd(x, min, max)

def fz_clampi(x, min, max):
    r""" Class-aware wrapper for `::fz_clampi()`."""
    return _mupdf.fz_clampi(x, min, max)

def fz_clampp(x, min, max):
    r""" Class-aware wrapper for `::fz_clampp()`."""
    return _mupdf.fz_clampp(x, min, max)

def fz_cleanname(name):
    r"""
    Class-aware wrapper for `::fz_cleanname()`.
    	rewrite path to the shortest string that names the same path.

    	Eliminates multiple and trailing slashes, interprets "." and
    	"..". Overwrites the string in place.
    """
    return _mupdf.fz_cleanname(name)

def fz_cleanname_strdup(name):
    r"""
    Class-aware wrapper for `::fz_cleanname_strdup()`.
    	rewrite path to the shortest string that names the same path.

    	Eliminates multiple and trailing slashes, interprets "." and
    	"..". Allocates a new string that the caller must free.
    """
    return _mupdf.fz_cleanname_strdup(name)

def fz_clear_bitmap(bit):
    r"""
    Class-aware wrapper for `::fz_clear_bitmap()`.
    	Set the entire bitmap to 0.

    	Never throws exceptions.
    """
    return _mupdf.fz_clear_bitmap(bit)

def fz_clear_buffer(buf):
    r"""
    Class-aware wrapper for `::fz_clear_buffer()`.
    	Empties the buffer. Storage is not freed, but is held ready
    	to be reused as the buffer is refilled.

    	Never throws exceptions.
    """
    return _mupdf.fz_clear_buffer(buf)

def fz_clear_pixmap(pix):
    r"""
    Class-aware wrapper for `::fz_clear_pixmap()`.
    	Sets all components (including alpha) of
    	all pixels in a pixmap to 0.

    	pix: The pixmap to clear.
    """
    return _mupdf.fz_clear_pixmap(pix)

def fz_clear_pixmap_rect_with_value(pix, value, r):
    r"""
    Class-aware wrapper for `::fz_clear_pixmap_rect_with_value()`.
    	Clears a subrect of a pixmap with the given value.

    	pix: The pixmap to clear.

    	value: Values in the range 0 to 255 are valid. Each component
    	sample for each pixel in the pixmap will be set to this value,
    	while alpha will always be set to 255 (non-transparent).

    	r: the rectangle.
    """
    return _mupdf.fz_clear_pixmap_rect_with_value(pix, value, r)

def fz_clear_pixmap_with_value(pix, value):
    r"""
    Class-aware wrapper for `::fz_clear_pixmap_with_value()`.
    	Clears a pixmap with the given value.

    	pix: The pixmap to clear.

    	value: Values in the range 0 to 255 are valid. Each component
    	sample for each pixel in the pixmap will be set to this value,
    	while alpha will always be set to 255 (non-transparent).

    	This function is horrible, and should be removed from the
    	API and replaced with a less magic one.
    """
    return _mupdf.fz_clear_pixmap_with_value(pix, value)

def fz_clip_image_mask(dev, image, ctm, scissor):
    r""" Class-aware wrapper for `::fz_clip_image_mask()`."""
    return _mupdf.fz_clip_image_mask(dev, image, ctm, scissor)

def fz_clip_path(dev, path, even_odd, ctm, scissor):
    r""" Class-aware wrapper for `::fz_clip_path()`."""
    return _mupdf.fz_clip_path(dev, path, even_odd, ctm, scissor)

def fz_clip_stroke_path(dev, path, stroke, ctm, scissor):
    r""" Class-aware wrapper for `::fz_clip_stroke_path()`."""
    return _mupdf.fz_clip_stroke_path(dev, path, stroke, ctm, scissor)

def fz_clip_stroke_text(dev, text, stroke, ctm, scissor):
    r""" Class-aware wrapper for `::fz_clip_stroke_text()`."""
    return _mupdf.fz_clip_stroke_text(dev, text, stroke, ctm, scissor)

def fz_clip_text(dev, text, ctm, scissor):
    r""" Class-aware wrapper for `::fz_clip_text()`."""
    return _mupdf.fz_clip_text(dev, text, ctm, scissor)

def fz_clone_buffer(buf):
    r"""
    Class-aware wrapper for `::fz_clone_buffer()`.
    	Make a new buffer, containing a copy of the data used in
    	the original.
    """
    return _mupdf.fz_clone_buffer(buf)

def fz_clone_default_colorspaces(base):
    r"""
    Class-aware wrapper for `::fz_clone_default_colorspaces()`.
    	Returns a reference to a newly cloned default colorspaces
    	structure.

    	The new clone may safely be altered without fear of race
    	conditions as the caller is the only reference holder.
    """
    return _mupdf.fz_clone_default_colorspaces(base)

def fz_clone_path(path):
    r"""
    Class-aware wrapper for `::fz_clone_path()`.
    	Clone the data for a path.

    	This is used in preference to fz_keep_path when a whole
    	new copy of a path is required, rather than just a shared
    	pointer. This probably indicates that the path is about to
    	be modified.

    	path: path to clone.

    	Throws exceptions on failure to allocate.
    """
    return _mupdf.fz_clone_path(path)

def fz_clone_pixmap(old):
    r"""
    Class-aware wrapper for `::fz_clone_pixmap()`.
    	Clone a pixmap, copying the pixels and associated data to new
    	storage.

    	The reference count of 'old' is unchanged.
    """
    return _mupdf.fz_clone_pixmap(old)

def fz_clone_pixmap_area_with_different_seps(src, bbox, dcs, seps, color_params, default_cs):
    r""" Class-aware wrapper for `::fz_clone_pixmap_area_with_different_seps()`."""
    return _mupdf.fz_clone_pixmap_area_with_different_seps(src, bbox, dcs, seps, color_params, default_cs)

def fz_clone_separations_for_overprint(seps):
    r"""
    Class-aware wrapper for `::fz_clone_separations_for_overprint()`.
    	Return a separations object with all the spots in the input
    	separations object that are set to composite, reset to be
    	enabled. If there ARE no spots in the object, this returns
    	NULL. If the object already has all its spots enabled, then
    	just returns another handle on the same object.
    """
    return _mupdf.fz_clone_separations_for_overprint(seps)

def fz_clone_stroke_state(stroke):
    r"""
    Class-aware wrapper for `::fz_clone_stroke_state()`.
    	Create an identical stroke_state structure and return a
    	reference to it.

    	stroke: The stroke state reference to clone.

    	Exceptions may be thrown in the event of a failure to
    	allocate.
    """
    return _mupdf.fz_clone_stroke_state(stroke)

def fz_close_band_writer(writer):
    r"""
    Class-aware wrapper for `::fz_close_band_writer()`.
    	Finishes up the output and closes the band writer. After this
    	call no more headers or bands may be written.
    """
    return _mupdf.fz_close_band_writer(writer)

def fz_close_device(dev):
    r"""
    Class-aware wrapper for `::fz_close_device()`.
    	Signal the end of input, and flush any buffered output.
    	This is NOT called implicitly on fz_drop_device. This
    	may throw exceptions.
    """
    return _mupdf.fz_close_device(dev)

def fz_close_document_writer(wri):
    r"""
    Class-aware wrapper for `::fz_close_document_writer()`.
    	Called to end the process of writing
    	pages to a document.

    	This writes any file level trailers required. After this
    	completes successfully the file is up to date and complete.
    """
    return _mupdf.fz_close_document_writer(wri)

def fz_close_output(arg_0):
    r"""
    Class-aware wrapper for `::fz_close_output()`.
    	Flush pending output and close an output stream.
    """
    return _mupdf.fz_close_output(arg_0)

def fz_close_zip_writer(zip):
    r"""
    Class-aware wrapper for `::fz_close_zip_writer()`.
    	Close the zip file for writing.

    	This flushes any pending data to the file. This can throw
    	exceptions.
    """
    return _mupdf.fz_close_zip_writer(zip)

def fz_closepath(path):
    r"""
    Class-aware wrapper for `::fz_closepath()`.
    	Close the current subpath.

    	path: The path to modify.

    	Throws exceptions on failure to allocate, attempting to modify
    	a packed path, and illegal path closes (i.e. closing a non open
    	path).
    """
    return _mupdf.fz_closepath(path)

def fz_colorspace_colorant(cs, n):
    r"""
    Class-aware wrapper for `::fz_colorspace_colorant()`.
    	Retrieve a the name for a colorant.

    	Returns a pointer with the same lifespan as the colorspace.
    """
    return _mupdf.fz_colorspace_colorant(cs, n)

def fz_colorspace_device_n_has_cmyk(cs):
    r"""
    Class-aware wrapper for `::fz_colorspace_device_n_has_cmyk()`.
    	True if DeviceN color space has cyan magenta yellow or black as
    	one of its colorants.
    """
    return _mupdf.fz_colorspace_device_n_has_cmyk(cs)

def fz_colorspace_device_n_has_only_cmyk(cs):
    r"""
    Class-aware wrapper for `::fz_colorspace_device_n_has_only_cmyk()`.
    	True if DeviceN color space has only colorants from the CMYK set.
    """
    return _mupdf.fz_colorspace_device_n_has_only_cmyk(cs)

def fz_colorspace_is_cmyk(cs):
    r""" Class-aware wrapper for `::fz_colorspace_is_cmyk()`."""
    return _mupdf.fz_colorspace_is_cmyk(cs)

def fz_colorspace_is_device(cs):
    r""" Class-aware wrapper for `::fz_colorspace_is_device()`."""
    return _mupdf.fz_colorspace_is_device(cs)

def fz_colorspace_is_device_cmyk(cs):
    r""" Class-aware wrapper for `::fz_colorspace_is_device_cmyk()`."""
    return _mupdf.fz_colorspace_is_device_cmyk(cs)

def fz_colorspace_is_device_gray(cs):
    r""" Class-aware wrapper for `::fz_colorspace_is_device_gray()`."""
    return _mupdf.fz_colorspace_is_device_gray(cs)

def fz_colorspace_is_device_n(cs):
    r""" Class-aware wrapper for `::fz_colorspace_is_device_n()`."""
    return _mupdf.fz_colorspace_is_device_n(cs)

def fz_colorspace_is_gray(cs):
    r"""
    Class-aware wrapper for `::fz_colorspace_is_gray()`.
    	Tests for particular types of colorspaces
    """
    return _mupdf.fz_colorspace_is_gray(cs)

def fz_colorspace_is_indexed(cs):
    r""" Class-aware wrapper for `::fz_colorspace_is_indexed()`."""
    return _mupdf.fz_colorspace_is_indexed(cs)

def fz_colorspace_is_lab(cs):
    r""" Class-aware wrapper for `::fz_colorspace_is_lab()`."""
    return _mupdf.fz_colorspace_is_lab(cs)

def fz_colorspace_is_lab_icc(cs):
    r""" Class-aware wrapper for `::fz_colorspace_is_lab_icc()`."""
    return _mupdf.fz_colorspace_is_lab_icc(cs)

def fz_colorspace_is_rgb(cs):
    r""" Class-aware wrapper for `::fz_colorspace_is_rgb()`."""
    return _mupdf.fz_colorspace_is_rgb(cs)

def fz_colorspace_is_subtractive(cs):
    r"""
    Class-aware wrapper for `::fz_colorspace_is_subtractive()`.
    	True for CMYK, Separation and DeviceN colorspaces.
    """
    return _mupdf.fz_colorspace_is_subtractive(cs)

def fz_colorspace_n(cs):
    r"""
    Class-aware wrapper for `::fz_colorspace_n()`.
    	Query the number of colorants in a colorspace.
    """
    return _mupdf.fz_colorspace_n(cs)

def fz_colorspace_name(cs):
    r"""
    Class-aware wrapper for `::fz_colorspace_name()`.
    	Query the name of a colorspace.

    	The returned string has the same lifespan as the colorspace
    	does. Caller should not free it.
    """
    return _mupdf.fz_colorspace_name(cs)

def fz_colorspace_name_colorant(cs, n, name):
    r"""
    Class-aware wrapper for `::fz_colorspace_name_colorant()`.
    	Assign a name for a given colorant in a colorspace.

    	Used while initially setting up a colorspace. The string is
    	copied into local storage, so need not be retained by the
    	caller.
    """
    return _mupdf.fz_colorspace_name_colorant(cs, n, name)

def fz_colorspace_type(cs):
    r"""
    Class-aware wrapper for `::fz_colorspace_type()`.
    	Query the type of colorspace.
    """
    return _mupdf.fz_colorspace_type(cs)

def fz_compare_separations(sep1, sep2):
    r"""
    Class-aware wrapper for `::fz_compare_separations()`.
    	Compare 2 separations structures (or NULLs).

    	Return 0 if identical, non-zero if not identical.
    """
    return _mupdf.fz_compare_separations(sep1, sep2)

def fz_compress_ccitt_fax_g3(data, columns, rows, stride):
    r"""
    Class-aware wrapper for `::fz_compress_ccitt_fax_g3()`.
    	Compress bitmap data as CCITT Group 3 1D fax image.
    	Creates a stream assuming the default PDF parameters,
    	except the number of columns.
    """
    return _mupdf.fz_compress_ccitt_fax_g3(data, columns, rows, stride)

def fz_compress_ccitt_fax_g4(data, columns, rows, stride):
    r"""
    Class-aware wrapper for `::fz_compress_ccitt_fax_g4()`.
    	Compress bitmap data as CCITT Group 4 2D fax image.
    	Creates a stream assuming the default PDF parameters, except
    	K=-1 and the number of columns.
    """
    return _mupdf.fz_compress_ccitt_fax_g4(data, columns, rows, stride)

def fz_compressed_buffer_size(buffer):
    r"""
    Class-aware wrapper for `::fz_compressed_buffer_size()`.
    	Return the storage size used for a buffer and its data.
    	Used in implementing store handling.

    	Never throws exceptions.
    """
    return _mupdf.fz_compressed_buffer_size(buffer)

def fz_compressed_image_buffer(image):
    r"""
    Class-aware wrapper for `::fz_compressed_image_buffer()`.
    	Retrieve the underlying compressed data for an image.

    	Returns a pointer to the underlying data buffer for an image,
    	or NULL if this image is not based upon a compressed data
    	buffer.

    	This is not a reference counted structure, so no reference is
    	returned. Lifespan is limited to that of the image itself.
    """
    return _mupdf.fz_compressed_image_buffer(image)

def fz_compressed_image_type(image):
    r"""
    Class-aware wrapper for `::fz_compressed_image_type()`.
    	Return the type of a compressed image.

    	Any non-compressed image will have the type returned as UNKNOWN.
    """
    return _mupdf.fz_compressed_image_type(image)

def fz_concat(left, right):
    r"""
    Class-aware wrapper for `::fz_concat()`.
    	Multiply two matrices.

    	The order of the two matrices are important since matrix
    	multiplication is not commutative.

    	Returns result.
    """
    return _mupdf.fz_concat(left, right)

def fz_contains_rect(a, b):
    r"""
    Class-aware wrapper for `::fz_contains_rect()`.
    	Test rectangle inclusion.

    	Return true if a entirely contains b.
    """
    return _mupdf.fz_contains_rect(a, b)

def fz_convert_color(ss, sv, ds, dv, _is, params):
    r"""
    Class-aware wrapper for `::fz_convert_color()`.

    This function has out-params. Python/C# wrappers look like:
    	`fz_convert_color(::fz_colorspace *ss, const float *sv, ::fz_colorspace *ds, ::fz_colorspace *is, ::fz_color_params params)` => float dv

    	Convert color values sv from colorspace ss into colorvalues dv
    	for colorspace ds, via an optional intervening space is,
    	respecting the given color_params.
    """
    return _mupdf.fz_convert_color(ss, sv, ds, dv, _is, params)

def fz_convert_error(code):
    r"""
    Class-aware wrapper for `::fz_convert_error()`.

    This function has out-params. Python/C# wrappers look like:
    	`fz_convert_error()` => `(const char *, int code)`
    """
    return _mupdf.fz_convert_error(code)

def fz_convert_indexed_pixmap_to_base(src):
    r"""
    Class-aware wrapper for `::fz_convert_indexed_pixmap_to_base()`.
    	Convert pixmap from indexed to base colorspace.

    	This creates a new bitmap containing the converted pixmap data.
    """
    return _mupdf.fz_convert_indexed_pixmap_to_base(src)

def fz_convert_pixmap(pix, cs_des, prf, default_cs, color_params, keep_alpha):
    r"""
    Class-aware wrapper for `::fz_convert_pixmap()`.
    	Convert an existing pixmap to a desired
    	colorspace. Other properties of the pixmap, such as resolution
    	and position are copied to the converted pixmap.

    	pix: The pixmap to convert.

    	default_cs: If NULL pix->colorspace is used. It is possible that
    	the data may need to be interpreted as one of the color spaces
    	in default_cs.

    	cs_des: Desired colorspace, may be NULL to denote alpha-only.

    	prf: Proofing color space through which we need to convert.

    	color_params: Parameters that may be used in conversion (e.g.
    	ri).

    	keep_alpha: If 0 any alpha component is removed, otherwise
    	alpha is kept if present in the pixmap.
    """
    return _mupdf.fz_convert_pixmap(pix, cs_des, prf, default_cs, color_params, keep_alpha)

def fz_convert_separation_colors(src_cs, src_color, dst_seps, dst_cs, dst_color, color_params):
    r"""
    Class-aware wrapper for `::fz_convert_separation_colors()`.

    This function has out-params. Python/C# wrappers look like:
    	`fz_convert_separation_colors(::fz_colorspace *src_cs, const float *src_color, ::fz_separations *dst_seps, ::fz_colorspace *dst_cs, ::fz_color_params color_params)` => float dst_color

    	Convert a color given in terms of one colorspace,
    	to a color in terms of another colorspace/separations.
    """
    return _mupdf.fz_convert_separation_colors(src_cs, src_color, dst_seps, dst_cs, dst_color, color_params)

def fz_convert_separation_pixmap_to_base(src):
    r"""
    Class-aware wrapper for `::fz_convert_separation_pixmap_to_base()`.
    	Convert pixmap from DeviceN/Separation to base colorspace.

    	This creates a new bitmap containing the converted pixmap data.
    """
    return _mupdf.fz_convert_separation_pixmap_to_base(src)

def fz_copy_option(val, dest, maxlen):
    r"""
    Class-aware wrapper for `::fz_copy_option()`.
    	Copy an option (val) into a destination buffer (dest), of maxlen
    	bytes.

    	Returns the number of bytes (including terminator) that did not
    	fit. If val is maxlen or greater bytes in size, it will be left
    	unterminated.
    """
    return _mupdf.fz_copy_option(val, dest, maxlen)

def fz_copy_pixmap_rect(dest, src, r, default_cs):
    r""" Class-aware wrapper for `::fz_copy_pixmap_rect()`."""
    return _mupdf.fz_copy_pixmap_rect(dest, src, r, default_cs)

def fz_copy_rectangle(page, area, crlf):
    r"""
    Class-aware wrapper for `::fz_copy_rectangle()`.
    	Return a newly allocated UTF-8 string with the text for a given
    	selection rectangle.

    	crlf: If true, write "\r\n" style line endings (otherwise "\n"
    	only).
    """
    return _mupdf.fz_copy_rectangle(page, area, crlf)

def fz_copy_selection(page, a, b, crlf):
    r"""
    Class-aware wrapper for `::fz_copy_selection()`.
    	Return a newly allocated UTF-8 string with the text for a given
    	selection.

    	crlf: If true, write "\r\n" style line endings (otherwise "\n"
    	only).
    """
    return _mupdf.fz_copy_selection(page, a, b, crlf)

def fz_count_active_separations(seps):
    r"""
    Class-aware wrapper for `::fz_count_active_separations()`.
    	Return the number of active separations.
    """
    return _mupdf.fz_count_active_separations(seps)

def fz_count_archive_entries(arch):
    r"""
    Class-aware wrapper for `::fz_count_archive_entries()`.
    	Number of entries in archive.

    	Will always return a value >= 0.

    	May throw an exception if this type of archive cannot count the
    	entries (such as a directory).
    """
    return _mupdf.fz_count_archive_entries(arch)

def fz_count_chapter_pages(doc, chapter):
    r"""
    Class-aware wrapper for `::fz_count_chapter_pages()`.
    	Return the number of pages in a chapter.
    	May return 0.
    """
    return _mupdf.fz_count_chapter_pages(doc, chapter)

def fz_count_chapters(doc):
    r"""
    Class-aware wrapper for `::fz_count_chapters()`.
    	Return the number of chapters in the document.
    	At least 1.
    """
    return _mupdf.fz_count_chapters(doc)

def fz_count_pages(doc):
    r"""
    Class-aware wrapper for `::fz_count_pages()`.
    	Return the number of pages in document

    	May return 0 for documents with no pages.
    """
    return _mupdf.fz_count_pages(doc)

def fz_count_separations(sep):
    r""" Class-aware wrapper for `::fz_count_separations()`."""
    return _mupdf.fz_count_separations(sep)

def fz_create_link(page, bbox, uri):
    r"""
    Class-aware wrapper for `::fz_create_link()`.
    	Create a new link on a page.
    """
    return _mupdf.fz_create_link(page, bbox, uri)

def fz_currentpoint(path):
    r"""
    Class-aware wrapper for `::fz_currentpoint()`.
    	Return the current point that a path has
    	reached or (0,0) if empty.

    	path: path to return the current point of.
    """
    return _mupdf.fz_currentpoint(path)

def fz_curveto(path, x0, y0, x1, y1, x2, y2):
    r"""
    Class-aware wrapper for `::fz_curveto()`.
    	Append a 'curveto' command to an open path. (For a
    	cubic bezier).

    	path: The path to modify.

    	x0, y0: The coordinates of the first control point for the
    	curve.

    	x1, y1: The coordinates of the second control point for the
    	curve.

    	x2, y2: The end coordinates for the curve.

    	Throws exceptions on failure to allocate, or attempting to
    	modify a packed path.
    """
    return _mupdf.fz_curveto(path, x0, y0, x1, y1, x2, y2)

def fz_curvetov(path, x1, y1, x2, y2):
    r"""
    Class-aware wrapper for `::fz_curvetov()`.
    	Append a 'curvetov' command to an open path. (For a
    	cubic bezier with the first control coordinate equal to
    	the start point).

    	path: The path to modify.

    	x1, y1: The coordinates of the second control point for the
    	curve.

    	x2, y2: The end coordinates for the curve.

    	Throws exceptions on failure to allocate, or attempting to
    	modify a packed path.
    """
    return _mupdf.fz_curvetov(path, x1, y1, x2, y2)

def fz_curvetoy(path, x0, y0, x2, y2):
    r"""
    Class-aware wrapper for `::fz_curvetoy()`.
    	Append a 'curvetoy' command to an open path. (For a
    	cubic bezier with the second control coordinate equal to
    	the end point).

    	path: The path to modify.

    	x0, y0: The coordinates of the first control point for the
    	curve.

    	x2, y2: The end coordinates for the curve (and the second
    	control coordinate).

    	Throws exceptions on failure to allocate, or attempting to
    	modify a packed path.
    """
    return _mupdf.fz_curvetoy(path, x0, y0, x2, y2)

def fz_debug_store(out):
    r"""
    Class-aware wrapper for `::fz_debug_store()`.
    	Output debugging information for the current state of the store
    	to the given output channel.
    """
    return _mupdf.fz_debug_store(out)

def fz_debug_xml(item, level):
    r"""
    Class-aware wrapper for `::fz_debug_xml()`.
    	Pretty-print an XML tree to stdout. (Deprecated, use
    	fz_output_xml in preference).
    """
    return _mupdf.fz_debug_xml(item, level)

def fz_decode_tile(pix, decode):
    r""" Class-aware wrapper for `::fz_decode_tile()`."""
    return _mupdf.fz_decode_tile(pix, decode)

def fz_decode_uri(s):
    r"""
     Class-aware wrapper for `::fz_decode_uri()`.
    Return a new string representing the unencoded version of the given URI.
    This decodes all escape sequences except those that would result in a reserved
    character that are part of the URI syntax (; / ? : @ & = + $ , #).
    """
    return _mupdf.fz_decode_uri(s)

def fz_decode_uri_component(s):
    r"""
     Class-aware wrapper for `::fz_decode_uri_component()`.
    Return a new string representing the unencoded version of the given URI component.
    This decodes all escape sequences!
    """
    return _mupdf.fz_decode_uri_component(s)

def fz_decomp_image_from_stream(stm, image, subarea, indexed, l2factor, l2extra):
    r"""
    Class-aware wrapper for `::fz_decomp_image_from_stream()`.

    This function has out-params. Python/C# wrappers look like:
    	`fz_decomp_image_from_stream(::fz_stream *stm, ::fz_compressed_image *image, ::fz_irect *subarea, int indexed, int l2factor)` => `(fz_pixmap *, int l2extra)`

    	Decode a subarea of a compressed image. l2factor is the amount
    	of subsampling inbuilt to the stream (i.e. performed by the
    	decoder). If non NULL, l2extra is the extra amount of
    	subsampling that should be performed by this routine. This will
    	be updated on exit to the amount of subsampling that is still
    	required to be done.

    	Returns a kept reference.
    """
    return _mupdf.fz_decomp_image_from_stream(stm, image, subarea, indexed, l2factor, l2extra)

def fz_decouple_type3_font(font, t3doc):
    r""" Class-aware wrapper for `::fz_decouple_type3_font()`."""
    return _mupdf.fz_decouple_type3_font(font, t3doc)

def fz_default_cmyk(default_cs):
    r""" Class-aware wrapper for `::fz_default_cmyk()`."""
    return _mupdf.fz_default_cmyk(default_cs)

def fz_default_error_callback(user, message):
    r"""
    Class-aware wrapper for `::fz_default_error_callback()`.
    	FIXME: Better not to expose fz_default_error_callback, and
    	fz_default_warning callback and to allow 'NULL' to be used
    	int fz_set_xxxx_callback to mean "defaults".

    	FIXME: Do we need/want functions like
    	fz_error_callback(ctx, message) to allow callers to inject
    	stuff into the error/warning streams?

    	The default error callback. Declared publicly just so that the
    	error callback can be set back to this after it has been
    	overridden.
    """
    return _mupdf.fz_default_error_callback(user, message)

def fz_default_gray(default_cs):
    r"""
    Class-aware wrapper for `::fz_default_gray()`.
    	Retrieve default colorspaces (typically page local).

    	If default_cs is non NULL, the default is retrieved from there,
    	otherwise the global default is retrieved.

    	These return borrowed references that should not be dropped,
    	unless they are kept first.
    """
    return _mupdf.fz_default_gray(default_cs)

def fz_default_halftone(num_comps):
    r"""
    Class-aware wrapper for `::fz_default_halftone()`.
    	Create a 'default' halftone structure
    	for the given number of components.

    	num_comps: The number of components to use.

    	Returns a simple default halftone. The default halftone uses
    	the same halftone tile for each plane, which may not be ideal
    	for all purposes.
    """
    return _mupdf.fz_default_halftone(num_comps)

def fz_default_output_intent(default_cs):
    r""" Class-aware wrapper for `::fz_default_output_intent()`."""
    return _mupdf.fz_default_output_intent(default_cs)

def fz_default_rgb(default_cs):
    r""" Class-aware wrapper for `::fz_default_rgb()`."""
    return _mupdf.fz_default_rgb(default_cs)

def fz_default_warning_callback(user, message):
    r"""
    Class-aware wrapper for `::fz_default_warning_callback()`.
    	The default warning callback. Declared publicly just so that
    	the warning callback can be set back to this after it has been
    	overridden.
    """
    return _mupdf.fz_default_warning_callback(user, message)

def fz_defer_reap_end():
    r"""
    Class-aware wrapper for `::fz_defer_reap_end()`.
    	Decrement the defer reap count.

    	If the defer reap count returns to 0, and the store
    	has reapable objects in, a reap pass will begin.

    	Call this at the end of a process during which you
    	potentially might drop many reapable objects.

    	It is vital that every fz_defer_reap_start is matched
    	by a fz_defer_reap_end call.
    """
    return _mupdf.fz_defer_reap_end()

def fz_defer_reap_start():
    r"""
    Class-aware wrapper for `::fz_defer_reap_start()`.
    	Increment the defer reap count.

    	No reap operations will take place (except for those
    	triggered by an immediate failed malloc) until the
    	defer reap count returns to 0.

    	Call this at the start of a process during which you
    	potentially might drop many reapable objects.

    	It is vital that every fz_defer_reap_start is matched
    	by a fz_defer_reap_end call.
    """
    return _mupdf.fz_defer_reap_start()

def fz_deflate(dest, compressed_length, source, source_length, level):
    r"""
     Class-aware wrapper for `::fz_deflate()`.

    	This function has out-params. Python/C# wrappers look like:
    		`fz_deflate(unsigned char *dest, const unsigned char *source, size_t source_length, ::fz_deflate_level level)` => size_t compressed_length

    		Compress source_length bytes of data starting
    		at source, into a buffer of length *destLen, starting at dest.
    compressed_length will be updated on exit to contain the size
    		actually used.
    """
    return _mupdf.fz_deflate(dest, compressed_length, source, source_length, level)

def fz_deflate_bound(size):
    r"""
    Class-aware wrapper for `::fz_deflate_bound()`.
    	Returns the upper bound on the
    	size of flated data of length size.
    """
    return _mupdf.fz_deflate_bound(size)

def fz_delete_link(page, link):
    r"""
    Class-aware wrapper for `::fz_delete_link()`.
    	Delete an existing link on a page.
    """
    return _mupdf.fz_delete_link(page, link)

def fz_detach_xml(node):
    r"""
    Class-aware wrapper for `::fz_detach_xml()`.
    	Detach a node from the tree, unlinking it from its parent,
    	and setting the document root to the node.
    """
    return _mupdf.fz_detach_xml(node)

def fz_device_bgr():
    r""" Class-aware wrapper for `::fz_device_bgr()`."""
    return _mupdf.fz_device_bgr()

def fz_device_cmyk():
    r""" Class-aware wrapper for `::fz_device_cmyk()`."""
    return _mupdf.fz_device_cmyk()

def fz_device_current_scissor(dev):
    r"""
    Class-aware wrapper for `::fz_device_current_scissor()`.
    	Find current scissor region as tracked by the device.
    """
    return _mupdf.fz_device_current_scissor(dev)

def fz_device_gray():
    r"""
    Class-aware wrapper for `::fz_device_gray()`.
    	Retrieve global default colorspaces.

    	These return borrowed references that should not be dropped,
    	unless they are kept first.
    """
    return _mupdf.fz_device_gray()

def fz_device_lab():
    r""" Class-aware wrapper for `::fz_device_lab()`."""
    return _mupdf.fz_device_lab()

def fz_device_rgb():
    r""" Class-aware wrapper for `::fz_device_rgb()`."""
    return _mupdf.fz_device_rgb()

def fz_dirname(dir, path, dirsize):
    r"""
    Class-aware wrapper for `::fz_dirname()`.
    	extract the directory component from a path.
    """
    return _mupdf.fz_dirname(dir, path, dirsize)

def fz_disable_device_hints(dev, hints):
    r"""
    Class-aware wrapper for `::fz_disable_device_hints()`.
    	Disable (clear) hint bits within the hint bitfield for a device.
    """
    return _mupdf.fz_disable_device_hints(dev, hints)

def fz_disable_icc():
    r"""
    Class-aware wrapper for `::fz_disable_icc()`.
    	Disable icc profile based operation.
    """
    return _mupdf.fz_disable_icc()

def fz_display_list_is_empty(list):
    r"""
    Class-aware wrapper for `::fz_display_list_is_empty()`.
    	Check for a display list being empty

    	list: The list to check.

    	Returns true if empty, false otherwise.
    """
    return _mupdf.fz_display_list_is_empty(list)

def fz_div255(c, a):
    r"""
    Class-aware wrapper for `::fz_div255()`.
    	Undo alpha premultiplication.
    """
    return _mupdf.fz_div255(c, a)

def fz_do_always():
    r""" Class-aware wrapper for `::fz_do_always()`."""
    return _mupdf.fz_do_always()

def fz_do_catch():
    r""" Class-aware wrapper for `::fz_do_catch()`."""
    return _mupdf.fz_do_catch()

def fz_do_try():
    r""" Class-aware wrapper for `::fz_do_try()`."""
    return _mupdf.fz_do_try()

def fz_document_open_fn_call(fn, stream, accel, dir):
    r"""
    Class-aware wrapper for `::fz_document_open_fn_call()`.   Helper for calling a `fz_document_open_fn` function pointer via Swig
    from Python/C#.
    """
    return _mupdf.fz_document_open_fn_call(fn, stream, accel, dir)

def fz_document_output_intent(doc):
    r"""
    Class-aware wrapper for `::fz_document_output_intent()`.
    	Find the output intent colorspace if the document has defined
    	one.

    	Returns a borrowed reference that should not be dropped, unless
    	it is kept first.
    """
    return _mupdf.fz_document_output_intent(doc)

def fz_document_recognize_content_fn_call(fn, stream, dir):
    r"""
    Class-aware wrapper for `::fz_document_recognize_content_fn_call()`.   Helper for calling a `fz_document_recognize_content_fn` function
    pointer via Swig from Python/C#.
    """
    return _mupdf.fz_document_recognize_content_fn_call(fn, stream, dir)

def fz_document_supports_accelerator(doc):
    r"""
    Class-aware wrapper for `::fz_document_supports_accelerator()`.
    	Query if the document supports the saving of accelerator data.
    """
    return _mupdf.fz_document_supports_accelerator(doc)

def fz_dom_add_attribute(elt, att, value):
    r"""
    Class-aware wrapper for `::fz_dom_add_attribute()`.
    	Add an attribute to an element.

    	Ownership of att and value remain with the caller.
    """
    return _mupdf.fz_dom_add_attribute(elt, att, value)

def fz_dom_append_child(parent, child):
    r"""
    Class-aware wrapper for `::fz_dom_append_child()`.
    	Insert an element as the last child of a parent, unlinking the
    	child from its current position if required.
    """
    return _mupdf.fz_dom_append_child(parent, child)

def fz_dom_attribute(elt, att):
    r"""
    Class-aware wrapper for `::fz_dom_attribute()`.
    	Retrieve the value of a given attribute from a given element.

    	Returns a borrowed pointer to the value or NULL if not found.
    """
    return _mupdf.fz_dom_attribute(elt, att)

def fz_dom_body(dom):
    r"""
    Class-aware wrapper for `::fz_dom_body()`.
    	Return a borrowed reference for the 'body' element of
    	the given DOM.
    """
    return _mupdf.fz_dom_body(dom)

def fz_dom_clone(elt):
    r"""
    Class-aware wrapper for `::fz_dom_clone()`.
    	Clone an element (and its children).

    	A borrowed reference to the clone is returned. The clone is not
    	yet linked into the DOM.
    """
    return _mupdf.fz_dom_clone(elt)

def fz_dom_create_element(dom, tag):
    r"""
    Class-aware wrapper for `::fz_dom_create_element()`.
    	Create an element of a given tag type for the given DOM.

    	The element is not linked into the DOM yet.
    """
    return _mupdf.fz_dom_create_element(dom, tag)

def fz_dom_create_text_node(dom, text):
    r"""
    Class-aware wrapper for `::fz_dom_create_text_node()`.
    	Create a text node for the given DOM.

    	The element is not linked into the DOM yet.
    """
    return _mupdf.fz_dom_create_text_node(dom, text)

def fz_dom_document_element(dom):
    r"""
    Class-aware wrapper for `::fz_dom_document_element()`.
    	Return a borrowed reference for the document (the top
    	level element) of the DOM.
    """
    return _mupdf.fz_dom_document_element(dom)

def fz_dom_find(elt, tag, att, match):
    r"""
    Class-aware wrapper for `::fz_dom_find()`.
    	Find the first element matching the requirements in a depth first traversal from elt.

    	The tagname must match tag, unless tag is NULL, when all tag names are considered to match.

    	If att is NULL, then all tags match.
    	Otherwise:
    		If match is NULL, then only nodes that have an att attribute match.
    		If match is non-NULL, then only nodes that have an att attribute that matches match match.

    	Returns NULL (if no match found), or a borrowed reference to the first matching element.
    """
    return _mupdf.fz_dom_find(elt, tag, att, match)

def fz_dom_find_next(elt, tag, att, match):
    r"""
    Class-aware wrapper for `::fz_dom_find_next()`.
    	Find the next element matching the requirements.
    """
    return _mupdf.fz_dom_find_next(elt, tag, att, match)

def fz_dom_first_child(elt):
    r"""
    Class-aware wrapper for `::fz_dom_first_child()`.
    	Return a borrowed reference to the first child of a node,
    	or NULL if there isn't one.
    """
    return _mupdf.fz_dom_first_child(elt)

def fz_dom_get_attribute(elt, i, att):
    r"""
    Class-aware wrapper for `::fz_dom_get_attribute()`.

    This function has out-params. Python/C# wrappers look like:
    	`fz_dom_get_attribute(::fz_xml *elt, int i)` => `(const char *, const char *att)`

    	Enumerate through the attributes of an element.

    	Call with i=0,1,2,3... to enumerate attributes.

    	On return *att and the return value will be NULL if there are not
    	that many attributes to read. Otherwise, *att will be filled in
    	with a borrowed pointer to the attribute name, and the return
    	value will be a borrowed pointer to the value.
    """
    return _mupdf.fz_dom_get_attribute(elt, i, att)

def fz_dom_insert_after(node, new_elt):
    r"""
    Class-aware wrapper for `::fz_dom_insert_after()`.
    	Insert an element (new_elt), after another element (node),
    	unlinking the new_elt from its current position if required.
    """
    return _mupdf.fz_dom_insert_after(node, new_elt)

def fz_dom_insert_before(node, new_elt):
    r"""
    Class-aware wrapper for `::fz_dom_insert_before()`.
    	Insert an element (new_elt), before another element (node),
    	unlinking the new_elt from its current position if required.
    """
    return _mupdf.fz_dom_insert_before(node, new_elt)

def fz_dom_next(elt):
    r"""
    Class-aware wrapper for `::fz_dom_next()`.
    	Return a borrowed reference to the next sibling of a node,
    	or NULL if there isn't one.
    """
    return _mupdf.fz_dom_next(elt)

def fz_dom_parent(elt):
    r"""
    Class-aware wrapper for `::fz_dom_parent()`.
    	Return a borrowed reference to the parent of a node,
    	or NULL if there isn't one.
    """
    return _mupdf.fz_dom_parent(elt)

def fz_dom_previous(elt):
    r"""
    Class-aware wrapper for `::fz_dom_previous()`.
    	Return a borrowed reference to the previous sibling of a node,
    	or NULL if there isn't one.
    """
    return _mupdf.fz_dom_previous(elt)

def fz_dom_remove(elt):
    r"""
    Class-aware wrapper for `::fz_dom_remove()`.
    	Remove an element from the DOM. The element can be added back elsewhere
    	if required.

    	No reference counting changes for the element.
    """
    return _mupdf.fz_dom_remove(elt)

def fz_dom_remove_attribute(elt, att):
    r"""
    Class-aware wrapper for `::fz_dom_remove_attribute()`.
    	Remove an attribute from an element.
    """
    return _mupdf.fz_dom_remove_attribute(elt, att)

def fz_draw_story(story, dev, ctm):
    r""" Class-aware wrapper for `::fz_draw_story()`."""
    return _mupdf.fz_draw_story(story, dev, ctm)

def fz_dump_glyph_cache_stats(out):
    r"""
    Class-aware wrapper for `::fz_dump_glyph_cache_stats()`.
    	Dump debug statistics for the glyph cache.
    """
    return _mupdf.fz_dump_glyph_cache_stats(out)

def fz_duplicate_glyph_names_from_unicode(unicode):
    r""" Class-aware wrapper for `::fz_duplicate_glyph_names_from_unicode()`."""
    return _mupdf.fz_duplicate_glyph_names_from_unicode(unicode)

def fz_empty_store():
    r"""
    Class-aware wrapper for `::fz_empty_store()`.
    	Evict every item from the store.
    """
    return _mupdf.fz_empty_store()

def fz_enable_device_hints(dev, hints):
    r"""
    Class-aware wrapper for `::fz_enable_device_hints()`.
    	Enable (set) hint bits within the hint bitfield for a device.
    """
    return _mupdf.fz_enable_device_hints(dev, hints)

def fz_enable_icc():
    r"""
    Class-aware wrapper for `::fz_enable_icc()`.
    	Enable icc profile based operation.
    """
    return _mupdf.fz_enable_icc()

def fz_encode_character(font, unicode):
    r"""
    Class-aware wrapper for `::fz_encode_character()`.
    	Find the glyph id for a given unicode
    	character within a font.

    	font: The font to look for the unicode character in.

    	unicode: The unicode character to encode.

    	Returns the glyph id for the given unicode value, or 0 if
    	unknown.
    """
    return _mupdf.fz_encode_character(font, unicode)

def fz_encode_character_by_glyph_name(font, glyphname):
    r"""
    Class-aware wrapper for `::fz_encode_character_by_glyph_name()`.
    	Encode character.

    	Either by direct lookup of glyphname within a font, or, failing
    	that, by mapping glyphname to unicode and thence to the glyph
    	index within the given font.

    	Returns zero for type3 fonts.
    """
    return _mupdf.fz_encode_character_by_glyph_name(font, glyphname)

def fz_encode_character_sc(font, unicode):
    r"""
    Class-aware wrapper for `::fz_encode_character_sc()`.
    	Encode character, preferring small-caps variant if available.

    	font: The font to look for the unicode character in.

    	unicode: The unicode character to encode.

    	Returns the glyph id for the given unicode value, or 0 if
    	unknown.
    """
    return _mupdf.fz_encode_character_sc(font, unicode)

def fz_encode_character_with_fallback(font, unicode, script, language, out_font):
    r"""
    Class-aware wrapper for `::fz_encode_character_with_fallback()`.

    This function has out-params. Python/C# wrappers look like:
    	`fz_encode_character_with_fallback(::fz_font *font, int unicode, int script, int language, ::fz_font **out_font)` => `(int)`

    	Find the glyph id for
    	a given unicode character within a font, falling back to
    	an alternative if not found.

    	font: The font to look for the unicode character in.

    	unicode: The unicode character to encode.

    	script: The script in use.

    	language: The language in use.

    	out_font: The font handle in which the given glyph represents
    	the requested unicode character. The caller does not own the
    	reference it is passed, so should call fz_keep_font if it is
    	not simply to be used immediately.

    	Returns the glyph id for the given unicode value in the supplied
    	font (and sets *out_font to font) if it is present. Otherwise
    	an alternative fallback font (based on script/language) is
    	searched for. If the glyph is found therein, *out_font is set
    	to this reference, and the glyph reference is returned. If it
    	cannot be found anywhere, the function returns 0.
    """
    return _mupdf.fz_encode_character_with_fallback(font, unicode, script, language, out_font)

def fz_encode_uri(s):
    r"""
     Class-aware wrapper for `::fz_encode_uri()`.
    Return a new string representing the provided string encoded as a URI.
    """
    return _mupdf.fz_encode_uri(s)

def fz_encode_uri_component(s):
    r"""
     Class-aware wrapper for `::fz_encode_uri_component()`.
    Return a new string representing the provided string encoded as an URI component.
    This also encodes the special reserved characters (; / ? : @ & = + $ , #).
    """
    return _mupdf.fz_encode_uri_component(s)

def fz_encode_uri_pathname(s):
    r"""
     Class-aware wrapper for `::fz_encode_uri_pathname()`.
    Return a new string representing the provided string encoded as an URI path name.
    This also encodes the special reserved characters except /.
    """
    return _mupdf.fz_encode_uri_pathname(s)

def fz_end_group(dev):
    r""" Class-aware wrapper for `::fz_end_group()`."""
    return _mupdf.fz_end_group(dev)

def fz_end_layer(dev):
    r""" Class-aware wrapper for `::fz_end_layer()`."""
    return _mupdf.fz_end_layer(dev)

def fz_end_mask(dev):
    r""" Class-aware wrapper for `::fz_end_mask()`."""
    return _mupdf.fz_end_mask(dev)

def fz_end_mask_tr(dev, fn):
    r""" Class-aware wrapper for `::fz_end_mask_tr()`."""
    return _mupdf.fz_end_mask_tr(dev, fn)

def fz_end_metatext(dev):
    r""" Class-aware wrapper for `::fz_end_metatext()`."""
    return _mupdf.fz_end_metatext(dev)

def fz_end_page(wri):
    r"""
    Class-aware wrapper for `::fz_end_page()`.
    	Called to end the process of writing a page to a
    	document.
    """
    return _mupdf.fz_end_page(wri)

def fz_end_structure(dev):
    r""" Class-aware wrapper for `::fz_end_structure()`."""
    return _mupdf.fz_end_structure(dev)

def fz_end_throw_on_repair():
    r""" Class-aware wrapper for `::fz_end_throw_on_repair()`."""
    return _mupdf.fz_end_throw_on_repair()

def fz_end_tile(dev):
    r""" Class-aware wrapper for `::fz_end_tile()`."""
    return _mupdf.fz_end_tile(dev)

def fz_error_callback(user):
    r"""
    Class-aware wrapper for `::fz_error_callback()`.

    This function has out-params. Python/C# wrappers look like:
    	`fz_error_callback()` => `(fz_error_cb *, void *user)`

    	Retrieve the currently set error callback, or NULL if none
    	has been set. Optionally, if user is non-NULL, the user pointer
    	given when the warning callback was set is also passed back to
    	the caller.
    """
    return _mupdf.fz_error_callback(user)

def fz_eval_function(func, _in, inlen, out, outlen):
    r"""
    Class-aware wrapper for `::fz_eval_function()`.

    This function has out-params. Python/C# wrappers look like:
    	`fz_eval_function(::fz_function *func, const float *in, int inlen, int outlen)` => float out
    """
    return _mupdf.fz_eval_function(func, _in, inlen, out, outlen)

def fz_expand_irect(a, expand):
    r""" Class-aware wrapper for `::fz_expand_irect()`."""
    return _mupdf.fz_expand_irect(a, expand)

def fz_expand_rect(b, expand):
    r"""
    Class-aware wrapper for `::fz_expand_rect()`.
    	Expand a bbox by a given amount in all directions.
    """
    return _mupdf.fz_expand_rect(b, expand)

def fz_extract_ttf_from_ttc(font):
    r""" Class-aware wrapper for `::fz_extract_ttf_from_ttc()`."""
    return _mupdf.fz_extract_ttf_from_ttc(font)

def fz_file_exists(path):
    r"""
    Class-aware wrapper for `::fz_file_exists()`.
    	Return true if the named file exists and is readable.
    """
    return _mupdf.fz_file_exists(path)

def fz_fill_image(dev, image, ctm, alpha, color_params):
    r""" Class-aware wrapper for `::fz_fill_image()`."""
    return _mupdf.fz_fill_image(dev, image, ctm, alpha, color_params)

def fz_fill_image_mask(dev, image, ctm, colorspace, color, alpha, color_params):
    r""" Class-aware wrapper for `::fz_fill_image_mask()`."""
    return _mupdf.fz_fill_image_mask(dev, image, ctm, colorspace, color, alpha, color_params)

def fz_fill_path(dev, path, even_odd, ctm, colorspace, color, alpha, color_params):
    r"""
    Class-aware wrapper for `::fz_fill_path()`.
    	Device calls; graphics primitives and containers.
    """
    return _mupdf.fz_fill_path(dev, path, even_odd, ctm, colorspace, color, alpha, color_params)

def fz_fill_pixmap_from_display_list(list, ctm, pix):
    r""" Class-aware wrapper for `::fz_fill_pixmap_from_display_list()`."""
    return _mupdf.fz_fill_pixmap_from_display_list(list, ctm, pix)

def fz_fill_pixmap_with_color(pix, colorspace, color, color_params):
    r"""
    Class-aware wrapper for `::fz_fill_pixmap_with_color()`.

    This function has out-params. Python/C# wrappers look like:
    	`fz_fill_pixmap_with_color(::fz_pixmap *pix, ::fz_colorspace *colorspace, ::fz_color_params color_params)` => float color

    	Fill pixmap with solid color.
    """
    return _mupdf.fz_fill_pixmap_with_color(pix, colorspace, color, color_params)

def fz_fill_shade(dev, shade, ctm, alpha, color_params):
    r""" Class-aware wrapper for `::fz_fill_shade()`."""
    return _mupdf.fz_fill_shade(dev, shade, ctm, alpha, color_params)

def fz_fill_text(dev, text, ctm, colorspace, color, alpha, color_params):
    r""" Class-aware wrapper for `::fz_fill_text()`."""
    return _mupdf.fz_fill_text(dev, text, ctm, colorspace, color, alpha, color_params)

def fz_filter_store(fn, arg, type):
    r"""
    Class-aware wrapper for `::fz_filter_store()`.
    	Filter every element in the store with a matching type with the
    	given function.

    	If the function returns 1 for an element, drop the element.
    """
    return _mupdf.fz_filter_store(fn, arg, type)

def fz_find_item(drop, key, type):
    r"""
    Class-aware wrapper for `::fz_find_item()`.
    	Find an item within the store.

    	drop: The function used to free the value (to ensure we get a
    	value of the correct type).

    	key: The key used to index the item.

    	type: Functions used to manipulate the key.

    	Returns NULL for not found, otherwise returns a pointer to the
    	value indexed by key to which a reference has been taken.
    """
    return _mupdf.fz_find_item(drop, key, type)

def fz_flush_output(out):
    r"""
    Class-aware wrapper for `::fz_flush_output()`.
    	Flush unwritten data.
    """
    return _mupdf.fz_flush_output(out)

def fz_flush_warnings():
    r"""
    Class-aware wrapper for `::fz_flush_warnings()`.
    	Flush any repeated warnings.

    	Repeated warnings are buffered, counted and eventually printed
    	along with the number of repetitions. Call fz_flush_warnings
    	to force printing of the latest buffered warning and the
    	number of repetitions, for example to make sure that all
    	warnings are printed before exiting an application.
    """
    return _mupdf.fz_flush_warnings()

def fz_font_ascender(font):
    r"""
    Class-aware wrapper for `::fz_font_ascender()`.
    	Retrieve font ascender in ems.
    """
    return _mupdf.fz_font_ascender(font)

def fz_font_bbox(font):
    r"""
    Class-aware wrapper for `::fz_font_bbox()`.
    	Retrieve the font bbox.

    	font: The font to query.

    	Returns the font bbox by value; it is valid only if
    	fz_font_flags(font)->invalid_bbox is zero.
    """
    return _mupdf.fz_font_bbox(font)

def fz_font_descender(font):
    r"""
    Class-aware wrapper for `::fz_font_descender()`.
    	Retrieve font descender in ems.
    """
    return _mupdf.fz_font_descender(font)

def fz_font_digest(font, digest):
    r"""
    Class-aware wrapper for `::fz_font_digest()`.
    	Retrieve the MD5 digest for the font's data.
    """
    return _mupdf.fz_font_digest(font, digest)

def fz_font_ft_face(font):
    r"""
    Class-aware wrapper for `::fz_font_ft_face()`.
    	Retrieve the FT_Face handle
    	for the font.

    	font: The font to query

    	Returns the FT_Face handle for the font, or NULL
    	if not a freetype handled font. (Cast to void *
    	to avoid nasty header exposure).
    """
    return _mupdf.fz_font_ft_face(font)

def fz_font_is_bold(font):
    r"""
    Class-aware wrapper for `::fz_font_is_bold()`.
    	Query whether the font flags say that this font is bold.
    """
    return _mupdf.fz_font_is_bold(font)

def fz_font_is_italic(font):
    r"""
    Class-aware wrapper for `::fz_font_is_italic()`.
    	Query whether the font flags say that this font is italic.
    """
    return _mupdf.fz_font_is_italic(font)

def fz_font_is_monospaced(font):
    r"""
    Class-aware wrapper for `::fz_font_is_monospaced()`.
    	Query whether the font flags say that this font is monospaced.
    """
    return _mupdf.fz_font_is_monospaced(font)

def fz_font_is_serif(font):
    r"""
    Class-aware wrapper for `::fz_font_is_serif()`.
    	Query whether the font flags say that this font is serif.
    """
    return _mupdf.fz_font_is_serif(font)

def fz_font_name(font):
    r"""
    Class-aware wrapper for `::fz_font_name()`.
    	Retrieve a pointer to the name of the font.

    	font: The font to query.

    	Returns a pointer to an internal copy of the font name.
    	Will never be NULL, but may be the empty string.
    """
    return _mupdf.fz_font_name(font)

def fz_font_t3_procs(font):
    r"""
    Class-aware wrapper for `::fz_font_t3_procs()`.
    	Retrieve the Type3 procs
    	for a font.

    	font: The font to query

    	Returns the t3_procs pointer. Will be NULL for a
    	non type-3 font.
    """
    return _mupdf.fz_font_t3_procs(font)

def fz_format_double(fmt, value):
    r"""
    Class-aware wrapper for `::fz_format_double()`.   Swig-friendly and typesafe way to do fz_snprintf(fmt, value). `fmt`
    must end with one of 'efg' otherwise we throw an exception.
    """
    return _mupdf.fz_format_double(fmt, value)

def fz_format_link_uri(doc, dest):
    r"""
    Class-aware wrapper for `::fz_format_link_uri()`.
    	Format an internal link to a page number, location, and possible viewing parameters,
    	suitable for use with fz_create_link.

    	Returns a newly allocated string that the caller must free.
    """
    return _mupdf.fz_format_link_uri(doc, dest)

def fz_format_output_path(path, size, fmt, page):
    r"""
    Class-aware wrapper for `::fz_format_output_path()`.
    	create output file name using a template.

    	If the path contains %[0-9]*d, the first such pattern will be
    	replaced with the page number. If the template does not contain
    	such a pattern, the page number will be inserted before the
    	filename extension. If the template does not have a filename
    	extension, the page number will be added to the end.
    """
    return _mupdf.fz_format_output_path(path, size, fmt, page)

def fz_free(p):
    r"""
    Class-aware wrapper for `::fz_free()`.
    	Free a previously allocated block of memory.

    	fz_free(ctx, NULL) does nothing.

    	Never throws exceptions.
    """
    return _mupdf.fz_free(p)

def fz_ft_lock():
    r""" Class-aware wrapper for `::fz_ft_lock()`."""
    return _mupdf.fz_ft_lock()

def fz_ft_lock_held():
    r""" Class-aware wrapper for `::fz_ft_lock_held()`."""
    return _mupdf.fz_ft_lock_held()

def fz_ft_unlock():
    r""" Class-aware wrapper for `::fz_ft_unlock()`."""
    return _mupdf.fz_ft_unlock()

def fz_function_size(func):
    r""" Class-aware wrapper for `::fz_function_size()`."""
    return _mupdf.fz_function_size(func)

def fz_gamma_pixmap(pix, gamma):
    r"""
    Class-aware wrapper for `::fz_gamma_pixmap()`.
    	Apply gamma correction to a pixmap. All components
    	of all pixels are modified (except alpha, which is unchanged).

    	gamma: The gamma value to apply; 1.0 for no change.
    """
    return _mupdf.fz_gamma_pixmap(pix, gamma)

def fz_generate_transition(tpix, opix, npix, time, trans):
    r"""
    Class-aware wrapper for `::fz_generate_transition()`.
    	Generate a frame of a transition.

    	tpix: Target pixmap
    	opix: Old pixmap
    	npix: New pixmap
    	time: Position within the transition (0 to 256)
    	trans: Transition details

    	Returns 1 if successfully generated a frame.

    	Note: Pixmaps must include alpha.
    """
    return _mupdf.fz_generate_transition(tpix, opix, npix, time, trans)

def fz_get_glyph_name(font, glyph, buf, size):
    r"""
    Class-aware wrapper for `::fz_get_glyph_name()`.
    	Find the name of a glyph

    	font: The font to look for the glyph in.

    	glyph: The glyph id to look for.

    	buf: Pointer to a buffer for the name to be inserted into.

    	size: The size of the buffer.

    	If a font contains a name table, then the name of the glyph
    	will be returned in the supplied buffer. Otherwise a name
    	is synthesised. The name will be truncated to fit in
    	the buffer.
    """
    return _mupdf.fz_get_glyph_name(font, glyph, buf, size)

def fz_get_glyph_name2(font, glyph):
    r"""
    Class-aware wrapper for `::fz_get_glyph_name2()`.
    C++ alternative to fz_get_glyph_name() that returns information in a std::string.
    """
    return _mupdf.fz_get_glyph_name2(font, glyph)

def fz_get_pixmap_from_image(image, subarea, ctm, w, h):
    r"""
    Class-aware wrapper for `::fz_get_pixmap_from_image()`.

    This function has out-params. Python/C# wrappers look like:
    	`fz_get_pixmap_from_image(::fz_image *image, const ::fz_irect *subarea, ::fz_matrix *ctm)` => `(fz_pixmap *, int w, int h)`

    	Called to get a handle to a pixmap from an image.

    	image: The image to retrieve a pixmap from.

    	subarea: The subarea of the image that we actually care about
    	(or NULL to indicate the whole image).

    	ctm: Optional, unless subarea is given. If given, then on
    	entry this is the transform that will be applied to the complete
    	image. It should be updated on exit to the transform to apply to
    	the given subarea of the image. This is used to calculate the
    	desired width/height for subsampling.

    	w: If non-NULL, a pointer to an int to be updated on exit to the
    	width (in pixels) that the scaled output will cover.

    	h: If non-NULL, a pointer to an int to be updated on exit to the
    	height (in pixels) that the scaled output will cover.

    	Returns a non NULL kept pixmap pointer. May throw exceptions.
    """
    return _mupdf.fz_get_pixmap_from_image(image, subarea, ctm, w, h)

def fz_get_unscaled_pixmap_from_image(image):
    r"""
    Class-aware wrapper for `::fz_get_unscaled_pixmap_from_image()`.
    	Calls fz_get_pixmap_from_image() with ctm, subarea, w and h all set to NULL.
    """
    return _mupdf.fz_get_unscaled_pixmap_from_image(image)

def fz_getopt(nargc, nargv, ostr):
    r"""
    Class-aware wrapper for `::fz_getopt()`.

    This function has out-params. Python/C# wrappers look like:
    	`fz_getopt(int nargc, const char *ostr)` => `(int, char *nargv)`

    	Identical to fz_getopt_long, but with a NULL longopts field, signifying no long
    	options.
    """
    return _mupdf.fz_getopt(nargc, nargv, ostr)

def fz_getopt_long(nargc, nargv, ostr, longopts):
    r"""
    Class-aware wrapper for `::fz_getopt_long()`.

    This function has out-params. Python/C# wrappers look like:
    	`fz_getopt_long(int nargc, const char *ostr, const ::fz_getopt_long_options *longopts)` => `(int, char *nargv)`

    	Simple functions/variables for use in tools.

    	ostr = option string. Comprises single letter options, followed by : if there
    	is an argument to the option.

    	longopts: NULL (indicating no long options), or a pointer to an array of
    	longoptions, terminated by an entry with option == NULL.

    	In the event of matching a single char option, this function will normally
    	return the char. The exception to this is when the option requires an
    	argument and none is supplied; in this case we return ':'.

    	In the event of matching a long option, this function returns 0, with fz_optlong
    	set to point to the matching option.

    	A long option entry may be followed with : to indicate there is an argument to the
    	option. If the need for an argument is specified in this way, and no argument is
    	given, an error will be displayed and argument processing will stop. If an argument
    	is given, and the long option record contains a non-null flag pointer, then the code
    	will decode the argument and fill in that flag pointer. Specifically,
    	case-insensitive matches to 'yes', 'no', 'true' and 'false' will cause a value of 0
    	or 1 as appropriate to be written; failing this the arg will be interpreted as a
    	decimal integer using atoi.

    	A long option entry may be followed by an list of options (e.g. myoption=foo|bar|baz)
    	and the option will be passed to fz_opt_from_list. The return value of that will be
    	placed in fz_optitem. If the return value of that function is -1, then an error will
    	be displayed and argument processing will stop.

    	In the event of reaching the end of the arg list or '--', this function returns EOF.

    	In the event of failing to match anything, an error is printed, and we return '?'.

    	If an argument is expected for the option, then fz_optarg will be returned pointing
    	at the start of the argument. Examples of supported argument formats: '-r500', '-r 500',
    	'--resolution 500', '--resolution=500'.
    """
    return _mupdf.fz_getopt_long(nargc, nargv, ostr, longopts)

def fz_glyph_bbox(glyph):
    r"""
    Class-aware wrapper for `::fz_glyph_bbox()`.
    	Return the bounding box of the glyph in pixels.
    """
    return _mupdf.fz_glyph_bbox(glyph)

def fz_glyph_bbox_no_ctx(src):
    r""" Class-aware wrapper for `::fz_glyph_bbox_no_ctx()`."""
    return _mupdf.fz_glyph_bbox_no_ctx(src)

def fz_glyph_cacheable(font, gid):
    r"""
    Class-aware wrapper for `::fz_glyph_cacheable()`.
    	Determine if a given glyph in a font
    	is cacheable. Certain glyphs in a type 3 font cannot safely
    	be cached, as their appearance depends on the enclosing
    	graphic state.

    	font: The font to look for the glyph in.

    	gif: The glyph to query.

    	Returns non-zero if cacheable, 0 if not.
    """
    return _mupdf.fz_glyph_cacheable(font, gid)

def fz_glyph_height(glyph):
    r"""
    Class-aware wrapper for `::fz_glyph_height()`.
    	Return the height of the glyph in pixels.
    """
    return _mupdf.fz_glyph_height(glyph)

def fz_glyph_name_from_unicode_sc(unicode):
    r""" Class-aware wrapper for `::fz_glyph_name_from_unicode_sc()`."""
    return _mupdf.fz_glyph_name_from_unicode_sc(unicode)

def fz_glyph_width(glyph):
    r"""
    Class-aware wrapper for `::fz_glyph_width()`.
    	Return the width of the glyph in pixels.
    """
    return _mupdf.fz_glyph_width(glyph)

def fz_graphics_aa_level():
    r"""
    Class-aware wrapper for `::fz_graphics_aa_level()`.
    	Get the number of bits of antialiasing we are
    	using for graphics. Between 0 and 8.
    """
    return _mupdf.fz_graphics_aa_level()

def fz_graphics_min_line_width():
    r"""
    Class-aware wrapper for `::fz_graphics_min_line_width()`.
    	Get the minimum line width to be
    	used for stroked lines.

    	min_line_width: The minimum line width to use (in pixels).
    """
    return _mupdf.fz_graphics_min_line_width()

def fz_gridfit_matrix(as_tiled, m):
    r"""
    Class-aware wrapper for `::fz_gridfit_matrix()`.
    	Grid fit a matrix.

    	as_tiled = 0 => adjust the matrix so that the image of the unit
    	square completely covers any pixel that was touched by the
    	image of the unit square under the original matrix.

    	as_tiled = 1 => adjust the matrix so that the corners of the
    	image of the unit square align with the closest integer corner
    	of the image of the unit square under the original matrix.
    """
    return _mupdf.fz_gridfit_matrix(as_tiled, m)

def fz_grisu(f, s, exp):
    r"""
    Class-aware wrapper for `::fz_grisu()`.

    This function has out-params. Python/C# wrappers look like:
    	`fz_grisu(float f, char *s)` => `(int, int exp)`
    """
    return _mupdf.fz_grisu(f, s, exp)

def fz_grow_buffer(buf):
    r"""
    Class-aware wrapper for `::fz_grow_buffer()`.
    	Make some space within a buffer (i.e. ensure that
    	capacity > size).
    """
    return _mupdf.fz_grow_buffer(buf)

def fz_has_archive_entry(arch, name):
    r"""
    Class-aware wrapper for `::fz_has_archive_entry()`.
    	Check if entry by given name exists.

    	If named entry does not exist 0 will be returned, if it does
    	exist 1 is returned.

    	name: Entry name to look for, this must be an exact match to
    	the entry name in the archive.
    """
    return _mupdf.fz_has_archive_entry(arch, name)

def fz_has_option(opts, key, val):
    r"""
    Class-aware wrapper for `::fz_has_option()`.

    This function has out-params. Python/C# wrappers look like:
    	`fz_has_option(const char *opts, const char *key)` => `(int, const char *val)`

    	Look for a given option (key) in the opts string. Return 1 if
    	it has it, and update *val to point to the value within opts.
    """
    return _mupdf.fz_has_option(opts, key, val)

def fz_has_permission(doc, p):
    r"""
    Class-aware wrapper for `::fz_has_permission()`.
    	Check permission flags on document.
    """
    return _mupdf.fz_has_permission(doc, p)

def fz_hash_filter(table, state, callback):
    r"""
    Class-aware wrapper for `::fz_hash_filter()`.
    	Iterate over the entries in a hash table, removing all the ones where callback returns true.
    	Does NOT free the value of the entry, so the caller is expected to take care of this.
    """
    return _mupdf.fz_hash_filter(table, state, callback)

def fz_hash_find(table, key):
    r"""
    Class-aware wrapper for `::fz_hash_find()`.
    	Search for a matching hash within the table, and return the
    	associated value.
    """
    return _mupdf.fz_hash_find(table, key)

def fz_hash_for_each(table, state, callback):
    r"""
    Class-aware wrapper for `::fz_hash_for_each()`.
    	Iterate over the entries in a hash table.
    """
    return _mupdf.fz_hash_for_each(table, state, callback)

def fz_hash_insert(table, key, val):
    r"""
    Class-aware wrapper for `::fz_hash_insert()`.
    	Insert a new key/value pair into the hash table.

    	If an existing entry with the same key is found, no change is
    	made to the hash table, and a pointer to the existing value is
    	returned.

    	If no existing entry with the same key is found, ownership of
    	val passes in, key is copied, and NULL is returned.
    """
    return _mupdf.fz_hash_insert(table, key, val)

def fz_hash_remove(table, key):
    r"""
    Class-aware wrapper for `::fz_hash_remove()`.
    	Remove the entry for a given key.

    	The value is NOT freed, so the caller is expected to take care
    	of this.
    """
    return _mupdf.fz_hash_remove(table, key)

def fz_hb_lock():
    r"""
    Class-aware wrapper for `::fz_hb_lock()`.
    	Lock against Harfbuzz being called
    	simultaneously in several threads. This reuses
    	FZ_LOCK_FREETYPE.
    """
    return _mupdf.fz_hb_lock()

def fz_hb_unlock():
    r"""
    Class-aware wrapper for `::fz_hb_unlock()`.
    	Unlock after a Harfbuzz call. This reuses
    	FZ_LOCK_FREETYPE.
    """
    return _mupdf.fz_hb_unlock()

def fz_highlight_selection(page, a, b, quads, max_quads):
    r"""
    Class-aware wrapper for `::fz_highlight_selection()`.
    	Return a list of quads to highlight lines inside the selection
    	points.
    """
    return _mupdf.fz_highlight_selection(page, a, b, quads, max_quads)

def fz_highlight_selection2(page, a, b, max_quads):
    r"""
    Class-aware wrapper for `::fz_highlight_selection2()`.
    C++ alternative to fz_highlight_selection() that returns quads in a
    std::vector.
    """
    return _mupdf.fz_highlight_selection2(page, a, b, max_quads)

def fz_ignore_error():
    r""" Class-aware wrapper for `::fz_ignore_error()`."""
    return _mupdf.fz_ignore_error()

def fz_ignore_text(dev, text, ctm):
    r""" Class-aware wrapper for `::fz_ignore_text()`."""
    return _mupdf.fz_ignore_text(dev, text, ctm)

def fz_image_orientation(image):
    r"""
    Class-aware wrapper for `::fz_image_orientation()`.
    	Request the natural orientation of an image.

    	This is for images (such as JPEG) that can contain internal
    	specifications of rotation/flips. This is ignored by all the
    	internal decode/rendering routines, but can be used by callers
    	(such as the image document handler) to respect such
    	specifications.

    	The values used by MuPDF are as follows, with the equivalent
    	Exif specifications given for information:

    	0: Undefined
    	1: 0 degree ccw rotation. (Exif = 1)
    	2: 90 degree ccw rotation. (Exif = 8)
    	3: 180 degree ccw rotation. (Exif = 3)
    	4: 270 degree ccw rotation. (Exif = 6)
    	5: flip on X. (Exif = 2)
    	6: flip on X, then rotate ccw by 90 degrees. (Exif = 5)
    	7: flip on X, then rotate ccw by 180 degrees. (Exif = 4)
    	8: flip on X, then rotate ccw by 270 degrees. (Exif = 7)
    """
    return _mupdf.fz_image_orientation(image)

def fz_image_orientation_matrix(image):
    r""" Class-aware wrapper for `::fz_image_orientation_matrix()`."""
    return _mupdf.fz_image_orientation_matrix(image)

def fz_image_resolution(image, xres, yres):
    r"""
    Class-aware wrapper for `::fz_image_resolution()`.

    This function has out-params. Python/C# wrappers look like:
    	`fz_image_resolution(::fz_image *image)` => `(int xres, int yres)`

    	Request the natural resolution
    	of an image.

    	xres, yres: Pointers to ints to be updated with the
    	natural resolution of an image (or a sensible default
    	if not encoded).
    """
    return _mupdf.fz_image_resolution(image, xres, yres)

def fz_image_size(im):
    r"""
    Class-aware wrapper for `::fz_image_size()`.
    	Return the size of the storage used by an image.
    """
    return _mupdf.fz_image_size(im)

def fz_image_type_name(type):
    r"""
    Class-aware wrapper for `::fz_image_type_name()`.
    	Map from FZ_IMAGE_* value to string.

    	The returned string is static and therefore must not be freed.
    """
    return _mupdf.fz_image_type_name(type)

def fz_include_point_in_rect(r, p):
    r"""
    Class-aware wrapper for `::fz_include_point_in_rect()`.
    	Expand a bbox to include a given point.
    	To create a rectangle that encompasses a sequence of points, the
    	rectangle must first be set to be the empty rectangle at one of
    	the points before including the others.
    """
    return _mupdf.fz_include_point_in_rect(r, p)

def fz_init_text_decoder(dec, encoding):
    r""" Class-aware wrapper for `::fz_init_text_decoder()`."""
    return _mupdf.fz_init_text_decoder(dec, encoding)

def fz_install_load_system_font_funcs(f, f_cjk, f_fallback):
    r"""
    Class-aware wrapper for `::fz_install_load_system_font_funcs()`.
    	Install functions to allow MuPDF to request fonts from the
    	system.

    	Only one set of hooks can be in use at a time.
    """
    return _mupdf.fz_install_load_system_font_funcs(f, f_cjk, f_fallback)

def fz_install_load_system_font_funcs2(args):
    r"""
    Class-aware wrapper for `::fz_install_load_system_font_funcs2()`.
    Alternative to fz_install_load_system_font_funcs() that takes args in a
    struct, to allow use from Python/C# via Swig Directors.
    """
    return _mupdf.fz_install_load_system_font_funcs2(args)

def fz_int2_heap_insert(heap, v):
    r""" Class-aware wrapper for `::fz_int2_heap_insert()`."""
    return _mupdf.fz_int2_heap_insert(heap, v)

def fz_int2_heap_sort(heap):
    r""" Class-aware wrapper for `::fz_int2_heap_sort()`."""
    return _mupdf.fz_int2_heap_sort(heap)

def fz_int2_heap_uniq(heap):
    r""" Class-aware wrapper for `::fz_int2_heap_uniq()`."""
    return _mupdf.fz_int2_heap_uniq(heap)

def fz_int_heap_insert(heap, v):
    r""" Class-aware wrapper for `::fz_int_heap_insert()`."""
    return _mupdf.fz_int_heap_insert(heap, v)

def fz_int_heap_sort(heap):
    r""" Class-aware wrapper for `::fz_int_heap_sort()`."""
    return _mupdf.fz_int_heap_sort(heap)

def fz_int_heap_uniq(heap):
    r""" Class-aware wrapper for `::fz_int_heap_uniq()`."""
    return _mupdf.fz_int_heap_uniq(heap)

def fz_intersect_irect(a, b):
    r"""
    Class-aware wrapper for `::fz_intersect_irect()`.
    	Compute intersection of two bounding boxes.

    	Similar to fz_intersect_rect but operates on two bounding
    	boxes instead of two rectangles.
    """
    return _mupdf.fz_intersect_irect(a, b)

def fz_intersect_rect(a, b):
    r"""
    Class-aware wrapper for `::fz_intersect_rect()`.
    	Compute intersection of two rectangles.

    	Given two rectangles, update the first to be the smallest
    	axis-aligned rectangle that covers the area covered by both
    	given rectangles. If either rectangle is empty then the
    	intersection is also empty. If either rectangle is infinite
    	then the intersection is simply the non-infinite rectangle.
    	Should both rectangles be infinite, then the intersection is
    	also infinite.
    """
    return _mupdf.fz_intersect_rect(a, b)

def fz_intptr_heap_insert(heap, v):
    r""" Class-aware wrapper for `::fz_intptr_heap_insert()`."""
    return _mupdf.fz_intptr_heap_insert(heap, v)

def fz_intptr_heap_sort(heap):
    r""" Class-aware wrapper for `::fz_intptr_heap_sort()`."""
    return _mupdf.fz_intptr_heap_sort(heap)

def fz_intptr_heap_uniq(heap):
    r""" Class-aware wrapper for `::fz_intptr_heap_uniq()`."""
    return _mupdf.fz_intptr_heap_uniq(heap)

def fz_invert_bitmap(bmp):
    r"""
    Class-aware wrapper for `::fz_invert_bitmap()`.
    	Invert bitmap.

    	Never throws exceptions.
    """
    return _mupdf.fz_invert_bitmap(bmp)

def fz_invert_matrix(matrix):
    r"""
    Class-aware wrapper for `::fz_invert_matrix()`.
    	Create an inverse matrix.

    	inverse: Place to store inverse matrix.

    	matrix: Matrix to invert. A degenerate matrix, where the
    	determinant is equal to zero, can not be inverted and the
    	original matrix is returned instead.

    	Returns inverse.
    """
    return _mupdf.fz_invert_matrix(matrix)

def fz_invert_pixmap(pix):
    r"""
    Class-aware wrapper for `::fz_invert_pixmap()`.
    	Invert all the pixels in a pixmap. All components (process and
    	spots) of all pixels are inverted (except alpha, which is
    	unchanged).
    """
    return _mupdf.fz_invert_pixmap(pix)

def fz_invert_pixmap_alpha(pix):
    r"""
    Class-aware wrapper for `::fz_invert_pixmap_alpha()`.
    	Invert the alpha fo all the pixels in a pixmap.
    """
    return _mupdf.fz_invert_pixmap_alpha(pix)

def fz_invert_pixmap_luminance(pix):
    r"""
    Class-aware wrapper for `::fz_invert_pixmap_luminance()`.
    	Transform the pixels in a pixmap so that luminance of each
    	pixel is inverted, and the chrominance remains unchanged (as
    	much as accuracy allows).

    	All components of all pixels are inverted (except alpha, which
    	is unchanged). Only supports Grey and RGB bitmaps.
    """
    return _mupdf.fz_invert_pixmap_luminance(pix)

def fz_invert_pixmap_raw(pix):
    r"""
    Class-aware wrapper for `::fz_invert_pixmap_raw()`.
    	Invert all the pixels in a non-premultiplied pixmap in a
    	very naive manner.
    """
    return _mupdf.fz_invert_pixmap_raw(pix)

def fz_invert_pixmap_rect(image, rect):
    r"""
    Class-aware wrapper for `::fz_invert_pixmap_rect()`.
    	Invert all the pixels in a given rectangle of a (premultiplied)
    	pixmap. All components of all pixels in the rectangle are
    	inverted (except alpha, which is unchanged).
    """
    return _mupdf.fz_invert_pixmap_rect(image, rect)

def fz_irect_from_rect(rect):
    r"""
    Class-aware wrapper for `::fz_irect_from_rect()`.
    	Convert a rect into the minimal bounding box
    	that covers the rectangle.

    	Coordinates in a bounding box are integers, so rounding of the
    	rects coordinates takes place. The top left corner is rounded
    	upwards and left while the bottom right corner is rounded
    	downwards and to the right.
    """
    return _mupdf.fz_irect_from_rect(rect)

def fz_irect_height(r):
    r"""
    Class-aware wrapper for `::fz_irect_height()`.
    	Return the height of an irect. Invalid irects return 0.
    """
    return _mupdf.fz_irect_height(r)

def fz_irect_width(r):
    r"""
    Class-aware wrapper for `::fz_irect_width()`.
    	Return the width of an irect. Invalid irects return 0.
    """
    return _mupdf.fz_irect_width(r)

def fz_is_cfb_archive(file):
    r"""
    Class-aware wrapper for `::fz_is_cfb_archive()`.
    	Detect if stream object is a cfb archive.

    	Assumes that the stream object is seekable.
    """
    return _mupdf.fz_is_cfb_archive(file)

def fz_is_directory(path):
    r"""
    Class-aware wrapper for `::fz_is_directory()`.
    	Determine if a given path is a directory.

    	In the case of the path not existing, or having no access
    	we will return 0.
    """
    return _mupdf.fz_is_directory(path)

def fz_is_document_reflowable(doc):
    r"""
    Class-aware wrapper for `::fz_is_document_reflowable()`.
    	Is the document reflowable.

    	Returns 1 to indicate reflowable documents, otherwise 0.
    """
    return _mupdf.fz_is_document_reflowable(doc)

def fz_is_empty_irect(r):
    r""" Class-aware wrapper for `::fz_is_empty_irect()`."""
    return _mupdf.fz_is_empty_irect(r)

def fz_is_empty_rect(r):
    r"""
    Class-aware wrapper for `::fz_is_empty_rect()`.
    	Check if rectangle is empty.

    	An empty rectangle is defined as one whose area is zero.
    	All invalid rectangles are empty.
    """
    return _mupdf.fz_is_empty_rect(r)

def fz_is_eof(stm):
    r"""
    Class-aware wrapper for `::fz_is_eof()`.
    	Query if the stream has reached EOF (during normal bytewise
    	reading).

    	See fz_is_eof_bits for the equivalent function for bitwise
    	reading.
    """
    return _mupdf.fz_is_eof(stm)

def fz_is_eof_bits(stm):
    r"""
    Class-aware wrapper for `::fz_is_eof_bits()`.
    	Query if the stream has reached EOF (during bitwise
    	reading).

    	See fz_is_eof for the equivalent function for bytewise
    	reading.
    """
    return _mupdf.fz_is_eof_bits(stm)

def fz_is_external_link(uri):
    r"""
    Class-aware wrapper for `::fz_is_external_link()`.
    	Query whether a link is external to a document (determined by
    	uri containing a ':', intended to match with '://' which
    	separates the scheme from the scheme specific parts in URIs).
    """
    return _mupdf.fz_is_external_link(uri)

def fz_is_identity(m):
    r""" Class-aware wrapper for `::fz_is_identity()`."""
    return _mupdf.fz_is_identity(m)

def fz_is_infinite_irect(r):
    r"""
    Class-aware wrapper for `::fz_is_infinite_irect()`.
    	Check if an integer rectangle
    	is infinite.
    """
    return _mupdf.fz_is_infinite_irect(r)

def fz_is_infinite_rect(r):
    r"""
    Class-aware wrapper for `::fz_is_infinite_rect()`.
    	Check if rectangle is infinite.
    """
    return _mupdf.fz_is_infinite_rect(r)

def fz_is_libarchive_archive(file):
    r"""
    Class-aware wrapper for `::fz_is_libarchive_archive()`.
    	Detect if stream object is an archive supported by libarchive.

    	Assumes that the stream object is seekable.
    """
    return _mupdf.fz_is_libarchive_archive(file)

def fz_is_page_range(s):
    r"""
     Class-aware wrapper for `::fz_is_page_range()`.
    		Check and parse string into page ranges:
    ,?(-?+|N)(-(-?+|N))?/
    """
    return _mupdf.fz_is_page_range(s)

def fz_is_pixmap_monochrome(pixmap):
    r"""
    Class-aware wrapper for `::fz_is_pixmap_monochrome()`.
    	Check if the pixmap is a 1-channel image containing samples with
    	only values 0 and 255
    """
    return _mupdf.fz_is_pixmap_monochrome(pixmap)

def fz_is_point_inside_irect(x, y, r):
    r"""
    Class-aware wrapper for `::fz_is_point_inside_irect()`.
    	Inclusion test for irects. (Rect is assumed to be open, i.e.
    	top right corner is not included).
    """
    return _mupdf.fz_is_point_inside_irect(x, y, r)

def fz_is_point_inside_quad(p, q):
    r"""
    Class-aware wrapper for `::fz_is_point_inside_quad()`.
    	Inclusion test for quads.
    """
    return _mupdf.fz_is_point_inside_quad(p, q)

def fz_is_point_inside_rect(p, r):
    r"""
    Class-aware wrapper for `::fz_is_point_inside_rect()`.
    	Inclusion test for rects. (Rect is assumed to be open, i.e.
    	top right corner is not included).
    """
    return _mupdf.fz_is_point_inside_rect(p, r)

def fz_is_pow2(a):
    r""" Class-aware wrapper for `::fz_is_pow2()`."""
    return _mupdf.fz_is_pow2(a)

def fz_is_quad_inside_quad(needle, haystack):
    r"""
    Class-aware wrapper for `::fz_is_quad_inside_quad()`.
    	Inclusion test for quad in quad.

    	This may break down if quads are not 'well formed'.
    """
    return _mupdf.fz_is_quad_inside_quad(needle, haystack)

def fz_is_quad_intersecting_quad(a, b):
    r"""
    Class-aware wrapper for `::fz_is_quad_intersecting_quad()`.
    	Intersection test for quads.

    	This may break down if quads are not 'well formed'.
    """
    return _mupdf.fz_is_quad_intersecting_quad(a, b)

def fz_is_rectilinear(m):
    r"""
    Class-aware wrapper for `::fz_is_rectilinear()`.
    	Check if a transformation is rectilinear.

    	Rectilinear means that no shearing is present and that any
    	rotations present are a multiple of 90 degrees. Usually this
    	is used to make sure that axis-aligned rectangles before the
    	transformation are still axis-aligned rectangles afterwards.
    """
    return _mupdf.fz_is_rectilinear(m)

def fz_is_tar_archive(file):
    r"""
    Class-aware wrapper for `::fz_is_tar_archive()`.
    	Detect if stream object is a tar archive.

    	Assumes that the stream object is seekable.
    """
    return _mupdf.fz_is_tar_archive(file)

def fz_is_valid_blend_colorspace(cs):
    r"""
    Class-aware wrapper for `::fz_is_valid_blend_colorspace()`.
    	Check to see that a colorspace is appropriate to be used as
    	a blending space (i.e. only grey, rgb or cmyk).
    """
    return _mupdf.fz_is_valid_blend_colorspace(cs)

def fz_is_valid_irect(r):
    r"""
    Class-aware wrapper for `::fz_is_valid_irect()`.
    	Check if an integer rectangle is valid.
    """
    return _mupdf.fz_is_valid_irect(r)

def fz_is_valid_rect(r):
    r"""
    Class-aware wrapper for `::fz_is_valid_rect()`.
    	Check if rectangle is valid.
    """
    return _mupdf.fz_is_valid_rect(r)

def fz_is_zip_archive(file):
    r"""
    Class-aware wrapper for `::fz_is_zip_archive()`.
    	Detect if stream object is a zip archive.

    	Assumes that the stream object is seekable.
    """
    return _mupdf.fz_is_zip_archive(file)

def fz_iso8859_1_from_unicode(u):
    r""" Class-aware wrapper for `::fz_iso8859_1_from_unicode()`."""
    return _mupdf.fz_iso8859_1_from_unicode(u)

def fz_iso8859_7_from_unicode(u):
    r""" Class-aware wrapper for `::fz_iso8859_7_from_unicode()`."""
    return _mupdf.fz_iso8859_7_from_unicode(u)

def fz_jbig2_globals_data(globals):
    r"""
    Class-aware wrapper for `::fz_jbig2_globals_data()`.
    	Return buffer containing jbig2 globals data stream.
    """
    return _mupdf.fz_jbig2_globals_data(globals)

def fz_koi8u_from_unicode(u):
    r""" Class-aware wrapper for `::fz_koi8u_from_unicode()`."""
    return _mupdf.fz_koi8u_from_unicode(u)

def fz_last_page(doc):
    r"""
    Class-aware wrapper for `::fz_last_page()`.
    	Function to get the location for the last page in the document.
    	Using this can be far more efficient in some cases than calling
    	fz_count_pages and using the page number.
    """
    return _mupdf.fz_last_page(doc)

def fz_layout_document(doc, w, h, em):
    r"""
    Class-aware wrapper for `::fz_layout_document()`.
    	Layout reflowable document types.

    	w, h: Page size in points.
    	em: Default font size in points.
    """
    return _mupdf.fz_layout_document(doc, w, h, em)

def fz_lineto(path, x, y):
    r"""
    Class-aware wrapper for `::fz_lineto()`.
    	Append a 'lineto' command to an open path.

    	path: The path to modify.

    	x, y: The coordinate to line to.

    	Throws exceptions on failure to allocate, or attempting to
    	modify a packed path.
    """
    return _mupdf.fz_lineto(path, x, y)

def fz_list_archive_entry(arch, idx):
    r"""
    Class-aware wrapper for `::fz_list_archive_entry()`.
    	Get listed name of entry position idx.

    	idx: Must be a value >= 0 < return value from
    	fz_count_archive_entries. If not in range NULL will be
    	returned.

    	May throw an exception if this type of archive cannot list the
    	entries (such as a directory).
    """
    return _mupdf.fz_list_archive_entry(arch, idx)

def fz_load_bmp_subimage(buf, len, subimage):
    r""" Class-aware wrapper for `::fz_load_bmp_subimage()`."""
    return _mupdf.fz_load_bmp_subimage(buf, len, subimage)

def fz_load_bmp_subimage_count(buf, len):
    r""" Class-aware wrapper for `::fz_load_bmp_subimage_count()`."""
    return _mupdf.fz_load_bmp_subimage_count(buf, len)

def fz_load_chapter_page(doc, chapter, page):
    r"""
    Class-aware wrapper for `::fz_load_chapter_page()`.
    	Load a page.

    	After fz_load_page is it possible to retrieve the size of the
    	page using fz_bound_page, or to render the page using
    	fz_run_page_*. Free the page by calling fz_drop_page.

    	chapter: chapter number, 0 is the first chapter of the document.
    	number: page number, 0 is the first page of the chapter.
    """
    return _mupdf.fz_load_chapter_page(doc, chapter, page)

def fz_load_fallback_font(script, language, serif, bold, italic):
    r"""
    Class-aware wrapper for `::fz_load_fallback_font()`.
    	Try to load a fallback font for the
    	given combination of font attributes. Whether a font is
    	present or not will depend on the configuration in which
    	MuPDF is built.

    	script: The script desired (e.g. UCDN_SCRIPT_KATAKANA).

    	language: The language desired (e.g. FZ_LANG_ja).

    	serif: 1 if serif desired, 0 otherwise.

    	bold: 1 if bold desired, 0 otherwise.

    	italic: 1 if italic desired, 0 otherwise.

    	Returns a new font handle, or NULL if not available.
    """
    return _mupdf.fz_load_fallback_font(script, language, serif, bold, italic)

def fz_load_jbig2_globals(buf):
    r"""
    Class-aware wrapper for `::fz_load_jbig2_globals()`.
    	Create a jbig2 globals record from a buffer.

    	Immutable once created.
    """
    return _mupdf.fz_load_jbig2_globals(buf)

def fz_load_jbig2_subimage(buf, len, subimage):
    r""" Class-aware wrapper for `::fz_load_jbig2_subimage()`."""
    return _mupdf.fz_load_jbig2_subimage(buf, len, subimage)

def fz_load_jbig2_subimage_count(buf, len):
    r""" Class-aware wrapper for `::fz_load_jbig2_subimage_count()`."""
    return _mupdf.fz_load_jbig2_subimage_count(buf, len)

def fz_load_jpx(data, size, cs):
    r"""
    Class-aware wrapper for `::fz_load_jpx()`.
    	Exposed for PDF.
    """
    return _mupdf.fz_load_jpx(data, size, cs)

def fz_load_links(page):
    r"""
    Class-aware wrapper for `::fz_load_links()`.
    	Load the list of links for a page.

    	Returns a linked list of all the links on the page, each with
    	its clickable region and link destination. Each link is
    	reference counted so drop and free the list of links by
    	calling fz_drop_link on the pointer return from fz_load_links.

    	page: Page obtained from fz_load_page.
    """
    return _mupdf.fz_load_links(page)

def fz_load_outline(doc):
    r"""
    Class-aware wrapper for `::fz_load_outline()`.
    	Load the hierarchical document outline.

    	Should be freed by fz_drop_outline.
    """
    return _mupdf.fz_load_outline(doc)

def fz_load_outline_from_iterator(iter):
    r"""
    Class-aware wrapper for `::fz_load_outline_from_iterator()`.
    	Routine to implement the old Structure based API from an iterator.
    """
    return _mupdf.fz_load_outline_from_iterator(iter)

def fz_load_page(doc, number):
    r"""
    Class-aware wrapper for `::fz_load_page()`.
    	Load a given page number from a document. This may be much less
    	efficient than loading by location (chapter+page) for some
    	document types.
    """
    return _mupdf.fz_load_page(doc, number)

def fz_load_pnm_subimage(buf, len, subimage):
    r""" Class-aware wrapper for `::fz_load_pnm_subimage()`."""
    return _mupdf.fz_load_pnm_subimage(buf, len, subimage)

def fz_load_pnm_subimage_count(buf, len):
    r""" Class-aware wrapper for `::fz_load_pnm_subimage_count()`."""
    return _mupdf.fz_load_pnm_subimage_count(buf, len)

def fz_load_system_cjk_font(name, ordering, serif):
    r"""
    Class-aware wrapper for `::fz_load_system_cjk_font()`.
    	Attempt to load a given font from
    	the system.

    	name: The name of the desired font.

    	ordering: The ordering to load the font from (e.g. FZ_ADOBE_KOREA)

    	serif: 1 if serif desired, 0 otherwise.

    	Returns a new font handle, or NULL if no matching font was found
    	(or on error).
    """
    return _mupdf.fz_load_system_cjk_font(name, ordering, serif)

def fz_load_system_font(name, bold, italic, needs_exact_metrics):
    r"""
    Class-aware wrapper for `::fz_load_system_font()`.
    	Attempt to load a given font from the system.

    	name: The name of the desired font.

    	bold: 1 if bold desired, 0 otherwise.

    	italic: 1 if italic desired, 0 otherwise.

    	needs_exact_metrics: 1 if an exact metrical match is required,
    	0 otherwise.

    	Returns a new font handle, or NULL if no matching font was found
    	(or on error).
    """
    return _mupdf.fz_load_system_font(name, bold, italic, needs_exact_metrics)

def fz_load_tiff_subimage(buf, len, subimage):
    r""" Class-aware wrapper for `::fz_load_tiff_subimage()`."""
    return _mupdf.fz_load_tiff_subimage(buf, len, subimage)

def fz_load_tiff_subimage_count(buf, len):
    r"""
    Class-aware wrapper for `::fz_load_tiff_subimage_count()`.
    	Exposed for CBZ.
    """
    return _mupdf.fz_load_tiff_subimage_count(buf, len)

def fz_location_from_page_number(doc, number):
    r"""
    Class-aware wrapper for `::fz_location_from_page_number()`.
    	Converts from page number to chapter+page. This may cause many
    	chapters to be laid out in order to calculate the number of
    	pages within those chapters.
    """
    return _mupdf.fz_location_from_page_number(doc, number)

def fz_lock(lock):
    r"""
    Class-aware wrapper for `::fz_lock()`.
    	Lock one of the user supplied mutexes.
    """
    return _mupdf.fz_lock(lock)

def fz_log_error(str):
    r"""
    Class-aware wrapper for `::fz_log_error()`.
    	Log a (preformatted) string to the registered
    	error stream (stderr by default).
    """
    return _mupdf.fz_log_error(str)

def fz_lookup_base14_font(name, len):
    r"""
    Class-aware wrapper for `::fz_lookup_base14_font()`.

    This function has out-params. Python/C# wrappers look like:
    	`fz_lookup_base14_font(const char *name)` => `(const unsigned char *, int len)`

    	Search the builtin base14 fonts for a match.
    	Whether a given font is present or not will depend on the
    	configuration in which MuPDF is built.

    	name: The name of the font desired.

    	len: Pointer to a place to receive the length of the discovered
    	font buffer.

    	Returns a pointer to the font file data, or NULL if not present.
    """
    return _mupdf.fz_lookup_base14_font(name, len)

def fz_lookup_blendmode(name):
    r"""
    Class-aware wrapper for `::fz_lookup_blendmode()`.
    	Map from (case sensitive) blend mode string to enumeration.
    """
    return _mupdf.fz_lookup_blendmode(name)

def fz_lookup_bookmark(doc, mark):
    r"""
    Class-aware wrapper for `::fz_lookup_bookmark()`.
    	Find a bookmark and return its page number.
    """
    return _mupdf.fz_lookup_bookmark(doc, mark)

def fz_lookup_builtin_font(name, bold, italic, len):
    r"""
    Class-aware wrapper for `::fz_lookup_builtin_font()`.

    This function has out-params. Python/C# wrappers look like:
    	`fz_lookup_builtin_font(const char *name, int bold, int italic)` => `(const unsigned char *, int len)`

    	Search the builtin fonts for a match.
    	Whether a given font is present or not will depend on the
    	configuration in which MuPDF is built.

    	name: The name of the font desired.

    	bold: 1 if bold desired, 0 otherwise.

    	italic: 1 if italic desired, 0 otherwise.

    	len: Pointer to a place to receive the length of the discovered
    	font buffer.

    	Returns a pointer to the font file data, or NULL if not present.
    """
    return _mupdf.fz_lookup_builtin_font(name, bold, italic, len)

def fz_lookup_cjk_font(ordering, len, index):
    r"""
    Class-aware wrapper for `::fz_lookup_cjk_font()`.

    This function has out-params. Python/C# wrappers look like:
    	`fz_lookup_cjk_font(int ordering)` => `(const unsigned char *, int len, int index)`

    	Search the builtin cjk fonts for a match.
    	Whether a font is present or not will depend on the
    	configuration in which MuPDF is built.

    	ordering: The desired ordering of the font (e.g. FZ_ADOBE_KOREA).

    	len: Pointer to a place to receive the length of the discovered
    	font buffer.

    	Returns a pointer to the font file data, or NULL if not present.
    """
    return _mupdf.fz_lookup_cjk_font(ordering, len, index)

def fz_lookup_cjk_font_by_language(lang, len, subfont):
    r"""
    Class-aware wrapper for `::fz_lookup_cjk_font_by_language()`.

    This function has out-params. Python/C# wrappers look like:
    	`fz_lookup_cjk_font_by_language(const char *lang)` => `(const unsigned char *, int len, int subfont)`

    	Search the builtin cjk fonts for a match for a given language.
    	Whether a font is present or not will depend on the
    	configuration in which MuPDF is built.

    	lang: Pointer to a (case sensitive) language string (e.g.
    	"ja", "ko", "zh-Hant" etc).

    	len: Pointer to a place to receive the length of the discovered
    	font buffer.

    	subfont: Pointer to a place to store the subfont index of the
    	discovered font.

    	Returns a pointer to the font file data, or NULL if not present.
    """
    return _mupdf.fz_lookup_cjk_font_by_language(lang, len, subfont)

def fz_lookup_cjk_ordering_by_language(name):
    r"""
    Class-aware wrapper for `::fz_lookup_cjk_ordering_by_language()`.
    	Return the matching FZ_ADOBE_* ordering
    	for the given language tag, such as "zh-Hant", "zh-Hans", "ja", or "ko".
    """
    return _mupdf.fz_lookup_cjk_ordering_by_language(name)

def fz_lookup_image_type(type):
    r"""
    Class-aware wrapper for `::fz_lookup_image_type()`.
    	Map from (case sensitive) image type string to FZ_IMAGE_*
    	type value.
    """
    return _mupdf.fz_lookup_image_type(type)

def fz_lookup_metadata(doc, key, buf, size):
    r"""
    Class-aware wrapper for `::fz_lookup_metadata()`.
    	Retrieve document meta data strings.

    	doc: The document to query.

    	key: Which meta data key to retrieve...

    	Basic information:
    		'format'	-- Document format and version.
    		'encryption'	-- Description of the encryption used.

    	From the document information dictionary:
    		'info:Title'
    		'info:Author'
    		'info:Subject'
    		'info:Keywords'
    		'info:Creator'
    		'info:Producer'
    		'info:CreationDate'
    		'info:ModDate'

    	buf: The buffer to hold the results (a nul-terminated UTF-8
    	string).

    	size: Size of 'buf'.

    	Returns the number of bytes need to store the string plus terminator
    	(will be larger than 'size' if the output was truncated), or -1 if the
    	key is not recognized or found.
    """
    return _mupdf.fz_lookup_metadata(doc, key, buf, size)

def fz_lookup_metadata2(doc, key):
    r"""
    Class-aware wrapper for `::fz_lookup_metadata2()`.
    C++ alternative to `fz_lookup_metadata()` that returns a `std::string`
    or calls `fz_throw()` if not found.
    """
    return _mupdf.fz_lookup_metadata2(doc, key)

def fz_lookup_noto_boxes_font(len):
    r"""
    Class-aware wrapper for `::fz_lookup_noto_boxes_font()`.

    This function has out-params. Python/C# wrappers look like:
    	`fz_lookup_noto_boxes_font()` => `(const unsigned char *, int len)`
    """
    return _mupdf.fz_lookup_noto_boxes_font(len)

def fz_lookup_noto_emoji_font(len):
    r"""
    Class-aware wrapper for `::fz_lookup_noto_emoji_font()`.

    This function has out-params. Python/C# wrappers look like:
    	`fz_lookup_noto_emoji_font()` => `(const unsigned char *, int len)`
    """
    return _mupdf.fz_lookup_noto_emoji_font(len)

def fz_lookup_noto_font(script, lang, len, subfont):
    r"""
    Class-aware wrapper for `::fz_lookup_noto_font()`.

    This function has out-params. Python/C# wrappers look like:
    	`fz_lookup_noto_font(int script, int lang)` => `(const unsigned char *, int len, int subfont)`

    	Search the builtin noto fonts for a match.
    	Whether a font is present or not will depend on the
    	configuration in which MuPDF is built.

    	script: The script desired (e.g. UCDN_SCRIPT_KATAKANA).

    	lang: The language desired (e.g. FZ_LANG_ja).

    	len: Pointer to a place to receive the length of the discovered
    	font buffer.

    	Returns a pointer to the font file data, or NULL if not present.
    """
    return _mupdf.fz_lookup_noto_font(script, lang, len, subfont)

def fz_lookup_noto_math_font(len):
    r"""
    Class-aware wrapper for `::fz_lookup_noto_math_font()`.

    This function has out-params. Python/C# wrappers look like:
    	`fz_lookup_noto_math_font()` => `(const unsigned char *, int len)`

    	Search the builtin noto fonts specific symbol fonts.
    	Whether a font is present or not will depend on the
    	configuration in which MuPDF is built.
    """
    return _mupdf.fz_lookup_noto_math_font(len)

def fz_lookup_noto_music_font(len):
    r"""
    Class-aware wrapper for `::fz_lookup_noto_music_font()`.

    This function has out-params. Python/C# wrappers look like:
    	`fz_lookup_noto_music_font()` => `(const unsigned char *, int len)`
    """
    return _mupdf.fz_lookup_noto_music_font(len)

def fz_lookup_noto_symbol1_font(len):
    r"""
    Class-aware wrapper for `::fz_lookup_noto_symbol1_font()`.

    This function has out-params. Python/C# wrappers look like:
    	`fz_lookup_noto_symbol1_font()` => `(const unsigned char *, int len)`
    """
    return _mupdf.fz_lookup_noto_symbol1_font(len)

def fz_lookup_noto_symbol2_font(len):
    r"""
    Class-aware wrapper for `::fz_lookup_noto_symbol2_font()`.

    This function has out-params. Python/C# wrappers look like:
    	`fz_lookup_noto_symbol2_font()` => `(const unsigned char *, int len)`
    """
    return _mupdf.fz_lookup_noto_symbol2_font(len)

def fz_lookup_rendering_intent(name):
    r"""
    Class-aware wrapper for `::fz_lookup_rendering_intent()`.
    	Map from (case sensitive) rendering intent string to enumeration
    	value.
    """
    return _mupdf.fz_lookup_rendering_intent(name)

def fz_make_bookmark(doc, loc):
    r"""
    Class-aware wrapper for `::fz_make_bookmark()`.
    	Create a bookmark for the given page, which can be used to find
    	the same location after the document has been laid out with
    	different parameters.
    """
    return _mupdf.fz_make_bookmark(doc, loc)

def fz_make_irect(x0, y0, x1, y1):
    r""" Class-aware wrapper for `::fz_make_irect()`."""
    return _mupdf.fz_make_irect(x0, y0, x1, y1)

def fz_make_location(chapter, page):
    r"""
    Class-aware wrapper for `::fz_make_location()`.
    	Simple constructor for fz_locations.
    """
    return _mupdf.fz_make_location(chapter, page)

def fz_make_matrix(a, b, c, d, e, f):
    r""" Class-aware wrapper for `::fz_make_matrix()`."""
    return _mupdf.fz_make_matrix(a, b, c, d, e, f)

def fz_make_point(x, y):
    r""" Class-aware wrapper for `::fz_make_point()`."""
    return _mupdf.fz_make_point(x, y)

def fz_make_quad(ul_x, ul_y, ur_x, ur_y, ll_x, ll_y, lr_x, lr_y):
    r"""
    Class-aware wrapper for `::fz_make_quad()`.
    	Inline convenience construction function.
    """
    return _mupdf.fz_make_quad(ul_x, ul_y, ur_x, ur_y, ll_x, ll_y, lr_x, lr_y)

def fz_make_rect(x0, y0, x1, y1):
    r""" Class-aware wrapper for `::fz_make_rect()`."""
    return _mupdf.fz_make_rect(x0, y0, x1, y1)

def fz_malloc(size):
    r"""
    Class-aware wrapper for `::fz_malloc()`.
    	Allocate uninitialized memory of a given size.
    	Does NOT clear the memory!

    	May return NULL for size = 0.

    	Throws exception in the event of failure to allocate.
    """
    return _mupdf.fz_malloc(size)

def fz_malloc_no_throw(size):
    r"""
    Class-aware wrapper for `::fz_malloc_no_throw()`.
    	fz_malloc equivalent that returns NULL rather than throwing
    	exceptions.
    """
    return _mupdf.fz_malloc_no_throw(size)

def fz_matrix_expansion(m):
    r"""
    Class-aware wrapper for `::fz_matrix_expansion()`.
    	Calculate average scaling factor of matrix.
    """
    return _mupdf.fz_matrix_expansion(m)

def fz_matrix_max_expansion(m):
    r"""
    Class-aware wrapper for `::fz_matrix_max_expansion()`.
    	Find the largest expansion performed by this matrix.
    	(i.e. max(abs(m.a),abs(m.b),abs(m.c),abs(m.d))
    """
    return _mupdf.fz_matrix_max_expansion(m)

def fz_max(a, b):
    r""" Class-aware wrapper for `::fz_max()`."""
    return _mupdf.fz_max(a, b)

def fz_maxi(a, b):
    r""" Class-aware wrapper for `::fz_maxi()`."""
    return _mupdf.fz_maxi(a, b)

def fz_maxi64(a, b):
    r""" Class-aware wrapper for `::fz_maxi64()`."""
    return _mupdf.fz_maxi64(a, b)

def fz_maxz(a, b):
    r""" Class-aware wrapper for `::fz_maxz()`."""
    return _mupdf.fz_maxz(a, b)

def fz_md5_buffer(buffer, digest):
    r"""
    Class-aware wrapper for `::fz_md5_buffer()`.
    	Create an MD5 digest from buffer contents.

    	Never throws exceptions.
    """
    return _mupdf.fz_md5_buffer(buffer, digest)

def fz_md5_final(state, digest):
    r"""
    Class-aware wrapper for `::fz_md5_final()`.
    	MD5 finalization. Ends an MD5 message-digest operation, writing
    	the message digest and zeroizing the context.

    	Never throws an exception.
    """
    return _mupdf.fz_md5_final(state, digest)

def fz_md5_final2(md5):
    r"""
    Class-aware wrapper for `::fz_md5_final2()`.
    C++ alternative to fz_md5_final() that returns the digest by value.
    """
    return _mupdf.fz_md5_final2(md5)

def fz_md5_init(state):
    r"""
    Class-aware wrapper for `::fz_md5_init()`.
    	MD5 initialization. Begins an MD5 operation, writing a new
    	context.

    	Never throws an exception.
    """
    return _mupdf.fz_md5_init(state)

def fz_md5_pixmap(pixmap, digest):
    r""" Class-aware wrapper for `::fz_md5_pixmap()`."""
    return _mupdf.fz_md5_pixmap(pixmap, digest)

def fz_md5_pixmap2(pixmap):
    r"""
    Class-aware wrapper for `::fz_md5_pixmap2()`.
    C++ alternative to `fz_md5_pixmap()` that returns the digest by value.
    """
    return _mupdf.fz_md5_pixmap2(pixmap)

def fz_md5_update(state, input, inlen):
    r"""
    Class-aware wrapper for `::fz_md5_update()`.
    	MD5 block update operation. Continues an MD5 message-digest
    	operation, processing another message block, and updating the
    	context.

    	Never throws an exception.
    """
    return _mupdf.fz_md5_update(state, input, inlen)

def fz_md5_update_int64(state, i):
    r"""
    Class-aware wrapper for `::fz_md5_update_int64()`.
    	MD5 block update operation. Continues an MD5 message-digest
    	operation, processing an int64, and updating the context.

    	Never throws an exception.
    """
    return _mupdf.fz_md5_update_int64(state, i)

def fz_measure_string(user_font, trm, s, wmode, bidi_level, markup_dir, language):
    r"""
    Class-aware wrapper for `::fz_measure_string()`.
    	Measure the advance width of a UTF8 string should it be added to a text object.

    	This uses the same layout algorithms as fz_show_string, and can be used
    	to calculate text alignment adjustments.
    """
    return _mupdf.fz_measure_string(user_font, trm, s, wmode, bidi_level, markup_dir, language)

def fz_memmem(haystack, haystacklen, needle, needlelen):
    r"""
    Class-aware wrapper for `::fz_memmem()`.
    	Find the start of the first occurrence of the substring needle in haystack.
    """
    return _mupdf.fz_memmem(haystack, haystacklen, needle, needlelen)

def fz_memrnd(block, len):
    r"""
    Class-aware wrapper for `::fz_memrnd()`.
    	Fill block with len bytes of pseudo-randomness.
    """
    return _mupdf.fz_memrnd(block, len)

def fz_min(a, b):
    r""" Class-aware wrapper for `::fz_min()`."""
    return _mupdf.fz_min(a, b)

def fz_mini(a, b):
    r""" Class-aware wrapper for `::fz_mini()`."""
    return _mupdf.fz_mini(a, b)

def fz_mini64(a, b):
    r""" Class-aware wrapper for `::fz_mini64()`."""
    return _mupdf.fz_mini64(a, b)

def fz_minz(a, b):
    r""" Class-aware wrapper for `::fz_minz()`."""
    return _mupdf.fz_minz(a, b)

def fz_mkdir(path):
    r""" Class-aware wrapper for `::fz_mkdir()`."""
    return _mupdf.fz_mkdir(path)

def fz_morph_error(fromcode, tocode):
    r"""
    Class-aware wrapper for `::fz_morph_error()`.
    	Called within a catch block this modifies the current
    	exception's code. If it's of type 'fromcode' it is
    	modified to 'tocode'. Typically used for 'downgrading'
    	exception severity.
    """
    return _mupdf.fz_morph_error(fromcode, tocode)

def fz_mount_multi_archive(arch_, sub, path):
    r"""
    Class-aware wrapper for `::fz_mount_multi_archive()`.
    	Add an archive to the set of archives handled by a multi
    	archive.

    	If path is NULL, then the archive contents will appear at the
    	top level, otherwise, the archives contents will appear prefixed
    	by path.
    """
    return _mupdf.fz_mount_multi_archive(arch_, sub, path)

def fz_moveto(path, x, y):
    r"""
    Class-aware wrapper for `::fz_moveto()`.
    	Append a 'moveto' command to a path.
    	This 'opens' a path.

    	path: The path to modify.

    	x, y: The coordinate to move to.

    	Throws exceptions on failure to allocate, or attempting to
    	modify a packed path.
    """
    return _mupdf.fz_moveto(path, x, y)

def fz_mul255(a, b):
    r"""
    Class-aware wrapper for `::fz_mul255()`.
    	Multiply scaled two integers in the 0..255 range
    """
    return _mupdf.fz_mul255(a, b)

def fz_needs_password(doc):
    r"""
    Class-aware wrapper for `::fz_needs_password()`.
    	Check if a document is encrypted with a
    	non-blank password.
    """
    return _mupdf.fz_needs_password(doc)

def fz_new_archive_of_size(file, size):
    r""" Class-aware wrapper for `::fz_new_archive_of_size()`."""
    return _mupdf.fz_new_archive_of_size(file, size)

def fz_new_base14_font(name):
    r"""
    Class-aware wrapper for `::fz_new_base14_font()`.
    	Create a new font from one of the built-in fonts.
    """
    return _mupdf.fz_new_base14_font(name)

def fz_new_bbox_device(rectp):
    r"""
    Class-aware wrapper for `::fz_new_bbox_device()`.
    	Create a device to compute the bounding
    	box of all marks on a page.

    	The returned bounding box will be the union of all bounding
    	boxes of all objects on a page.
    """
    return _mupdf.fz_new_bbox_device(rectp)

def fz_new_bitmap(w, h, n, xres, yres):
    r"""
    Class-aware wrapper for `::fz_new_bitmap()`.
    	Create a new bitmap.

    	w, h: Width and Height for the bitmap

    	n: Number of color components (assumed to be a divisor of 8)

    	xres, yres: X and Y resolutions (in pixels per inch).

    	Returns pointer to created bitmap structure. The bitmap
    	data is uninitialised.
    """
    return _mupdf.fz_new_bitmap(w, h, n, xres, yres)

def fz_new_bitmap_from_pixmap(pix, ht):
    r"""
    Class-aware wrapper for `::fz_new_bitmap_from_pixmap()`.
    	Make a bitmap from a pixmap and a halftone.

    	pix: The pixmap to generate from. Currently must be a single
    	color component with no alpha.

    	ht: The halftone to use. NULL implies the default halftone.

    	Returns the resultant bitmap. Throws exceptions in the case of
    	failure to allocate.
    """
    return _mupdf.fz_new_bitmap_from_pixmap(pix, ht)

def fz_new_bitmap_from_pixmap_band(pix, ht, band_start):
    r"""
    Class-aware wrapper for `::fz_new_bitmap_from_pixmap_band()`.
    	Make a bitmap from a pixmap and a
    	halftone, allowing for the position of the pixmap within an
    	overall banded rendering.

    	pix: The pixmap to generate from. Currently must be a single
    	color component with no alpha.

    	ht: The halftone to use. NULL implies the default halftone.

    	band_start: Vertical offset within the overall banded rendering
    	(in pixels)

    	Returns the resultant bitmap. Throws exceptions in the case of
    	failure to allocate.
    """
    return _mupdf.fz_new_bitmap_from_pixmap_band(pix, ht, band_start)

def fz_new_buffer(capacity):
    r""" Class-aware wrapper for `::fz_new_buffer()`."""
    return _mupdf.fz_new_buffer(capacity)

def fz_new_buffer_from_base64(data, size):
    r"""
    Class-aware wrapper for `::fz_new_buffer_from_base64()`.
    	Create a new buffer with data decoded from a base64 input string.
    """
    return _mupdf.fz_new_buffer_from_base64(data, size)

def fz_new_buffer_from_copied_data(data, size):
    r"""
    Class-aware wrapper for `::fz_new_buffer_from_copied_data()`.
    	Create a new buffer containing a copy of the passed data.
    """
    return _mupdf.fz_new_buffer_from_copied_data(data, size)

def fz_new_buffer_from_data(data, size):
    r"""
    Class-aware wrapper for `::fz_new_buffer_from_data()`.
    	Create a new buffer with existing data.

    	data: Pointer to existing data.
    	size: Size of existing data.

    	Takes ownership of data. Does not make a copy. Calls fz_free on
    	the data when the buffer is deallocated. Do not use 'data' after
    	passing to this function.

    	Returns pointer to new buffer. Throws exception on allocation
    	failure.
    """
    return _mupdf.fz_new_buffer_from_data(data, size)

def fz_new_buffer_from_display_list(list, options):
    r""" Class-aware wrapper for `::fz_new_buffer_from_display_list()`."""
    return _mupdf.fz_new_buffer_from_display_list(list, options)

def fz_new_buffer_from_image_as_jpeg(image, color_params, quality, invert_cmyk):
    r""" Class-aware wrapper for `::fz_new_buffer_from_image_as_jpeg()`."""
    return _mupdf.fz_new_buffer_from_image_as_jpeg(image, color_params, quality, invert_cmyk)

def fz_new_buffer_from_image_as_jpx(image, color_params, quality):
    r""" Class-aware wrapper for `::fz_new_buffer_from_image_as_jpx()`."""
    return _mupdf.fz_new_buffer_from_image_as_jpx(image, color_params, quality)

def fz_new_buffer_from_image_as_pam(image, color_params):
    r""" Class-aware wrapper for `::fz_new_buffer_from_image_as_pam()`."""
    return _mupdf.fz_new_buffer_from_image_as_pam(image, color_params)

def fz_new_buffer_from_image_as_png(image, color_params):
    r"""
    Class-aware wrapper for `::fz_new_buffer_from_image_as_png()`.
    	Reencode a given image as a PNG into a buffer.

    	Ownership of the buffer is returned.
    """
    return _mupdf.fz_new_buffer_from_image_as_png(image, color_params)

def fz_new_buffer_from_image_as_pnm(image, color_params):
    r""" Class-aware wrapper for `::fz_new_buffer_from_image_as_pnm()`."""
    return _mupdf.fz_new_buffer_from_image_as_pnm(image, color_params)

def fz_new_buffer_from_image_as_psd(image, color_params):
    r""" Class-aware wrapper for `::fz_new_buffer_from_image_as_psd()`."""
    return _mupdf.fz_new_buffer_from_image_as_psd(image, color_params)

def fz_new_buffer_from_page(page, options):
    r""" Class-aware wrapper for `::fz_new_buffer_from_page()`."""
    return _mupdf.fz_new_buffer_from_page(page, options)

def fz_new_buffer_from_page_number(doc, number, options):
    r""" Class-aware wrapper for `::fz_new_buffer_from_page_number()`."""
    return _mupdf.fz_new_buffer_from_page_number(doc, number, options)

def fz_new_buffer_from_page_with_format(page, format, options, transform, cookie):
    r"""
    Class-aware wrapper for `::fz_new_buffer_from_page_with_format()`.
    	Returns an fz_buffer containing a page after conversion to specified format.

    	page: The page to convert.
    	format, options: Passed to fz_new_document_writer_with_output() internally.
    	transform, cookie: Passed to fz_run_page() internally.
    """
    return _mupdf.fz_new_buffer_from_page_with_format(page, format, options, transform, cookie)

def fz_new_buffer_from_pixmap_as_jpeg(pixmap, color_params, quality, invert_cmyk):
    r""" Class-aware wrapper for `::fz_new_buffer_from_pixmap_as_jpeg()`."""
    return _mupdf.fz_new_buffer_from_pixmap_as_jpeg(pixmap, color_params, quality, invert_cmyk)

def fz_new_buffer_from_pixmap_as_jpx(pix, color_params, quality):
    r""" Class-aware wrapper for `::fz_new_buffer_from_pixmap_as_jpx()`."""
    return _mupdf.fz_new_buffer_from_pixmap_as_jpx(pix, color_params, quality)

def fz_new_buffer_from_pixmap_as_pam(pixmap, color_params):
    r""" Class-aware wrapper for `::fz_new_buffer_from_pixmap_as_pam()`."""
    return _mupdf.fz_new_buffer_from_pixmap_as_pam(pixmap, color_params)

def fz_new_buffer_from_pixmap_as_png(pixmap, color_params):
    r"""
    Class-aware wrapper for `::fz_new_buffer_from_pixmap_as_png()`.
    	Reencode a given pixmap as a PNG into a buffer.

    	Ownership of the buffer is returned.
    """
    return _mupdf.fz_new_buffer_from_pixmap_as_png(pixmap, color_params)

def fz_new_buffer_from_pixmap_as_pnm(pixmap, color_params):
    r""" Class-aware wrapper for `::fz_new_buffer_from_pixmap_as_pnm()`."""
    return _mupdf.fz_new_buffer_from_pixmap_as_pnm(pixmap, color_params)

def fz_new_buffer_from_pixmap_as_psd(pix, color_params):
    r""" Class-aware wrapper for `::fz_new_buffer_from_pixmap_as_psd()`."""
    return _mupdf.fz_new_buffer_from_pixmap_as_psd(pix, color_params)

def fz_new_buffer_from_shared_data(data, size):
    r"""
    Class-aware wrapper for `::fz_new_buffer_from_shared_data()`.
    	Like fz_new_buffer, but does not take ownership.
    """
    return _mupdf.fz_new_buffer_from_shared_data(data, size)

def fz_new_buffer_from_stext_page(text):
    r"""
    Class-aware wrapper for `::fz_new_buffer_from_stext_page()`.
    	Convert structured text into plain text.
    """
    return _mupdf.fz_new_buffer_from_stext_page(text)

def fz_new_builtin_font(name, is_bold, is_italic):
    r""" Class-aware wrapper for `::fz_new_builtin_font()`."""
    return _mupdf.fz_new_builtin_font(name, is_bold, is_italic)

def fz_new_cal_gray_colorspace(wp, bp, gamma):
    r"""
    Class-aware wrapper for `::fz_new_cal_gray_colorspace()`.
    	Create a calibrated gray colorspace.

    	The returned reference should be dropped when it is finished
    	with.

    	Colorspaces are immutable once created.
    """
    return _mupdf.fz_new_cal_gray_colorspace(wp, bp, gamma)

def fz_new_cal_rgb_colorspace(wp, bp, gamma, matrix):
    r"""
    Class-aware wrapper for `::fz_new_cal_rgb_colorspace()`.
    	Create a calibrated rgb colorspace.

    	The returned reference should be dropped when it is finished
    	with.

    	Colorspaces are immutable once created.
    """
    return _mupdf.fz_new_cal_rgb_colorspace(wp, bp, gamma, matrix)

def fz_new_cjk_font(ordering):
    r""" Class-aware wrapper for `::fz_new_cjk_font()`."""
    return _mupdf.fz_new_cjk_font(ordering)

def fz_new_colorspace(type, flags, n, name):
    r"""
    Class-aware wrapper for `::fz_new_colorspace()`.
    	Creates a new colorspace instance and returns a reference.

    	No internal checking is done that the colorspace type (e.g.
    	CMYK) matches with the flags (e.g. FZ_COLORSPACE_HAS_CMYK) or
    	colorant count (n) or name.

    	The reference should be dropped when it is finished with.

    	Colorspaces are immutable once created (with the exception of
    	setting up colorant names for separation spaces).
    """
    return _mupdf.fz_new_colorspace(type, flags, n, name)

def fz_new_compressed_buffer():
    r"""
    Class-aware wrapper for `::fz_new_compressed_buffer()`.
    	Create a new, UNKNOWN format, compressed_buffer.
    """
    return _mupdf.fz_new_compressed_buffer()

def fz_new_default_colorspaces():
    r"""
    Class-aware wrapper for `::fz_new_default_colorspaces()`.
    	Create a new default colorspace structure with values inherited
    	from the context, and return a reference to it.

    	These can be overridden using fz_set_default_xxxx.

    	These should not be overridden while more than one caller has
    	the reference for fear of race conditions.

    	The caller should drop this reference once finished with it.
    """
    return _mupdf.fz_new_default_colorspaces()

def fz_new_deflated_data(compressed_length, source, source_length, level):
    r"""
     Class-aware wrapper for `::fz_new_deflated_data()`.

    	This function has out-params. Python/C# wrappers look like:
    		`fz_new_deflated_data(const unsigned char *source, size_t source_length, ::fz_deflate_level level)` => `(unsigned char *, size_t compressed_length)`

    		Compress source_length bytes of data starting
    		at source, into a new memory block malloced for that purpose.
    compressed_length is updated on exit to contain the size used.
    		Ownership of the block is returned from this function, and the
    		caller is therefore responsible for freeing it. The block may be
    		considerably larger than is actually required. The caller is
    		free to fz_realloc it down if it wants to.
    """
    return _mupdf.fz_new_deflated_data(compressed_length, source, source_length, level)

def fz_new_deflated_data_from_buffer(compressed_length, buffer, level):
    r"""
    Class-aware wrapper for `::fz_new_deflated_data_from_buffer()`.

    This function has out-params. Python/C# wrappers look like:
    	`fz_new_deflated_data_from_buffer(::fz_buffer *buffer, ::fz_deflate_level level)` => `(unsigned char *, size_t compressed_length)`

    	Compress the contents of a fz_buffer into a
    	new block malloced for that purpose. *compressed_length is
    	updated on exit to contain the size used. Ownership of the block
    	is returned from this function, and the caller is therefore
    	responsible for freeing it. The block may be considerably larger
    	than is actually required. The caller is free to fz_realloc it
    	down if it wants to.
    """
    return _mupdf.fz_new_deflated_data_from_buffer(compressed_length, buffer, level)

def fz_new_device_of_size(size):
    r"""
    Class-aware wrapper for `::fz_new_device_of_size()`.
    	Devices are created by calls to device implementations, for
    	instance: foo_new_device(). These will be implemented by calling
    	fz_new_derived_device(ctx, foo_device) where foo_device is a
    	structure "derived from" fz_device, for instance
    	typedef struct { fz_device base;  ...extras...} foo_device;
    """
    return _mupdf.fz_new_device_of_size(size)

def fz_new_display_list(mediabox):
    r"""
    Class-aware wrapper for `::fz_new_display_list()`.
    	Create an empty display list.

    	A display list contains drawing commands (text, images, etc.).
    	Use fz_new_list_device for populating the list.

    	mediabox: Bounds of the page (in points) represented by the
    	display list.
    """
    return _mupdf.fz_new_display_list(mediabox)

def fz_new_display_list_from_page(page):
    r"""
    Class-aware wrapper for `::fz_new_display_list_from_page()`.
    	Create a display list.

    	Ownership of the display list is returned to the caller.
    """
    return _mupdf.fz_new_display_list_from_page(page)

def fz_new_display_list_from_page_contents(page):
    r"""
    Class-aware wrapper for `::fz_new_display_list_from_page_contents()`.
    	Create a display list from page contents (no annotations).

    	Ownership of the display list is returned to the caller.
    """
    return _mupdf.fz_new_display_list_from_page_contents(page)

def fz_new_display_list_from_page_number(doc, number):
    r""" Class-aware wrapper for `::fz_new_display_list_from_page_number()`."""
    return _mupdf.fz_new_display_list_from_page_number(doc, number)

def fz_new_display_list_from_svg(buf, base_uri, dir, w, h):
    r"""
    Class-aware wrapper for `::fz_new_display_list_from_svg()`.

    This function has out-params. Python/C# wrappers look like:
    	`fz_new_display_list_from_svg(::fz_buffer *buf, const char *base_uri, ::fz_archive *dir)` => `(fz_display_list *, float w, float h)`

    	Parse an SVG document into a display-list.
    """
    return _mupdf.fz_new_display_list_from_svg(buf, base_uri, dir, w, h)

def fz_new_display_list_from_svg_xml(xmldoc, xml, base_uri, dir, w, h):
    r"""
    Class-aware wrapper for `::fz_new_display_list_from_svg_xml()`.

    This function has out-params. Python/C# wrappers look like:
    	`fz_new_display_list_from_svg_xml(::fz_xml_doc *xmldoc, ::fz_xml *xml, const char *base_uri, ::fz_archive *dir)` => `(fz_display_list *, float w, float h)`

    	Parse an SVG document into a display-list.
    """
    return _mupdf.fz_new_display_list_from_svg_xml(xmldoc, xml, base_uri, dir, w, h)

def fz_new_document_of_size(size):
    r"""
    Class-aware wrapper for `::fz_new_document_of_size()`.
    	New documents are typically created by calls like
    	foo_new_document(fz_context *ctx, ...). These work by
    	deriving a new document type from fz_document, for instance:
    	typedef struct { fz_document base; ...extras... } foo_document;
    	These are allocated by calling
    	fz_new_derived_document(ctx, foo_document)
    """
    return _mupdf.fz_new_document_of_size(size)

def fz_new_draw_device(transform, dest):
    r"""
    Class-aware wrapper for `::fz_new_draw_device()`.
    	Create a device to draw on a pixmap.

    	dest: Target pixmap for the draw device. See fz_new_pixmap*
    	for how to obtain a pixmap. The pixmap is not cleared by the
    	draw device, see fz_clear_pixmap* for how to clear it prior to
    	calling fz_new_draw_device. Free the device by calling
    	fz_drop_device.

    	transform: Transform from user space in points to device space
    	in pixels.
    """
    return _mupdf.fz_new_draw_device(transform, dest)

def fz_new_draw_device_type3(transform, dest):
    r""" Class-aware wrapper for `::fz_new_draw_device_type3()`."""
    return _mupdf.fz_new_draw_device_type3(transform, dest)

def fz_new_draw_device_with_bbox(transform, dest, clip):
    r"""
    Class-aware wrapper for `::fz_new_draw_device_with_bbox()`.
    	Create a device to draw on a pixmap.

    	dest: Target pixmap for the draw device. See fz_new_pixmap*
    	for how to obtain a pixmap. The pixmap is not cleared by the
    	draw device, see fz_clear_pixmap* for how to clear it prior to
    	calling fz_new_draw_device. Free the device by calling
    	fz_drop_device.

    	transform: Transform from user space in points to device space
    	in pixels.

    	clip: Bounding box to restrict any marking operations of the
    	draw device.
    """
    return _mupdf.fz_new_draw_device_with_bbox(transform, dest, clip)

def fz_new_draw_device_with_bbox_proof(transform, dest, clip, cs):
    r"""
    Class-aware wrapper for `::fz_new_draw_device_with_bbox_proof()`.
    	Create a device to draw on a pixmap.

    	dest: Target pixmap for the draw device. See fz_new_pixmap*
    	for how to obtain a pixmap. The pixmap is not cleared by the
    	draw device, see fz_clear_pixmap* for how to clear it prior to
    	calling fz_new_draw_device. Free the device by calling
    	fz_drop_device.

    	transform: Transform from user space in points to device space
    	in pixels.

    	clip: Bounding box to restrict any marking operations of the
    	draw device.

    	proof_cs: Color space to render to prior to mapping to color
    	space defined by pixmap.
    """
    return _mupdf.fz_new_draw_device_with_bbox_proof(transform, dest, clip, cs)

def fz_new_draw_device_with_options(options, mediabox, pixmap):
    r"""
    Class-aware wrapper for `::fz_new_draw_device_with_options()`.

    This function has out-params. Python/C# wrappers look like:
    	`fz_new_draw_device_with_options(const ::fz_draw_options *options, ::fz_rect mediabox, ::fz_pixmap **pixmap)` => `(fz_device *)`

    	Create a new pixmap and draw device, using the specified options.

    	options: Options to configure the draw device, and choose the
    	resolution and colorspace.

    	mediabox: The bounds of the page in points.

    	pixmap: An out parameter containing the newly created pixmap.
    """
    return _mupdf.fz_new_draw_device_with_options(options, mediabox, pixmap)

def fz_new_draw_device_with_proof(transform, dest, proof_cs):
    r"""
    Class-aware wrapper for `::fz_new_draw_device_with_proof()`.
    	Create a device to draw on a pixmap.

    	dest: Target pixmap for the draw device. See fz_new_pixmap*
    	for how to obtain a pixmap. The pixmap is not cleared by the
    	draw device, see fz_clear_pixmap* for how to clear it prior to
    	calling fz_new_draw_device. Free the device by calling
    	fz_drop_device.

    	transform: Transform from user space in points to device space
    	in pixels.

    	proof_cs: Intermediate color space to map though when mapping to
    	color space defined by pixmap.
    """
    return _mupdf.fz_new_draw_device_with_proof(transform, dest, proof_cs)

def fz_new_font_from_buffer(name, buffer, index, use_glyph_bbox):
    r"""
    Class-aware wrapper for `::fz_new_font_from_buffer()`.
    	Create a new font from a font file in a fz_buffer.

    	Fonts created in this way, will be eligible for embedding by default.

    	name: Name of font (leave NULL to use name from font).

    	buffer: Buffer to load from.

    	index: Which font from the file to load (0 for default).

    	use_glyph_box: 1 if we should use the glyph bbox, 0 otherwise.

    	Returns new font handle, or throws exception on error.
    """
    return _mupdf.fz_new_font_from_buffer(name, buffer, index, use_glyph_bbox)

def fz_new_font_from_file(name, path, index, use_glyph_bbox):
    r"""
    Class-aware wrapper for `::fz_new_font_from_file()`.
    	Create a new font from a font file.

    	Fonts created in this way, will be eligible for embedding by default.

    	name: Name of font (leave NULL to use name from font).

    	path: File path to load from.

    	index: Which font from the file to load (0 for default).

    	use_glyph_box: 1 if we should use the glyph bbox, 0 otherwise.

    	Returns new font handle, or throws exception on error.
    """
    return _mupdf.fz_new_font_from_file(name, path, index, use_glyph_bbox)

def fz_new_font_from_memory(name, data, len, index, use_glyph_bbox):
    r"""
    Class-aware wrapper for `::fz_new_font_from_memory()`.
    	Create a new font from a font file in memory.

    	Fonts created in this way, will be eligible for embedding by default.

    	name: Name of font (leave NULL to use name from font).

    	data: Pointer to the font file data.

    	len: Length of the font file data.

    	index: Which font from the file to load (0 for default).

    	use_glyph_box: 1 if we should use the glyph bbox, 0 otherwise.

    	Returns new font handle, or throws exception on error.
    """
    return _mupdf.fz_new_font_from_memory(name, data, len, index, use_glyph_bbox)

def fz_new_function_of_size(size, size2, m, n, eval, drop):
    r""" Class-aware wrapper for `::fz_new_function_of_size()`."""
    return _mupdf.fz_new_function_of_size(size, size2, m, n, eval, drop)

def fz_new_icc_colorspace(type, flags, name, buf):
    r"""
    Class-aware wrapper for `::fz_new_icc_colorspace()`.
    	Create a colorspace from an ICC profile supplied in buf.

    	Limited checking is done to ensure that the colorspace type is
    	appropriate for the supplied ICC profile.

    	An additional reference is taken to buf, which will be dropped
    	on destruction. Ownership is NOT passed in.

    	The returned reference should be dropped when it is finished
    	with.

    	Colorspaces are immutable once created.
    """
    return _mupdf.fz_new_icc_colorspace(type, flags, name, buf)

def fz_new_image_from_buffer(buffer):
    r"""
    Class-aware wrapper for `::fz_new_image_from_buffer()`.
    	Create a new image from a
    	buffer of data, inferring its type from the format
    	of the data.
    """
    return _mupdf.fz_new_image_from_buffer(buffer)

def fz_new_image_from_compressed_buffer(w, h, bpc, colorspace, xres, yres, interpolate, imagemask, decode, colorkey, buffer, mask):
    r"""
    Class-aware wrapper for `::fz_new_image_from_compressed_buffer()`.
    	Create an image based on
    	the data in the supplied compressed buffer.

    	w,h: Width and height of the created image.

    	bpc: Bits per component.

    	colorspace: The colorspace (determines the number of components,
    	and any color conversions required while decoding).

    	xres, yres: The X and Y resolutions respectively.

    	interpolate: 1 if interpolation should be used when decoding
    	this image, 0 otherwise.

    	imagemask: 1 if this is an imagemask (i.e. transparency bitmap
    	mask), 0 otherwise.

    	decode: NULL, or a pointer to to a decode array. The default
    	decode array is [0 1] (repeated n times, for n color components).

    	colorkey: NULL, or a pointer to a colorkey array. The default
    	colorkey array is [0 255] (repeated n times, for n color
    	components).

    	buffer: Buffer of compressed data and compression parameters.
    	Ownership of this reference is passed in.

    	mask: NULL, or another image to use as a mask for this one.
    	A new reference is taken to this image. Supplying a masked
    	image as a mask to another image is illegal!
    """
    return _mupdf.fz_new_image_from_compressed_buffer(w, h, bpc, colorspace, xres, yres, interpolate, imagemask, decode, colorkey, buffer, mask)

def fz_new_image_from_compressed_buffer2(w, h, bpc, colorspace, xres, yres, interpolate, imagemask, decode, colorkey, buffer, mask):
    r"""
    Class-aware wrapper for `::fz_new_image_from_compressed_buffer2()`.   Swig-friendly wrapper for fz_new_image_from_compressed_buffer(),
    uses specified `decode` and `colorkey` if they are not null (in which
    case we assert that they have size `2*fz_colorspace_n(colorspace)`).
    """
    return _mupdf.fz_new_image_from_compressed_buffer2(w, h, bpc, colorspace, xres, yres, interpolate, imagemask, decode, colorkey, buffer, mask)

def fz_new_image_from_display_list(w, h, list):
    r"""
    Class-aware wrapper for `::fz_new_image_from_display_list()`.
    	Create a new image from a display list.

    	w, h: The conceptual width/height of the image.

    	transform: The matrix that needs to be applied to the given
    	list to make it render to the unit square.

    	list: The display list.
    """
    return _mupdf.fz_new_image_from_display_list(w, h, list)

def fz_new_image_from_file(path):
    r"""
    Class-aware wrapper for `::fz_new_image_from_file()`.
    	Create a new image from the contents
    	of a file, inferring its type from the format of the
    	data.
    """
    return _mupdf.fz_new_image_from_file(path)

def fz_new_image_from_pixmap(pixmap, mask):
    r"""
    Class-aware wrapper for `::fz_new_image_from_pixmap()`.
    	Create an image from the given
    	pixmap.

    	pixmap: The pixmap to base the image upon. A new reference
    	to this is taken.

    	mask: NULL, or another image to use as a mask for this one.
    	A new reference is taken to this image. Supplying a masked
    	image as a mask to another image is illegal!
    """
    return _mupdf.fz_new_image_from_pixmap(pixmap, mask)

def fz_new_image_from_svg(buf, base_uri, dir):
    r"""
    Class-aware wrapper for `::fz_new_image_from_svg()`.
    	Create a scalable image from an SVG document.
    """
    return _mupdf.fz_new_image_from_svg(buf, base_uri, dir)

def fz_new_image_from_svg_xml(xmldoc, xml, base_uri, dir):
    r"""
    Class-aware wrapper for `::fz_new_image_from_svg_xml()`.
    	Create a scalable image from an SVG document.
    """
    return _mupdf.fz_new_image_from_svg_xml(xmldoc, xml, base_uri, dir)

def fz_new_image_of_size(w, h, bpc, colorspace, xres, yres, interpolate, imagemask, decode, colorkey, mask, size, get_pixmap, get_size, drop):
    r"""
    Class-aware wrapper for `::fz_new_image_of_size()`.
    	Internal function to make a new fz_image structure
    	for a derived class.

    	w,h: Width and height of the created image.

    	bpc: Bits per component.

    	colorspace: The colorspace (determines the number of components,
    	and any color conversions required while decoding).

    	xres, yres: The X and Y resolutions respectively.

    	interpolate: 1 if interpolation should be used when decoding
    	this image, 0 otherwise.

    	imagemask: 1 if this is an imagemask (i.e. transparent), 0
    	otherwise.

    	decode: NULL, or a pointer to to a decode array. The default
    	decode array is [0 1] (repeated n times, for n color components).

    	colorkey: NULL, or a pointer to a colorkey array. The default
    	colorkey array is [0 255] (repeated n times, for n color
    	components).

    	mask: NULL, or another image to use as a mask for this one.
    	A new reference is taken to this image. Supplying a masked
    	image as a mask to another image is illegal!

    	size: The size of the required allocated structure (the size of
    	the derived structure).

    	get: The function to be called to obtain a decoded pixmap.

    	get_size: The function to be called to return the storage size
    	used by this image.

    	drop: The function to be called to dispose of this image once
    	the last reference is dropped.

    	Returns a pointer to an allocated structure of the required size,
    	with the first sizeof(fz_image) bytes initialised as appropriate
    	given the supplied parameters, and the other bytes set to zero.
    """
    return _mupdf.fz_new_image_of_size(w, h, bpc, colorspace, xres, yres, interpolate, imagemask, decode, colorkey, mask, size, get_pixmap, get_size, drop)

def fz_new_indexed_colorspace(base, high, lookup):
    r"""
    Class-aware wrapper for `::fz_new_indexed_colorspace()`.
    	Create an indexed colorspace.

    	The supplied lookup table is high palette entries long. Each
    	entry is n bytes long, where n is given by the number of
    	colorants in the base colorspace, one byte per colorant.

    	Ownership of lookup is passed it; it will be freed on
    	destruction, so must be heap allocated.

    	The colorspace will keep an additional reference to the base
    	colorspace that will be dropped on destruction.

    	The returned reference should be dropped when it is finished
    	with.

    	Colorspaces are immutable once created.
    """
    return _mupdf.fz_new_indexed_colorspace(base, high, lookup)

def fz_new_link_of_size(size, rect, uri):
    r"""
    Class-aware wrapper for `::fz_new_link_of_size()`.
    	Create a new link record.

    	next is set to NULL with the expectation that the caller will
    	handle the linked list setup. Internal function.

    	Different document types will be implemented by deriving from
    	fz_link. This macro allocates such derived structures, and
    	initialises the base sections.
    """
    return _mupdf.fz_new_link_of_size(size, rect, uri)

def fz_new_list_device(list):
    r"""
    Class-aware wrapper for `::fz_new_list_device()`.
    	Create a rendering device for a display list.

    	When the device is rendering a page it will populate the
    	display list with drawing commands (text, images, etc.). The
    	display list can later be reused to render a page many times
    	without having to re-interpret the page from the document file
    	for each rendering. Once the device is no longer needed, free
    	it with fz_drop_device.

    	list: A display list that the list device takes a reference to.
    """
    return _mupdf.fz_new_list_device(list)

def fz_new_multi_archive():
    r"""
    Class-aware wrapper for `::fz_new_multi_archive()`.
    	Create a new multi archive (initially empty).
    """
    return _mupdf.fz_new_multi_archive()

def fz_new_ocr_device(target, ctm, mediabox, with_list, language, datadir, progress, progress_arg):
    r"""
    Class-aware wrapper for `::fz_new_ocr_device()`.
    	Create a device to OCR the text on the page.

    	Renders the page internally to a bitmap that is then OCRd. Text
    	is then forwarded onto the target device.

    	target: The target device to receive the OCRd text.

    	ctm: The transform to apply to the mediabox to get the size for
    	the rendered page image. Also used to calculate the resolution
    	for the page image. In general, this will be the same as the CTM
    	that you pass to fz_run_page (or fz_run_display_list) to feed
    	this device.

    	mediabox: The mediabox (in points). Combined with the CTM to get
    	the bounds of the pixmap used internally for the rendered page
    	image.

    	with_list: If with_list is false, then all non-text operations
    	are forwarded instantly to the target device. This results in
    	the target device seeing all NON-text operations, followed by
    	all the text operations (derived from OCR).

    	If with_list is true, then all the marking operations are
    	collated into a display list which is then replayed to the
    	target device at the end.

    	language: NULL (for "eng"), or a pointer to a string to describe
    	the languages/scripts that should be used for OCR (e.g.
    	"eng,ara").

    	datadir: NULL (for ""), or a pointer to a path string otherwise
    	provided to Tesseract in the TESSDATA_PREFIX environment variable.

    	progress: NULL, or function to be called periodically to indicate
    	progress. Return 0 to continue, or 1 to cancel. progress_arg is
    	returned as the void *. The int is a value between 0 and 100 to
    	indicate progress.

    	progress_arg: A void * value to be parrotted back to the progress
    	function.
    """
    return _mupdf.fz_new_ocr_device(target, ctm, mediabox, with_list, language, datadir, progress, progress_arg)

def fz_new_outline():
    r"""
    Class-aware wrapper for `::fz_new_outline()`.
    	Create a new outline entry with zeroed fields for the caller
    	to fill in.
    """
    return _mupdf.fz_new_outline()

def fz_new_page_of_size(size, doc):
    r"""
    Class-aware wrapper for `::fz_new_page_of_size()`.
    	Different document types will be implemented by deriving from
    	fz_page. This macro allocates such derived structures, and
    	initialises the base sections.
    """
    return _mupdf.fz_new_page_of_size(size, doc)

def fz_new_path():
    r"""
    Class-aware wrapper for `::fz_new_path()`.
    	Create a new (empty) path structure.
    """
    return _mupdf.fz_new_path()

def fz_new_pixmap(cs, w, h, seps, alpha):
    r"""
    Class-aware wrapper for `::fz_new_pixmap()`.
    	Create a new pixmap, with its origin at (0,0)

    	cs: The colorspace to use for the pixmap, or NULL for an alpha
    	plane/mask.

    	w: The width of the pixmap (in pixels)

    	h: The height of the pixmap (in pixels)

    	seps: Details of separations.

    	alpha: 0 for no alpha, 1 for alpha.

    	Returns a pointer to the new pixmap. Throws exception on failure
    	to allocate.
    """
    return _mupdf.fz_new_pixmap(cs, w, h, seps, alpha)

def fz_new_pixmap_from_alpha_channel(src):
    r""" Class-aware wrapper for `::fz_new_pixmap_from_alpha_channel()`."""
    return _mupdf.fz_new_pixmap_from_alpha_channel(src)

def fz_new_pixmap_from_color_and_mask(color, mask):
    r""" Class-aware wrapper for `::fz_new_pixmap_from_color_and_mask()`."""
    return _mupdf.fz_new_pixmap_from_color_and_mask(color, mask)

def fz_new_pixmap_from_display_list(list, ctm, cs, alpha):
    r"""
    Class-aware wrapper for `::fz_new_pixmap_from_display_list()`.
    	Render the page to a pixmap using the transform and colorspace.

    	Ownership of the pixmap is returned to the caller.
    """
    return _mupdf.fz_new_pixmap_from_display_list(list, ctm, cs, alpha)

def fz_new_pixmap_from_display_list_with_separations(list, ctm, cs, seps, alpha):
    r"""
    Class-aware wrapper for `::fz_new_pixmap_from_display_list_with_separations()`.
    	Render the page contents with control over spot colors.

    	Ownership of the pixmap is returned to the caller.
    """
    return _mupdf.fz_new_pixmap_from_display_list_with_separations(list, ctm, cs, seps, alpha)

def fz_new_pixmap_from_page(page, ctm, cs, alpha):
    r""" Class-aware wrapper for `::fz_new_pixmap_from_page()`."""
    return _mupdf.fz_new_pixmap_from_page(page, ctm, cs, alpha)

def fz_new_pixmap_from_page_contents(page, ctm, cs, alpha):
    r"""
    Class-aware wrapper for `::fz_new_pixmap_from_page_contents()`.
    	Render the page contents without annotations.

    	Ownership of the pixmap is returned to the caller.
    """
    return _mupdf.fz_new_pixmap_from_page_contents(page, ctm, cs, alpha)

def fz_new_pixmap_from_page_contents_with_separations(page, ctm, cs, seps, alpha):
    r""" Class-aware wrapper for `::fz_new_pixmap_from_page_contents_with_separations()`."""
    return _mupdf.fz_new_pixmap_from_page_contents_with_separations(page, ctm, cs, seps, alpha)

def fz_new_pixmap_from_page_number(doc, number, ctm, cs, alpha):
    r""" Class-aware wrapper for `::fz_new_pixmap_from_page_number()`."""
    return _mupdf.fz_new_pixmap_from_page_number(doc, number, ctm, cs, alpha)

def fz_new_pixmap_from_page_number_with_separations(doc, number, ctm, cs, seps, alpha):
    r""" Class-aware wrapper for `::fz_new_pixmap_from_page_number_with_separations()`."""
    return _mupdf.fz_new_pixmap_from_page_number_with_separations(doc, number, ctm, cs, seps, alpha)

def fz_new_pixmap_from_page_with_separations(page, ctm, cs, seps, alpha):
    r""" Class-aware wrapper for `::fz_new_pixmap_from_page_with_separations()`."""
    return _mupdf.fz_new_pixmap_from_page_with_separations(page, ctm, cs, seps, alpha)

def fz_new_pixmap_from_pixmap(pixmap, rect):
    r"""
    Class-aware wrapper for `::fz_new_pixmap_from_pixmap()`.
    	Create a new pixmap that represents a subarea of the specified
    	pixmap. A reference is taken to this pixmap that will be dropped
    	on destruction.

    	The supplied rectangle must be wholly contained within the
    	original pixmap.

    	Returns a pointer to the new pixmap. Throws exception on failure
    	to allocate.
    """
    return _mupdf.fz_new_pixmap_from_pixmap(pixmap, rect)

def fz_new_pixmap_with_bbox(colorspace, bbox, seps, alpha):
    r"""
    Class-aware wrapper for `::fz_new_pixmap_with_bbox()`.
    	Create a pixmap of a given size, location and pixel format.

    	The bounding box specifies the size of the created pixmap and
    	where it will be located. The colorspace determines the number
    	of components per pixel. Alpha is always present. Pixmaps are
    	reference counted, so drop references using fz_drop_pixmap.

    	colorspace: Colorspace format used for the created pixmap. The
    	pixmap will keep a reference to the colorspace.

    	bbox: Bounding box specifying location/size of created pixmap.

    	seps: Details of separations.

    	alpha: 0 for no alpha, 1 for alpha.

    	Returns a pointer to the new pixmap. Throws exception on failure
    	to allocate.
    """
    return _mupdf.fz_new_pixmap_with_bbox(colorspace, bbox, seps, alpha)

def fz_new_pixmap_with_bbox_and_data(colorspace, rect, seps, alpha, samples):
    r"""
    Class-aware wrapper for `::fz_new_pixmap_with_bbox_and_data()`.
    	Create a pixmap of a given size, location and pixel format,
    	using the supplied data block.

    	The bounding box specifies the size of the created pixmap and
    	where it will be located. The colorspace determines the number
    	of components per pixel. Alpha is always present. Pixmaps are
    	reference counted, so drop references using fz_drop_pixmap.

    	colorspace: Colorspace format used for the created pixmap. The
    	pixmap will keep a reference to the colorspace.

    	rect: Bounding box specifying location/size of created pixmap.

    	seps: Details of separations.

    	alpha: Number of alpha planes (0 or 1).

    	samples: The data block to keep the samples in.

    	Returns a pointer to the new pixmap. Throws exception on failure
    	to allocate.
    """
    return _mupdf.fz_new_pixmap_with_bbox_and_data(colorspace, rect, seps, alpha, samples)

def fz_new_pixmap_with_data(colorspace, w, h, seps, alpha, stride, samples):
    r"""
    Class-aware wrapper for `::fz_new_pixmap_with_data()`.
    	Create a new pixmap, with its origin at
    	(0,0) using the supplied data block.

    	cs: The colorspace to use for the pixmap, or NULL for an alpha
    	plane/mask.

    	w: The width of the pixmap (in pixels)

    	h: The height of the pixmap (in pixels)

    	seps: Details of separations.

    	alpha: 0 for no alpha, 1 for alpha.

    	stride: The byte offset from the pixel data in a row to the
    	pixel data in the next row.

    	samples: The data block to keep the samples in.

    	Returns a pointer to the new pixmap. Throws exception on failure to
    	allocate.
    """
    return _mupdf.fz_new_pixmap_with_data(colorspace, w, h, seps, alpha, stride, samples)

def fz_new_separations(controllable):
    r"""
    Class-aware wrapper for `::fz_new_separations()`.
    	Create a new separations structure (initially empty)
    """
    return _mupdf.fz_new_separations(controllable)

def fz_new_stext_device(page, options):
    r"""
    Class-aware wrapper for `::fz_new_stext_device()`.
    	Create a device to extract the text on a page.

    	Gather the text on a page into blocks and lines.

    	The reading order is taken from the order the text is drawn in
    	the source file, so may not be accurate.

    	page: The text page to which content should be added. This will
    	usually be a newly created (empty) text page, but it can be one
    	containing data already (for example when merging multiple
    	pages, or watermarking).

    	options: Options to configure the stext device.
    """
    return _mupdf.fz_new_stext_device(page, options)

def fz_new_store_context(max):
    r"""
    Class-aware wrapper for `::fz_new_store_context()`.
    	Create a new store inside the context

    	max: The maximum size (in bytes) that the store is allowed to
    	grow to. FZ_STORE_UNLIMITED means no limit.
    """
    return _mupdf.fz_new_store_context(max)

def fz_new_stream(state, next, drop):
    r"""
    Class-aware wrapper for `::fz_new_stream()`.
    	Create a new stream object with the given
    	internal state and function pointers.

    	state: Internal state (opaque to everything but implementation).

    	next: Should provide the next set of bytes (up to max) of stream
    	data. Return the number of bytes read, or EOF when there is no
    	more data.

    	drop: Should clean up and free the internal state. May not
    	throw exceptions.
    """
    return _mupdf.fz_new_stream(state, next, drop)

def fz_new_string(str):
    r""" Class-aware wrapper for `::fz_new_string()`."""
    return _mupdf.fz_new_string(str)

def fz_new_stroke_state():
    r"""
    Class-aware wrapper for `::fz_new_stroke_state()`.
    	Create a new (empty) stroke state structure (with no dash
    	data) and return a reference to it.

    	Throws exception on failure to allocate.
    """
    return _mupdf.fz_new_stroke_state()

def fz_new_stroke_state_with_dash_len(len):
    r"""
    Class-aware wrapper for `::fz_new_stroke_state_with_dash_len()`.
    	Create a new (empty) stroke state structure, with room for
    	dash data of the given length, and return a reference to it.

    	len: The number of dash elements to allow room for.

    	Throws exception on failure to allocate.
    """
    return _mupdf.fz_new_stroke_state_with_dash_len(len)

def fz_new_svg_device(out, page_width, page_height, text_format, reuse_images):
    r"""
    Class-aware wrapper for `::fz_new_svg_device()`.
    	Create a device that outputs (single page) SVG files to
    	the given output stream.

    	Equivalent to fz_new_svg_device_with_id passing id = NULL.
    """
    return _mupdf.fz_new_svg_device(out, page_width, page_height, text_format, reuse_images)

def fz_new_svg_device_with_id(out, page_width, page_height, text_format, reuse_images, id):
    r"""
    Class-aware wrapper for `::fz_new_svg_device_with_id()`.

    This function has out-params. Python/C# wrappers look like:
    	`fz_new_svg_device_with_id(::fz_output *out, float page_width, float page_height, int text_format, int reuse_images)` => `(fz_device *, int id)`

    	Create a device that outputs (single page) SVG files to
    	the given output stream.

    	output: The output stream to send the constructed SVG page to.

    	page_width, page_height: The page dimensions to use (in points).

    	text_format: How to emit text. One of the following values:
    		FZ_SVG_TEXT_AS_TEXT: As <text> elements with possible
    		layout errors and mismatching fonts.
    		FZ_SVG_TEXT_AS_PATH: As <path> elements with exact
    		visual appearance.

    	reuse_images: Share image resources using <symbol> definitions.

    	id: ID parameter to keep generated IDs unique across SVG files.
    """
    return _mupdf.fz_new_svg_device_with_id(out, page_width, page_height, text_format, reuse_images, id)

def fz_new_test_device(is_color, threshold, options, passthrough):
    r"""
    Class-aware wrapper for `::fz_new_test_device()`.

    This function has out-params. Python/C# wrappers look like:
    	`fz_new_test_device(float threshold, int options, ::fz_device *passthrough)` => `(fz_device *, int is_color)`

    	Create a device to test for features.

    	Currently only tests for the presence of non-grayscale colors.

    	is_color: Possible values returned:
    		0: Definitely greyscale
    		1: Probably color (all colors were grey, but there
    		were images or shadings in a non grey colorspace).
    		2: Definitely color

    	threshold: The difference from grayscale that will be tolerated.
    	Typical values to use are either 0 (be exact) and 0.02 (allow an
    	imperceptible amount of slop).

    	options: A set of bitfield options, from the FZ_TEST_OPT set.

    	passthrough: A device to pass all calls through to, or NULL.
    	If set, then the test device can both test and pass through to
    	an underlying device (like, say, the display list device). This
    	means that a display list can be created and at the end we'll
    	know if it's colored or not.

    	In the absence of a passthrough device, the device will throw
    	an exception to stop page interpretation when color is found.
    """
    return _mupdf.fz_new_test_device(is_color, threshold, options, passthrough)

def fz_new_text():
    r"""
    Class-aware wrapper for `::fz_new_text()`.
    	Create a new empty fz_text object.

    	Throws exception on failure to allocate.
    """
    return _mupdf.fz_new_text()

def fz_new_trace_device(out):
    r"""
    Class-aware wrapper for `::fz_new_trace_device()`.
    	Create a device to print a debug trace of all device calls.
    """
    return _mupdf.fz_new_trace_device(out)

def fz_new_tree_archive(tree):
    r"""
    Class-aware wrapper for `::fz_new_tree_archive()`.
    	Create an archive that holds named buffers.

    	tree can either be a preformed tree with fz_buffers as values,
    	or it can be NULL for an empty tree.
    """
    return _mupdf.fz_new_tree_archive(tree)

def fz_new_type3_font(name, matrix):
    r"""
    Class-aware wrapper for `::fz_new_type3_font()`.
    	Create a new (empty) type3 font.

    	name: Name of font (or NULL).

    	matrix: Font matrix.

    	Returns a new font handle, or throws exception on
    	allocation failure.
    """
    return _mupdf.fz_new_type3_font(name, matrix)

def fz_new_xhtml_document_from_document(old_doc, opts):
    r"""
    Class-aware wrapper for `::fz_new_xhtml_document_from_document()`.
    	Use text extraction to convert the input document into XHTML,
    	then open the result as a new document that can be reflowed.
    """
    return _mupdf.fz_new_xhtml_document_from_document(old_doc, opts)

def fz_new_xmltext_device(out):
    r"""
    Class-aware wrapper for `::fz_new_xmltext_device()`.
    	Create a device to output raw information.
    """
    return _mupdf.fz_new_xmltext_device(out)

def fz_next_page(doc, loc):
    r"""
    Class-aware wrapper for `::fz_next_page()`.
    	Function to get the location of the next page (allowing for the
    	end of chapters etc). If at the end of the document, returns the
    	current location.
    """
    return _mupdf.fz_next_page(doc, loc)

def fz_normalize_vector(p):
    r"""
    Class-aware wrapper for `::fz_normalize_vector()`.
    	Normalize a vector to length one.
    """
    return _mupdf.fz_normalize_vector(p)

def fz_open_a85d(chain):
    r"""
    Class-aware wrapper for `::fz_open_a85d()`.
    	a85d filter performs ASCII 85 Decoding of data read
    	from the chained filter.
    """
    return _mupdf.fz_open_a85d(chain)

def fz_open_accelerated_document(filename, accel):
    r"""
    Class-aware wrapper for `::fz_open_accelerated_document()`.
    	Open a document file and read its basic structure so pages and
    	objects can be located. MuPDF will try to repair broken
    	documents (without actually changing the file contents).

    	The returned fz_document is used when calling most other
    	document related functions.

    	filename: a path to a file as it would be given to open(2).
    """
    return _mupdf.fz_open_accelerated_document(filename, accel)

def fz_open_accelerated_document_with_stream(magic, stream, accel):
    r"""
    Class-aware wrapper for `::fz_open_accelerated_document_with_stream()`.
    	Open a document using the specified stream object rather than
    	opening a file on disk.

    	magic: a string used to detect document type; either a file name
    	or mime-type.

    	stream: a stream of the document contents.

    	accel: NULL, or a stream of the 'accelerator' contents for this document.

    	NOTE: The caller retains ownership of 'stream' and 'accel' - the document will
    	take its own references if required.
    """
    return _mupdf.fz_open_accelerated_document_with_stream(magic, stream, accel)

def fz_open_accelerated_document_with_stream_and_dir(magic, stream, accel, dir):
    r"""
    Class-aware wrapper for `::fz_open_accelerated_document_with_stream_and_dir()`.
    	Open a document using the specified stream object rather than
    	opening a file on disk.

    	magic: a string used to detect document type; either a file name
    	or mime-type.

    	stream: a stream of the document contents.

    	accel: NULL, or a stream of the 'accelerator' contents for this document.

    	dir: NULL, or the 'directory context' for the stream contents.

    	NOTE: The caller retains ownership of 'stream', 'accel' and 'dir' - the document will
    	take its own references if required.
    """
    return _mupdf.fz_open_accelerated_document_with_stream_and_dir(magic, stream, accel, dir)

def fz_open_aesd(chain, key, keylen):
    r"""
    Class-aware wrapper for `::fz_open_aesd()`.
    	aesd filter performs AES decoding of data read from the chained
    	filter using the supplied key.
    """
    return _mupdf.fz_open_aesd(chain, key, keylen)

def fz_open_ahxd(chain):
    r"""
    Class-aware wrapper for `::fz_open_ahxd()`.
    	ahxd filter performs ASCII Hex decoding of data read
    	from the chained filter.
    """
    return _mupdf.fz_open_ahxd(chain)

def fz_open_arc4(chain, key, keylen):
    r"""
    Class-aware wrapper for `::fz_open_arc4()`.
    	arc4 filter performs RC4 decoding of data read from the chained
    	filter using the supplied key.
    """
    return _mupdf.fz_open_arc4(chain, key, keylen)

def fz_open_archive(filename):
    r"""
    Class-aware wrapper for `::fz_open_archive()`.
    	Open a zip or tar archive

    	Open a file and identify its archive type based on the archive
    	signature contained inside.

    	filename: a path to a file as it would be given to open(2).
    """
    return _mupdf.fz_open_archive(filename)

def fz_open_archive_entry(arch, name):
    r"""
    Class-aware wrapper for `::fz_open_archive_entry()`.
    	Opens an archive entry as a stream.

    	name: Entry name to look for, this must be an exact match to
    	the entry name in the archive.

    	Throws an exception if a matching entry cannot be found.
    """
    return _mupdf.fz_open_archive_entry(arch, name)

def fz_open_archive_with_stream(file):
    r"""
    Class-aware wrapper for `::fz_open_archive_with_stream()`.
    	Open zip or tar archive stream.

    	Open an archive using a seekable stream object rather than
    	opening a file or directory on disk.
    """
    return _mupdf.fz_open_archive_with_stream(file)

def fz_open_buffer(buf):
    r"""
    Class-aware wrapper for `::fz_open_buffer()`.
    	Open a buffer as a stream.

    	buf: The buffer to open. Ownership of the buffer is NOT passed
    	in (this function takes its own reference).

    	Returns pointer to newly created stream. May throw exceptions on
    	failure to allocate.
    """
    return _mupdf.fz_open_buffer(buf)

def fz_open_cfb_archive(filename):
    r"""
    Class-aware wrapper for `::fz_open_cfb_archive()`.
    	Open a cfb file as an archive.

    	An exception is thrown if the file is not recognised as a cfb.

    	filename: a path to an archive file as it would be given to
    	open(2).
    """
    return _mupdf.fz_open_cfb_archive(filename)

def fz_open_cfb_archive_with_stream(file):
    r"""
    Class-aware wrapper for `::fz_open_cfb_archive_with_stream()`.
    	Open a cfb file as an archive.

    	Open an archive using a seekable stream object rather than
    	opening a file or directory on disk.

    	An exception is thrown if the file is not recognised as a chm.
    """
    return _mupdf.fz_open_cfb_archive_with_stream(file)

def fz_open_compressed_buffer(arg_0):
    r"""
    Class-aware wrapper for `::fz_open_compressed_buffer()`.
    	Open a stream to read the decompressed version of a buffer.
    """
    return _mupdf.fz_open_compressed_buffer(arg_0)

def fz_open_concat(max, pad):
    r"""
    Class-aware wrapper for `::fz_open_concat()`.
    	Concat filter concatenates several streams into one.
    """
    return _mupdf.fz_open_concat(max, pad)

def fz_open_dctd(chain, color_transform, invert_cmyk, l2factor, jpegtables):
    r"""
    Class-aware wrapper for `::fz_open_dctd()`.
    	dctd filter performs DCT (JPEG) decoding of data read
    	from the chained filter.

    	color_transform implements the PDF color_transform option
    		use -1 for default behavior
    		use 0 to disable YUV-RGB / YCCK-CMYK transforms
    		use 1 to enable YUV-RGB / YCCK-CMYK transforms

    	invert_cmyk implements the necessary inversion for Photoshop CMYK images
    		use 0 if embedded in PDF
    		use 1 if not embedded in PDF

    	For subsampling on decode, set l2factor to the log2 of the
    	reduction required (therefore 0 = full size decode).

    	jpegtables is an optional stream from which the JPEG tables
    	can be read. Use NULL if not required.
    """
    return _mupdf.fz_open_dctd(chain, color_transform, invert_cmyk, l2factor, jpegtables)

def fz_open_directory(path):
    r"""
    Class-aware wrapper for `::fz_open_directory()`.
    	Open a directory as if it was an archive.

    	A special case where a directory is opened as if it was an
    	archive.

    	Note that for directories it is not possible to retrieve the
    	number of entries or list the entries. It is however possible
    	to check if the archive has a particular entry.

    	path: a path to a directory as it would be given to opendir(3).
    """
    return _mupdf.fz_open_directory(path)

def fz_open_document(filename):
    r"""
    Class-aware wrapper for `::fz_open_document()`.
    	Open a document file and read its basic structure so pages and
    	objects can be located. MuPDF will try to repair broken
    	documents (without actually changing the file contents).

    	The returned fz_document is used when calling most other
    	document related functions.

    	filename: a path to a file as it would be given to open(2).
    """
    return _mupdf.fz_open_document(filename)

def fz_open_document_with_buffer(magic, buffer):
    r"""
    Class-aware wrapper for `::fz_open_document_with_buffer()`.
    	Open a document using a buffer rather than opening a file on disk.
    """
    return _mupdf.fz_open_document_with_buffer(magic, buffer)

def fz_open_document_with_stream(magic, stream):
    r"""
    Class-aware wrapper for `::fz_open_document_with_stream()`.
    	Open a document using the specified stream object rather than
    	opening a file on disk.

    	magic: a string used to detect document type; either a file name
    	or mime-type.

    	stream: a stream representing the contents of the document file.

    	NOTE: The caller retains ownership of 'stream' - the document will take its
    	own reference if required.
    """
    return _mupdf.fz_open_document_with_stream(magic, stream)

def fz_open_document_with_stream_and_dir(magic, stream, dir):
    r"""
    Class-aware wrapper for `::fz_open_document_with_stream_and_dir()`.
    	Open a document using the specified stream object rather than
    	opening a file on disk.

    	magic: a string used to detect document type; either a file name
    	or mime-type.

    	stream: a stream representing the contents of the document file.

    	dir: a 'directory context' for those filetypes that need it.

    	NOTE: The caller retains ownership of 'stream' and 'dir' - the document will
    	take its own references if required.
    """
    return _mupdf.fz_open_document_with_stream_and_dir(magic, stream, dir)

def fz_open_endstream_filter(chain, len, offset):
    r"""
    Class-aware wrapper for `::fz_open_endstream_filter()`.
    	The endstream filter reads a PDF substream, and starts to look
    	for an 'endstream' token after the specified length.
    """
    return _mupdf.fz_open_endstream_filter(chain, len, offset)

def fz_open_faxd(chain, k, end_of_line, encoded_byte_align, columns, rows, end_of_block, black_is_1):
    r"""
    Class-aware wrapper for `::fz_open_faxd()`.
    	faxd filter performs FAX decoding of data read from
    	the chained filter.

    	k: see fax specification (fax default is 0).

    	end_of_line: whether we expect end of line markers (fax default
    	is 0).

    	encoded_byte_align: whether we align to bytes after each line
    	(fax default is 0).

    	columns: how many columns in the image (fax default is 1728).

    	rows: 0 for unspecified or the number of rows of data to expect.

    	end_of_block: whether we expect end of block markers (fax
    	default is 1).

    	black_is_1: determines the polarity of the image (fax default is
    	0).
    """
    return _mupdf.fz_open_faxd(chain, k, end_of_line, encoded_byte_align, columns, rows, end_of_block, black_is_1)

def fz_open_file(filename):
    r"""
    Class-aware wrapper for `::fz_open_file()`.
    	Open the named file and wrap it in a stream.

    	filename: Path to a file. On non-Windows machines the filename
    	should be exactly as it would be passed to fopen(2). On Windows
    	machines, the path should be UTF-8 encoded so that non-ASCII
    	characters can be represented. Other platforms do the encoding
    	as standard anyway (and in most cases, particularly for MacOS
    	and Linux, the encoding they use is UTF-8 anyway).
    """
    return _mupdf.fz_open_file(filename)

def fz_open_file_ptr_no_close(file):
    r"""
    Class-aware wrapper for `::fz_open_file_ptr_no_close()`.
    	Create a stream from a FILE * that will not be closed
    	when the stream is dropped.
    """
    return _mupdf.fz_open_file_ptr_no_close(file)

def fz_open_flated(chain, window_bits):
    r"""
    Class-aware wrapper for `::fz_open_flated()`.
    	flated filter performs LZ77 decoding (inflating) of data read
    	from the chained filter.

    	window_bits: How large a decompression window to use. Typically
    	15. A negative number, -n, means to use n bits, but to expect
    	raw data with no header.
    """
    return _mupdf.fz_open_flated(chain, window_bits)

def fz_open_image_decomp_stream(arg_0, arg_1, l2factor):
    r"""
    Class-aware wrapper for `::fz_open_image_decomp_stream()`.

    This function has out-params. Python/C# wrappers look like:
    	`fz_open_image_decomp_stream(::fz_stream *arg_0, ::fz_compression_params *arg_1)` => `(fz_stream *, int l2factor)`

    	Open a stream to read the decompressed version of another stream
    	with optional log2 subsampling.
    """
    return _mupdf.fz_open_image_decomp_stream(arg_0, arg_1, l2factor)

def fz_open_image_decomp_stream_from_buffer(arg_0, l2factor):
    r"""
    Class-aware wrapper for `::fz_open_image_decomp_stream_from_buffer()`.

    This function has out-params. Python/C# wrappers look like:
    	`fz_open_image_decomp_stream_from_buffer(::fz_compressed_buffer *arg_0)` => `(fz_stream *, int l2factor)`

    	Open a stream to read the decompressed version of a buffer,
    	with optional log2 subsampling.

    	l2factor = NULL for no subsampling, or a pointer to an integer
    	containing the maximum log2 subsample factor acceptable (0 =
    	none, 1 = halve dimensions, 2 = quarter dimensions etc). If
    	non-NULL, then *l2factor will be updated on exit with the actual
    	log2 subsample factor achieved.
    """
    return _mupdf.fz_open_image_decomp_stream_from_buffer(arg_0, l2factor)

def fz_open_jbig2d(chain, globals, embedded):
    r"""
    Class-aware wrapper for `::fz_open_jbig2d()`.
    	Open a filter that performs jbig2 decompression on the chained
    	stream, using the optional globals record.
    """
    return _mupdf.fz_open_jbig2d(chain, globals, embedded)

def fz_open_leecher(chain, buf):
    r"""
    Class-aware wrapper for `::fz_open_leecher()`.
    	Attach a filter to a stream that will store any
    	characters read from the stream into the supplied buffer.

    	chain: The underlying stream to leech from.

    	buf: The buffer into which the read data should be appended.
    	The buffer will be resized as required.

    	Returns pointer to newly created stream. May throw exceptions on
    	failure to allocate.
    """
    return _mupdf.fz_open_leecher(chain, buf)

def fz_open_libarchive_archive(filename):
    r"""
    Class-aware wrapper for `::fz_open_libarchive_archive()`.
    	Open an archive using libarchive.

    	An exception is thrown if the file is not supported by libarchive.

    	filename: a path to an archive file as it would be given to
    	open(2).
    """
    return _mupdf.fz_open_libarchive_archive(filename)

def fz_open_libarchive_archive_with_stream(file):
    r"""
    Class-aware wrapper for `::fz_open_libarchive_archive_with_stream()`.
    	Open an archive using libarchive.

    	Open an archive using a seekable stream object rather than
    	opening a file or directory on disk.

    	An exception is thrown if the stream is not supported by libarchive.
    """
    return _mupdf.fz_open_libarchive_archive_with_stream(file)

def fz_open_libarchived(chain):
    r"""
    Class-aware wrapper for `::fz_open_libarchived()`.
    	libarchived filter performs generic compressed decoding of data
    	in any format understood by libarchive from the chained filter.

    	This will throw an exception if libarchive is not built in, or
    	if the compression format is not recognised.
    """
    return _mupdf.fz_open_libarchived(chain)

def fz_open_lzwd(chain, early_change, min_bits, reverse_bits, old_tiff):
    r"""
    Class-aware wrapper for `::fz_open_lzwd()`.
    	lzwd filter performs LZW decoding of data read from the chained
    	filter.

    	early_change: (Default 1) specifies whether to change codes 1
    	bit early.

    	min_bits: (Default 9) specifies the minimum number of bits to
    	use.

    	reverse_bits: (Default 0) allows for compatibility with gif and
    	old style tiffs (1).

    	old_tiff: (Default 0) allows for different handling of the clear
    	code, as found in old style tiffs.
    """
    return _mupdf.fz_open_lzwd(chain, early_change, min_bits, reverse_bits, old_tiff)

def fz_open_memory(data, len):
    r"""
    Class-aware wrapper for `::fz_open_memory()`.
    	Open a block of memory as a stream.

    	data: Pointer to start of data block. Ownership of the data
    	block is NOT passed in.

    	len: Number of bytes in data block.

    	Returns pointer to newly created stream. May throw exceptions on
    	failure to allocate.
    """
    return _mupdf.fz_open_memory(data, len)

def fz_open_null_filter(chain, len, offset):
    r"""
    Class-aware wrapper for `::fz_open_null_filter()`.
    	The null filter reads a specified amount of data from the
    	substream.
    """
    return _mupdf.fz_open_null_filter(chain, len, offset)

def fz_open_predict(chain, predictor, columns, colors, bpc):
    r"""
    Class-aware wrapper for `::fz_open_predict()`.
    	predict filter performs pixel prediction on data read from
    	the chained filter.

    	predictor: 1 = copy, 2 = tiff, other = inline PNG predictor

    	columns: width of image in pixels

    	colors: number of components.

    	bpc: bits per component (typically 8)
    """
    return _mupdf.fz_open_predict(chain, predictor, columns, colors, bpc)

def fz_open_range_filter(chain, ranges, nranges):
    r"""
    Class-aware wrapper for `::fz_open_range_filter()`.
    	The range filter copies data from specified ranges of the
    	chained stream.
    """
    return _mupdf.fz_open_range_filter(chain, ranges, nranges)

def fz_open_reflowed_document(underdoc, opts):
    r""" Class-aware wrapper for `::fz_open_reflowed_document()`."""
    return _mupdf.fz_open_reflowed_document(underdoc, opts)

def fz_open_rld(chain):
    r"""
    Class-aware wrapper for `::fz_open_rld()`.
    	rld filter performs Run Length Decoding of data read
    	from the chained filter.
    """
    return _mupdf.fz_open_rld(chain)

def fz_open_sgilog16(chain, w):
    r"""
    Class-aware wrapper for `::fz_open_sgilog16()`.
    	SGI Log 16bit (greyscale) decode from the chained filter.
    	Decodes lines of w pixels to 8bpp greyscale.
    """
    return _mupdf.fz_open_sgilog16(chain, w)

def fz_open_sgilog24(chain, w):
    r"""
    Class-aware wrapper for `::fz_open_sgilog24()`.
    	SGI Log 24bit (LUV) decode from the chained filter.
    	Decodes lines of w pixels to 8bpc rgb.
    """
    return _mupdf.fz_open_sgilog24(chain, w)

def fz_open_sgilog32(chain, w):
    r"""
    Class-aware wrapper for `::fz_open_sgilog32()`.
    	SGI Log 32bit (LUV) decode from the chained filter.
    	Decodes lines of w pixels to 8bpc rgb.
    """
    return _mupdf.fz_open_sgilog32(chain, w)

def fz_open_tar_archive(filename):
    r"""
    Class-aware wrapper for `::fz_open_tar_archive()`.
    	Open a tar archive file.

    	An exception is thrown if the file is not a tar archive as
    	indicated by the presence of a tar signature.

    	filename: a path to a tar archive file as it would be given to
    	open(2).
    """
    return _mupdf.fz_open_tar_archive(filename)

def fz_open_tar_archive_with_stream(file):
    r"""
    Class-aware wrapper for `::fz_open_tar_archive_with_stream()`.
    	Open a tar archive stream.

    	Open an archive using a seekable stream object rather than
    	opening a file or directory on disk.

    	An exception is thrown if the stream is not a tar archive as
    	indicated by the presence of a tar signature.

    """
    return _mupdf.fz_open_tar_archive_with_stream(file)

def fz_open_thunder(chain, w):
    r"""
    Class-aware wrapper for `::fz_open_thunder()`.
    	4bit greyscale Thunderscan decoding from the chained filter.
    	Decodes lines of w pixels to 8bpp greyscale.
    """
    return _mupdf.fz_open_thunder(chain, w)

def fz_open_zip_archive(path):
    r"""
    Class-aware wrapper for `::fz_open_zip_archive()`.
    	Open a zip archive file.

    	An exception is thrown if the file is not a zip archive as
    	indicated by the presence of a zip signature.

    	filename: a path to a zip archive file as it would be given to
    	open(2).
    """
    return _mupdf.fz_open_zip_archive(path)

def fz_open_zip_archive_with_stream(file):
    r"""
    Class-aware wrapper for `::fz_open_zip_archive_with_stream()`.
    	Open a zip archive stream.

    	Open an archive using a seekable stream object rather than
    	opening a file or directory on disk.

    	An exception is thrown if the stream is not a zip archive as
    	indicated by the presence of a zip signature.

    """
    return _mupdf.fz_open_zip_archive_with_stream(file)

def fz_opt_from_list(opt, optlist):
    r"""
    Class-aware wrapper for `::fz_opt_from_list()`.
    	Return the index of a (case-insensitive) option within an optlist.

    	For instance for optlist = "Foo|Bar|Baz", and  opt = "bar",
    	this would return 1.

    	If the optlist ends with "|*" then that is a catch all case and
    	matches all options allowing the caller to process it itself.
    	fz_optarg will be set to point to the option, and the return
    	value will be the index of the '*' option within that list.

    	If an optlist entry ends with ':' (e.g. "Foo:") then that option
    	may have suboptions appended to it (for example "JPG:80") and
    	fz_optarg will be set to point at "80". Otherwise fz_optarg will
    	be set to NULL.

    	In the event of no-match found, prints an error and returns -1.
    """
    return _mupdf.fz_opt_from_list(opt, optlist)

def fz_option_eq(a, b):
    r"""
    Class-aware wrapper for `::fz_option_eq()`.
    	Check to see if an option, a, from a string matches a reference
    	option, b.

    	(i.e. a could be 'foo' or 'foo,bar...' etc, but b can only be
    	'foo'.)
    """
    return _mupdf.fz_option_eq(a, b)

def fz_outline_glyph(font, gid, ctm):
    r"""
    Class-aware wrapper for `::fz_outline_glyph()`.
    	Look a glyph up from a font, and return the outline of the
    	glyph using the given transform.

    	The caller owns the returned path, and so is responsible for
    	ensuring that it eventually gets dropped.
    """
    return _mupdf.fz_outline_glyph(font, gid, ctm)

def fz_outline_iterator_delete(iter):
    r"""
    Class-aware wrapper for `::fz_outline_iterator_delete()`.
    	Delete the current item.

    	This implicitly moves us to the 'next' item, and the return code is as for fz_outline_iterator_next.
    """
    return _mupdf.fz_outline_iterator_delete(iter)

def fz_outline_iterator_down(iter):
    r""" Class-aware wrapper for `::fz_outline_iterator_down()`."""
    return _mupdf.fz_outline_iterator_down(iter)

def fz_outline_iterator_item(iter):
    r"""
    Class-aware wrapper for `::fz_outline_iterator_item()`.
    	Call to get the current outline item.

    	Can return NULL. The item is only valid until the next call.
    """
    return _mupdf.fz_outline_iterator_item(iter)

def fz_outline_iterator_next(iter):
    r"""
    Class-aware wrapper for `::fz_outline_iterator_next()`.
    	Calls to move the iterator position.

    	A negative return value means we could not move as requested. Otherwise:
    	0 = the final position has a valid item.
    	1 = not a valid item, but we can insert an item here.
    """
    return _mupdf.fz_outline_iterator_next(iter)

def fz_outline_iterator_prev(iter):
    r""" Class-aware wrapper for `::fz_outline_iterator_prev()`."""
    return _mupdf.fz_outline_iterator_prev(iter)

def fz_outline_iterator_up(iter):
    r""" Class-aware wrapper for `::fz_outline_iterator_up()`."""
    return _mupdf.fz_outline_iterator_up(iter)

def fz_output_accelerator(doc, accel):
    r"""
    Class-aware wrapper for `::fz_output_accelerator()`.
    	Output accelerator data for the document to a given output
    	stream.
    """
    return _mupdf.fz_output_accelerator(doc, accel)

def fz_output_supports_stream(out):
    r"""
    Class-aware wrapper for `::fz_output_supports_stream()`.
    	Query whether a given fz_output supports fz_stream_from_output.
    """
    return _mupdf.fz_output_supports_stream(out)

def fz_output_xml(out, item, level):
    r"""
    Class-aware wrapper for `::fz_output_xml()`.
    	Pretty-print an XML tree to given output.
    """
    return _mupdf.fz_output_xml(out, item, level)

def fz_pack_path(pack, path):
    r"""
    Class-aware wrapper for `::fz_pack_path()`.
    	Pack a path into the given block.
    	To minimise the size of paths, this function allows them to be
    	packed into a buffer with other information. Paths can be used
    	interchangeably regardless of how they are packed.

    	pack: Pointer to a block of data to pack the path into. Should
    	be aligned by the caller to the same alignment as required for
    	a fz_path pointer.

    	path: The path to pack.

    	Returns the number of bytes within the block used. Callers can
    	access the packed path data by casting the value of pack on
    	entry to be a fz_path *.

    	Throws exceptions on failure to allocate.

    	Implementation details: Paths can be 'unpacked', 'flat', or
    	'open'. Standard paths, as created are 'unpacked'. Paths
    	will be packed as 'flat', unless they are too large
    	(where large indicates that they exceed some private
    	implementation defined limits, currently including having
    	more than 256 coordinates or commands).

    	Large paths are 'open' packed as a header into the given block,
    	plus pointers to other data blocks.

    	Users should not have to care about whether paths are 'open'
    	or 'flat' packed. Simply pack a path (if required), and then
    	forget about the details.
    """
    return _mupdf.fz_pack_path(pack, path)

def fz_packed_path_size(path):
    r"""
    Class-aware wrapper for `::fz_packed_path_size()`.
    	Return the number of bytes required to pack a path.
    """
    return _mupdf.fz_packed_path_size(path)

def fz_page_label(page, buf, size):
    r"""
    Class-aware wrapper for `::fz_page_label()`.
    	Get page label for a given page.
    """
    return _mupdf.fz_page_label(page, buf, size)

def fz_page_number_from_location(doc, loc):
    r"""
    Class-aware wrapper for `::fz_page_number_from_location()`.
    	Converts from chapter+page to page number. This may cause many
    	chapters to be laid out in order to calculate the number of
    	pages within those chapters.
    """
    return _mupdf.fz_page_number_from_location(doc, loc)

def fz_page_presentation(page, transition, duration):
    r"""
    Class-aware wrapper for `::fz_page_presentation()`.

    This function has out-params. Python/C# wrappers look like:
    	`fz_page_presentation(::fz_page *page, ::fz_transition *transition)` => `(fz_transition *, float duration)`

    	Get the presentation details for a given page.

    	transition: A pointer to a transition struct to fill out.

    	duration: A pointer to a place to set the page duration in
    	seconds. Will be set to 0 if no transition is specified for the
    	page.

    	Returns: a pointer to the transition structure, or NULL if there
    	is no transition specified for the page.
    """
    return _mupdf.fz_page_presentation(page, transition, duration)

def fz_page_separations(page):
    r"""
    Class-aware wrapper for `::fz_page_separations()`.
    	Get the separations details for a page.
    	This will be NULL, unless the format specifically supports
    	separations (such as PDF files). May be NULL even
    	so, if there are no separations on a page.

    	Returns a reference that must be dropped.
    """
    return _mupdf.fz_page_separations(page)

def fz_page_uses_overprint(page):
    r"""
    Class-aware wrapper for `::fz_page_uses_overprint()`.
    	Query if a given page requires overprint.
    """
    return _mupdf.fz_page_uses_overprint(page)

def fz_paint_shade(shade, override_cs, ctm, dest, color_params, bbox, eop, cache):
    r"""
    Class-aware wrapper for `::fz_paint_shade()`.

    This function has out-params. Python/C# wrappers look like:
    	`fz_paint_shade(::fz_shade *shade, ::fz_colorspace *override_cs, ::fz_matrix ctm, ::fz_pixmap *dest, ::fz_color_params color_params, ::fz_irect bbox, const ::fz_overprint *eop, ::fz_shade_color_cache **cache)` =>

    	Render a shade to a given pixmap.

    	shade: The shade to paint.

    	override_cs: NULL, or colorspace to override the shades
    	inbuilt colorspace.

    	ctm: The transform to apply.

    	dest: The pixmap to render into.

    	color_params: The color rendering settings

    	bbox: Pointer to a bounding box to limit the rendering
    	of the shade.

    	eop: NULL, or pointer to overprint bitmap.

    	cache: *cache is used to cache color information. If *cache is NULL it
    	is set to point to a new fz_shade_color_cache. If cache is NULL it is
    	ignored.
    """
    return _mupdf.fz_paint_shade(shade, override_cs, ctm, dest, color_params, bbox, eop, cache)

def fz_parse_page_range(s, a, b, n):
    r"""
    Class-aware wrapper for `::fz_parse_page_range()`.

    This function has out-params. Python/C# wrappers look like:
    	`fz_parse_page_range(const char *s, int n)` => `(const char *, int a, int b)`
    """
    return _mupdf.fz_parse_page_range(s, a, b, n)

def fz_parse_pdfocr_options(opts, args):
    r"""
    Class-aware wrapper for `::fz_parse_pdfocr_options()`.
    	Parse PDFOCR options.

    	Currently defined options and values are as follows:

    		compression=none: No compression
    		compression=flate: Flate compression
    		strip-height=n: Strip height (default 16)
    		ocr-language=<lang>: OCR Language (default eng)
    		ocr-datadir=<datadir>: OCR data path (default rely on TESSDATA_PREFIX)
    """
    return _mupdf.fz_parse_pdfocr_options(opts, args)

def fz_parse_stext_options(opts, string):
    r"""
    Class-aware wrapper for `::fz_parse_stext_options()`.
    	Parse stext device options from a comma separated key-value
    	string.
    """
    return _mupdf.fz_parse_stext_options(opts, string)

def fz_parse_xml(buf, preserve_white):
    r"""
    Class-aware wrapper for `::fz_parse_xml()`.
    	Parse the contents of buffer into a tree of xml nodes.

    	preserve_white: whether to keep or delete all-whitespace nodes.
    """
    return _mupdf.fz_parse_xml(buf, preserve_white)

def fz_parse_xml_archive_entry(dir, filename, preserve_white):
    r"""
    Class-aware wrapper for `::fz_parse_xml_archive_entry()`.
    	Parse the contents of an archive entry into a tree of xml nodes.

    	preserve_white: whether to keep or delete all-whitespace nodes.
    """
    return _mupdf.fz_parse_xml_archive_entry(dir, filename, preserve_white)

def fz_parse_xml_from_html5(buf):
    r"""
    Class-aware wrapper for `::fz_parse_xml_from_html5()`.
    	Parse the contents of a buffer into a tree of XML nodes,
    	using the HTML5 parsing algorithm.
    """
    return _mupdf.fz_parse_xml_from_html5(buf)

def fz_parse_xml_stream(stream, preserve_white):
    r"""
    Class-aware wrapper for `::fz_parse_xml_stream()`.
    	Parse the contents of buffer into a tree of xml nodes.

    	preserve_white: whether to keep or delete all-whitespace nodes.
    """
    return _mupdf.fz_parse_xml_stream(stream, preserve_white)

def fz_pcl_preset(opts, preset):
    r"""
    Class-aware wrapper for `::fz_pcl_preset()`.
    	Initialize PCL option struct for a given preset.

    	Currently defined presets include:

    		generic	Generic PCL printer
    		ljet4	HP DeskJet
    		dj500	HP DeskJet 500
    		fs600	Kyocera FS-600
    		lj	HP LaserJet, HP LaserJet Plus
    		lj2	HP LaserJet IIp, HP LaserJet IId
    		lj3	HP LaserJet III
    		lj3d	HP LaserJet IIId
    		lj4	HP LaserJet 4
    		lj4pl	HP LaserJet 4 PL
    		lj4d	HP LaserJet 4d
    		lp2563b	HP 2563B line printer
    		oce9050	Oce 9050 Line printer
    """
    return _mupdf.fz_pcl_preset(opts, preset)

def fz_pdfocr_band_writer_set_progress(writer, progress_fn, progress_arg):
    r"""
    Class-aware wrapper for `::fz_pdfocr_band_writer_set_progress()`.
    	Set the progress callback for a pdfocr bandwriter.
    """
    return _mupdf.fz_pdfocr_band_writer_set_progress(writer, progress_fn, progress_arg)

def fz_pdfocr_writer_set_progress(writer, progress, arg_2):
    r""" Class-aware wrapper for `::fz_pdfocr_writer_set_progress()`."""
    return _mupdf.fz_pdfocr_writer_set_progress(writer, progress, arg_2)

def fz_peek_byte(stm):
    r"""
    Class-aware wrapper for `::fz_peek_byte()`.
    	Peek at the next byte in a stream.

    	stm: The stream to peek at.

    	Returns -1 for EOF, or the next byte that will be read.
    """
    return _mupdf.fz_peek_byte(stm)

def fz_pixmap_alpha(pix):
    r"""
    Class-aware wrapper for `::fz_pixmap_alpha()`.
    	Return the number of alpha planes in a pixmap.

    	Returns the number of alphas. Does not throw exceptions.
    """
    return _mupdf.fz_pixmap_alpha(pix)

def fz_pixmap_bbox(pix):
    r"""
    Class-aware wrapper for `::fz_pixmap_bbox()`.
    	Return the bounding box for a pixmap.
    """
    return _mupdf.fz_pixmap_bbox(pix)

def fz_pixmap_colorants(pix):
    r"""
    Class-aware wrapper for `::fz_pixmap_colorants()`.
    	Return the number of colorants in a pixmap.

    	Returns the number of colorants (components, less any spots and
    	alpha).
    """
    return _mupdf.fz_pixmap_colorants(pix)

def fz_pixmap_colorspace(pix):
    r"""
    Class-aware wrapper for `::fz_pixmap_colorspace()`.
    	Return the colorspace of a pixmap

    	Returns colorspace.
    """
    return _mupdf.fz_pixmap_colorspace(pix)

def fz_pixmap_components(pix):
    r"""
    Class-aware wrapper for `::fz_pixmap_components()`.
    	Return the number of components in a pixmap.

    	Returns the number of components (including spots and alpha).
    """
    return _mupdf.fz_pixmap_components(pix)

def fz_pixmap_height(pix):
    r"""
    Class-aware wrapper for `::fz_pixmap_height()`.
    	Return the height of the pixmap in pixels.
    """
    return _mupdf.fz_pixmap_height(pix)

def fz_pixmap_image_tile(cimg):
    r"""
    Class-aware wrapper for `::fz_pixmap_image_tile()`.
    	Retrieve the underlying fz_pixmap for an image.

    	Returns a pointer to the underlying fz_pixmap for an image,
    	or NULL if this image is not based upon an fz_pixmap.

    	No reference is returned. Lifespan is limited to that of
    	the image itself. If required, use fz_keep_pixmap to take
    	a reference to keep it longer.
    """
    return _mupdf.fz_pixmap_image_tile(cimg)

def fz_pixmap_samples(pix):
    r"""
    Class-aware wrapper for `::fz_pixmap_samples()`.
    	Returns a pointer to the pixel data of a pixmap.

    	Returns the pointer.
    """
    return _mupdf.fz_pixmap_samples(pix)

def fz_pixmap_samples_int(pixmap):
    r""" Class-aware wrapper for `::fz_pixmap_samples_int()`."""
    return _mupdf.fz_pixmap_samples_int(pixmap)

def fz_pixmap_size(pix):
    r"""
    Class-aware wrapper for `::fz_pixmap_size()`.
    	Return sizeof fz_pixmap plus size of data, in bytes.
    """
    return _mupdf.fz_pixmap_size(pix)

def fz_pixmap_spots(pix):
    r"""
    Class-aware wrapper for `::fz_pixmap_spots()`.
    	Return the number of spots in a pixmap.

    	Returns the number of spots (components, less colorants and
    	alpha). Does not throw exceptions.
    """
    return _mupdf.fz_pixmap_spots(pix)

def fz_pixmap_stride(pix):
    r"""
    Class-aware wrapper for `::fz_pixmap_stride()`.
    	Return the number of bytes in a row in the pixmap.
    """
    return _mupdf.fz_pixmap_stride(pix)

def fz_pixmap_width(pix):
    r"""
    Class-aware wrapper for `::fz_pixmap_width()`.
    	Return the width of the pixmap in pixels.
    """
    return _mupdf.fz_pixmap_width(pix)

def fz_pixmap_x(pix):
    r"""
    Class-aware wrapper for `::fz_pixmap_x()`.
    	Return the x value of the pixmap in pixels.
    """
    return _mupdf.fz_pixmap_x(pix)

def fz_pixmap_y(pix):
    r"""
    Class-aware wrapper for `::fz_pixmap_y()`.
    	Return the y value of the pixmap in pixels.
    """
    return _mupdf.fz_pixmap_y(pix)

def fz_place_story(story, where, filled):
    r""" Class-aware wrapper for `::fz_place_story()`."""
    return _mupdf.fz_place_story(story, where, filled)

def fz_place_story_flags(story, where, filled, flags):
    r""" Class-aware wrapper for `::fz_place_story_flags()`."""
    return _mupdf.fz_place_story_flags(story, where, filled, flags)

def fz_pool_alloc(pool, size):
    r"""
    Class-aware wrapper for `::fz_pool_alloc()`.
    	Allocate a block of size bytes from the pool.
    """
    return _mupdf.fz_pool_alloc(pool, size)

def fz_pool_size(pool):
    r"""
    Class-aware wrapper for `::fz_pool_size()`.
    	The current size of the pool.

    	The number of bytes of storage currently allocated to the pool.
    	This is the total of the storage used for the blocks making
    	up the pool, rather then total of the allocated blocks so far,
    	so it will increase in 'lumps'.
    	from the pool, then the pool size may still be X
    """
    return _mupdf.fz_pool_size(pool)

def fz_pool_strdup(pool, s):
    r"""
    Class-aware wrapper for `::fz_pool_strdup()`.
    	strdup equivalent allocating from the pool.
    """
    return _mupdf.fz_pool_strdup(pool, s)

def fz_pop_clip(dev):
    r""" Class-aware wrapper for `::fz_pop_clip()`."""
    return _mupdf.fz_pop_clip(dev)

def fz_post_scale(m, sx, sy):
    r"""
    Class-aware wrapper for `::fz_post_scale()`.
    	Scale a matrix by postmultiplication.

    	m: Pointer to the matrix to scale

    	sx, sy: Scaling factors along the X- and Y-axes. A scaling
    	factor of 1.0 will not cause any scaling along the relevant
    	axis.

    	Returns m (updated).
    """
    return _mupdf.fz_post_scale(m, sx, sy)

def fz_pre_rotate(m, degrees):
    r"""
    Class-aware wrapper for `::fz_pre_rotate()`.
    	Rotate a transformation by premultiplying.

    	The premultiplied matrix is of the form
    	[ cos(deg) sin(deg) -sin(deg) cos(deg) 0 0 ].

    	m: Pointer to matrix to premultiply.

    	degrees: Degrees of counter clockwise rotation. Values less
    	than zero and greater than 360 are handled as expected.

    	Returns m (updated).
    """
    return _mupdf.fz_pre_rotate(m, degrees)

def fz_pre_scale(m, sx, sy):
    r"""
    Class-aware wrapper for `::fz_pre_scale()`.
    	Scale a matrix by premultiplication.

    	m: Pointer to the matrix to scale

    	sx, sy: Scaling factors along the X- and Y-axes. A scaling
    	factor of 1.0 will not cause any scaling along the relevant
    	axis.

    	Returns m (updated).
    """
    return _mupdf.fz_pre_scale(m, sx, sy)

def fz_pre_shear(m, sx, sy):
    r"""
    Class-aware wrapper for `::fz_pre_shear()`.
    	Premultiply a matrix with a shearing matrix.

    	The shearing matrix is of the form [ 1 sy sx 1 0 0 ].

    	m: pointer to matrix to premultiply

    	sx, sy: Shearing factors. A shearing factor of 0.0 will not
    	cause any shearing along the relevant axis.

    	Returns m (updated).
    """
    return _mupdf.fz_pre_shear(m, sx, sy)

def fz_pre_translate(m, tx, ty):
    r"""
    Class-aware wrapper for `::fz_pre_translate()`.
    	Translate a matrix by premultiplication.

    	m: The matrix to translate

    	tx, ty: Translation distances along the X- and Y-axes. A
    	translation of 0 will not cause any translation along the
    	relevant axis.

    	Returns m.
    """
    return _mupdf.fz_pre_translate(m, tx, ty)

def fz_prepare_t3_glyph(font, gid):
    r"""
    Class-aware wrapper for `::fz_prepare_t3_glyph()`.
    	Force a type3 font to cache the displaylist for a given glyph
    	id.

    	This caching can involve reading the underlying file, so must
    	happen ahead of time, so we aren't suddenly forced to read the
    	file while playing a displaylist back.
    """
    return _mupdf.fz_prepare_t3_glyph(font, gid)

def fz_previous_page(doc, loc):
    r"""
    Class-aware wrapper for `::fz_previous_page()`.
    	Function to get the location of the previous page (allowing for
    	the end of chapters etc). If already at the start of the
    	document, returns the current page.
    """
    return _mupdf.fz_previous_page(doc, loc)

def fz_print_stext_header_as_html(out):
    r""" Class-aware wrapper for `::fz_print_stext_header_as_html()`."""
    return _mupdf.fz_print_stext_header_as_html(out)

def fz_print_stext_header_as_xhtml(out):
    r""" Class-aware wrapper for `::fz_print_stext_header_as_xhtml()`."""
    return _mupdf.fz_print_stext_header_as_xhtml(out)

def fz_print_stext_page_as_html(out, page, id):
    r"""
    Class-aware wrapper for `::fz_print_stext_page_as_html()`.
    	Output structured text to a file in HTML (visual) format.
    """
    return _mupdf.fz_print_stext_page_as_html(out, page, id)

def fz_print_stext_page_as_json(out, page, scale):
    r"""
    Class-aware wrapper for `::fz_print_stext_page_as_json()`.
    	Output structured text to a file in JSON format.
    """
    return _mupdf.fz_print_stext_page_as_json(out, page, scale)

def fz_print_stext_page_as_text(out, page):
    r"""
    Class-aware wrapper for `::fz_print_stext_page_as_text()`.
    	Output structured text to a file in plain-text UTF-8 format.
    """
    return _mupdf.fz_print_stext_page_as_text(out, page)

def fz_print_stext_page_as_xhtml(out, page, id):
    r"""
    Class-aware wrapper for `::fz_print_stext_page_as_xhtml()`.
    	Output structured text to a file in XHTML (semantic) format.
    """
    return _mupdf.fz_print_stext_page_as_xhtml(out, page, id)

def fz_print_stext_page_as_xml(out, page, id):
    r"""
    Class-aware wrapper for `::fz_print_stext_page_as_xml()`.
    	Output structured text to a file in XML format.
    """
    return _mupdf.fz_print_stext_page_as_xml(out, page, id)

def fz_print_stext_trailer_as_html(out):
    r""" Class-aware wrapper for `::fz_print_stext_trailer_as_html()`."""
    return _mupdf.fz_print_stext_trailer_as_html(out)

def fz_print_stext_trailer_as_xhtml(out):
    r""" Class-aware wrapper for `::fz_print_stext_trailer_as_xhtml()`."""
    return _mupdf.fz_print_stext_trailer_as_xhtml(out)

def fz_process_opened_pages(doc, process_openend_page, state):
    r"""
    Class-aware wrapper for `::fz_process_opened_pages()`.
    	Iterates over all opened pages of the document, calling the
    	provided callback for each page for processing. If the callback
    	returns non-NULL then the iteration stops and that value is returned
    	to the called of fz_process_opened_pages().

    	The state pointer provided to fz_process_opened_pages() is
    	passed on to the callback but is owned by the caller.

    	Returns the first non-NULL value returned by the callback,
    	or NULL if the callback returned NULL for all opened pages.
    """
    return _mupdf.fz_process_opened_pages(doc, process_openend_page, state)

def fz_process_shade(shade, ctm, scissor, prepare, process, process_arg):
    r"""
    Class-aware wrapper for `::fz_process_shade()`.
    	Process a shade, using supplied callback functions. This
    	decomposes the shading to a mesh (even ones that are not
    	natively meshes, such as linear or radial shadings), and
    	processes triangles from those meshes.

    	shade: The shade to process.

    	ctm: The transform to use

    	prepare: Callback function to 'prepare' each vertex.
    	This function is passed an array of floats, and populates
    	a fz_vertex structure.

    	process: This function is passed 3 pointers to vertex
    	structures, and actually performs the processing (typically
    	filling the area between the vertexes).

    	process_arg: An opaque argument passed through from caller
    	to callback functions.
    """
    return _mupdf.fz_process_shade(shade, ctm, scissor, prepare, process, process_arg)

def fz_ptr_heap_insert(heap, v, HEAP_CMP):
    r""" Class-aware wrapper for `::fz_ptr_heap_insert()`."""
    return _mupdf.fz_ptr_heap_insert(heap, v, HEAP_CMP)

def fz_ptr_heap_sort(heap, HEAP_CMP):
    r""" Class-aware wrapper for `::fz_ptr_heap_sort()`."""
    return _mupdf.fz_ptr_heap_sort(heap, HEAP_CMP)

def fz_ptr_heap_uniq(heap, HEAP_CMP):
    r""" Class-aware wrapper for `::fz_ptr_heap_uniq()`."""
    return _mupdf.fz_ptr_heap_uniq(heap, HEAP_CMP)

def fz_purge_glyph_cache():
    r"""
    Class-aware wrapper for `::fz_purge_glyph_cache()`.
    	Purge all the glyphs from the cache.
    """
    return _mupdf.fz_purge_glyph_cache()

def fz_quad_from_rect(r):
    r"""
    Class-aware wrapper for `::fz_quad_from_rect()`.
    	Convert a rect to a quad (losslessly).
    """
    return _mupdf.fz_quad_from_rect(r)

def fz_quadto(path, x0, y0, x1, y1):
    r"""
    Class-aware wrapper for `::fz_quadto()`.
    	Append a 'quadto' command to an open path. (For a
    	quadratic bezier).

    	path: The path to modify.

    	x0, y0: The control coordinates for the quadratic curve.

    	x1, y1: The end coordinates for the quadratic curve.

    	Throws exceptions on failure to allocate, or attempting to
    	modify a packed path.
    """
    return _mupdf.fz_quadto(path, x0, y0, x1, y1)

def fz_read(stm, data, len):
    r"""
    Class-aware wrapper for `::fz_read()`.
    	Read from a stream into a given data block.

    	stm: The stream to read from.

    	data: The data block to read into.

    	len: The length of the data block (in bytes).

    	Returns the number of bytes read. May throw exceptions.
    """
    return _mupdf.fz_read(stm, data, len)

def fz_read_all(stm, initial):
    r"""
    Class-aware wrapper for `::fz_read_all()`.
    	Read all of a stream into a buffer.

    	stm: The stream to read from

    	initial: Suggested initial size for the buffer.

    	Returns a buffer created from reading from the stream. May throw
    	exceptions on failure to allocate.
    """
    return _mupdf.fz_read_all(stm, initial)

def fz_read_archive_entry(arch, name):
    r"""
    Class-aware wrapper for `::fz_read_archive_entry()`.
    	Reads all bytes in an archive entry
    	into a buffer.

    	name: Entry name to look for, this must be an exact match to
    	the entry name in the archive.

    	Throws an exception if a matching entry cannot be found.
    """
    return _mupdf.fz_read_archive_entry(arch, name)

def fz_read_best(stm, initial, truncated, worst_case):
    r"""
    Class-aware wrapper for `::fz_read_best()`.

    This function has out-params. Python/C# wrappers look like:
    	`fz_read_best(::fz_stream *stm, size_t initial, size_t worst_case)` => `(fz_buffer *, int truncated)`

    	Attempt to read a stream into a buffer. If truncated
    	is NULL behaves as fz_read_all, sets a truncated flag in case of
    	error.

    	stm: The stream to read from.

    	initial: Suggested initial size for the buffer.

    	truncated: Flag to store success/failure indication in.

    	worst_case: 0 for unknown, otherwise an upper bound for the
    	size of the stream.

    	Returns a buffer created from reading from the stream.
    """
    return _mupdf.fz_read_best(stm, initial, truncated, worst_case)

def fz_read_bits(stm, n):
    r"""
    Class-aware wrapper for `::fz_read_bits()`.
    	Read the next n bits from a stream (assumed to
    	be packed most significant bit first).

    	stm: The stream to read from.

    	n: The number of bits to read, between 1 and 8*sizeof(int)
    	inclusive.

    	Returns -1 for EOF, or the required number of bits.
    """
    return _mupdf.fz_read_bits(stm, n)

def fz_read_byte(stm):
    r"""
    Class-aware wrapper for `::fz_read_byte()`.
    	Read the next byte from a stream.

    	stm: The stream t read from.

    	Returns -1 for end of stream, or the next byte. May
    	throw exceptions.
    """
    return _mupdf.fz_read_byte(stm)

def fz_read_file(filename):
    r"""
    Class-aware wrapper for `::fz_read_file()`.
    	Read all the contents of a file into a buffer.
    """
    return _mupdf.fz_read_file(filename)

def fz_read_float(stm):
    r""" Class-aware wrapper for `::fz_read_float()`."""
    return _mupdf.fz_read_float(stm)

def fz_read_float_le(stm):
    r""" Class-aware wrapper for `::fz_read_float_le()`."""
    return _mupdf.fz_read_float_le(stm)

def fz_read_int16(stm):
    r""" Class-aware wrapper for `::fz_read_int16()`."""
    return _mupdf.fz_read_int16(stm)

def fz_read_int16_le(stm):
    r""" Class-aware wrapper for `::fz_read_int16_le()`."""
    return _mupdf.fz_read_int16_le(stm)

def fz_read_int32(stm):
    r""" Class-aware wrapper for `::fz_read_int32()`."""
    return _mupdf.fz_read_int32(stm)

def fz_read_int32_le(stm):
    r""" Class-aware wrapper for `::fz_read_int32_le()`."""
    return _mupdf.fz_read_int32_le(stm)

def fz_read_int64(stm):
    r""" Class-aware wrapper for `::fz_read_int64()`."""
    return _mupdf.fz_read_int64(stm)

def fz_read_int64_le(stm):
    r""" Class-aware wrapper for `::fz_read_int64_le()`."""
    return _mupdf.fz_read_int64_le(stm)

def fz_read_line(stm, buf, max):
    r"""
    Class-aware wrapper for `::fz_read_line()`.
    	Read a line from stream into the buffer until either a
    	terminating newline or EOF, which it replaces with a null byte
    	('').

    	Returns buf on success, and NULL when end of file occurs while
    	no characters have been read.
    """
    return _mupdf.fz_read_line(stm, buf, max)

def fz_read_rbits(stm, n):
    r"""
    Class-aware wrapper for `::fz_read_rbits()`.
    	Read the next n bits from a stream (assumed to
    	be packed least significant bit first).

    	stm: The stream to read from.

    	n: The number of bits to read, between 1 and 8*sizeof(int)
    	inclusive.

    	Returns (unsigned int)-1 for EOF, or the required number of bits.
    """
    return _mupdf.fz_read_rbits(stm, n)

def fz_read_rune(_in):
    r"""
    Class-aware wrapper for `::fz_read_rune()`.
    	Read a utf-8 rune from a stream.

    	In the event of encountering badly formatted utf-8 codes
    	(such as a leading code with an unexpected number of following
    	codes) no error/exception is given, but undefined values may be
    	returned.
    """
    return _mupdf.fz_read_rune(_in)

def fz_read_string(stm, buffer, len):
    r"""
    Class-aware wrapper for `::fz_read_string()`.
    	Read a null terminated string from the stream into
    	a buffer of a given length. The buffer will be null terminated.
    	Throws on failure (including the failure to fit the entire
    	string including the terminator into the buffer).
    """
    return _mupdf.fz_read_string(stm, buffer, len)

def fz_read_uint16(stm):
    r"""
    Class-aware wrapper for `::fz_read_uint16()`.
    	fz_read_[u]int(16|24|32|64)(_le)?

    	Read a 16/32/64 bit signed/unsigned integer from stream,
    	in big or little-endian byte orders.

    	Throws an exception if EOF is encountered.
    """
    return _mupdf.fz_read_uint16(stm)

def fz_read_uint16_le(stm):
    r""" Class-aware wrapper for `::fz_read_uint16_le()`."""
    return _mupdf.fz_read_uint16_le(stm)

def fz_read_uint24(stm):
    r""" Class-aware wrapper for `::fz_read_uint24()`."""
    return _mupdf.fz_read_uint24(stm)

def fz_read_uint24_le(stm):
    r""" Class-aware wrapper for `::fz_read_uint24_le()`."""
    return _mupdf.fz_read_uint24_le(stm)

def fz_read_uint32(stm):
    r""" Class-aware wrapper for `::fz_read_uint32()`."""
    return _mupdf.fz_read_uint32(stm)

def fz_read_uint32_le(stm):
    r""" Class-aware wrapper for `::fz_read_uint32_le()`."""
    return _mupdf.fz_read_uint32_le(stm)

def fz_read_uint64(stm):
    r""" Class-aware wrapper for `::fz_read_uint64()`."""
    return _mupdf.fz_read_uint64(stm)

def fz_read_uint64_le(stm):
    r""" Class-aware wrapper for `::fz_read_uint64_le()`."""
    return _mupdf.fz_read_uint64_le(stm)

def fz_read_utf16_be(stm):
    r""" Class-aware wrapper for `::fz_read_utf16_be()`."""
    return _mupdf.fz_read_utf16_be(stm)

def fz_read_utf16_le(stm):
    r"""
    Class-aware wrapper for `::fz_read_utf16_le()`.
    	Read a utf-16 rune from a stream. (little endian and
    	big endian respectively).

    	In the event of encountering badly formatted utf-16 codes
    	(mismatched surrogates) no error/exception is given, but
    	undefined values may be returned.
    """
    return _mupdf.fz_read_utf16_le(stm)

def fz_realloc(p, size):
    r"""
    Class-aware wrapper for `::fz_realloc()`.
    	Reallocates a block of memory to given size. Existing contents
    	up to min(old_size,new_size) are maintained. The rest of the
    	block is uninitialised.

    	fz_realloc(ctx, NULL, size) behaves like fz_malloc(ctx, size).

    	fz_realloc(ctx, p, 0); behaves like fz_free(ctx, p).

    	Throws exception in the event of failure to allocate.
    """
    return _mupdf.fz_realloc(p, size)

def fz_realloc_no_throw(p, size):
    r"""
    Class-aware wrapper for `::fz_realloc_no_throw()`.
    	fz_realloc equivalent that returns NULL rather than throwing
    	exceptions.
    """
    return _mupdf.fz_realloc_no_throw(p, size)

def fz_realpath(path, resolved_path):
    r"""
    Class-aware wrapper for `::fz_realpath()`.
    	Resolve a path to an absolute file name.
    	The resolved path buffer must be of at least PATH_MAX size.
    """
    return _mupdf.fz_realpath(path, resolved_path)

def fz_recognize_image_format(p):
    r"""
    Class-aware wrapper for `::fz_recognize_image_format()`.
    	Recognise image format strings in the first 8 bytes from image
    	data.
    """
    return _mupdf.fz_recognize_image_format(p)

def fz_rect_from_irect(bbox):
    r"""
    Class-aware wrapper for `::fz_rect_from_irect()`.
    	Convert a bbox into a rect.

    	For our purposes, a rect can represent all the values we meet in
    	a bbox, so nothing can go wrong.

    	rect: A place to store the generated rectangle.

    	bbox: The bbox to convert.

    	Returns rect (updated).
    """
    return _mupdf.fz_rect_from_irect(bbox)

def fz_rect_from_quad(q):
    r"""
    Class-aware wrapper for `::fz_rect_from_quad()`.
    	Convert a quad to the smallest rect that covers it.
    """
    return _mupdf.fz_rect_from_quad(q)

def fz_rectto(path, x0, y0, x1, y1):
    r"""
    Class-aware wrapper for `::fz_rectto()`.
    	Append a 'rectto' command to an open path.

    	The rectangle is equivalent to:
    		moveto x0 y0
    		lineto x1 y0
    		lineto x1 y1
    		lineto x0 y1
    		closepath

    	path: The path to modify.

    	x0, y0: First corner of the rectangle.

    	x1, y1: Second corner of the rectangle.

    	Throws exceptions on failure to allocate, or attempting to
    	modify a packed path.
    """
    return _mupdf.fz_rectto(path, x0, y0, x1, y1)

def fz_register_archive_handler(handler):
    r""" Class-aware wrapper for `::fz_register_archive_handler()`."""
    return _mupdf.fz_register_archive_handler(handler)

def fz_register_document_handler(handler):
    r"""
    Class-aware wrapper for `::fz_register_document_handler()`.
    	Register a handler for a document type.

    	handler: The handler to register.
    """
    return _mupdf.fz_register_document_handler(handler)

def fz_register_document_handlers():
    r"""
    Class-aware wrapper for `::fz_register_document_handlers()`.
    	Register handlers
    	for all the standard document types supported in
    	this build.
    """
    return _mupdf.fz_register_document_handlers()

def fz_remove_item(drop, key, type):
    r"""
    Class-aware wrapper for `::fz_remove_item()`.
    	Remove an item from the store.

    	If an item indexed by the given key exists in the store, remove
    	it.

    	drop: The function used to free the value (to ensure we get a
    	value of the correct type).

    	key: The key used to find the item to remove.

    	type: Functions used to manipulate the key.
    """
    return _mupdf.fz_remove_item(drop, key, type)

def fz_render_flags(dev, set, clear):
    r""" Class-aware wrapper for `::fz_render_flags()`."""
    return _mupdf.fz_render_flags(dev, set, clear)

def fz_render_glyph_pixmap(font, gid, ctm, scissor, aa):
    r"""
    Class-aware wrapper for `::fz_render_glyph_pixmap()`.
    	Create a pixmap containing a rendered glyph.

    	Lookup gid from font, clip it with scissor, and rendering it
    	with aa bits of antialiasing into a new pixmap.

    	The caller takes ownership of the pixmap and so must free it.

    	Note: This function is no longer used for normal rendering
    	operations, and is kept around just because we use it in the
    	app. It should be considered "at risk" of removal from the API.
    """
    return _mupdf.fz_render_glyph_pixmap(font, gid, ctm, scissor, aa)

def fz_render_t3_glyph_direct(dev, font, gid, trm, gstate, def_cs):
    r"""
    Class-aware wrapper for `::fz_render_t3_glyph_direct()`.
    	Nasty PDF interpreter specific hernia, required to allow the
    	interpreter to replay glyphs from a type3 font directly into
    	the target device.

    	This is only used in exceptional circumstances (such as type3
    	glyphs that inherit current graphics state, or nested type3
    	glyphs).
    """
    return _mupdf.fz_render_t3_glyph_direct(dev, font, gid, trm, gstate, def_cs)

def fz_rendering_intent_name(ri):
    r"""
    Class-aware wrapper for `::fz_rendering_intent_name()`.
    	Map from enumerated rendering intent to string.

    	The returned string is static and therefore must not be freed.
    """
    return _mupdf.fz_rendering_intent_name(ri)

def fz_report_error():
    r""" Class-aware wrapper for `::fz_report_error()`."""
    return _mupdf.fz_report_error()

def fz_reset_output(arg_0):
    r"""
    Class-aware wrapper for `::fz_reset_output()`.
    	Reset a closed output stream. Returns state to
    	(broadly) that which it was in when opened. Not
    	all outputs can be reset, so this may throw an
    	exception.
    """
    return _mupdf.fz_reset_output(arg_0)

def fz_reset_story(story):
    r""" Class-aware wrapper for `::fz_reset_story()`."""
    return _mupdf.fz_reset_story(story)

def fz_resize_buffer(buf, capacity):
    r"""
    Class-aware wrapper for `::fz_resize_buffer()`.
    	Ensure that a buffer has a given capacity,
    	truncating data if required.

    	capacity: The desired capacity for the buffer. If the current
    	size of the buffer contents is smaller than capacity, it is
    	truncated.
    """
    return _mupdf.fz_resize_buffer(buf, capacity)

def fz_resolve_link(doc, uri, xp, yp):
    r"""
    Class-aware wrapper for `::fz_resolve_link()`.

    This function has out-params. Python/C# wrappers look like:
    	`fz_resolve_link(::fz_document *doc, const char *uri)` => `(fz_location, float xp, float yp)`

    	Resolve an internal link to a page number.

    	xp, yp: Pointer to store coordinate of destination on the page.

    	Returns (-1,-1) if the URI cannot be resolved.
    """
    return _mupdf.fz_resolve_link(doc, uri, xp, yp)

def fz_rethrow():
    r""" Class-aware wrapper for `::fz_rethrow()`."""
    return _mupdf.fz_rethrow()

def fz_rethrow_if(errcode):
    r"""
    Class-aware wrapper for `::fz_rethrow_if()`.
    	Within an fz_catch() block, rethrow the current exception
    	if the errcode of the current exception matches.

    	This assumes no intervening use of fz_try/fz_catch.
    """
    return _mupdf.fz_rethrow_if(errcode)

def fz_rethrow_unless(errcode):
    r""" Class-aware wrapper for `::fz_rethrow_unless()`."""
    return _mupdf.fz_rethrow_unless(errcode)

def fz_rotate(degrees):
    r"""
    Class-aware wrapper for `::fz_rotate()`.
    	Create a rotation matrix.

    	The returned matrix is of the form
    	[ cos(deg) sin(deg) -sin(deg) cos(deg) 0 0 ].

    	m: Pointer to place to store matrix

    	degrees: Degrees of counter clockwise rotation. Values less
    	than zero and greater than 360 are handled as expected.

    	Returns m.
    """
    return _mupdf.fz_rotate(degrees)

def fz_round_rect(rect):
    r"""
    Class-aware wrapper for `::fz_round_rect()`.
    	Round rectangle coordinates.

    	Coordinates in a bounding box are integers, so rounding of the
    	rects coordinates takes place. The top left corner is rounded
    	upwards and left while the bottom right corner is rounded
    	downwards and to the right.

    	This differs from fz_irect_from_rect, in that fz_irect_from_rect
    	slavishly follows the numbers (i.e any slight over/under
    	calculations can cause whole extra pixels to be added).
    	fz_round_rect allows for a small amount of rounding error when
    	calculating the bbox.
    """
    return _mupdf.fz_round_rect(rect)

def fz_run_display_list(list, dev, ctm, scissor, cookie):
    r"""
    Class-aware wrapper for `::fz_run_display_list()`.
    	(Re)-run a display list through a device.

    	list: A display list, created by fz_new_display_list and
    	populated with objects from a page by running fz_run_page on a
    	device obtained from fz_new_list_device.

    	ctm: Transform to apply to display list contents. May include
    	for example scaling and rotation, see fz_scale, fz_rotate and
    	fz_concat. Set to fz_identity if no transformation is desired.

    	scissor: Only the part of the contents of the display list
    	visible within this area will be considered when the list is
    	run through the device. This does not imply for tile objects
    	contained in the display list.

    	cookie: Communication mechanism between caller and library
    	running the page. Intended for multi-threaded applications,
    	while single-threaded applications set cookie to NULL. The
    	caller may abort an ongoing page run. Cookie also communicates
    	progress information back to the caller. The fields inside
    	cookie are continually updated while the page is being run.
    """
    return _mupdf.fz_run_display_list(list, dev, ctm, scissor, cookie)

def fz_run_document_structure(doc, dev, cookie):
    r"""
    Class-aware wrapper for `::fz_run_document_structure()`.
    	Run the document structure through a device.

    	doc: Document in question.

    	dev: Device obtained from fz_new_*_device.

    	cookie: Communication mechanism between caller and library.
    	Intended for multi-threaded applications, while
    	single-threaded applications set cookie to NULL. The
    	caller may abort an ongoing rendering of a page. Cookie also
    	communicates progress information back to the caller. The
    	fields inside cookie are continually updated while the page is
    	rendering.
    """
    return _mupdf.fz_run_document_structure(doc, dev, cookie)

def fz_run_page(page, dev, transform, cookie):
    r"""
    Class-aware wrapper for `::fz_run_page()`.
    	Run a page through a device.

    	page: Page obtained from fz_load_page.

    	dev: Device obtained from fz_new_*_device.

    	transform: Transform to apply to page. May include for example
    	scaling and rotation, see fz_scale, fz_rotate and fz_concat.
    	Set to fz_identity if no transformation is desired.

    	cookie: Communication mechanism between caller and library
    	rendering the page. Intended for multi-threaded applications,
    	while single-threaded applications set cookie to NULL. The
    	caller may abort an ongoing rendering of a page. Cookie also
    	communicates progress information back to the caller. The
    	fields inside cookie are continually updated while the page is
    	rendering.
    """
    return _mupdf.fz_run_page(page, dev, transform, cookie)

def fz_run_page_annots(page, dev, transform, cookie):
    r"""
    Class-aware wrapper for `::fz_run_page_annots()`.
    	Run the annotations on a page through a device.
    """
    return _mupdf.fz_run_page_annots(page, dev, transform, cookie)

def fz_run_page_contents(page, dev, transform, cookie):
    r"""
    Class-aware wrapper for `::fz_run_page_contents()`.
    	Run a page through a device. Just the main
    	page content, without the annotations, if any.

    	page: Page obtained from fz_load_page.

    	dev: Device obtained from fz_new_*_device.

    	transform: Transform to apply to page. May include for example
    	scaling and rotation, see fz_scale, fz_rotate and fz_concat.
    	Set to fz_identity if no transformation is desired.

    	cookie: Communication mechanism between caller and library
    	rendering the page. Intended for multi-threaded applications,
    	while single-threaded applications set cookie to NULL. The
    	caller may abort an ongoing rendering of a page. Cookie also
    	communicates progress information back to the caller. The
    	fields inside cookie are continually updated while the page is
    	rendering.
    """
    return _mupdf.fz_run_page_contents(page, dev, transform, cookie)

def fz_run_page_widgets(page, dev, transform, cookie):
    r"""
    Class-aware wrapper for `::fz_run_page_widgets()`.
    	Run the widgets on a page through a device.
    """
    return _mupdf.fz_run_page_widgets(page, dev, transform, cookie)

def fz_run_t3_glyph(font, gid, trm, dev):
    r"""
    Class-aware wrapper for `::fz_run_t3_glyph()`.
    	Run a glyph from a Type3 font to
    	a given device.

    	font: The font to find the glyph in.

    	gid: The glyph to run.

    	trm: The transform to apply.

    	dev: The device to render onto.
    """
    return _mupdf.fz_run_t3_glyph(font, gid, trm, dev)

def fz_runeidx(str, p):
    r"""
    Class-aware wrapper for `::fz_runeidx()`.
    	Compute the index of a rune in a string.

    	str: Pointer to beginning of a string.

    	p: Pointer to a char in str.

    	Returns the index of the rune pointed to by p in str.
    """
    return _mupdf.fz_runeidx(str, p)

def fz_runelen(rune):
    r"""
    Class-aware wrapper for `::fz_runelen()`.
    	Count how many chars are required to represent a rune.

    	rune: The rune to encode.

    	Returns the number of bytes required to represent this run in
    	UTF8.
    """
    return _mupdf.fz_runelen(rune)

def fz_runeptr(str, idx):
    r"""
    Class-aware wrapper for `::fz_runeptr()`.
    	Obtain a pointer to the char representing the rune
    	at a given index.

    	str: Pointer to beginning of a string.

    	idx: Index of a rune to return a char pointer to.

    	Returns a pointer to the char where the desired rune starts,
    	or NULL if the string ends before the index is reached.
    """
    return _mupdf.fz_runeptr(str, idx)

def fz_runetochar(str, rune):
    r"""
    Class-aware wrapper for `::fz_runetochar()`.
    	UTF8 encode a rune to a sequence of chars.

    	str: Pointer to a place to put the UTF8 encoded character.

    	rune: Pointer to a 'rune'.

    	Returns the number of bytes the rune took to output.
    """
    return _mupdf.fz_runetochar(str, rune)

def fz_samples_get(pixmap, offset):
    r"""
    Class-aware wrapper for `::fz_samples_get()`.
    Provides simple (but slow) access to pixmap data from Python and C#.
    """
    return _mupdf.fz_samples_get(pixmap, offset)

def fz_samples_set(pixmap, offset, value):
    r"""
    Class-aware wrapper for `::fz_samples_set()`.
    Provides simple (but slow) write access to pixmap data from Python and
    C#.
    """
    return _mupdf.fz_samples_set(pixmap, offset, value)

def fz_save_accelerator(doc, accel):
    r"""
    Class-aware wrapper for `::fz_save_accelerator()`.
    	Save accelerator data for the document to a given file.
    """
    return _mupdf.fz_save_accelerator(doc, accel)

def fz_save_bitmap_as_pbm(bitmap, filename):
    r"""
    Class-aware wrapper for `::fz_save_bitmap_as_pbm()`.
    	Save a bitmap as a pbm.
    """
    return _mupdf.fz_save_bitmap_as_pbm(bitmap, filename)

def fz_save_bitmap_as_pcl(bitmap, filename, append, pcl):
    r"""
    Class-aware wrapper for `::fz_save_bitmap_as_pcl()`.
    	Save a bitmap as mono PCL.
    """
    return _mupdf.fz_save_bitmap_as_pcl(bitmap, filename, append, pcl)

def fz_save_bitmap_as_pkm(bitmap, filename):
    r"""
    Class-aware wrapper for `::fz_save_bitmap_as_pkm()`.
    	Save a CMYK bitmap as a pkm.
    """
    return _mupdf.fz_save_bitmap_as_pkm(bitmap, filename)

def fz_save_bitmap_as_pwg(bitmap, filename, append, pwg):
    r"""
    Class-aware wrapper for `::fz_save_bitmap_as_pwg()`.
    	Save a bitmap as a PWG.
    """
    return _mupdf.fz_save_bitmap_as_pwg(bitmap, filename, append, pwg)

def fz_save_buffer(buf, filename):
    r"""
    Class-aware wrapper for `::fz_save_buffer()`.
    	Save the contents of a buffer to a file.
    """
    return _mupdf.fz_save_buffer(buf, filename)

def fz_save_pixmap_as_jpeg(pixmap, filename, quality):
    r"""
    Class-aware wrapper for `::fz_save_pixmap_as_jpeg()`.
    	Save a pixmap as a JPEG.
    """
    return _mupdf.fz_save_pixmap_as_jpeg(pixmap, filename, quality)

def fz_save_pixmap_as_jpx(pixmap, filename, q):
    r"""
    Class-aware wrapper for `::fz_save_pixmap_as_jpx()`.
    	Save pixmap data as JP2K with no subsampling.

    	quality = 100 = lossless
    	otherwise for a factor of x compression use 100-x. (so 80 is 1:20 compression)
    """
    return _mupdf.fz_save_pixmap_as_jpx(pixmap, filename, q)

def fz_save_pixmap_as_pam(pixmap, filename):
    r"""
    Class-aware wrapper for `::fz_save_pixmap_as_pam()`.
    	Save a pixmap as a pnm (greyscale, rgb or cmyk, with or without
    	alpha).
    """
    return _mupdf.fz_save_pixmap_as_pam(pixmap, filename)

def fz_save_pixmap_as_pbm(pixmap, filename):
    r"""
    Class-aware wrapper for `::fz_save_pixmap_as_pbm()`.
    	Save a pixmap as a pbm. (Performing halftoning).
    """
    return _mupdf.fz_save_pixmap_as_pbm(pixmap, filename)

def fz_save_pixmap_as_pcl(pixmap, filename, append, pcl):
    r"""
    Class-aware wrapper for `::fz_save_pixmap_as_pcl()`.
    	Save an (RGB) pixmap as color PCL.
    """
    return _mupdf.fz_save_pixmap_as_pcl(pixmap, filename, append, pcl)

def fz_save_pixmap_as_pclm(pixmap, filename, append, options):
    r"""
    Class-aware wrapper for `::fz_save_pixmap_as_pclm()`.
    	Save a (Greyscale or RGB) pixmap as pclm.
    """
    return _mupdf.fz_save_pixmap_as_pclm(pixmap, filename, append, options)

def fz_save_pixmap_as_pdfocr(pixmap, filename, append, options):
    r"""
    Class-aware wrapper for `::fz_save_pixmap_as_pdfocr()`.
    	Save a (Greyscale or RGB) pixmap as pdfocr.
    """
    return _mupdf.fz_save_pixmap_as_pdfocr(pixmap, filename, append, options)

def fz_save_pixmap_as_pkm(pixmap, filename):
    r"""
    Class-aware wrapper for `::fz_save_pixmap_as_pkm()`.
    	Save a CMYK pixmap as a pkm. (Performing halftoning).
    """
    return _mupdf.fz_save_pixmap_as_pkm(pixmap, filename)

def fz_save_pixmap_as_png(pixmap, filename):
    r"""
    Class-aware wrapper for `::fz_save_pixmap_as_png()`.
    	Save a (Greyscale or RGB) pixmap as a png.
    """
    return _mupdf.fz_save_pixmap_as_png(pixmap, filename)

def fz_save_pixmap_as_pnm(pixmap, filename):
    r"""
    Class-aware wrapper for `::fz_save_pixmap_as_pnm()`.
    	Save a pixmap as a pnm (greyscale or rgb, no alpha).
    """
    return _mupdf.fz_save_pixmap_as_pnm(pixmap, filename)

def fz_save_pixmap_as_ps(pixmap, filename, append):
    r"""
    Class-aware wrapper for `::fz_save_pixmap_as_ps()`.
    	Save a (gray, rgb, or cmyk, no alpha) pixmap out as postscript.
    """
    return _mupdf.fz_save_pixmap_as_ps(pixmap, filename, append)

def fz_save_pixmap_as_psd(pixmap, filename):
    r"""
    Class-aware wrapper for `::fz_save_pixmap_as_psd()`.
    	Save a pixmap as a PSD file.
    """
    return _mupdf.fz_save_pixmap_as_psd(pixmap, filename)

def fz_save_pixmap_as_pwg(pixmap, filename, append, pwg):
    r"""
    Class-aware wrapper for `::fz_save_pixmap_as_pwg()`.
    	Save a pixmap as a PWG.
    """
    return _mupdf.fz_save_pixmap_as_pwg(pixmap, filename, append, pwg)

def fz_scale(sx, sy):
    r"""
    Class-aware wrapper for `::fz_scale()`.
    	Create a scaling matrix.

    	The returned matrix is of the form [ sx 0 0 sy 0 0 ].

    	m: Pointer to the matrix to populate

    	sx, sy: Scaling factors along the X- and Y-axes. A scaling
    	factor of 1.0 will not cause any scaling along the relevant
    	axis.

    	Returns m.
    """
    return _mupdf.fz_scale(sx, sy)

def fz_scale_pixmap(src, x, y, w, h, clip):
    r""" Class-aware wrapper for `::fz_scale_pixmap()`."""
    return _mupdf.fz_scale_pixmap(src, x, y, w, h, clip)

def fz_search_chapter_page_number(doc, chapter, page, needle, hit_mark, hit_bbox, hit_max):
    r"""
    Class-aware wrapper for `::fz_search_chapter_page_number()`.

    This function has out-params. Python/C# wrappers look like:
    	`fz_search_chapter_page_number(::fz_document *doc, int chapter, int page, const char *needle, ::fz_quad *hit_bbox, int hit_max)` => `(int, int hit_mark)`
    """
    return _mupdf.fz_search_chapter_page_number(doc, chapter, page, needle, hit_mark, hit_bbox, hit_max)

def fz_search_display_list(list, needle, hit_mark, hit_bbox, hit_max):
    r"""
    Class-aware wrapper for `::fz_search_display_list()`.

    This function has out-params. Python/C# wrappers look like:
    	`fz_search_display_list(::fz_display_list *list, const char *needle, ::fz_quad *hit_bbox, int hit_max)` => `(int, int hit_mark)`
    """
    return _mupdf.fz_search_display_list(list, needle, hit_mark, hit_bbox, hit_max)

def fz_search_page(page, needle, hit_mark, hit_bbox, hit_max):
    r"""
    Class-aware wrapper for `::fz_search_page()`.

    This function has out-params. Python/C# wrappers look like:
    	`fz_search_page(::fz_page *page, const char *needle, ::fz_quad *hit_bbox, int hit_max)` => `(int, int hit_mark)`

    	Search for the 'needle' text on the page.
    	Record the hits in the hit_bbox array and return the number of
    	hits. Will stop looking once it has filled hit_max rectangles.
    """
    return _mupdf.fz_search_page(page, needle, hit_mark, hit_bbox, hit_max)

def fz_search_page2(doc, number, needle, hit_max):
    r"""
    Class-aware wrapper for `::fz_search_page2()`.
    C++ alternative to fz_search_page() that returns information in a std::vector.
    """
    return _mupdf.fz_search_page2(doc, number, needle, hit_max)

def fz_search_page_number(doc, number, needle, hit_mark, hit_bbox, hit_max):
    r"""
    Class-aware wrapper for `::fz_search_page_number()`.

    This function has out-params. Python/C# wrappers look like:
    	`fz_search_page_number(::fz_document *doc, int number, const char *needle, ::fz_quad *hit_bbox, int hit_max)` => `(int, int hit_mark)`
    """
    return _mupdf.fz_search_page_number(doc, number, needle, hit_mark, hit_bbox, hit_max)

def fz_search_stext_page(text, needle, hit_mark, hit_bbox, hit_max):
    r"""
    Class-aware wrapper for `::fz_search_stext_page()`.

    This function has out-params. Python/C# wrappers look like:
    	`fz_search_stext_page(::fz_stext_page *text, const char *needle, ::fz_quad *hit_bbox, int hit_max)` => `(int, int hit_mark)`

    	Search for occurrence of 'needle' in text page.

    	Return the number of hits and store hit quads in the passed in
    	array.

    	NOTE: This is an experimental interface and subject to change
    	without notice.
    """
    return _mupdf.fz_search_stext_page(text, needle, hit_mark, hit_bbox, hit_max)

def fz_seek(stm, offset, whence):
    r"""
    Class-aware wrapper for `::fz_seek()`.
    	Seek within a stream.

    	stm: The stream to seek within.

    	offset: The offset to seek to.

    	whence: From where the offset is measured (see fseek).
    	SEEK_SET - start of stream.
    	SEEK_CUR - current position.
    	SEEK_END - end of stream.

    """
    return _mupdf.fz_seek(stm, offset, whence)

def fz_seek_output(out, off, whence):
    r"""
    Class-aware wrapper for `::fz_seek_output()`.
    	Seek to the specified file position.
    	See fseek for arguments.

    	Throw an error on unseekable outputs.
    """
    return _mupdf.fz_seek_output(out, off, whence)

def fz_separation_current_behavior(sep, separation):
    r"""
    Class-aware wrapper for `::fz_separation_current_behavior()`.
    	Test for the current behavior of a separation.
    """
    return _mupdf.fz_separation_current_behavior(sep, separation)

def fz_separation_equivalent(seps, idx, dst_cs, dst_color, prf, color_params):
    r"""
    Class-aware wrapper for `::fz_separation_equivalent()`.

    This function has out-params. Python/C# wrappers look like:
    	`fz_separation_equivalent(const ::fz_separations *seps, int idx, ::fz_colorspace *dst_cs, ::fz_colorspace *prf, ::fz_color_params color_params)` => float dst_color

    	Get the equivalent separation color in a given colorspace.
    """
    return _mupdf.fz_separation_equivalent(seps, idx, dst_cs, dst_color, prf, color_params)

def fz_separation_name(sep, separation):
    r""" Class-aware wrapper for `::fz_separation_name()`."""
    return _mupdf.fz_separation_name(sep, separation)

def fz_set_aa_level(bits):
    r"""
    Class-aware wrapper for `::fz_set_aa_level()`.
    	Set the number of bits of antialiasing we should
    	use (for both text and graphics).

    	bits: The number of bits of antialiasing to use (values are
    	clamped to within the 0 to 8 range).
    """
    return _mupdf.fz_set_aa_level(bits)

def fz_set_compressed_image_buffer(cimg, buf):
    r""" Class-aware wrapper for `::fz_set_compressed_image_buffer()`."""
    return _mupdf.fz_set_compressed_image_buffer(cimg, buf)

def fz_set_default_cmyk(default_cs, cs):
    r""" Class-aware wrapper for `::fz_set_default_cmyk()`."""
    return _mupdf.fz_set_default_cmyk(default_cs, cs)

def fz_set_default_colorspaces(dev, default_cs):
    r""" Class-aware wrapper for `::fz_set_default_colorspaces()`."""
    return _mupdf.fz_set_default_colorspaces(dev, default_cs)

def fz_set_default_gray(default_cs, cs):
    r"""
    Class-aware wrapper for `::fz_set_default_gray()`.
    	Set new defaults within the default colorspace structure.

    	New references are taken to the new default, and references to
    	the old defaults dropped.

    	Never throws exceptions.
    """
    return _mupdf.fz_set_default_gray(default_cs, cs)

def fz_set_default_output_intent(default_cs, cs):
    r""" Class-aware wrapper for `::fz_set_default_output_intent()`."""
    return _mupdf.fz_set_default_output_intent(default_cs, cs)

def fz_set_default_rgb(default_cs, cs):
    r""" Class-aware wrapper for `::fz_set_default_rgb()`."""
    return _mupdf.fz_set_default_rgb(default_cs, cs)

def fz_set_error_callback(error_cb, user):
    r"""
    Class-aware wrapper for `::fz_set_error_callback()`.
    	Set the error callback. This will be called as part of the
    	exception handling.

    	The callback must not throw exceptions!
    """
    return _mupdf.fz_set_error_callback(error_cb, user)

def fz_set_font_bbox(font, xmin, ymin, xmax, ymax):
    r"""
    Class-aware wrapper for `::fz_set_font_bbox()`.
    	Set the font bbox.

    	font: The font to set the bbox for.

    	xmin, ymin, xmax, ymax: The bounding box.
    """
    return _mupdf.fz_set_font_bbox(font, xmin, ymin, xmax, ymax)

def fz_set_font_embedding(font, embed):
    r"""
    Class-aware wrapper for `::fz_set_font_embedding()`.
    	Control whether a given font should be embedded or not when writing.
    """
    return _mupdf.fz_set_font_embedding(font, embed)

def fz_set_graphics_aa_level(bits):
    r"""
    Class-aware wrapper for `::fz_set_graphics_aa_level()`.
    	Set the number of bits of antialiasing we
    	should use for graphics.

    	bits: The number of bits of antialiasing to use (values are
    	clamped to within the 0 to 8 range).
    """
    return _mupdf.fz_set_graphics_aa_level(bits)

def fz_set_graphics_min_line_width(min_line_width):
    r"""
    Class-aware wrapper for `::fz_set_graphics_min_line_width()`.
    	Set the minimum line width to be
    	used for stroked lines.

    	min_line_width: The minimum line width to use (in pixels).
    """
    return _mupdf.fz_set_graphics_min_line_width(min_line_width)

def fz_set_link_rect(link, rect):
    r""" Class-aware wrapper for `::fz_set_link_rect()`."""
    return _mupdf.fz_set_link_rect(link, rect)

def fz_set_link_uri(link, uri):
    r""" Class-aware wrapper for `::fz_set_link_uri()`."""
    return _mupdf.fz_set_link_uri(link, uri)

def fz_set_metadata(doc, key, value):
    r""" Class-aware wrapper for `::fz_set_metadata()`."""
    return _mupdf.fz_set_metadata(doc, key, value)

def fz_set_pixmap_image_tile(cimg, pix):
    r""" Class-aware wrapper for `::fz_set_pixmap_image_tile()`."""
    return _mupdf.fz_set_pixmap_image_tile(cimg, pix)

def fz_set_pixmap_resolution(pix, xres, yres):
    r"""
    Class-aware wrapper for `::fz_set_pixmap_resolution()`.
    	Set the pixels per inch resolution of the pixmap.
    """
    return _mupdf.fz_set_pixmap_resolution(pix, xres, yres)

def fz_set_separation_behavior(sep, separation, behavior):
    r"""
    Class-aware wrapper for `::fz_set_separation_behavior()`.
    	Control the rendering of a given separation.
    """
    return _mupdf.fz_set_separation_behavior(sep, separation, behavior)

def fz_set_stddbg(out):
    r"""
    Class-aware wrapper for `::fz_set_stddbg()`.
    	Set the output stream to be used for fz_stddbg. Set to NULL to
    	reset to default (stderr).
    """
    return _mupdf.fz_set_stddbg(out)

def fz_set_text_aa_level(bits):
    r"""
    Class-aware wrapper for `::fz_set_text_aa_level()`.
    	Set the number of bits of antialiasing we
    	should use for text.

    	bits: The number of bits of antialiasing to use (values are
    	clamped to within the 0 to 8 range).
    """
    return _mupdf.fz_set_text_aa_level(bits)

def fz_set_use_document_css(use):
    r"""
    Class-aware wrapper for `::fz_set_use_document_css()`.
    	Toggle whether to respect document styles in HTML and EPUB.
    """
    return _mupdf.fz_set_use_document_css(use)

def fz_set_user_context(user):
    r"""
    Class-aware wrapper for `::fz_set_user_context()`.
    	Set the user field in the context.

    	NULL initially, this field can be set to any opaque value
    	required by the user. It is copied on clones.
    """
    return _mupdf.fz_set_user_context(user)

def fz_set_user_css(text):
    r"""
    Class-aware wrapper for `::fz_set_user_css()`.
    	Set the user stylesheet source text for use with HTML and EPUB.
    """
    return _mupdf.fz_set_user_css(text)

def fz_set_warning_callback(warning_cb, user):
    r"""
    Class-aware wrapper for `::fz_set_warning_callback()`.
    	Set the warning callback. This will be called as part of the
    	exception handling.

    	The callback must not throw exceptions!
    """
    return _mupdf.fz_set_warning_callback(warning_cb, user)

def fz_sha256_final(state, digest):
    r"""
    Class-aware wrapper for `::fz_sha256_final()`.
    	MD5 finalization. Ends an MD5 message-digest operation, writing
    	the message digest and zeroizing the context.

    	Never throws an exception.
    """
    return _mupdf.fz_sha256_final(state, digest)

def fz_sha256_init(state):
    r"""
    Class-aware wrapper for `::fz_sha256_init()`.
    	SHA256 initialization. Begins an SHA256 operation, initialising
    	the supplied context.

    	Never throws an exception.
    """
    return _mupdf.fz_sha256_init(state)

def fz_sha256_update(state, input, inlen):
    r"""
    Class-aware wrapper for `::fz_sha256_update()`.
    	SHA256 block update operation. Continues an SHA256 message-
    	digest operation, processing another message block, and updating
    	the context.

    	Never throws an exception.
    """
    return _mupdf.fz_sha256_update(state, input, inlen)

def fz_sha384_final(state, digest):
    r"""
    Class-aware wrapper for `::fz_sha384_final()`.
    	SHA384 finalization. Ends an SHA384 message-digest operation,
    	writing the message digest and zeroizing the context.

    	Never throws an exception.
    """
    return _mupdf.fz_sha384_final(state, digest)

def fz_sha384_init(state):
    r"""
    Class-aware wrapper for `::fz_sha384_init()`.
    	SHA384 initialization. Begins an SHA384 operation, initialising
    	the supplied context.

    	Never throws an exception.
    """
    return _mupdf.fz_sha384_init(state)

def fz_sha384_update(state, input, inlen):
    r"""
    Class-aware wrapper for `::fz_sha384_update()`.
    	SHA384 block update operation. Continues an SHA384 message-
    	digest operation, processing another message block, and updating
    	the context.

    	Never throws an exception.
    """
    return _mupdf.fz_sha384_update(state, input, inlen)

def fz_sha512_final(state, digest):
    r"""
    Class-aware wrapper for `::fz_sha512_final()`.
    	SHA512 finalization. Ends an SHA512 message-digest operation,
    	writing the message digest and zeroizing the context.

    	Never throws an exception.
    """
    return _mupdf.fz_sha512_final(state, digest)

def fz_sha512_init(state):
    r"""
    Class-aware wrapper for `::fz_sha512_init()`.
    	SHA512 initialization. Begins an SHA512 operation, initialising
    	the supplied context.

    	Never throws an exception.
    """
    return _mupdf.fz_sha512_init(state)

def fz_sha512_update(state, input, inlen):
    r"""
    Class-aware wrapper for `::fz_sha512_update()`.
    	SHA512 block update operation. Continues an SHA512 message-
    	digest operation, processing another message block, and updating
    	the context.

    	Never throws an exception.
    """
    return _mupdf.fz_sha512_update(state, input, inlen)

def fz_shear(sx, sy):
    r"""
    Class-aware wrapper for `::fz_shear()`.
    	Create a shearing matrix.

    	The returned matrix is of the form [ 1 sy sx 1 0 0 ].

    	m: pointer to place to store returned matrix

    	sx, sy: Shearing factors. A shearing factor of 0.0 will not
    	cause any shearing along the relevant axis.

    	Returns m.
    """
    return _mupdf.fz_shear(sx, sy)

def fz_show_glyph(text, font, trm, glyph, unicode, wmode, bidi_level, markup_dir, language):
    r"""
    Class-aware wrapper for `::fz_show_glyph()`.
    	Add a glyph/unicode value to a text object.

    	text: Text object to add to.

    	font: The font the glyph should be added in.

    	trm: The transform to use for the glyph.

    	glyph: The glyph id to add.

    	unicode: The unicode character for the glyph.

    	cid: The CJK CID value or raw character code.

    	wmode: 1 for vertical mode, 0 for horizontal.

    	bidi_level: The bidirectional level for this glyph.

    	markup_dir: The direction of the text as specified in the
    	markup.

    	language: The language in use (if known, 0 otherwise)
    	(e.g. FZ_LANG_zh_Hans).

    	Throws exception on failure to allocate.
    """
    return _mupdf.fz_show_glyph(text, font, trm, glyph, unicode, wmode, bidi_level, markup_dir, language)

def fz_show_glyph_aux(text, font, trm, glyph, unicode, cid, wmode, bidi_level, markup_dir, lang):
    r""" Class-aware wrapper for `::fz_show_glyph_aux()`."""
    return _mupdf.fz_show_glyph_aux(text, font, trm, glyph, unicode, cid, wmode, bidi_level, markup_dir, lang)

def fz_show_string(text, font, trm, s, wmode, bidi_level, markup_dir, language):
    r"""
    Class-aware wrapper for `::fz_show_string()`.
    	Add a UTF8 string to a text object.

    	text: Text object to add to.

    	font: The font the string should be added in.

    	trm: The transform to use.

    	s: The utf-8 string to add.

    	wmode: 1 for vertical mode, 0 for horizontal.

    	bidi_level: The bidirectional level for this glyph.

    	markup_dir: The direction of the text as specified in the markup.

    	language: The language in use (if known, 0 otherwise)
    		(e.g. FZ_LANG_zh_Hans).

    	Returns the transform updated with the advance width of the
    	string.
    """
    return _mupdf.fz_show_string(text, font, trm, s, wmode, bidi_level, markup_dir, language)

def fz_shrink_store(percent):
    r"""
    Class-aware wrapper for `::fz_shrink_store()`.
    	Evict items from the store until the total size of
    	the objects in the store is reduced to a given percentage of its
    	current size.

    	percent: %age of current size to reduce the store to.

    	Returns non zero if we managed to free enough memory, zero
    	otherwise.
    """
    return _mupdf.fz_shrink_store(percent)

def fz_skip(stm, len):
    r"""
    Class-aware wrapper for `::fz_skip()`.
    	Read from a stream discarding data.

    	stm: The stream to read from.

    	len: The number of bytes to read.

    	Returns the number of bytes read. May throw exceptions.
    """
    return _mupdf.fz_skip(stm, len)

def fz_skip_space(stm):
    r"""
    Class-aware wrapper for `::fz_skip_space()`.
    	Skip over whitespace (bytes <= 32) in a stream.
    """
    return _mupdf.fz_skip_space(stm)

def fz_skip_string(stm, str):
    r"""
    Class-aware wrapper for `::fz_skip_string()`.
    	Skip over a given string in a stream. Return 0 if successfully
    	skipped, non-zero otherwise. As many characters will be skipped
    	over as matched in the string.
    """
    return _mupdf.fz_skip_string(stm, str)

def fz_slice_buffer(buf, start, end):
    r"""
    Class-aware wrapper for `::fz_slice_buffer()`.
    	Create a new buffer with a (subset of) the data from the buffer.

    	start: if >= 0, offset from start of buffer, if < 0 offset from end of buffer.

    	end: if >= 0, offset from start of buffer, if < 0 offset from end of buffer.

    """
    return _mupdf.fz_slice_buffer(buf, start, end)

def fz_snap_selection(page, ap, bp, mode):
    r""" Class-aware wrapper for `::fz_snap_selection()`."""
    return _mupdf.fz_snap_selection(page, ap, bp, mode)

def fz_start_throw_on_repair():
    r""" Class-aware wrapper for `::fz_start_throw_on_repair()`."""
    return _mupdf.fz_start_throw_on_repair()

def fz_stat_ctime(path):
    r""" Class-aware wrapper for `::fz_stat_ctime()`."""
    return _mupdf.fz_stat_ctime(path)

def fz_stat_mtime(path):
    r""" Class-aware wrapper for `::fz_stat_mtime()`."""
    return _mupdf.fz_stat_mtime(path)

def fz_store_item(key, val, itemsize, type):
    r"""
    Class-aware wrapper for `::fz_store_item()`.
    	Add an item to the store.

    	Add an item into the store, returning NULL for success. If an
    	item with the same key is found in the store, then our item will
    	not be inserted, and the function will return a pointer to that
    	value instead. This function takes its own reference to val, as
    	required (i.e. the caller maintains ownership of its own
    	reference).

    	key: The key used to index the item.

    	val: The value to store.

    	itemsize: The size in bytes of the value (as counted towards the
    	store size).

    	type: Functions used to manipulate the key.
    """
    return _mupdf.fz_store_item(key, val, itemsize, type)

def fz_store_scavenge(size, phase):
    r"""
    Class-aware wrapper for `::fz_store_scavenge()`.

    This function has out-params. Python/C# wrappers look like:
    	`fz_store_scavenge(size_t size)` => `(int, int phase)`

    	Internal function used as part of the scavenging
    	allocator; when we fail to allocate memory, before returning a
    	failure to the caller, we try to scavenge space within the store
    	by evicting at least 'size' bytes. The allocator then retries.

    	size: The number of bytes we are trying to have free.

    	phase: What phase of the scavenge we are in. Updated on exit.

    	Returns non zero if we managed to free any memory.
    """
    return _mupdf.fz_store_scavenge(size, phase)

def fz_store_scavenge_external(size, phase):
    r"""
    Class-aware wrapper for `::fz_store_scavenge_external()`.

    This function has out-params. Python/C# wrappers look like:
    	`fz_store_scavenge_external(size_t size)` => `(int, int phase)`

    	External function for callers to use
    	to scavenge while trying allocations.

    	size: The number of bytes we are trying to have free.

    	phase: What phase of the scavenge we are in. Updated on exit.

    	Returns non zero if we managed to free any memory.
    """
    return _mupdf.fz_store_scavenge_external(size, phase)

def fz_story_document(story):
    r""" Class-aware wrapper for `::fz_story_document()`."""
    return _mupdf.fz_story_document(story)

def fz_story_positions(story, cb, arg):
    r""" Class-aware wrapper for `::fz_story_positions()`."""
    return _mupdf.fz_story_positions(story, cb, arg)

def fz_story_warnings(story):
    r""" Class-aware wrapper for `::fz_story_warnings()`."""
    return _mupdf.fz_story_warnings(story)

def fz_strcasecmp(a, b):
    r"""
    Class-aware wrapper for `::fz_strcasecmp()`.
    	Case insensitive (ASCII only) string comparison.
    """
    return _mupdf.fz_strcasecmp(a, b)

def fz_strdup(s):
    r"""
    Class-aware wrapper for `::fz_strdup()`.
    	Portable strdup implementation, using fz allocators.
    """
    return _mupdf.fz_strdup(s)

def fz_stream_from_output(arg_0):
    r"""
    Class-aware wrapper for `::fz_stream_from_output()`.
    	Obtain the fz_output in the form of a fz_stream.

    	This allows data to be read back from some forms of fz_output
    	object. When finished reading, the fz_stream should be released
    	by calling fz_drop_stream. Until the fz_stream is dropped, no
    	further operations should be performed on the fz_output object.
    """
    return _mupdf.fz_stream_from_output(arg_0)

def fz_string_from_box_type(box):
    r""" Class-aware wrapper for `::fz_string_from_box_type()`."""
    return _mupdf.fz_string_from_box_type(box)

def fz_string_from_buffer(buf):
    r"""
    Class-aware wrapper for `::fz_string_from_buffer()`.
    	Ensure that a buffer's data ends in a
    	0 byte, and return a pointer to it.
    """
    return _mupdf.fz_string_from_buffer(buf)

def fz_string_from_text_language(str, lang):
    r"""
    Class-aware wrapper for `::fz_string_from_text_language()`.
    	Recover ISO 639 (639-{1,2,3,5}) language specification
    	strings losslessly from a 15 bit fz_text_language code.

    	No validation is carried out. See note above.
    """
    return _mupdf.fz_string_from_text_language(str, lang)

def fz_string_from_text_language2(lang):
    r"""
    Class-aware wrapper for `::fz_string_from_text_language2()`.
    C++ alternative to fz_string_from_text_language() that returns information in a std::string.
    """
    return _mupdf.fz_string_from_text_language2(lang)

def fz_strlcat(dst, src, n):
    r"""
    Class-aware wrapper for `::fz_strlcat()`.
    	Concatenate 2 strings, with a maximum length.

    	dst: pointer to first string in a buffer of n bytes.

    	src: pointer to string to concatenate.

    	n: Size (in bytes) of buffer that dst is in.

    	Returns the real length that a concatenated dst + src would have
    	been (not including terminator).
    """
    return _mupdf.fz_strlcat(dst, src, n)

def fz_strlcpy(dst, src, n):
    r"""
    Class-aware wrapper for `::fz_strlcpy()`.
    	Copy at most n-1 chars of a string into a destination
    	buffer with null termination, returning the real length of the
    	initial string (excluding terminator).

    	dst: Destination buffer, at least n bytes long.

    	src: C string (non-NULL).

    	n: Size of dst buffer in bytes.

    	Returns the length (excluding terminator) of src.
    """
    return _mupdf.fz_strlcpy(dst, src, n)

def fz_strncasecmp(a, b, n):
    r""" Class-aware wrapper for `::fz_strncasecmp()`."""
    return _mupdf.fz_strncasecmp(a, b, n)

def fz_strnlen(s, maxlen):
    r"""
    Class-aware wrapper for `::fz_strnlen()`.
    	Return strlen(s), if that is less than maxlen, or maxlen if
    	there is no null byte ('') among the first maxlen bytes.
    """
    return _mupdf.fz_strnlen(s, maxlen)

def fz_stroke_path(dev, path, stroke, ctm, colorspace, color, alpha, color_params):
    r""" Class-aware wrapper for `::fz_stroke_path()`."""
    return _mupdf.fz_stroke_path(dev, path, stroke, ctm, colorspace, color, alpha, color_params)

def fz_stroke_text(dev, text, stroke, ctm, colorspace, color, alpha, color_params):
    r""" Class-aware wrapper for `::fz_stroke_text()`."""
    return _mupdf.fz_stroke_text(dev, text, stroke, ctm, colorspace, color, alpha, color_params)

def fz_strsep(stringp, delim):
    r"""
    Class-aware wrapper for `::fz_strsep()`.

    This function has out-params. Python/C# wrappers look like:
    	`fz_strsep(const char *delim)` => `(char *, char *stringp)`

    	Given a pointer to a C string (or a pointer to NULL) break
    	it at the first occurrence of a delimiter char (from a given
    	set).

    	stringp: Pointer to a C string pointer (or NULL). Updated on
    	exit to point to the first char of the string after the
    	delimiter that was found. The string pointed to by stringp will
    	be corrupted by this call (as the found delimiter will be
    	overwritten by 0).

    	delim: A C string of acceptable delimiter characters.

    	Returns a pointer to a C string containing the chars of stringp
    	up to the first delimiter char (or the end of the string), or
    	NULL.
    """
    return _mupdf.fz_strsep(stringp, delim)

def fz_strtof(s, es):
    r"""
    Class-aware wrapper for `::fz_strtof()`.

    This function has out-params. Python/C# wrappers look like:
    	`fz_strtof(const char *s)` => `(float, char *es)`

    	Locale-independent decimal to binary conversion. On overflow
    	return (-)INFINITY and set errno to ERANGE. On underflow return
    	0 and set errno to ERANGE. Special inputs (case insensitive):
    	"NAN", "INF" or "INFINITY".
    """
    return _mupdf.fz_strtof(s, es)

def fz_structure_from_string(str):
    r""" Class-aware wrapper for `::fz_structure_from_string()`."""
    return _mupdf.fz_structure_from_string(str)

def fz_structure_to_string(type):
    r""" Class-aware wrapper for `::fz_structure_to_string()`."""
    return _mupdf.fz_structure_to_string(type)

def fz_subpixel_adjust(ctm, subpix_ctm, qe, qf):
    r"""
    Class-aware wrapper for `::fz_subpixel_adjust()`.
    	Perform subpixel quantisation and adjustment on a glyph matrix.

    	ctm: On entry, the desired 'ideal' transformation for a glyph.
    	On exit, adjusted to a (very similar) transformation quantised
    	for subpixel caching.

    	subpix_ctm: Initialised by the routine to the transform that
    	should be used to render the glyph.

    	qe, qf: which subpixel position we quantised to.

    	Returns: the size of the glyph.

    	Note: This is currently only exposed for use in our app. It
    	should be considered "at risk" of removal from the API.
    """
    return _mupdf.fz_subpixel_adjust(ctm, subpix_ctm, qe, qf)

def fz_subsample_pixmap(tile, factor):
    r""" Class-aware wrapper for `::fz_subsample_pixmap()`."""
    return _mupdf.fz_subsample_pixmap(tile, factor)

def fz_subset_cff_for_gids(orig, gids, num_gids, symbolic, cidfont):
    r"""
    Class-aware wrapper for `::fz_subset_cff_for_gids()`.

    This function has out-params. Python/C# wrappers look like:
    	`fz_subset_cff_for_gids(::fz_buffer *orig, int num_gids, int symbolic, int cidfont)` => `(fz_buffer *, int gids)`
    """
    return _mupdf.fz_subset_cff_for_gids(orig, gids, num_gids, symbolic, cidfont)

def fz_subset_ttf_for_gids(orig, gids, num_gids, symbolic, cidfont):
    r"""
    Class-aware wrapper for `::fz_subset_ttf_for_gids()`.

    This function has out-params. Python/C# wrappers look like:
    	`fz_subset_ttf_for_gids(::fz_buffer *orig, int num_gids, int symbolic, int cidfont)` => `(fz_buffer *, int gids)`
    """
    return _mupdf.fz_subset_ttf_for_gids(orig, gids, num_gids, symbolic, cidfont)

def fz_sync_bits(stm):
    r"""
    Class-aware wrapper for `::fz_sync_bits()`.
    	Called after reading bits to tell the stream
    	that we are about to return to reading bytewise. Resyncs
    	the stream to whole byte boundaries.
    """
    return _mupdf.fz_sync_bits(stm)

def fz_tell(stm):
    r"""
    Class-aware wrapper for `::fz_tell()`.
    	return the current reading position within a stream
    """
    return _mupdf.fz_tell(stm)

def fz_tell_output(out):
    r"""
    Class-aware wrapper for `::fz_tell_output()`.
    	Return the current file position.

    	Throw an error on untellable outputs.
    """
    return _mupdf.fz_tell_output(out)

def fz_terminate_buffer(buf):
    r"""
    Class-aware wrapper for `::fz_terminate_buffer()`.
    	Zero-terminate buffer in order to use as a C string.

    	This byte is invisible and does not affect the length of the
    	buffer as returned by fz_buffer_storage. The zero byte is
    	written *after* the data, and subsequent writes will overwrite
    	the terminating byte.

    	Subsequent changes to the size of the buffer (such as by
    	fz_buffer_trim, fz_buffer_grow, fz_resize_buffer, etc) may
    	invalidate this.
    """
    return _mupdf.fz_terminate_buffer(buf)

def fz_text_aa_level():
    r"""
    Class-aware wrapper for `::fz_text_aa_level()`.
    	Get the number of bits of antialiasing we are
    	using for text. Between 0 and 8.
    """
    return _mupdf.fz_text_aa_level()

def fz_text_language_from_string(str):
    r"""
    Class-aware wrapper for `::fz_text_language_from_string()`.
    	Convert ISO 639 (639-{1,2,3,5}) language specification
    	strings losslessly to a 15 bit fz_text_language code.

    	No validation is carried out. Obviously invalid (out
    	of spec) codes will be mapped to FZ_LANG_UNSET, but
    	well-formed (but undefined) codes will be blithely
    	accepted.
    """
    return _mupdf.fz_text_language_from_string(str)

def fz_tint_pixmap(pix, black, white):
    r"""
    Class-aware wrapper for `::fz_tint_pixmap()`.
    	Tint all the pixels in an RGB, BGR, or Gray pixmap.

    	black: Map black to this hexadecimal RGB color.

    	white: Map white to this hexadecimal RGB color.
    """
    return _mupdf.fz_tint_pixmap(pix, black, white)

def fz_tolower(c):
    r"""
    Class-aware wrapper for `::fz_tolower()`.
    	Unicode aware tolower and toupper functions.
    """
    return _mupdf.fz_tolower(c)

def fz_toupper(c):
    r""" Class-aware wrapper for `::fz_toupper()`."""
    return _mupdf.fz_toupper(c)

def fz_transform_page(mediabox, resolution, rotate):
    r"""
    Class-aware wrapper for `::fz_transform_page()`.
    	Create transform matrix to draw page
    	at a given resolution and rotation. Adjusts the scaling
    	factors so that the page covers whole number of
    	pixels and adjust the page origin to be at 0,0.
    """
    return _mupdf.fz_transform_page(mediabox, resolution, rotate)

def fz_transform_path(path, transform):
    r"""
    Class-aware wrapper for `::fz_transform_path()`.
    	Transform a path by a given
    	matrix.

    	path: The path to modify (must not be a packed path).

    	transform: The transform to apply.

    	Throws exceptions if the path is packed, or on failure
    	to allocate.
    """
    return _mupdf.fz_transform_path(path, transform)

def fz_transform_point(point, m):
    r"""
    Class-aware wrapper for `::fz_transform_point()`.
    	Apply a transformation to a point.

    	transform: Transformation matrix to apply. See fz_concat,
    	fz_scale, fz_rotate and fz_translate for how to create a
    	matrix.

    	point: Pointer to point to update.

    	Returns transform (unchanged).
    """
    return _mupdf.fz_transform_point(point, m)

def fz_transform_point_xy(x, y, m):
    r""" Class-aware wrapper for `::fz_transform_point_xy()`."""
    return _mupdf.fz_transform_point_xy(x, y, m)

def fz_transform_quad(q, m):
    r"""
    Class-aware wrapper for `::fz_transform_quad()`.
    	Transform a quad by a matrix.
    """
    return _mupdf.fz_transform_quad(q, m)

def fz_transform_rect(rect, m):
    r"""
    Class-aware wrapper for `::fz_transform_rect()`.
    	Apply a transform to a rectangle.

    	After the four corner points of the axis-aligned rectangle
    	have been transformed it may not longer be axis-aligned. So a
    	new axis-aligned rectangle is created covering at least the
    	area of the transformed rectangle.

    	transform: Transformation matrix to apply. See fz_concat,
    	fz_scale and fz_rotate for how to create a matrix.

    	rect: Rectangle to be transformed. The two special cases
    	fz_empty_rect and fz_infinite_rect, may be used but are
    	returned unchanged as expected.
    """
    return _mupdf.fz_transform_rect(rect, m)

def fz_transform_vector(vector, m):
    r"""
    Class-aware wrapper for `::fz_transform_vector()`.
    	Apply a transformation to a vector.

    	transform: Transformation matrix to apply. See fz_concat,
    	fz_scale and fz_rotate for how to create a matrix. Any
    	translation will be ignored.

    	vector: Pointer to vector to update.
    """
    return _mupdf.fz_transform_vector(vector, m)

def fz_translate(tx, ty):
    r"""
    Class-aware wrapper for `::fz_translate()`.
    	Create a translation matrix.

    	The returned matrix is of the form [ 1 0 0 1 tx ty ].

    	m: A place to store the created matrix.

    	tx, ty: Translation distances along the X- and Y-axes. A
    	translation of 0 will not cause any translation along the
    	relevant axis.

    	Returns m.
    """
    return _mupdf.fz_translate(tx, ty)

def fz_translate_irect(a, xoff, yoff):
    r""" Class-aware wrapper for `::fz_translate_irect()`."""
    return _mupdf.fz_translate_irect(a, xoff, yoff)

def fz_translate_rect(a, xoff, yoff):
    r"""
    Class-aware wrapper for `::fz_translate_rect()`.
    	Translate bounding box.

    	Translate a bbox by a given x and y offset. Allows for overflow.
    """
    return _mupdf.fz_translate_rect(a, xoff, yoff)

def fz_tree_archive_add_buffer(arch_, name, buf):
    r"""
    Class-aware wrapper for `::fz_tree_archive_add_buffer()`.
    	Add a named buffer to an existing tree archive.

    	The tree will take a new reference to the buffer. Ownership
    	is not transferred.
    """
    return _mupdf.fz_tree_archive_add_buffer(arch_, name, buf)

def fz_tree_archive_add_data(arch_, name, data, size):
    r"""
    Class-aware wrapper for `::fz_tree_archive_add_data()`.
    	Add a named block of data to an existing tree archive.

    	The data will be copied into a buffer, and so the caller
    	may free it as soon as this returns.
    """
    return _mupdf.fz_tree_archive_add_data(arch_, name, data, size)

def fz_tree_lookup(node, key):
    r"""
    Class-aware wrapper for `::fz_tree_lookup()`.
    	Look for the value of a node in the tree with the given key.

    	Simple pointer equivalence is used for key.

    	Returns NULL for no match.
    """
    return _mupdf.fz_tree_lookup(node, key)

def fz_trim_buffer(buf):
    r"""
    Class-aware wrapper for `::fz_trim_buffer()`.
    	Trim wasted capacity from a buffer by resizing internal memory.
    """
    return _mupdf.fz_trim_buffer(buf)

def fz_trim_path(path):
    r"""
    Class-aware wrapper for `::fz_trim_path()`.
    	Minimise the internal storage used by a path.

    	As paths are constructed, the internal buffers
    	grow. To avoid repeated reallocations they
    	grow with some spare space. Once a path has
    	been fully constructed, this call allows the
    	excess space to be trimmed.
    """
    return _mupdf.fz_trim_path(path)

def fz_truncate_output(arg_0):
    r"""
    Class-aware wrapper for `::fz_truncate_output()`.
    	Truncate the output at the current position.

    	This allows output streams which have seeked back from the end
    	of their storage to be truncated at the current point.
    """
    return _mupdf.fz_truncate_output(arg_0)

def fz_try_invert_matrix(inv, src):
    r"""
    Class-aware wrapper for `::fz_try_invert_matrix()`.
    	Attempt to create an inverse matrix.

    	inverse: Place to store inverse matrix.

    	matrix: Matrix to invert. A degenerate matrix, where the
    	determinant is equal to zero, can not be inverted.

    	Returns 1 if matrix is degenerate (singular), or 0 otherwise.
    """
    return _mupdf.fz_try_invert_matrix(inv, src)

def fz_try_open_archive_entry(arch, name):
    r"""
    Class-aware wrapper for `::fz_try_open_archive_entry()`.
    	Opens an archive entry as a stream.

    	Returns NULL if a matching entry cannot be found, otherwise
    	behaves exactly as fz_open_archive_entry.
    """
    return _mupdf.fz_try_open_archive_entry(arch, name)

def fz_try_open_archive_with_stream(file):
    r"""
    Class-aware wrapper for `::fz_try_open_archive_with_stream()`.
    	Open zip or tar archive stream.

    	Does the same as fz_open_archive_with_stream, but will not throw
    	an error in the event of failing to recognise the format. Will
    	still throw errors in other cases though!
    """
    return _mupdf.fz_try_open_archive_with_stream(file)

def fz_try_open_file(name):
    r"""
    Class-aware wrapper for `::fz_try_open_file()`.
    	Open the named file and wrap it in a stream.

    	Does the same as fz_open_file, but in the event the file
    	does not open, it will return NULL rather than throw an
    	exception.
    """
    return _mupdf.fz_try_open_file(name)

def fz_try_parse_xml_archive_entry(dir, filename, preserve_white):
    r"""
    Class-aware wrapper for `::fz_try_parse_xml_archive_entry()`.
    	Try and parse the contents of an archive entry into a tree of xml nodes.

    	preserve_white: whether to keep or delete all-whitespace nodes.

    	Will return NULL if the archive entry can't be found. Otherwise behaves
    	the same as fz_parse_xml_archive_entry. May throw exceptions.
    """
    return _mupdf.fz_try_parse_xml_archive_entry(dir, filename, preserve_white)

def fz_try_read_archive_entry(arch, name):
    r"""
    Class-aware wrapper for `::fz_try_read_archive_entry()`.
    	Reads all bytes in an archive entry
    	into a buffer.

    	name: Entry name to look for, this must be an exact match to
    	the entry name in the archive.

    	Returns NULL if a matching entry cannot be found. Otherwise behaves
    	the same as fz_read_archive_entry. Exceptions may be thrown.
    """
    return _mupdf.fz_try_read_archive_entry(arch, name)

def fz_try_read_file(filename):
    r"""
    Class-aware wrapper for `::fz_try_read_file()`.
    	Read all the contents of a file into a buffer.

    	Returns NULL if the file does not exist, otherwise
    	behaves exactly as fz_read_file.
    """
    return _mupdf.fz_try_read_file(filename)

def fz_tune_image_decode(image_decode, arg):
    r"""
    Class-aware wrapper for `::fz_tune_image_decode()`.
    	Set the tuning function to use for
    	image decode.

    	image_decode: Function to use.

    	arg: Opaque argument to be passed to tuning function.
    """
    return _mupdf.fz_tune_image_decode(image_decode, arg)

def fz_tune_image_scale(image_scale, arg):
    r"""
    Class-aware wrapper for `::fz_tune_image_scale()`.
    	Set the tuning function to use for
    	image scaling.

    	image_scale: Function to use.

    	arg: Opaque argument to be passed to tuning function.
    """
    return _mupdf.fz_tune_image_scale(image_scale, arg)

def fz_unicode_from_glyph_name(name):
    r""" Class-aware wrapper for `::fz_unicode_from_glyph_name()`."""
    return _mupdf.fz_unicode_from_glyph_name(name)

def fz_unicode_from_glyph_name_strict(name):
    r""" Class-aware wrapper for `::fz_unicode_from_glyph_name_strict()`."""
    return _mupdf.fz_unicode_from_glyph_name_strict(name)

def fz_union_rect(a, b):
    r"""
    Class-aware wrapper for `::fz_union_rect()`.
    	Compute union of two rectangles.

    	Given two rectangles, update the first to be the smallest
    	axis-aligned rectangle that encompasses both given rectangles.
    	If either rectangle is infinite then the union is also infinite.
    	If either rectangle is empty then the union is simply the
    	non-empty rectangle. Should both rectangles be empty, then the
    	union is also empty.
    """
    return _mupdf.fz_union_rect(a, b)

def fz_unlock(lock):
    r"""
    Class-aware wrapper for `::fz_unlock()`.
    	Unlock one of the user supplied mutexes.
    """
    return _mupdf.fz_unlock(lock)

def fz_unpack_stream(src, depth, w, h, n, indexed, pad, skip):
    r""" Class-aware wrapper for `::fz_unpack_stream()`."""
    return _mupdf.fz_unpack_stream(src, depth, w, h, n, indexed, pad, skip)

def fz_unread_byte(stm):
    r"""
    Class-aware wrapper for `::fz_unread_byte()`.
    	Unread the single last byte successfully
    	read from a stream. Do not call this without having
    	successfully read a byte.

    	stm: The stream to operate upon.
    """
    return _mupdf.fz_unread_byte(stm)

def fz_unshare_stroke_state(shared):
    r"""
    Class-aware wrapper for `::fz_unshare_stroke_state()`.
    	Given a reference to a (possibly) shared stroke_state structure,
    	return a reference to an equivalent stroke_state structure
    	that is guaranteed to be unshared (i.e. one that can
    	safely be modified).

    	shared: The reference to a (possibly) shared structure
    	to unshare. Ownership of this reference is passed in
    	to this function, even in the case of exceptions being
    	thrown.

    	Exceptions may be thrown in the event of failure to
    	allocate if required.
    """
    return _mupdf.fz_unshare_stroke_state(shared)

def fz_unshare_stroke_state_with_dash_len(shared, len):
    r"""
    Class-aware wrapper for `::fz_unshare_stroke_state_with_dash_len()`.
    	Given a reference to a (possibly) shared stroke_state structure,
    	return a reference to a stroke_state structure (with room for a
    	given amount of dash data) that is guaranteed to be unshared
    	(i.e. one that can safely be modified).

    	shared: The reference to a (possibly) shared structure
    	to unshare. Ownership of this reference is passed in
    	to this function, even in the case of exceptions being
    	thrown.

    	Exceptions may be thrown in the event of failure to
    	allocate if required.
    """
    return _mupdf.fz_unshare_stroke_state_with_dash_len(shared, len)

def fz_urldecode(url):
    r"""
    Class-aware wrapper for `::fz_urldecode()`.
    	Like fz_decode_uri_component but in-place.
    """
    return _mupdf.fz_urldecode(url)

def fz_use_document_css():
    r"""
    Class-aware wrapper for `::fz_use_document_css()`.
    	Return whether to respect document styles in HTML and EPUB.
    """
    return _mupdf.fz_use_document_css()

def fz_user_context():
    r"""
    Class-aware wrapper for `::fz_user_context()`.
    	Read the user field from the context.
    """
    return _mupdf.fz_user_context()

def fz_user_css():
    r"""
    Class-aware wrapper for `::fz_user_css()`.
    	Get the user stylesheet source text.
    """
    return _mupdf.fz_user_css()

def fz_utflen(s):
    r"""
    Class-aware wrapper for `::fz_utflen()`.
    	Count how many runes the UTF-8 encoded string
    	consists of.

    	s: The UTF-8 encoded, NUL-terminated text string.

    	Returns the number of runes in the string.
    """
    return _mupdf.fz_utflen(s)

def fz_var_imp(arg_0):
    r""" Class-aware wrapper for `::fz_var_imp()`."""
    return _mupdf.fz_var_imp(arg_0)

def fz_walk_path(path, walker, arg):
    r"""
    Class-aware wrapper for `::fz_walk_path()`.
    	Walk the segments of a path, calling the
    	appropriate callback function from a given set for each
    	segment of the path.

    	path: The path to walk.

    	walker: The set of callback functions to use. The first
    	4 callback pointers in the set must be non-NULL. The
    	subsequent ones can either be supplied, or can be left
    	as NULL, in which case the top 4 functions will be
    	called as appropriate to simulate them.

    	arg: An opaque argument passed in to each callback.

    	Exceptions will only be thrown if the underlying callback
    	functions throw them.
    """
    return _mupdf.fz_walk_path(path, walker, arg)

def fz_warn(*args):
    r""" Class-aware wrapper for `::fz_warn()`."""
    return _mupdf.fz_warn(*args)

def fz_warning_callback(user):
    r"""
    Class-aware wrapper for `::fz_warning_callback()`.

    This function has out-params. Python/C# wrappers look like:
    	`fz_warning_callback()` => `(fz_warning_cb *, void *user)`

    	Retrieve the currently set warning callback, or NULL if none
    	has been set. Optionally, if user is non-NULL, the user pointer
    	given when the warning callback was set is also passed back to
    	the caller.
    """
    return _mupdf.fz_warning_callback(user)

def fz_warp_pixmap(src, points, width, height):
    r""" Class-aware wrapper for `::fz_warp_pixmap()`."""
    return _mupdf.fz_warp_pixmap(src, points, width, height)

def fz_windows_1250_from_unicode(u):
    r""" Class-aware wrapper for `::fz_windows_1250_from_unicode()`."""
    return _mupdf.fz_windows_1250_from_unicode(u)

def fz_windows_1251_from_unicode(u):
    r""" Class-aware wrapper for `::fz_windows_1251_from_unicode()`."""
    return _mupdf.fz_windows_1251_from_unicode(u)

def fz_windows_1252_from_unicode(u):
    r""" Class-aware wrapper for `::fz_windows_1252_from_unicode()`."""
    return _mupdf.fz_windows_1252_from_unicode(u)

def fz_write_band(writer, stride, band_height, samples):
    r"""
    Class-aware wrapper for `::fz_write_band()`.
    	Cause a band writer to write the next band
    	of data for an image.

    	stride: The byte offset from the first byte of the data
    	for a pixel to the first byte of the data for the same pixel
    	on the row below.

    	band_height: The number of lines in this band.

    	samples: Pointer to first byte of the data.
    """
    return _mupdf.fz_write_band(writer, stride, band_height, samples)

def fz_write_base64(out, data, size, newline):
    r"""
    Class-aware wrapper for `::fz_write_base64()`.
    	Write a base64 encoded data block, optionally with periodic
    	newlines.
    """
    return _mupdf.fz_write_base64(out, data, size, newline)

def fz_write_base64_buffer(out, data, newline):
    r"""
    Class-aware wrapper for `::fz_write_base64_buffer()`.
    	Write a base64 encoded fz_buffer, optionally with periodic
    	newlines.
    """
    return _mupdf.fz_write_base64_buffer(out, data, newline)

def fz_write_bitmap_as_pbm(out, bitmap):
    r"""
    Class-aware wrapper for `::fz_write_bitmap_as_pbm()`.
    	Write a bitmap as a pbm.
    """
    return _mupdf.fz_write_bitmap_as_pbm(out, bitmap)

def fz_write_bitmap_as_pcl(out, bitmap, pcl):
    r"""
    Class-aware wrapper for `::fz_write_bitmap_as_pcl()`.
    	Write a bitmap as mono PCL.
    """
    return _mupdf.fz_write_bitmap_as_pcl(out, bitmap, pcl)

def fz_write_bitmap_as_pkm(out, bitmap):
    r"""
    Class-aware wrapper for `::fz_write_bitmap_as_pkm()`.
    	Write a CMYK bitmap as a pkm.
    """
    return _mupdf.fz_write_bitmap_as_pkm(out, bitmap)

def fz_write_bitmap_as_pwg(out, bitmap, pwg):
    r"""
    Class-aware wrapper for `::fz_write_bitmap_as_pwg()`.
    	Write a bitmap as a PWG.
    """
    return _mupdf.fz_write_bitmap_as_pwg(out, bitmap, pwg)

def fz_write_bitmap_as_pwg_page(out, bitmap, pwg):
    r"""
    Class-aware wrapper for `::fz_write_bitmap_as_pwg_page()`.
    	Write a bitmap as a PWG page.

    	Caller should provide a file header by calling
    	fz_write_pwg_file_header, but can then write several pages to
    	the same file.
    """
    return _mupdf.fz_write_bitmap_as_pwg_page(out, bitmap, pwg)

def fz_write_bits(out, data, num_bits):
    r"""
    Class-aware wrapper for `::fz_write_bits()`.
    	Write num_bits of data to the end of the output stream, assumed to be packed
    	most significant bits first.
    """
    return _mupdf.fz_write_bits(out, data, num_bits)

def fz_write_bits_sync(out):
    r"""
    Class-aware wrapper for `::fz_write_bits_sync()`.
    	Sync to byte boundary after writing bits.
    """
    return _mupdf.fz_write_bits_sync(out)

def fz_write_buffer(out, data):
    r""" Class-aware wrapper for `::fz_write_buffer()`."""
    return _mupdf.fz_write_buffer(out, data)

def fz_write_byte(out, x):
    r""" Class-aware wrapper for `::fz_write_byte()`."""
    return _mupdf.fz_write_byte(out, x)

def fz_write_char(out, x):
    r""" Class-aware wrapper for `::fz_write_char()`."""
    return _mupdf.fz_write_char(out, x)

def fz_write_data(out, data, size):
    r"""
    Class-aware wrapper for `::fz_write_data()`.
    	Write data to output.

    	data: Pointer to data to write.
    	size: Size of data to write in bytes.
    """
    return _mupdf.fz_write_data(out, data, size)

def fz_write_document(wri, doc):
    r"""
    Class-aware wrapper for `::fz_write_document()`.
    	Convenience function to feed all the pages of a document to
    	fz_begin_page/fz_run_page/fz_end_page.
    """
    return _mupdf.fz_write_document(wri, doc)

def fz_write_float_be(out, f):
    r""" Class-aware wrapper for `::fz_write_float_be()`."""
    return _mupdf.fz_write_float_be(out, f)

def fz_write_float_le(out, f):
    r""" Class-aware wrapper for `::fz_write_float_le()`."""
    return _mupdf.fz_write_float_le(out, f)

def fz_write_header(writer, w, h, n, alpha, xres, yres, pagenum, cs, seps):
    r"""
    Class-aware wrapper for `::fz_write_header()`.
    	Cause a band writer to write the header for
    	a banded image with the given properties/dimensions etc. This
    	also configures the bandwriter for the format of the data to be
    	passed in future calls.

    	w, h: Width and Height of the entire page.

    	n: Number of components (including spots and alphas).

    	alpha: Number of alpha components.

    	xres, yres: X and Y resolutions in dpi.

    	cs: Colorspace (NULL for bitmaps)

    	seps: Separation details (or NULL).
    """
    return _mupdf.fz_write_header(writer, w, h, n, alpha, xres, yres, pagenum, cs, seps)

def fz_write_image_as_data_uri(out, image):
    r"""
    Class-aware wrapper for `::fz_write_image_as_data_uri()`.
    	Write image as a data URI (for HTML and SVG output).
    """
    return _mupdf.fz_write_image_as_data_uri(out, image)

def fz_write_int16_be(out, x):
    r""" Class-aware wrapper for `::fz_write_int16_be()`."""
    return _mupdf.fz_write_int16_be(out, x)

def fz_write_int16_le(out, x):
    r""" Class-aware wrapper for `::fz_write_int16_le()`."""
    return _mupdf.fz_write_int16_le(out, x)

def fz_write_int32_be(out, x):
    r"""
    Class-aware wrapper for `::fz_write_int32_be()`.
    	Write different sized data to an output stream.
    """
    return _mupdf.fz_write_int32_be(out, x)

def fz_write_int32_le(out, x):
    r""" Class-aware wrapper for `::fz_write_int32_le()`."""
    return _mupdf.fz_write_int32_le(out, x)

def fz_write_pixmap_as_data_uri(out, pixmap):
    r""" Class-aware wrapper for `::fz_write_pixmap_as_data_uri()`."""
    return _mupdf.fz_write_pixmap_as_data_uri(out, pixmap)

def fz_write_pixmap_as_jpeg(out, pix, quality, invert_cmyk):
    r"""
    Class-aware wrapper for `::fz_write_pixmap_as_jpeg()`.
    	Write a pixmap as a JPEG.
    """
    return _mupdf.fz_write_pixmap_as_jpeg(out, pix, quality, invert_cmyk)

def fz_write_pixmap_as_jpx(out, pix, quality):
    r"""
    Class-aware wrapper for `::fz_write_pixmap_as_jpx()`.
    	Pixmap data as JP2K with no subsampling.

    	quality = 100 = lossless
    	otherwise for a factor of x compression use 100-x. (so 80 is 1:20 compression)
    """
    return _mupdf.fz_write_pixmap_as_jpx(out, pix, quality)

def fz_write_pixmap_as_pam(out, pixmap):
    r"""
    Class-aware wrapper for `::fz_write_pixmap_as_pam()`.
    	Write a pixmap as a pnm (greyscale, rgb or cmyk, with or without
    	alpha).
    """
    return _mupdf.fz_write_pixmap_as_pam(out, pixmap)

def fz_write_pixmap_as_pcl(out, pixmap, pcl):
    r"""
    Class-aware wrapper for `::fz_write_pixmap_as_pcl()`.
    	Write an (RGB) pixmap as color PCL.
    """
    return _mupdf.fz_write_pixmap_as_pcl(out, pixmap, pcl)

def fz_write_pixmap_as_pclm(out, pixmap, options):
    r"""
    Class-aware wrapper for `::fz_write_pixmap_as_pclm()`.
    	Write a (Greyscale or RGB) pixmap as pclm.
    """
    return _mupdf.fz_write_pixmap_as_pclm(out, pixmap, options)

def fz_write_pixmap_as_pdfocr(out, pixmap, options):
    r"""
    Class-aware wrapper for `::fz_write_pixmap_as_pdfocr()`.
    	Write a (Greyscale or RGB) pixmap as pdfocr.
    """
    return _mupdf.fz_write_pixmap_as_pdfocr(out, pixmap, options)

def fz_write_pixmap_as_png(out, pixmap):
    r"""
    Class-aware wrapper for `::fz_write_pixmap_as_png()`.
    	Write a (Greyscale or RGB) pixmap as a png.
    """
    return _mupdf.fz_write_pixmap_as_png(out, pixmap)

def fz_write_pixmap_as_pnm(out, pixmap):
    r"""
    Class-aware wrapper for `::fz_write_pixmap_as_pnm()`.
    	Write a pixmap as a pnm (greyscale or rgb, no alpha).
    """
    return _mupdf.fz_write_pixmap_as_pnm(out, pixmap)

def fz_write_pixmap_as_ps(out, pixmap):
    r"""
    Class-aware wrapper for `::fz_write_pixmap_as_ps()`.
    	Write a (gray, rgb, or cmyk, no alpha) pixmap out as postscript.
    """
    return _mupdf.fz_write_pixmap_as_ps(out, pixmap)

def fz_write_pixmap_as_psd(out, pixmap):
    r"""
    Class-aware wrapper for `::fz_write_pixmap_as_psd()`.
    	Write a pixmap as a PSD file.
    """
    return _mupdf.fz_write_pixmap_as_psd(out, pixmap)

def fz_write_pixmap_as_pwg(out, pixmap, pwg):
    r"""
    Class-aware wrapper for `::fz_write_pixmap_as_pwg()`.
    	Write a pixmap as a PWG.
    """
    return _mupdf.fz_write_pixmap_as_pwg(out, pixmap, pwg)

def fz_write_pixmap_as_pwg_page(out, pixmap, pwg):
    r"""
    Class-aware wrapper for `::fz_write_pixmap_as_pwg_page()`.
    	Write a pixmap as a PWG page.

    	Caller should provide a file header by calling
    	fz_write_pwg_file_header, but can then write several pages to
    	the same file.
    """
    return _mupdf.fz_write_pixmap_as_pwg_page(out, pixmap, pwg)

def fz_write_ps_file_header(out):
    r"""
    Class-aware wrapper for `::fz_write_ps_file_header()`.
    	Write the file level header for ps band writer output.
    """
    return _mupdf.fz_write_ps_file_header(out)

def fz_write_ps_file_trailer(out, pages):
    r"""
    Class-aware wrapper for `::fz_write_ps_file_trailer()`.
    	Write the file level trailer for ps band writer output.
    """
    return _mupdf.fz_write_ps_file_trailer(out, pages)

def fz_write_pwg_file_header(out):
    r"""
    Class-aware wrapper for `::fz_write_pwg_file_header()`.
    	Output the file header to a pwg stream, ready for pages to follow it.
    """
    return _mupdf.fz_write_pwg_file_header(out)

def fz_write_rune(out, rune):
    r"""
    Class-aware wrapper for `::fz_write_rune()`.
    	Write a UTF-8 encoded unicode character.
    """
    return _mupdf.fz_write_rune(out, rune)

def fz_write_stabilized_story(writer, user_css, em, contentfn, contentfn_ref, rectfn, rectfn_ref, pagefn, pagefn_ref, dir):
    r""" Class-aware wrapper for `::fz_write_stabilized_story()`."""
    return _mupdf.fz_write_stabilized_story(writer, user_css, em, contentfn, contentfn_ref, rectfn, rectfn_ref, pagefn, pagefn_ref, dir)

def fz_write_story(writer, story, rectfn, rectfn_ref, positionfn, positionfn_ref, pagefn, pagefn_ref):
    r""" Class-aware wrapper for `::fz_write_story()`."""
    return _mupdf.fz_write_story(writer, story, rectfn, rectfn_ref, positionfn, positionfn_ref, pagefn, pagefn_ref)

def fz_write_string(out, s):
    r"""
    Class-aware wrapper for `::fz_write_string()`.
    	Write a string. Does not write zero terminator.
    """
    return _mupdf.fz_write_string(out, s)

def fz_write_uint16_be(out, x):
    r""" Class-aware wrapper for `::fz_write_uint16_be()`."""
    return _mupdf.fz_write_uint16_be(out, x)

def fz_write_uint16_le(out, x):
    r""" Class-aware wrapper for `::fz_write_uint16_le()`."""
    return _mupdf.fz_write_uint16_le(out, x)

def fz_write_uint32_be(out, x):
    r""" Class-aware wrapper for `::fz_write_uint32_be()`."""
    return _mupdf.fz_write_uint32_be(out, x)

def fz_write_uint32_le(out, x):
    r""" Class-aware wrapper for `::fz_write_uint32_le()`."""
    return _mupdf.fz_write_uint32_le(out, x)

def fz_write_zip_entry(zip, name, buf, compress):
    r"""
    Class-aware wrapper for `::fz_write_zip_entry()`.
    	Given a buffer of data, (optionally) compress it, and add it to
    	the zip file with the given name.
    """
    return _mupdf.fz_write_zip_entry(zip, name, buf, compress)

def fz_xml_add_att(pool, node, key, val):
    r"""
    Class-aware wrapper for `::fz_xml_add_att()`.
    	Add an attribute to an XML node.
    """
    return _mupdf.fz_xml_add_att(pool, node, key, val)

def fz_xml_att(item, att):
    r"""
    Class-aware wrapper for `::fz_xml_att()`.
    	Return the value of an attribute of an XML node.
    	NULL if the attribute doesn't exist.
    """
    return _mupdf.fz_xml_att(item, att)

def fz_xml_att_alt(item, one, two):
    r"""
    Class-aware wrapper for `::fz_xml_att_alt()`.
    	Return the value of an attribute of an XML node.
    	If the first attribute doesn't exist, try the second.
    	NULL if neither attribute exists.
    """
    return _mupdf.fz_xml_att_alt(item, one, two)

def fz_xml_att_eq(item, name, match):
    r"""
    Class-aware wrapper for `::fz_xml_att_eq()`.
    	Check for a matching attribute on an XML node.

    	If the node has the requested attribute (name), and the value
    	matches (match) then return 1. Otherwise, 0.
    """
    return _mupdf.fz_xml_att_eq(item, name, match)

def fz_xml_down(item):
    r"""
    Class-aware wrapper for `::fz_xml_down()`.
    	Return first child of XML node.
    """
    return _mupdf.fz_xml_down(item)

def fz_xml_find(item, tag):
    r"""
    Class-aware wrapper for `::fz_xml_find()`.
    	Search the siblings of XML nodes starting with item looking for
    	the first with the given tag.

    	Return NULL if none found.
    """
    return _mupdf.fz_xml_find(item, tag)

def fz_xml_find_dfs(item, tag, att, match):
    r"""
    Class-aware wrapper for `::fz_xml_find_dfs()`.
    	Perform a depth first search from item, returning the first
    	child that matches the given tag (or any tag if tag is NULL),
    	with the given attribute (if att is non NULL), that matches
    	match (if match is non NULL).
    """
    return _mupdf.fz_xml_find_dfs(item, tag, att, match)

def fz_xml_find_dfs_top(item, tag, att, match, top):
    r"""
    Class-aware wrapper for `::fz_xml_find_dfs_top()`.
    	Perform a depth first search from item, returning the first
    	child that matches the given tag (or any tag if tag is NULL),
    	with the given attribute (if att is non NULL), that matches
    	match (if match is non NULL). The search stops if it ever
    	reaches the top of the tree, or the declared 'top' item.
    """
    return _mupdf.fz_xml_find_dfs_top(item, tag, att, match, top)

def fz_xml_find_down(item, tag):
    r"""
    Class-aware wrapper for `::fz_xml_find_down()`.
    	Search the siblings of XML nodes starting with the first child
    	of item looking for the first with the given tag.

    	Return NULL if none found.
    """
    return _mupdf.fz_xml_find_down(item, tag)

def fz_xml_find_down_match(item, tag, att, match):
    r"""
    Class-aware wrapper for `::fz_xml_find_down_match()`.
    	Search the siblings of XML nodes starting with the first child
    	of item looking for the first with the given tag (or any tag if
    	tag is NULL), and with a matching attribute.

    	Return NULL if none found.
    """
    return _mupdf.fz_xml_find_down_match(item, tag, att, match)

def fz_xml_find_match(item, tag, att, match):
    r"""
    Class-aware wrapper for `::fz_xml_find_match()`.
    	Search the siblings of XML nodes starting with item looking for
    	the first with the given tag (or any tag if tag is NULL), and
    	with a matching attribute.

    	Return NULL if none found.
    """
    return _mupdf.fz_xml_find_match(item, tag, att, match)

def fz_xml_find_next(item, tag):
    r"""
    Class-aware wrapper for `::fz_xml_find_next()`.
    	Search the siblings of XML nodes starting with the first sibling
    	of item looking for the first with the given tag.

    	Return NULL if none found.
    """
    return _mupdf.fz_xml_find_next(item, tag)

def fz_xml_find_next_dfs(item, tag, att, match):
    r"""
    Class-aware wrapper for `::fz_xml_find_next_dfs()`.
    	Perform a depth first search onwards from item, returning the first
    	child that matches the given tag (or any tag if tag is NULL),
    	with the given attribute (if att is non NULL), that matches
    	match (if match is non NULL).
    """
    return _mupdf.fz_xml_find_next_dfs(item, tag, att, match)

def fz_xml_find_next_dfs_top(item, tag, att, match, top):
    r"""
    Class-aware wrapper for `::fz_xml_find_next_dfs_top()`.
    	Perform a depth first search onwards from item, returning the first
    	child that matches the given tag (or any tag if tag is NULL),
    	with the given attribute (if att is non NULL), that matches
    	match (if match is non NULL). The search stops if it ever reaches
    	the top of the tree, or the declared 'top' item.
    """
    return _mupdf.fz_xml_find_next_dfs_top(item, tag, att, match, top)

def fz_xml_find_next_match(item, tag, att, match):
    r"""
    Class-aware wrapper for `::fz_xml_find_next_match()`.
    	Search the siblings of XML nodes starting with the first sibling
    	of item looking for the first with the given tag (or any tag if tag
    	is NULL), and with a matching attribute.

    	Return NULL if none found.
    """
    return _mupdf.fz_xml_find_next_match(item, tag, att, match)

def fz_xml_is_tag(item, name):
    r"""
    Class-aware wrapper for `::fz_xml_is_tag()`.
    	Return true if the tag name matches.
    """
    return _mupdf.fz_xml_is_tag(item, name)

def fz_xml_next(item):
    r"""
    Class-aware wrapper for `::fz_xml_next()`.
    	Return next sibling of XML node.
    """
    return _mupdf.fz_xml_next(item)

def fz_xml_prev(item):
    r"""
    Class-aware wrapper for `::fz_xml_prev()`.
    	Return previous sibling of XML node.
    """
    return _mupdf.fz_xml_prev(item)

def fz_xml_root(xml):
    r"""
    Class-aware wrapper for `::fz_xml_root()`.
    	Return the topmost XML node of a document.
    """
    return _mupdf.fz_xml_root(xml)

def fz_xml_tag(item):
    r"""
    Class-aware wrapper for `::fz_xml_tag()`.
    	Return tag of XML node. Return NULL for text nodes.
    """
    return _mupdf.fz_xml_tag(item)

def fz_xml_text(item):
    r"""
    Class-aware wrapper for `::fz_xml_text()`.
    	Return the text content of an XML node.
    	Return NULL if the node is a tag.
    """
    return _mupdf.fz_xml_text(item)

def fz_xml_up(item):
    r"""
    Class-aware wrapper for `::fz_xml_up()`.
    	Return parent of XML node.
    """
    return _mupdf.fz_xml_up(item)

def pdf_abandon_operation(doc):
    r""" Class-aware wrapper for `::pdf_abandon_operation()`."""
    return _mupdf.pdf_abandon_operation(doc)

def pdf_access_exec_menu_item_event(evt):
    r""" Class-aware wrapper for `::pdf_access_exec_menu_item_event()`."""
    return _mupdf.pdf_access_exec_menu_item_event(evt)

def pdf_add_annot_border_dash_item(annot, length):
    r""" Class-aware wrapper for `::pdf_add_annot_border_dash_item()`."""
    return _mupdf.pdf_add_annot_border_dash_item(annot, length)

def pdf_add_annot_ink_list(annot, n, stroke):
    r""" Class-aware wrapper for `::pdf_add_annot_ink_list()`."""
    return _mupdf.pdf_add_annot_ink_list(annot, n, stroke)

def pdf_add_annot_ink_list_stroke(annot):
    r""" Class-aware wrapper for `::pdf_add_annot_ink_list_stroke()`."""
    return _mupdf.pdf_add_annot_ink_list_stroke(annot)

def pdf_add_annot_ink_list_stroke_vertex(annot, p):
    r""" Class-aware wrapper for `::pdf_add_annot_ink_list_stroke_vertex()`."""
    return _mupdf.pdf_add_annot_ink_list_stroke_vertex(annot, p)

def pdf_add_annot_quad_point(annot, quad):
    r""" Class-aware wrapper for `::pdf_add_annot_quad_point()`."""
    return _mupdf.pdf_add_annot_quad_point(annot, quad)

def pdf_add_annot_vertex(annot, p):
    r""" Class-aware wrapper for `::pdf_add_annot_vertex()`."""
    return _mupdf.pdf_add_annot_vertex(annot, p)

def pdf_add_cid_font(doc, font):
    r""" Class-aware wrapper for `::pdf_add_cid_font()`."""
    return _mupdf.pdf_add_cid_font(doc, font)

def pdf_add_cjk_font(doc, font, script, wmode, serif):
    r""" Class-aware wrapper for `::pdf_add_cjk_font()`."""
    return _mupdf.pdf_add_cjk_font(doc, font, script, wmode, serif)

def pdf_add_codespace(cmap, low, high, n):
    r""" Class-aware wrapper for `::pdf_add_codespace()`."""
    return _mupdf.pdf_add_codespace(cmap, low, high, n)

def pdf_add_embedded_file(doc, filename, mimetype, contents, created, modifed, add_checksum):
    r""" Class-aware wrapper for `::pdf_add_embedded_file()`."""
    return _mupdf.pdf_add_embedded_file(doc, filename, mimetype, contents, created, modifed, add_checksum)

def pdf_add_hmtx(font, lo, hi, w):
    r""" Class-aware wrapper for `::pdf_add_hmtx()`."""
    return _mupdf.pdf_add_hmtx(font, lo, hi, w)

def pdf_add_image(doc, image):
    r""" Class-aware wrapper for `::pdf_add_image()`."""
    return _mupdf.pdf_add_image(doc, image)

def pdf_add_journal_fragment(doc, parent, copy, copy_stream, newobj):
    r""" Class-aware wrapper for `::pdf_add_journal_fragment()`."""
    return _mupdf.pdf_add_journal_fragment(doc, parent, copy, copy_stream, newobj)

def pdf_add_new_array(doc, initial):
    r""" Class-aware wrapper for `::pdf_add_new_array()`."""
    return _mupdf.pdf_add_new_array(doc, initial)

def pdf_add_new_dict(doc, initial):
    r""" Class-aware wrapper for `::pdf_add_new_dict()`."""
    return _mupdf.pdf_add_new_dict(doc, initial)

def pdf_add_object(doc, obj):
    r""" Class-aware wrapper for `::pdf_add_object()`."""
    return _mupdf.pdf_add_object(doc, obj)

def pdf_add_page(doc, mediabox, rotate, resources, contents):
    r""" Class-aware wrapper for `::pdf_add_page()`."""
    return _mupdf.pdf_add_page(doc, mediabox, rotate, resources, contents)

def pdf_add_simple_font(doc, font, encoding):
    r""" Class-aware wrapper for `::pdf_add_simple_font()`."""
    return _mupdf.pdf_add_simple_font(doc, font, encoding)

def pdf_add_stream(doc, buf, obj, compressed):
    r""" Class-aware wrapper for `::pdf_add_stream()`."""
    return _mupdf.pdf_add_stream(doc, buf, obj, compressed)

def pdf_add_substitute_font(doc, font):
    r""" Class-aware wrapper for `::pdf_add_substitute_font()`."""
    return _mupdf.pdf_add_substitute_font(doc, font)

def pdf_add_vmtx(font, lo, hi, x, y, w):
    r""" Class-aware wrapper for `::pdf_add_vmtx()`."""
    return _mupdf.pdf_add_vmtx(font, lo, hi, x, y, w)

def pdf_annot_MK_BC(annot, n, color):
    r"""
    Class-aware wrapper for `::pdf_annot_MK_BC()`.

    This function has out-params. Python/C# wrappers look like:
    	`pdf_annot_MK_BC(::pdf_annot *annot, float color[4])` => int n
    """
    return _mupdf.pdf_annot_MK_BC(annot, n, color)

def pdf_annot_MK_BC_rgb(annot, rgb):
    r""" Class-aware wrapper for `::pdf_annot_MK_BC_rgb()`."""
    return _mupdf.pdf_annot_MK_BC_rgb(annot, rgb)

def pdf_annot_MK_BG(annot, n, color):
    r"""
    Class-aware wrapper for `::pdf_annot_MK_BG()`.

    This function has out-params. Python/C# wrappers look like:
    	`pdf_annot_MK_BG(::pdf_annot *annot, float color[4])` => int n
    """
    return _mupdf.pdf_annot_MK_BG(annot, n, color)

def pdf_annot_MK_BG_rgb(annot, rgb):
    r""" Class-aware wrapper for `::pdf_annot_MK_BG_rgb()`."""
    return _mupdf.pdf_annot_MK_BG_rgb(annot, rgb)

def pdf_annot_active(annot):
    r""" Class-aware wrapper for `::pdf_annot_active()`."""
    return _mupdf.pdf_annot_active(annot)

def pdf_annot_ap(annot):
    r""" Class-aware wrapper for `::pdf_annot_ap()`."""
    return _mupdf.pdf_annot_ap(annot)

def pdf_annot_author(annot):
    r""" Class-aware wrapper for `::pdf_annot_author()`."""
    return _mupdf.pdf_annot_author(annot)

def pdf_annot_border(annot):
    r""" Class-aware wrapper for `::pdf_annot_border()`."""
    return _mupdf.pdf_annot_border(annot)

def pdf_annot_border_dash_count(annot):
    r""" Class-aware wrapper for `::pdf_annot_border_dash_count()`."""
    return _mupdf.pdf_annot_border_dash_count(annot)

def pdf_annot_border_dash_item(annot, i):
    r""" Class-aware wrapper for `::pdf_annot_border_dash_item()`."""
    return _mupdf.pdf_annot_border_dash_item(annot, i)

def pdf_annot_border_effect(annot):
    r""" Class-aware wrapper for `::pdf_annot_border_effect()`."""
    return _mupdf.pdf_annot_border_effect(annot)

def pdf_annot_border_effect_intensity(annot):
    r""" Class-aware wrapper for `::pdf_annot_border_effect_intensity()`."""
    return _mupdf.pdf_annot_border_effect_intensity(annot)

def pdf_annot_border_style(annot):
    r""" Class-aware wrapper for `::pdf_annot_border_style()`."""
    return _mupdf.pdf_annot_border_style(annot)

def pdf_annot_border_width(annot):
    r""" Class-aware wrapper for `::pdf_annot_border_width()`."""
    return _mupdf.pdf_annot_border_width(annot)

def pdf_annot_color(annot, n, color):
    r"""
    Class-aware wrapper for `::pdf_annot_color()`.

    This function has out-params. Python/C# wrappers look like:
    	`pdf_annot_color(::pdf_annot *annot, float color[4])` => int n
    """
    return _mupdf.pdf_annot_color(annot, n, color)

def pdf_annot_contents(annot):
    r""" Class-aware wrapper for `::pdf_annot_contents()`."""
    return _mupdf.pdf_annot_contents(annot)

def pdf_annot_creation_date(annot):
    r""" Class-aware wrapper for `::pdf_annot_creation_date()`."""
    return _mupdf.pdf_annot_creation_date(annot)

def pdf_annot_default_appearance(annot, font, size, n, color):
    r"""
    Class-aware wrapper for `::pdf_annot_default_appearance()`.

    This function has out-params. Python/C# wrappers look like:
    	`pdf_annot_default_appearance(::pdf_annot *annot, float color[4])` => `(const char *font, float size, int n)`
    """
    return _mupdf.pdf_annot_default_appearance(annot, font, size, n, color)

def pdf_annot_ensure_local_xref(annot):
    r""" Class-aware wrapper for `::pdf_annot_ensure_local_xref()`."""
    return _mupdf.pdf_annot_ensure_local_xref(annot)

def pdf_annot_event_blur(annot):
    r""" Class-aware wrapper for `::pdf_annot_event_blur()`."""
    return _mupdf.pdf_annot_event_blur(annot)

def pdf_annot_event_down(annot):
    r""" Class-aware wrapper for `::pdf_annot_event_down()`."""
    return _mupdf.pdf_annot_event_down(annot)

def pdf_annot_event_enter(annot):
    r""" Class-aware wrapper for `::pdf_annot_event_enter()`."""
    return _mupdf.pdf_annot_event_enter(annot)

def pdf_annot_event_exit(annot):
    r""" Class-aware wrapper for `::pdf_annot_event_exit()`."""
    return _mupdf.pdf_annot_event_exit(annot)

def pdf_annot_event_focus(annot):
    r""" Class-aware wrapper for `::pdf_annot_event_focus()`."""
    return _mupdf.pdf_annot_event_focus(annot)

def pdf_annot_event_page_close(annot):
    r""" Class-aware wrapper for `::pdf_annot_event_page_close()`."""
    return _mupdf.pdf_annot_event_page_close(annot)

def pdf_annot_event_page_invisible(annot):
    r""" Class-aware wrapper for `::pdf_annot_event_page_invisible()`."""
    return _mupdf.pdf_annot_event_page_invisible(annot)

def pdf_annot_event_page_open(annot):
    r""" Class-aware wrapper for `::pdf_annot_event_page_open()`."""
    return _mupdf.pdf_annot_event_page_open(annot)

def pdf_annot_event_page_visible(annot):
    r""" Class-aware wrapper for `::pdf_annot_event_page_visible()`."""
    return _mupdf.pdf_annot_event_page_visible(annot)

def pdf_annot_event_up(annot):
    r""" Class-aware wrapper for `::pdf_annot_event_up()`."""
    return _mupdf.pdf_annot_event_up(annot)

def pdf_annot_field_event_keystroke(doc, annot, evt):
    r""" Class-aware wrapper for `::pdf_annot_field_event_keystroke()`."""
    return _mupdf.pdf_annot_field_event_keystroke(doc, annot, evt)

def pdf_annot_field_flags(annot):
    r""" Class-aware wrapper for `::pdf_annot_field_flags()`."""
    return _mupdf.pdf_annot_field_flags(annot)

def pdf_annot_field_label(widget):
    r""" Class-aware wrapper for `::pdf_annot_field_label()`."""
    return _mupdf.pdf_annot_field_label(widget)

def pdf_annot_field_value(annot):
    r""" Class-aware wrapper for `::pdf_annot_field_value()`."""
    return _mupdf.pdf_annot_field_value(annot)

def pdf_annot_filespec(annot):
    r""" Class-aware wrapper for `::pdf_annot_filespec()`."""
    return _mupdf.pdf_annot_filespec(annot)

def pdf_annot_flags(annot):
    r""" Class-aware wrapper for `::pdf_annot_flags()`."""
    return _mupdf.pdf_annot_flags(annot)

def pdf_annot_has_author(annot):
    r""" Class-aware wrapper for `::pdf_annot_has_author()`."""
    return _mupdf.pdf_annot_has_author(annot)

def pdf_annot_has_border(annot):
    r""" Class-aware wrapper for `::pdf_annot_has_border()`."""
    return _mupdf.pdf_annot_has_border(annot)

def pdf_annot_has_border_effect(annot):
    r""" Class-aware wrapper for `::pdf_annot_has_border_effect()`."""
    return _mupdf.pdf_annot_has_border_effect(annot)

def pdf_annot_has_filespec(annot):
    r""" Class-aware wrapper for `::pdf_annot_has_filespec()`."""
    return _mupdf.pdf_annot_has_filespec(annot)

def pdf_annot_has_icon_name(annot):
    r""" Class-aware wrapper for `::pdf_annot_has_icon_name()`."""
    return _mupdf.pdf_annot_has_icon_name(annot)

def pdf_annot_has_ink_list(annot):
    r""" Class-aware wrapper for `::pdf_annot_has_ink_list()`."""
    return _mupdf.pdf_annot_has_ink_list(annot)

def pdf_annot_has_interior_color(annot):
    r""" Class-aware wrapper for `::pdf_annot_has_interior_color()`."""
    return _mupdf.pdf_annot_has_interior_color(annot)

def pdf_annot_has_line(annot):
    r""" Class-aware wrapper for `::pdf_annot_has_line()`."""
    return _mupdf.pdf_annot_has_line(annot)

def pdf_annot_has_line_ending_styles(annot):
    r""" Class-aware wrapper for `::pdf_annot_has_line_ending_styles()`."""
    return _mupdf.pdf_annot_has_line_ending_styles(annot)

def pdf_annot_has_open(annot):
    r""" Class-aware wrapper for `::pdf_annot_has_open()`."""
    return _mupdf.pdf_annot_has_open(annot)

def pdf_annot_has_quad_points(annot):
    r""" Class-aware wrapper for `::pdf_annot_has_quad_points()`."""
    return _mupdf.pdf_annot_has_quad_points(annot)

def pdf_annot_has_quadding(annot):
    r""" Class-aware wrapper for `::pdf_annot_has_quadding()`."""
    return _mupdf.pdf_annot_has_quadding(annot)

def pdf_annot_has_rect(annot):
    r""" Class-aware wrapper for `::pdf_annot_has_rect()`."""
    return _mupdf.pdf_annot_has_rect(annot)

def pdf_annot_has_vertices(annot):
    r""" Class-aware wrapper for `::pdf_annot_has_vertices()`."""
    return _mupdf.pdf_annot_has_vertices(annot)

def pdf_annot_hidden_for_editing(annot):
    r""" Class-aware wrapper for `::pdf_annot_hidden_for_editing()`."""
    return _mupdf.pdf_annot_hidden_for_editing(annot)

def pdf_annot_hot(annot):
    r""" Class-aware wrapper for `::pdf_annot_hot()`."""
    return _mupdf.pdf_annot_hot(annot)

def pdf_annot_icon_name(annot):
    r""" Class-aware wrapper for `::pdf_annot_icon_name()`."""
    return _mupdf.pdf_annot_icon_name(annot)

def pdf_annot_ink_list_count(annot):
    r""" Class-aware wrapper for `::pdf_annot_ink_list_count()`."""
    return _mupdf.pdf_annot_ink_list_count(annot)

def pdf_annot_ink_list_stroke_count(annot, i):
    r""" Class-aware wrapper for `::pdf_annot_ink_list_stroke_count()`."""
    return _mupdf.pdf_annot_ink_list_stroke_count(annot, i)

def pdf_annot_ink_list_stroke_vertex(annot, i, k):
    r""" Class-aware wrapper for `::pdf_annot_ink_list_stroke_vertex()`."""
    return _mupdf.pdf_annot_ink_list_stroke_vertex(annot, i, k)

def pdf_annot_interior_color(annot, n, color):
    r"""
    Class-aware wrapper for `::pdf_annot_interior_color()`.

    This function has out-params. Python/C# wrappers look like:
    	`pdf_annot_interior_color(::pdf_annot *annot, float color[4])` => int n
    """
    return _mupdf.pdf_annot_interior_color(annot, n, color)

def pdf_annot_is_open(annot):
    r""" Class-aware wrapper for `::pdf_annot_is_open()`."""
    return _mupdf.pdf_annot_is_open(annot)

def pdf_annot_is_standard_stamp(annot):
    r""" Class-aware wrapper for `::pdf_annot_is_standard_stamp()`."""
    return _mupdf.pdf_annot_is_standard_stamp(annot)

def pdf_annot_language(annot):
    r""" Class-aware wrapper for `::pdf_annot_language()`."""
    return _mupdf.pdf_annot_language(annot)

def pdf_annot_line(annot, a, b):
    r""" Class-aware wrapper for `::pdf_annot_line()`."""
    return _mupdf.pdf_annot_line(annot, a, b)

def pdf_annot_line_end_style(annot):
    r""" Class-aware wrapper for `::pdf_annot_line_end_style()`."""
    return _mupdf.pdf_annot_line_end_style(annot)

def pdf_annot_line_ending_styles(annot, start_style, end_style):
    r"""
    Class-aware wrapper for `::pdf_annot_line_ending_styles()`.

    This function has out-params. Python/C# wrappers look like:
    	`pdf_annot_line_ending_styles(::pdf_annot *annot)` => `(enum pdf_line_ending start_style, enum pdf_line_ending end_style)`
    """
    return _mupdf.pdf_annot_line_ending_styles(annot, start_style, end_style)

def pdf_annot_line_start_style(annot):
    r""" Class-aware wrapper for `::pdf_annot_line_start_style()`."""
    return _mupdf.pdf_annot_line_start_style(annot)

def pdf_annot_modification_date(annot):
    r""" Class-aware wrapper for `::pdf_annot_modification_date()`."""
    return _mupdf.pdf_annot_modification_date(annot)

def pdf_annot_needs_resynthesis(annot):
    r""" Class-aware wrapper for `::pdf_annot_needs_resynthesis()`."""
    return _mupdf.pdf_annot_needs_resynthesis(annot)

def pdf_annot_obj(annot):
    r""" Class-aware wrapper for `::pdf_annot_obj()`."""
    return _mupdf.pdf_annot_obj(annot)

def pdf_annot_opacity(annot):
    r""" Class-aware wrapper for `::pdf_annot_opacity()`."""
    return _mupdf.pdf_annot_opacity(annot)

def pdf_annot_page(annot):
    r""" Class-aware wrapper for `::pdf_annot_page()`."""
    return _mupdf.pdf_annot_page(annot)

def pdf_annot_pop_and_discard_local_xref(annot):
    r""" Class-aware wrapper for `::pdf_annot_pop_and_discard_local_xref()`."""
    return _mupdf.pdf_annot_pop_and_discard_local_xref(annot)

def pdf_annot_pop_local_xref(annot):
    r""" Class-aware wrapper for `::pdf_annot_pop_local_xref()`."""
    return _mupdf.pdf_annot_pop_local_xref(annot)

def pdf_annot_popup(annot):
    r""" Class-aware wrapper for `::pdf_annot_popup()`."""
    return _mupdf.pdf_annot_popup(annot)

def pdf_annot_push_local_xref(annot):
    r""" Class-aware wrapper for `::pdf_annot_push_local_xref()`."""
    return _mupdf.pdf_annot_push_local_xref(annot)

def pdf_annot_quad_point(annot, i):
    r""" Class-aware wrapper for `::pdf_annot_quad_point()`."""
    return _mupdf.pdf_annot_quad_point(annot, i)

def pdf_annot_quad_point_count(annot):
    r""" Class-aware wrapper for `::pdf_annot_quad_point_count()`."""
    return _mupdf.pdf_annot_quad_point_count(annot)

def pdf_annot_quadding(annot):
    r""" Class-aware wrapper for `::pdf_annot_quadding()`."""
    return _mupdf.pdf_annot_quadding(annot)

def pdf_annot_rect(annot):
    r""" Class-aware wrapper for `::pdf_annot_rect()`."""
    return _mupdf.pdf_annot_rect(annot)

def pdf_annot_request_resynthesis(annot):
    r""" Class-aware wrapper for `::pdf_annot_request_resynthesis()`."""
    return _mupdf.pdf_annot_request_resynthesis(annot)

def pdf_annot_request_synthesis(annot):
    r""" Class-aware wrapper for `::pdf_annot_request_synthesis()`."""
    return _mupdf.pdf_annot_request_synthesis(annot)

def pdf_annot_transform(annot):
    r""" Class-aware wrapper for `::pdf_annot_transform()`."""
    return _mupdf.pdf_annot_transform(annot)

def pdf_annot_type(annot):
    r""" Class-aware wrapper for `::pdf_annot_type()`."""
    return _mupdf.pdf_annot_type(annot)

def pdf_annot_type_from_string(subtype):
    r""" Class-aware wrapper for `::pdf_annot_type_from_string()`."""
    return _mupdf.pdf_annot_type_from_string(subtype)

def pdf_annot_vertex(annot, i):
    r""" Class-aware wrapper for `::pdf_annot_vertex()`."""
    return _mupdf.pdf_annot_vertex(annot, i)

def pdf_annot_vertex_count(annot):
    r""" Class-aware wrapper for `::pdf_annot_vertex_count()`."""
    return _mupdf.pdf_annot_vertex_count(annot)

def pdf_append_explicit_dest_to_uri(url, dest):
    r""" Class-aware wrapper for `::pdf_append_explicit_dest_to_uri()`."""
    return _mupdf.pdf_append_explicit_dest_to_uri(url, dest)

def pdf_append_named_dest_to_uri(url, name):
    r""" Class-aware wrapper for `::pdf_append_named_dest_to_uri()`."""
    return _mupdf.pdf_append_named_dest_to_uri(url, name)

def pdf_append_token(buf, tok, lex):
    r""" Class-aware wrapper for `::pdf_append_token()`."""
    return _mupdf.pdf_append_token(buf, tok, lex)

def pdf_apply_redaction(annot, opts):
    r""" Class-aware wrapper for `::pdf_apply_redaction()`."""
    return _mupdf.pdf_apply_redaction(annot, opts)

def pdf_array_contains(array, obj):
    r""" Class-aware wrapper for `::pdf_array_contains()`."""
    return _mupdf.pdf_array_contains(array, obj)

def pdf_array_delete(array, index):
    r""" Class-aware wrapper for `::pdf_array_delete()`."""
    return _mupdf.pdf_array_delete(array, index)

def pdf_array_find(array, obj):
    r""" Class-aware wrapper for `::pdf_array_find()`."""
    return _mupdf.pdf_array_find(array, obj)

def pdf_array_get(array, i):
    r""" Class-aware wrapper for `::pdf_array_get()`."""
    return _mupdf.pdf_array_get(array, i)

def pdf_array_get_bool(array, index):
    r""" Class-aware wrapper for `::pdf_array_get_bool()`."""
    return _mupdf.pdf_array_get_bool(array, index)

def pdf_array_get_int(array, index):
    r""" Class-aware wrapper for `::pdf_array_get_int()`."""
    return _mupdf.pdf_array_get_int(array, index)

def pdf_array_get_matrix(array, index):
    r""" Class-aware wrapper for `::pdf_array_get_matrix()`."""
    return _mupdf.pdf_array_get_matrix(array, index)

def pdf_array_get_name(array, index):
    r""" Class-aware wrapper for `::pdf_array_get_name()`."""
    return _mupdf.pdf_array_get_name(array, index)

def pdf_array_get_real(array, index):
    r""" Class-aware wrapper for `::pdf_array_get_real()`."""
    return _mupdf.pdf_array_get_real(array, index)

def pdf_array_get_rect(array, index):
    r""" Class-aware wrapper for `::pdf_array_get_rect()`."""
    return _mupdf.pdf_array_get_rect(array, index)

def pdf_array_get_string(array, index, sizep):
    r"""
    Class-aware wrapper for `::pdf_array_get_string()`.

    This function has out-params. Python/C# wrappers look like:
    	`pdf_array_get_string(::pdf_obj *array, int index)` => `(const char *, size_t sizep)`
    """
    return _mupdf.pdf_array_get_string(array, index, sizep)

def pdf_array_get_text_string(array, index):
    r""" Class-aware wrapper for `::pdf_array_get_text_string()`."""
    return _mupdf.pdf_array_get_text_string(array, index)

def pdf_array_insert(array, obj, index):
    r""" Class-aware wrapper for `::pdf_array_insert()`."""
    return _mupdf.pdf_array_insert(array, obj, index)

def pdf_array_len(array):
    r""" Class-aware wrapper for `::pdf_array_len()`."""
    return _mupdf.pdf_array_len(array)

def pdf_array_push(array, obj):
    r""" Class-aware wrapper for `::pdf_array_push()`."""
    return _mupdf.pdf_array_push(array, obj)

def pdf_array_push_array(array, initial):
    r""" Class-aware wrapper for `::pdf_array_push_array()`."""
    return _mupdf.pdf_array_push_array(array, initial)

def pdf_array_push_bool(array, x):
    r""" Class-aware wrapper for `::pdf_array_push_bool()`."""
    return _mupdf.pdf_array_push_bool(array, x)

def pdf_array_push_dict(array, initial):
    r""" Class-aware wrapper for `::pdf_array_push_dict()`."""
    return _mupdf.pdf_array_push_dict(array, initial)

def pdf_array_push_int(array, x):
    r""" Class-aware wrapper for `::pdf_array_push_int()`."""
    return _mupdf.pdf_array_push_int(array, x)

def pdf_array_push_name(array, x):
    r""" Class-aware wrapper for `::pdf_array_push_name()`."""
    return _mupdf.pdf_array_push_name(array, x)

def pdf_array_push_real(array, x):
    r""" Class-aware wrapper for `::pdf_array_push_real()`."""
    return _mupdf.pdf_array_push_real(array, x)

def pdf_array_push_string(array, x, n):
    r""" Class-aware wrapper for `::pdf_array_push_string()`."""
    return _mupdf.pdf_array_push_string(array, x, n)

def pdf_array_push_text_string(array, x):
    r""" Class-aware wrapper for `::pdf_array_push_text_string()`."""
    return _mupdf.pdf_array_push_text_string(array, x)

def pdf_array_put(array, i, obj):
    r""" Class-aware wrapper for `::pdf_array_put()`."""
    return _mupdf.pdf_array_put(array, i, obj)

def pdf_array_put_array(array, i, initial):
    r""" Class-aware wrapper for `::pdf_array_put_array()`."""
    return _mupdf.pdf_array_put_array(array, i, initial)

def pdf_array_put_bool(array, i, x):
    r""" Class-aware wrapper for `::pdf_array_put_bool()`."""
    return _mupdf.pdf_array_put_bool(array, i, x)

def pdf_array_put_dict(array, i, initial):
    r""" Class-aware wrapper for `::pdf_array_put_dict()`."""
    return _mupdf.pdf_array_put_dict(array, i, initial)

def pdf_array_put_int(array, i, x):
    r""" Class-aware wrapper for `::pdf_array_put_int()`."""
    return _mupdf.pdf_array_put_int(array, i, x)

def pdf_array_put_name(array, i, x):
    r""" Class-aware wrapper for `::pdf_array_put_name()`."""
    return _mupdf.pdf_array_put_name(array, i, x)

def pdf_array_put_real(array, i, x):
    r""" Class-aware wrapper for `::pdf_array_put_real()`."""
    return _mupdf.pdf_array_put_real(array, i, x)

def pdf_array_put_string(array, i, x, n):
    r""" Class-aware wrapper for `::pdf_array_put_string()`."""
    return _mupdf.pdf_array_put_string(array, i, x, n)

def pdf_array_put_text_string(array, i, x):
    r""" Class-aware wrapper for `::pdf_array_put_text_string()`."""
    return _mupdf.pdf_array_put_text_string(array, i, x)

def pdf_authenticate_password(doc, pw):
    r""" Class-aware wrapper for `::pdf_authenticate_password()`."""
    return _mupdf.pdf_authenticate_password(doc, pw)

def pdf_bake_document(doc, bake_annots, bake_widgets):
    r""" Class-aware wrapper for `::pdf_bake_document()`."""
    return _mupdf.pdf_bake_document(doc, bake_annots, bake_widgets)

def pdf_begin_implicit_operation(doc):
    r""" Class-aware wrapper for `::pdf_begin_implicit_operation()`."""
    return _mupdf.pdf_begin_implicit_operation(doc)

def pdf_begin_operation(doc, operation):
    r""" Class-aware wrapper for `::pdf_begin_operation()`."""
    return _mupdf.pdf_begin_operation(doc, operation)

def pdf_bound_annot(annot):
    r""" Class-aware wrapper for `::pdf_bound_annot()`."""
    return _mupdf.pdf_bound_annot(annot)

def pdf_bound_page(page, box):
    r""" Class-aware wrapper for `::pdf_bound_page()`."""
    return _mupdf.pdf_bound_page(page, box)

def pdf_bound_widget(widget):
    r""" Class-aware wrapper for `::pdf_bound_widget()`."""
    return _mupdf.pdf_bound_widget(widget)

def pdf_button_field_on_state(field):
    r""" Class-aware wrapper for `::pdf_button_field_on_state()`."""
    return _mupdf.pdf_button_field_on_state(field)

def pdf_calculate_form(doc):
    r""" Class-aware wrapper for `::pdf_calculate_form()`."""
    return _mupdf.pdf_calculate_form(doc)

def pdf_can_be_saved_incrementally(doc):
    r""" Class-aware wrapper for `::pdf_can_be_saved_incrementally()`."""
    return _mupdf.pdf_can_be_saved_incrementally(doc)

def pdf_can_redo(doc):
    r""" Class-aware wrapper for `::pdf_can_redo()`."""
    return _mupdf.pdf_can_redo(doc)

def pdf_can_undo(doc):
    r""" Class-aware wrapper for `::pdf_can_undo()`."""
    return _mupdf.pdf_can_undo(doc)

def pdf_check_certificate(verifier, doc, signature):
    r""" Class-aware wrapper for `::pdf_check_certificate()`."""
    return _mupdf.pdf_check_certificate(verifier, doc, signature)

def pdf_check_digest(verifier, doc, signature):
    r""" Class-aware wrapper for `::pdf_check_digest()`."""
    return _mupdf.pdf_check_digest(verifier, doc, signature)

def pdf_check_widget_certificate(verifier, widget):
    r""" Class-aware wrapper for `::pdf_check_widget_certificate()`."""
    return _mupdf.pdf_check_widget_certificate(verifier, widget)

def pdf_check_widget_digest(verifier, widget):
    r""" Class-aware wrapper for `::pdf_check_widget_digest()`."""
    return _mupdf.pdf_check_widget_digest(verifier, widget)

def pdf_choice_field_option(field, exportval, i):
    r""" Class-aware wrapper for `::pdf_choice_field_option()`."""
    return _mupdf.pdf_choice_field_option(field, exportval, i)

def pdf_choice_field_option_count(field):
    r""" Class-aware wrapper for `::pdf_choice_field_option_count()`."""
    return _mupdf.pdf_choice_field_option_count(field)

def pdf_choice_widget_is_multiselect(tw):
    r""" Class-aware wrapper for `::pdf_choice_widget_is_multiselect()`."""
    return _mupdf.pdf_choice_widget_is_multiselect(tw)

def pdf_choice_widget_options(tw, exportval, opts):
    r""" Class-aware wrapper for `::pdf_choice_widget_options()`."""
    return _mupdf.pdf_choice_widget_options(tw, exportval, opts)

def pdf_choice_widget_options2(tw, exportval):
    r"""
    Class-aware wrapper for `::pdf_choice_widget_options2()`.   Swig-friendly wrapper for pdf_choice_widget_options(), returns the
    options directly in a vector.
    """
    return _mupdf.pdf_choice_widget_options2(tw, exportval)

def pdf_choice_widget_set_value(tw, n, opts):
    r""" Class-aware wrapper for `::pdf_choice_widget_set_value()`."""
    return _mupdf.pdf_choice_widget_set_value(tw, n, opts)

def pdf_choice_widget_value(tw, opts):
    r""" Class-aware wrapper for `::pdf_choice_widget_value()`."""
    return _mupdf.pdf_choice_widget_value(tw, opts)

def pdf_clean_file(infile, outfile, password, opts, retainlen):
    r""" Class-aware wrapper for `::pdf_clean_file()`."""
    return _mupdf.pdf_clean_file(infile, outfile, password, opts, retainlen)

def pdf_clean_font_name(fontname):
    r""" Class-aware wrapper for `::pdf_clean_font_name()`."""
    return _mupdf.pdf_clean_font_name(fontname)

def pdf_clean_obj(obj):
    r""" Class-aware wrapper for `::pdf_clean_obj()`."""
    return _mupdf.pdf_clean_obj(obj)

def pdf_clear_annot_border_dash(annot):
    r""" Class-aware wrapper for `::pdf_clear_annot_border_dash()`."""
    return _mupdf.pdf_clear_annot_border_dash(annot)

def pdf_clear_annot_ink_list(annot):
    r""" Class-aware wrapper for `::pdf_clear_annot_ink_list()`."""
    return _mupdf.pdf_clear_annot_ink_list(annot)

def pdf_clear_annot_quad_points(annot):
    r""" Class-aware wrapper for `::pdf_clear_annot_quad_points()`."""
    return _mupdf.pdf_clear_annot_quad_points(annot)

def pdf_clear_annot_vertices(annot):
    r""" Class-aware wrapper for `::pdf_clear_annot_vertices()`."""
    return _mupdf.pdf_clear_annot_vertices(annot)

def pdf_clear_signature(widget):
    r""" Class-aware wrapper for `::pdf_clear_signature()`."""
    return _mupdf.pdf_clear_signature(widget)

def pdf_clear_xref(doc):
    r""" Class-aware wrapper for `::pdf_clear_xref()`."""
    return _mupdf.pdf_clear_xref(doc)

def pdf_clear_xref_to_mark(doc):
    r""" Class-aware wrapper for `::pdf_clear_xref_to_mark()`."""
    return _mupdf.pdf_clear_xref_to_mark(doc)

def pdf_close_processor(proc):
    r""" Class-aware wrapper for `::pdf_close_processor()`."""
    return _mupdf.pdf_close_processor(proc)

def pdf_cmap_size(cmap):
    r""" Class-aware wrapper for `::pdf_cmap_size()`."""
    return _mupdf.pdf_cmap_size(cmap)

def pdf_cmap_wmode(cmap):
    r""" Class-aware wrapper for `::pdf_cmap_wmode()`."""
    return _mupdf.pdf_cmap_wmode(cmap)

def pdf_copy_array(array):
    r""" Class-aware wrapper for `::pdf_copy_array()`."""
    return _mupdf.pdf_copy_array(array)

def pdf_copy_dict(dict):
    r""" Class-aware wrapper for `::pdf_copy_dict()`."""
    return _mupdf.pdf_copy_dict(dict)

def pdf_count_layer_config_ui(doc):
    r""" Class-aware wrapper for `::pdf_count_layer_config_ui()`."""
    return _mupdf.pdf_count_layer_config_ui(doc)

def pdf_count_layer_configs(doc):
    r""" Class-aware wrapper for `::pdf_count_layer_configs()`."""
    return _mupdf.pdf_count_layer_configs(doc)

def pdf_count_layers(doc):
    r""" Class-aware wrapper for `::pdf_count_layers()`."""
    return _mupdf.pdf_count_layers(doc)

def pdf_count_objects(doc):
    r""" Class-aware wrapper for `::pdf_count_objects()`."""
    return _mupdf.pdf_count_objects(doc)

def pdf_count_pages(doc):
    r""" Class-aware wrapper for `::pdf_count_pages()`."""
    return _mupdf.pdf_count_pages(doc)

def pdf_count_pages_imp(doc, chapter):
    r""" Class-aware wrapper for `::pdf_count_pages_imp()`."""
    return _mupdf.pdf_count_pages_imp(doc, chapter)

def pdf_count_q_balance(doc, res, stm, prepend, append):
    r"""
    Class-aware wrapper for `::pdf_count_q_balance()`.

    This function has out-params. Python/C# wrappers look like:
    	`pdf_count_q_balance(::pdf_document *doc, ::pdf_obj *res, ::pdf_obj *stm)` => `(int prepend, int append)`
    """
    return _mupdf.pdf_count_q_balance(doc, res, stm, prepend, append)

def pdf_count_signatures(doc):
    r""" Class-aware wrapper for `::pdf_count_signatures()`."""
    return _mupdf.pdf_count_signatures(doc)

def pdf_count_unsaved_versions(doc):
    r""" Class-aware wrapper for `::pdf_count_unsaved_versions()`."""
    return _mupdf.pdf_count_unsaved_versions(doc)

def pdf_count_versions(doc):
    r""" Class-aware wrapper for `::pdf_count_versions()`."""
    return _mupdf.pdf_count_versions(doc)

def pdf_create_annot(page, type):
    r""" Class-aware wrapper for `::pdf_create_annot()`."""
    return _mupdf.pdf_create_annot(page, type)

def pdf_create_annot_raw(page, type):
    r""" Class-aware wrapper for `::pdf_create_annot_raw()`."""
    return _mupdf.pdf_create_annot_raw(page, type)

def pdf_create_document():
    r""" Class-aware wrapper for `::pdf_create_document()`."""
    return _mupdf.pdf_create_document()

def pdf_create_field_name(doc, prefix, buf, len):
    r""" Class-aware wrapper for `::pdf_create_field_name()`."""
    return _mupdf.pdf_create_field_name(doc, prefix, buf, len)

def pdf_create_link(page, bbox, uri):
    r""" Class-aware wrapper for `::pdf_create_link()`."""
    return _mupdf.pdf_create_link(page, bbox, uri)

def pdf_create_object(doc):
    r""" Class-aware wrapper for `::pdf_create_object()`."""
    return _mupdf.pdf_create_object(doc)

def pdf_create_signature_widget(page, name):
    r""" Class-aware wrapper for `::pdf_create_signature_widget()`."""
    return _mupdf.pdf_create_signature_widget(page, name)

def pdf_crypt_encrypt_metadata(crypt):
    r""" Class-aware wrapper for `::pdf_crypt_encrypt_metadata()`."""
    return _mupdf.pdf_crypt_encrypt_metadata(crypt)

def pdf_crypt_key(crypt):
    r""" Class-aware wrapper for `::pdf_crypt_key()`."""
    return _mupdf.pdf_crypt_key(crypt)

def pdf_crypt_length(crypt):
    r""" Class-aware wrapper for `::pdf_crypt_length()`."""
    return _mupdf.pdf_crypt_length(crypt)

def pdf_crypt_method(crypt):
    r""" Class-aware wrapper for `::pdf_crypt_method()`."""
    return _mupdf.pdf_crypt_method(crypt)

def pdf_crypt_obj(crypt, obj, num, gen):
    r""" Class-aware wrapper for `::pdf_crypt_obj()`."""
    return _mupdf.pdf_crypt_obj(crypt, obj, num, gen)

def pdf_crypt_owner_encryption(crypt):
    r""" Class-aware wrapper for `::pdf_crypt_owner_encryption()`."""
    return _mupdf.pdf_crypt_owner_encryption(crypt)

def pdf_crypt_owner_password(crypt):
    r""" Class-aware wrapper for `::pdf_crypt_owner_password()`."""
    return _mupdf.pdf_crypt_owner_password(crypt)

def pdf_crypt_permissions(crypt):
    r""" Class-aware wrapper for `::pdf_crypt_permissions()`."""
    return _mupdf.pdf_crypt_permissions(crypt)

def pdf_crypt_permissions_encryption(crypt):
    r""" Class-aware wrapper for `::pdf_crypt_permissions_encryption()`."""
    return _mupdf.pdf_crypt_permissions_encryption(crypt)

def pdf_crypt_revision(crypt):
    r""" Class-aware wrapper for `::pdf_crypt_revision()`."""
    return _mupdf.pdf_crypt_revision(crypt)

def pdf_crypt_stream_method(crypt):
    r""" Class-aware wrapper for `::pdf_crypt_stream_method()`."""
    return _mupdf.pdf_crypt_stream_method(crypt)

def pdf_crypt_string_method(crypt):
    r""" Class-aware wrapper for `::pdf_crypt_string_method()`."""
    return _mupdf.pdf_crypt_string_method(crypt)

def pdf_crypt_user_encryption(crypt):
    r""" Class-aware wrapper for `::pdf_crypt_user_encryption()`."""
    return _mupdf.pdf_crypt_user_encryption(crypt)

def pdf_crypt_user_password(crypt):
    r""" Class-aware wrapper for `::pdf_crypt_user_password()`."""
    return _mupdf.pdf_crypt_user_password(crypt)

def pdf_crypt_version(crypt):
    r""" Class-aware wrapper for `::pdf_crypt_version()`."""
    return _mupdf.pdf_crypt_version(crypt)

def pdf_cycle(here, prev, obj):
    r""" Class-aware wrapper for `::pdf_cycle()`."""
    return _mupdf.pdf_cycle(here, prev, obj)

def pdf_debug_doc_changes(doc):
    r""" Class-aware wrapper for `::pdf_debug_doc_changes()`."""
    return _mupdf.pdf_debug_doc_changes(doc)

def pdf_debug_obj(obj):
    r""" Class-aware wrapper for `::pdf_debug_obj()`."""
    return _mupdf.pdf_debug_obj(obj)

def pdf_debug_ref(obj):
    r""" Class-aware wrapper for `::pdf_debug_ref()`."""
    return _mupdf.pdf_debug_ref(obj)

def pdf_decode_cmap(cmap, s, e, cpt):
    r"""
    Class-aware wrapper for `::pdf_decode_cmap()`.

    This function has out-params. Python/C# wrappers look like:
    	`pdf_decode_cmap(::pdf_cmap *cmap, unsigned char *s, unsigned char *e)` => `(int, unsigned int cpt)`
    """
    return _mupdf.pdf_decode_cmap(cmap, s, e, cpt)

def pdf_deep_copy_obj(obj):
    r""" Class-aware wrapper for `::pdf_deep_copy_obj()`."""
    return _mupdf.pdf_deep_copy_obj(obj)

def pdf_delete_annot(page, annot):
    r""" Class-aware wrapper for `::pdf_delete_annot()`."""
    return _mupdf.pdf_delete_annot(page, annot)

def pdf_delete_link(page, link):
    r""" Class-aware wrapper for `::pdf_delete_link()`."""
    return _mupdf.pdf_delete_link(page, link)

def pdf_delete_object(doc, num):
    r""" Class-aware wrapper for `::pdf_delete_object()`."""
    return _mupdf.pdf_delete_object(doc, num)

def pdf_delete_page(doc, number):
    r""" Class-aware wrapper for `::pdf_delete_page()`."""
    return _mupdf.pdf_delete_page(doc, number)

def pdf_delete_page_labels(doc, index):
    r""" Class-aware wrapper for `::pdf_delete_page_labels()`."""
    return _mupdf.pdf_delete_page_labels(doc, index)

def pdf_delete_page_range(doc, start, end):
    r""" Class-aware wrapper for `::pdf_delete_page_range()`."""
    return _mupdf.pdf_delete_page_range(doc, start, end)

def pdf_deselect_layer_config_ui(doc, ui):
    r""" Class-aware wrapper for `::pdf_deselect_layer_config_ui()`."""
    return _mupdf.pdf_deselect_layer_config_ui(doc, ui)

def pdf_deserialise_journal(doc, stm):
    r""" Class-aware wrapper for `::pdf_deserialise_journal()`."""
    return _mupdf.pdf_deserialise_journal(doc, stm)

def pdf_dict_del(dict, key):
    r""" Class-aware wrapper for `::pdf_dict_del()`."""
    return _mupdf.pdf_dict_del(dict, key)

def pdf_dict_dels(dict, key):
    r""" Class-aware wrapper for `::pdf_dict_dels()`."""
    return _mupdf.pdf_dict_dels(dict, key)

def pdf_dict_get(dict, key):
    r""" Class-aware wrapper for `::pdf_dict_get()`."""
    return _mupdf.pdf_dict_get(dict, key)

def pdf_dict_get_bool(dict, key):
    r""" Class-aware wrapper for `::pdf_dict_get_bool()`."""
    return _mupdf.pdf_dict_get_bool(dict, key)

def pdf_dict_get_bool_default(dict, key, _def):
    r""" Class-aware wrapper for `::pdf_dict_get_bool_default()`."""
    return _mupdf.pdf_dict_get_bool_default(dict, key, _def)

def pdf_dict_get_date(dict, key):
    r""" Class-aware wrapper for `::pdf_dict_get_date()`."""
    return _mupdf.pdf_dict_get_date(dict, key)

def pdf_dict_get_inheritable(dict, key):
    r""" Class-aware wrapper for `::pdf_dict_get_inheritable()`."""
    return _mupdf.pdf_dict_get_inheritable(dict, key)

def pdf_dict_get_inheritable_bool(dict, key):
    r""" Class-aware wrapper for `::pdf_dict_get_inheritable_bool()`."""
    return _mupdf.pdf_dict_get_inheritable_bool(dict, key)

def pdf_dict_get_inheritable_date(dict, key):
    r""" Class-aware wrapper for `::pdf_dict_get_inheritable_date()`."""
    return _mupdf.pdf_dict_get_inheritable_date(dict, key)

def pdf_dict_get_inheritable_int(dict, key):
    r""" Class-aware wrapper for `::pdf_dict_get_inheritable_int()`."""
    return _mupdf.pdf_dict_get_inheritable_int(dict, key)

def pdf_dict_get_inheritable_int64(dict, key):
    r""" Class-aware wrapper for `::pdf_dict_get_inheritable_int64()`."""
    return _mupdf.pdf_dict_get_inheritable_int64(dict, key)

def pdf_dict_get_inheritable_matrix(dict, key):
    r""" Class-aware wrapper for `::pdf_dict_get_inheritable_matrix()`."""
    return _mupdf.pdf_dict_get_inheritable_matrix(dict, key)

def pdf_dict_get_inheritable_name(dict, key):
    r""" Class-aware wrapper for `::pdf_dict_get_inheritable_name()`."""
    return _mupdf.pdf_dict_get_inheritable_name(dict, key)

def pdf_dict_get_inheritable_real(dict, key):
    r""" Class-aware wrapper for `::pdf_dict_get_inheritable_real()`."""
    return _mupdf.pdf_dict_get_inheritable_real(dict, key)

def pdf_dict_get_inheritable_rect(dict, key):
    r""" Class-aware wrapper for `::pdf_dict_get_inheritable_rect()`."""
    return _mupdf.pdf_dict_get_inheritable_rect(dict, key)

def pdf_dict_get_inheritable_string(dict, key, sizep):
    r"""
    Class-aware wrapper for `::pdf_dict_get_inheritable_string()`.

    This function has out-params. Python/C# wrappers look like:
    	`pdf_dict_get_inheritable_string(::pdf_obj *dict, ::pdf_obj *key)` => `(const char *, size_t sizep)`
    """
    return _mupdf.pdf_dict_get_inheritable_string(dict, key, sizep)

def pdf_dict_get_inheritable_text_string(dict, key):
    r""" Class-aware wrapper for `::pdf_dict_get_inheritable_text_string()`."""
    return _mupdf.pdf_dict_get_inheritable_text_string(dict, key)

def pdf_dict_get_int(dict, key):
    r""" Class-aware wrapper for `::pdf_dict_get_int()`."""
    return _mupdf.pdf_dict_get_int(dict, key)

def pdf_dict_get_int64(dict, key):
    r""" Class-aware wrapper for `::pdf_dict_get_int64()`."""
    return _mupdf.pdf_dict_get_int64(dict, key)

def pdf_dict_get_int_default(dict, key, _def):
    r""" Class-aware wrapper for `::pdf_dict_get_int_default()`."""
    return _mupdf.pdf_dict_get_int_default(dict, key, _def)

def pdf_dict_get_key(dict, idx):
    r""" Class-aware wrapper for `::pdf_dict_get_key()`."""
    return _mupdf.pdf_dict_get_key(dict, idx)

def pdf_dict_get_matrix(dict, key):
    r""" Class-aware wrapper for `::pdf_dict_get_matrix()`."""
    return _mupdf.pdf_dict_get_matrix(dict, key)

def pdf_dict_get_name(dict, key):
    r""" Class-aware wrapper for `::pdf_dict_get_name()`."""
    return _mupdf.pdf_dict_get_name(dict, key)

def pdf_dict_get_real(dict, key):
    r""" Class-aware wrapper for `::pdf_dict_get_real()`."""
    return _mupdf.pdf_dict_get_real(dict, key)

def pdf_dict_get_real_default(dict, key, _def):
    r""" Class-aware wrapper for `::pdf_dict_get_real_default()`."""
    return _mupdf.pdf_dict_get_real_default(dict, key, _def)

def pdf_dict_get_rect(dict, key):
    r""" Class-aware wrapper for `::pdf_dict_get_rect()`."""
    return _mupdf.pdf_dict_get_rect(dict, key)

def pdf_dict_get_string(dict, key, sizep):
    r"""
    Class-aware wrapper for `::pdf_dict_get_string()`.

    This function has out-params. Python/C# wrappers look like:
    	`pdf_dict_get_string(::pdf_obj *dict, ::pdf_obj *key)` => `(const char *, size_t sizep)`
    """
    return _mupdf.pdf_dict_get_string(dict, key, sizep)

def pdf_dict_get_text_string(dict, key):
    r""" Class-aware wrapper for `::pdf_dict_get_text_string()`."""
    return _mupdf.pdf_dict_get_text_string(dict, key)

def pdf_dict_get_val(dict, idx):
    r""" Class-aware wrapper for `::pdf_dict_get_val()`."""
    return _mupdf.pdf_dict_get_val(dict, idx)

def pdf_dict_geta(dict, key, abbrev):
    r""" Class-aware wrapper for `::pdf_dict_geta()`."""
    return _mupdf.pdf_dict_geta(dict, key, abbrev)

def pdf_dict_getp(dict, path):
    r""" Class-aware wrapper for `::pdf_dict_getp()`."""
    return _mupdf.pdf_dict_getp(dict, path)

def pdf_dict_getp_inheritable(dict, path):
    r""" Class-aware wrapper for `::pdf_dict_getp_inheritable()`."""
    return _mupdf.pdf_dict_getp_inheritable(dict, path)

def pdf_dict_gets(dict, key):
    r""" Class-aware wrapper for `::pdf_dict_gets()`."""
    return _mupdf.pdf_dict_gets(dict, key)

def pdf_dict_gets_inheritable(dict, key):
    r""" Class-aware wrapper for `::pdf_dict_gets_inheritable()`."""
    return _mupdf.pdf_dict_gets_inheritable(dict, key)

def pdf_dict_getsa(dict, key, abbrev):
    r""" Class-aware wrapper for `::pdf_dict_getsa()`."""
    return _mupdf.pdf_dict_getsa(dict, key, abbrev)

def pdf_dict_len(dict):
    r""" Class-aware wrapper for `::pdf_dict_len()`."""
    return _mupdf.pdf_dict_len(dict)

def pdf_dict_put(dict, key, val):
    r""" Class-aware wrapper for `::pdf_dict_put()`."""
    return _mupdf.pdf_dict_put(dict, key, val)

def pdf_dict_put_array(dict, key, initial):
    r""" Class-aware wrapper for `::pdf_dict_put_array()`."""
    return _mupdf.pdf_dict_put_array(dict, key, initial)

def pdf_dict_put_bool(dict, key, x):
    r""" Class-aware wrapper for `::pdf_dict_put_bool()`."""
    return _mupdf.pdf_dict_put_bool(dict, key, x)

def pdf_dict_put_date(dict, key, time):
    r""" Class-aware wrapper for `::pdf_dict_put_date()`."""
    return _mupdf.pdf_dict_put_date(dict, key, time)

def pdf_dict_put_dict(dict, key, initial):
    r""" Class-aware wrapper for `::pdf_dict_put_dict()`."""
    return _mupdf.pdf_dict_put_dict(dict, key, initial)

def pdf_dict_put_int(dict, key, x):
    r""" Class-aware wrapper for `::pdf_dict_put_int()`."""
    return _mupdf.pdf_dict_put_int(dict, key, x)

def pdf_dict_put_matrix(dict, key, x):
    r""" Class-aware wrapper for `::pdf_dict_put_matrix()`."""
    return _mupdf.pdf_dict_put_matrix(dict, key, x)

def pdf_dict_put_name(dict, key, x):
    r""" Class-aware wrapper for `::pdf_dict_put_name()`."""
    return _mupdf.pdf_dict_put_name(dict, key, x)

def pdf_dict_put_real(dict, key, x):
    r""" Class-aware wrapper for `::pdf_dict_put_real()`."""
    return _mupdf.pdf_dict_put_real(dict, key, x)

def pdf_dict_put_rect(dict, key, x):
    r""" Class-aware wrapper for `::pdf_dict_put_rect()`."""
    return _mupdf.pdf_dict_put_rect(dict, key, x)

def pdf_dict_put_string(dict, key, x, n):
    r""" Class-aware wrapper for `::pdf_dict_put_string()`."""
    return _mupdf.pdf_dict_put_string(dict, key, x, n)

def pdf_dict_put_text_string(dict, key, x):
    r""" Class-aware wrapper for `::pdf_dict_put_text_string()`."""
    return _mupdf.pdf_dict_put_text_string(dict, key, x)

def pdf_dict_put_val_null(obj, idx):
    r""" Class-aware wrapper for `::pdf_dict_put_val_null()`."""
    return _mupdf.pdf_dict_put_val_null(obj, idx)

def pdf_dict_putp(dict, path, val):
    r""" Class-aware wrapper for `::pdf_dict_putp()`."""
    return _mupdf.pdf_dict_putp(dict, path, val)

def pdf_dict_puts(dict, key, val):
    r""" Class-aware wrapper for `::pdf_dict_puts()`."""
    return _mupdf.pdf_dict_puts(dict, key, val)

def pdf_dict_puts_dict(dict, key, initial):
    r""" Class-aware wrapper for `::pdf_dict_puts_dict()`."""
    return _mupdf.pdf_dict_puts_dict(dict, key, initial)

def pdf_dirty_annot(annot):
    r""" Class-aware wrapper for `::pdf_dirty_annot()`."""
    return _mupdf.pdf_dirty_annot(annot)

def pdf_dirty_obj(obj):
    r""" Class-aware wrapper for `::pdf_dirty_obj()`."""
    return _mupdf.pdf_dirty_obj(obj)

def pdf_disable_js(doc):
    r""" Class-aware wrapper for `::pdf_disable_js()`."""
    return _mupdf.pdf_disable_js(doc)

def pdf_discard_journal(journal):
    r""" Class-aware wrapper for `::pdf_discard_journal()`."""
    return _mupdf.pdf_discard_journal(journal)

def pdf_doc_was_linearized(doc):
    r""" Class-aware wrapper for `::pdf_doc_was_linearized()`."""
    return _mupdf.pdf_doc_was_linearized(doc)

def pdf_document_event_did_print(doc):
    r""" Class-aware wrapper for `::pdf_document_event_did_print()`."""
    return _mupdf.pdf_document_event_did_print(doc)

def pdf_document_event_did_save(doc):
    r""" Class-aware wrapper for `::pdf_document_event_did_save()`."""
    return _mupdf.pdf_document_event_did_save(doc)

def pdf_document_event_will_close(doc):
    r""" Class-aware wrapper for `::pdf_document_event_will_close()`."""
    return _mupdf.pdf_document_event_will_close(doc)

def pdf_document_event_will_print(doc):
    r""" Class-aware wrapper for `::pdf_document_event_will_print()`."""
    return _mupdf.pdf_document_event_will_print(doc)

def pdf_document_event_will_save(doc):
    r""" Class-aware wrapper for `::pdf_document_event_will_save()`."""
    return _mupdf.pdf_document_event_will_save(doc)

def pdf_document_from_fz_document(ptr):
    r""" Class-aware wrapper for `::pdf_document_from_fz_document()`."""
    return _mupdf.pdf_document_from_fz_document(ptr)

def pdf_document_language(doc):
    r""" Class-aware wrapper for `::pdf_document_language()`."""
    return _mupdf.pdf_document_language(doc)

def pdf_document_output_intent(doc):
    r""" Class-aware wrapper for `::pdf_document_output_intent()`."""
    return _mupdf.pdf_document_output_intent(doc)

def pdf_document_permissions(doc):
    r""" Class-aware wrapper for `::pdf_document_permissions()`."""
    return _mupdf.pdf_document_permissions(doc)

def pdf_edit_text_field_value(widget, value, change, selStart, selEnd, newvalue):
    r"""
    Class-aware wrapper for `::pdf_edit_text_field_value()`.

    This function has out-params. Python/C# wrappers look like:
    	`pdf_edit_text_field_value(::pdf_annot *widget, const char *value, const char *change)` => `(int, int selStart, int selEnd, char *newvalue)`
    """
    return _mupdf.pdf_edit_text_field_value(widget, value, change, selStart, selEnd, newvalue)

def pdf_empty_store(doc):
    r""" Class-aware wrapper for `::pdf_empty_store()`."""
    return _mupdf.pdf_empty_store(doc)

def pdf_enable_journal(doc):
    r""" Class-aware wrapper for `::pdf_enable_journal()`."""
    return _mupdf.pdf_enable_journal(doc)

def pdf_enable_js(doc):
    r""" Class-aware wrapper for `::pdf_enable_js()`."""
    return _mupdf.pdf_enable_js(doc)

def pdf_enable_layer(doc, layer, enabled):
    r""" Class-aware wrapper for `::pdf_enable_layer()`."""
    return _mupdf.pdf_enable_layer(doc, layer, enabled)

def pdf_encrypt_data(crypt, num, gen, fmt_str_out, arg, s, n):
    r""" Class-aware wrapper for `::pdf_encrypt_data()`."""
    return _mupdf.pdf_encrypt_data(crypt, num, gen, fmt_str_out, arg, s, n)

def pdf_encrypted_len(crypt, num, gen, len):
    r""" Class-aware wrapper for `::pdf_encrypted_len()`."""
    return _mupdf.pdf_encrypted_len(crypt, num, gen, len)

def pdf_end_hmtx(font):
    r""" Class-aware wrapper for `::pdf_end_hmtx()`."""
    return _mupdf.pdf_end_hmtx(font)

def pdf_end_operation(doc):
    r""" Class-aware wrapper for `::pdf_end_operation()`."""
    return _mupdf.pdf_end_operation(doc)

def pdf_end_vmtx(font):
    r""" Class-aware wrapper for `::pdf_end_vmtx()`."""
    return _mupdf.pdf_end_vmtx(font)

def pdf_ensure_solid_xref(doc, num):
    r""" Class-aware wrapper for `::pdf_ensure_solid_xref()`."""
    return _mupdf.pdf_ensure_solid_xref(doc, num)

def pdf_eval_function(func, _in, inlen, out, outlen):
    r"""
    Class-aware wrapper for `::pdf_eval_function()`.

    This function has out-params. Python/C# wrappers look like:
    	`pdf_eval_function(::pdf_function *func, const float *in, int inlen, int outlen)` => float out
    """
    return _mupdf.pdf_eval_function(func, _in, inlen, out, outlen)

def pdf_event_issue_alert(doc, evt):
    r""" Class-aware wrapper for `::pdf_event_issue_alert()`."""
    return _mupdf.pdf_event_issue_alert(doc, evt)

def pdf_event_issue_exec_menu_item(doc, item):
    r""" Class-aware wrapper for `::pdf_event_issue_exec_menu_item()`."""
    return _mupdf.pdf_event_issue_exec_menu_item(doc, item)

def pdf_event_issue_launch_url(doc, url, new_frame):
    r""" Class-aware wrapper for `::pdf_event_issue_launch_url()`."""
    return _mupdf.pdf_event_issue_launch_url(doc, url, new_frame)

def pdf_event_issue_mail_doc(doc, evt):
    r""" Class-aware wrapper for `::pdf_event_issue_mail_doc()`."""
    return _mupdf.pdf_event_issue_mail_doc(doc, evt)

def pdf_event_issue_print(doc):
    r""" Class-aware wrapper for `::pdf_event_issue_print()`."""
    return _mupdf.pdf_event_issue_print(doc)

def pdf_field_border_style(field):
    r""" Class-aware wrapper for `::pdf_field_border_style()`."""
    return _mupdf.pdf_field_border_style(field)

def pdf_field_display(field):
    r""" Class-aware wrapper for `::pdf_field_display()`."""
    return _mupdf.pdf_field_display(field)

def pdf_field_event_calculate(doc, field):
    r""" Class-aware wrapper for `::pdf_field_event_calculate()`."""
    return _mupdf.pdf_field_event_calculate(doc, field)

def pdf_field_event_format(doc, field):
    r""" Class-aware wrapper for `::pdf_field_event_format()`."""
    return _mupdf.pdf_field_event_format(doc, field)

def pdf_field_event_keystroke(doc, field, evt):
    r""" Class-aware wrapper for `::pdf_field_event_keystroke()`."""
    return _mupdf.pdf_field_event_keystroke(doc, field, evt)

def pdf_field_event_validate(doc, field, value, newvalue):
    r"""
    Class-aware wrapper for `::pdf_field_event_validate()`.

    This function has out-params. Python/C# wrappers look like:
    	`pdf_field_event_validate(::pdf_document *doc, ::pdf_obj *field, const char *value)` => `(int, char *newvalue)`
    """
    return _mupdf.pdf_field_event_validate(doc, field, value, newvalue)

def pdf_field_flags(field):
    r""" Class-aware wrapper for `::pdf_field_flags()`."""
    return _mupdf.pdf_field_flags(field)

def pdf_field_label(field):
    r""" Class-aware wrapper for `::pdf_field_label()`."""
    return _mupdf.pdf_field_label(field)

def pdf_field_reset(doc, field):
    r""" Class-aware wrapper for `::pdf_field_reset()`."""
    return _mupdf.pdf_field_reset(doc, field)

def pdf_field_set_border_style(field, text):
    r""" Class-aware wrapper for `::pdf_field_set_border_style()`."""
    return _mupdf.pdf_field_set_border_style(field, text)

def pdf_field_set_button_caption(field, text):
    r""" Class-aware wrapper for `::pdf_field_set_button_caption()`."""
    return _mupdf.pdf_field_set_button_caption(field, text)

def pdf_field_set_display(field, d):
    r""" Class-aware wrapper for `::pdf_field_set_display()`."""
    return _mupdf.pdf_field_set_display(field, d)

def pdf_field_set_fill_color(field, col):
    r""" Class-aware wrapper for `::pdf_field_set_fill_color()`."""
    return _mupdf.pdf_field_set_fill_color(field, col)

def pdf_field_set_text_color(field, col):
    r""" Class-aware wrapper for `::pdf_field_set_text_color()`."""
    return _mupdf.pdf_field_set_text_color(field, col)

def pdf_field_type(field):
    r""" Class-aware wrapper for `::pdf_field_type()`."""
    return _mupdf.pdf_field_type(field)

def pdf_field_type_string(field):
    r""" Class-aware wrapper for `::pdf_field_type_string()`."""
    return _mupdf.pdf_field_type_string(field)

def pdf_field_value(field):
    r""" Class-aware wrapper for `::pdf_field_value()`."""
    return _mupdf.pdf_field_value(field)

def pdf_filter_annot_contents(doc, annot, options):
    r""" Class-aware wrapper for `::pdf_filter_annot_contents()`."""
    return _mupdf.pdf_filter_annot_contents(doc, annot, options)

def pdf_filter_page_contents(doc, page, options):
    r""" Class-aware wrapper for `::pdf_filter_page_contents()`."""
    return _mupdf.pdf_filter_page_contents(doc, page, options)

def pdf_filter_xobject_instance(old_xobj, page_res, ctm, options, cycle_up):
    r""" Class-aware wrapper for `::pdf_filter_xobject_instance()`."""
    return _mupdf.pdf_filter_xobject_instance(old_xobj, page_res, ctm, options, cycle_up)

def pdf_find_font_resource(doc, type, encoding, item, key):
    r""" Class-aware wrapper for `::pdf_find_font_resource()`."""
    return _mupdf.pdf_find_font_resource(doc, type, encoding, item, key)

def pdf_find_item(drop, key):
    r""" Class-aware wrapper for `::pdf_find_item()`."""
    return _mupdf.pdf_find_item(drop, key)

def pdf_find_version_for_obj(doc, obj):
    r""" Class-aware wrapper for `::pdf_find_version_for_obj()`."""
    return _mupdf.pdf_find_version_for_obj(doc, obj)

def pdf_first_annot(page):
    r""" Class-aware wrapper for `::pdf_first_annot()`."""
    return _mupdf.pdf_first_annot(page)

def pdf_first_widget(page):
    r""" Class-aware wrapper for `::pdf_first_widget()`."""
    return _mupdf.pdf_first_widget(page)

def pdf_flatten_inheritable_page_items(page):
    r""" Class-aware wrapper for `::pdf_flatten_inheritable_page_items()`."""
    return _mupdf.pdf_flatten_inheritable_page_items(page)

def pdf_font_cid_to_gid(fontdesc, cid):
    r""" Class-aware wrapper for `::pdf_font_cid_to_gid()`."""
    return _mupdf.pdf_font_cid_to_gid(fontdesc, cid)

def pdf_font_writing_supported(font):
    r""" Class-aware wrapper for `::pdf_font_writing_supported()`."""
    return _mupdf.pdf_font_writing_supported(font)

def pdf_forget_xref(doc):
    r""" Class-aware wrapper for `::pdf_forget_xref()`."""
    return _mupdf.pdf_forget_xref(doc)

def pdf_format_date(time, s, n):
    r""" Class-aware wrapper for `::pdf_format_date()`."""
    return _mupdf.pdf_format_date(time, s, n)

def pdf_format_write_options(buffer, buffer_len, opts):
    r""" Class-aware wrapper for `::pdf_format_write_options()`."""
    return _mupdf.pdf_format_write_options(buffer, buffer_len, opts)

def pdf_function_size(func):
    r""" Class-aware wrapper for `::pdf_function_size()`."""
    return _mupdf.pdf_function_size(func)

def pdf_get_bound_document(obj):
    r""" Class-aware wrapper for `::pdf_get_bound_document()`."""
    return _mupdf.pdf_get_bound_document(obj)

def pdf_get_doc_event_callback_data(doc):
    r""" Class-aware wrapper for `::pdf_get_doc_event_callback_data()`."""
    return _mupdf.pdf_get_doc_event_callback_data(doc)

def pdf_get_embedded_file_params(fs, out):
    r""" Class-aware wrapper for `::pdf_get_embedded_file_params()`."""
    return _mupdf.pdf_get_embedded_file_params(fs, out)

def pdf_get_indirect_document(obj):
    r""" Class-aware wrapper for `::pdf_get_indirect_document()`."""
    return _mupdf.pdf_get_indirect_document(obj)

def pdf_get_widget_editing_state(widget):
    r""" Class-aware wrapper for `::pdf_get_widget_editing_state()`."""
    return _mupdf.pdf_get_widget_editing_state(widget)

def pdf_graft_mapped_object(map, obj):
    r""" Class-aware wrapper for `::pdf_graft_mapped_object()`."""
    return _mupdf.pdf_graft_mapped_object(map, obj)

def pdf_graft_mapped_page(map, page_to, src, page_from):
    r""" Class-aware wrapper for `::pdf_graft_mapped_page()`."""
    return _mupdf.pdf_graft_mapped_page(map, page_to, src, page_from)

def pdf_graft_object(dst, obj):
    r""" Class-aware wrapper for `::pdf_graft_object()`."""
    return _mupdf.pdf_graft_object(dst, obj)

def pdf_graft_page(dst, page_to, src, page_from):
    r""" Class-aware wrapper for `::pdf_graft_page()`."""
    return _mupdf.pdf_graft_page(dst, page_to, src, page_from)

def pdf_has_permission(doc, p):
    r""" Class-aware wrapper for `::pdf_has_permission()`."""
    return _mupdf.pdf_has_permission(doc, p)

def pdf_has_unsaved_changes(doc):
    r""" Class-aware wrapper for `::pdf_has_unsaved_changes()`."""
    return _mupdf.pdf_has_unsaved_changes(doc)

def pdf_has_unsaved_sigs(doc):
    r""" Class-aware wrapper for `::pdf_has_unsaved_sigs()`."""
    return _mupdf.pdf_has_unsaved_sigs(doc)

def pdf_insert_font_resource(doc, key, obj):
    r""" Class-aware wrapper for `::pdf_insert_font_resource()`."""
    return _mupdf.pdf_insert_font_resource(doc, key, obj)

def pdf_insert_page(doc, at, page):
    r""" Class-aware wrapper for `::pdf_insert_page()`."""
    return _mupdf.pdf_insert_page(doc, at, page)

def pdf_invalidate_xfa(doc):
    r""" Class-aware wrapper for `::pdf_invalidate_xfa()`."""
    return _mupdf.pdf_invalidate_xfa(doc)

def pdf_is_array(obj):
    r""" Class-aware wrapper for `::pdf_is_array()`."""
    return _mupdf.pdf_is_array(obj)

def pdf_is_bool(obj):
    r""" Class-aware wrapper for `::pdf_is_bool()`."""
    return _mupdf.pdf_is_bool(obj)

def pdf_is_dict(obj):
    r""" Class-aware wrapper for `::pdf_is_dict()`."""
    return _mupdf.pdf_is_dict(obj)

def pdf_is_embedded_file(fs):
    r""" Class-aware wrapper for `::pdf_is_embedded_file()`."""
    return _mupdf.pdf_is_embedded_file(fs)

def pdf_is_field_locked(locked, name):
    r""" Class-aware wrapper for `::pdf_is_field_locked()`."""
    return _mupdf.pdf_is_field_locked(locked, name)

def pdf_is_indirect(obj):
    r""" Class-aware wrapper for `::pdf_is_indirect()`."""
    return _mupdf.pdf_is_indirect(obj)

def pdf_is_int(obj):
    r""" Class-aware wrapper for `::pdf_is_int()`."""
    return _mupdf.pdf_is_int(obj)

def pdf_is_jpx_image(dict):
    r""" Class-aware wrapper for `::pdf_is_jpx_image()`."""
    return _mupdf.pdf_is_jpx_image(dict)

def pdf_is_local_object(doc, obj):
    r""" Class-aware wrapper for `::pdf_is_local_object()`."""
    return _mupdf.pdf_is_local_object(doc, obj)

def pdf_is_name(obj):
    r""" Class-aware wrapper for `::pdf_is_name()`."""
    return _mupdf.pdf_is_name(obj)

def pdf_is_null(obj):
    r""" Class-aware wrapper for `::pdf_is_null()`."""
    return _mupdf.pdf_is_null(obj)

def pdf_is_number(obj):
    r""" Class-aware wrapper for `::pdf_is_number()`."""
    return _mupdf.pdf_is_number(obj)

def pdf_is_ocg_hidden(doc, rdb, usage, ocg):
    r""" Class-aware wrapper for `::pdf_is_ocg_hidden()`."""
    return _mupdf.pdf_is_ocg_hidden(doc, rdb, usage, ocg)

def pdf_is_real(obj):
    r""" Class-aware wrapper for `::pdf_is_real()`."""
    return _mupdf.pdf_is_real(obj)

def pdf_is_stream(obj):
    r""" Class-aware wrapper for `::pdf_is_stream()`."""
    return _mupdf.pdf_is_stream(obj)

def pdf_is_string(obj):
    r""" Class-aware wrapper for `::pdf_is_string()`."""
    return _mupdf.pdf_is_string(obj)

def pdf_is_tint_colorspace(cs):
    r""" Class-aware wrapper for `::pdf_is_tint_colorspace()`."""
    return _mupdf.pdf_is_tint_colorspace(cs)

def pdf_js_event_init(js, target, value, willCommit):
    r""" Class-aware wrapper for `::pdf_js_event_init()`."""
    return _mupdf.pdf_js_event_init(js, target, value, willCommit)

def pdf_js_event_init_keystroke(js, target, evt):
    r""" Class-aware wrapper for `::pdf_js_event_init_keystroke()`."""
    return _mupdf.pdf_js_event_init_keystroke(js, target, evt)

def pdf_js_event_result(js):
    r""" Class-aware wrapper for `::pdf_js_event_result()`."""
    return _mupdf.pdf_js_event_result(js)

def pdf_js_event_result_keystroke(js, evt):
    r""" Class-aware wrapper for `::pdf_js_event_result_keystroke()`."""
    return _mupdf.pdf_js_event_result_keystroke(js, evt)

def pdf_js_event_result_validate(js, newvalue):
    r"""
    Class-aware wrapper for `::pdf_js_event_result_validate()`.

    This function has out-params. Python/C# wrappers look like:
    	`pdf_js_event_result_validate(::pdf_js *js)` => `(int, char *newvalue)`
    """
    return _mupdf.pdf_js_event_result_validate(js, newvalue)

def pdf_js_event_value(js):
    r""" Class-aware wrapper for `::pdf_js_event_value()`."""
    return _mupdf.pdf_js_event_value(js)

def pdf_js_execute(js, name, code, result):
    r"""
    Class-aware wrapper for `::pdf_js_execute()`.

    This function has out-params. Python/C# wrappers look like:
    	`pdf_js_execute(::pdf_js *js, const char *name, const char *code)` => char *result
    """
    return _mupdf.pdf_js_execute(js, name, code, result)

def pdf_js_set_console(doc, console, user):
    r""" Class-aware wrapper for `::pdf_js_set_console()`."""
    return _mupdf.pdf_js_set_console(doc, console, user)

def pdf_js_supported(doc):
    r""" Class-aware wrapper for `::pdf_js_supported()`."""
    return _mupdf.pdf_js_supported(doc)

def pdf_layer_config_info(doc, config_num, info):
    r""" Class-aware wrapper for `::pdf_layer_config_info()`."""
    return _mupdf.pdf_layer_config_info(doc, config_num, info)

def pdf_layer_config_ui_info(doc, ui, info):
    r""" Class-aware wrapper for `::pdf_layer_config_ui_info()`."""
    return _mupdf.pdf_layer_config_ui_info(doc, ui, info)

def pdf_layer_is_enabled(doc, layer):
    r""" Class-aware wrapper for `::pdf_layer_is_enabled()`."""
    return _mupdf.pdf_layer_is_enabled(doc, layer)

def pdf_layer_name(doc, layer):
    r""" Class-aware wrapper for `::pdf_layer_name()`."""
    return _mupdf.pdf_layer_name(doc, layer)

def pdf_layout_fit_text(font, lang, str, bounds):
    r""" Class-aware wrapper for `::pdf_layout_fit_text()`."""
    return _mupdf.pdf_layout_fit_text(font, lang, str, bounds)

def pdf_lex(f, lexbuf):
    r""" Class-aware wrapper for `::pdf_lex()`."""
    return _mupdf.pdf_lex(f, lexbuf)

def pdf_lex_no_string(f, lexbuf):
    r""" Class-aware wrapper for `::pdf_lex_no_string()`."""
    return _mupdf.pdf_lex_no_string(f, lexbuf)

def pdf_lexbuf_fin(lexbuf):
    r""" Class-aware wrapper for `::pdf_lexbuf_fin()`."""
    return _mupdf.pdf_lexbuf_fin(lexbuf)

def pdf_lexbuf_grow(lexbuf):
    r""" Class-aware wrapper for `::pdf_lexbuf_grow()`."""
    return _mupdf.pdf_lexbuf_grow(lexbuf)

def pdf_lexbuf_init(lexbuf, size):
    r""" Class-aware wrapper for `::pdf_lexbuf_init()`."""
    return _mupdf.pdf_lexbuf_init(lexbuf, size)

def pdf_line_ending_from_name(end):
    r""" Class-aware wrapper for `::pdf_line_ending_from_name()`."""
    return _mupdf.pdf_line_ending_from_name(end)

def pdf_line_ending_from_string(end):
    r""" Class-aware wrapper for `::pdf_line_ending_from_string()`."""
    return _mupdf.pdf_line_ending_from_string(end)

def pdf_load_builtin_cmap(name):
    r""" Class-aware wrapper for `::pdf_load_builtin_cmap()`."""
    return _mupdf.pdf_load_builtin_cmap(name)

def pdf_load_cmap(file):
    r""" Class-aware wrapper for `::pdf_load_cmap()`."""
    return _mupdf.pdf_load_cmap(file)

def pdf_load_colorspace(obj):
    r""" Class-aware wrapper for `::pdf_load_colorspace()`."""
    return _mupdf.pdf_load_colorspace(obj)

def pdf_load_compressed_inline_image(doc, dict, length, cstm, indexed, image):
    r""" Class-aware wrapper for `::pdf_load_compressed_inline_image()`."""
    return _mupdf.pdf_load_compressed_inline_image(doc, dict, length, cstm, indexed, image)

def pdf_load_compressed_stream(doc, num, worst_case):
    r""" Class-aware wrapper for `::pdf_load_compressed_stream()`."""
    return _mupdf.pdf_load_compressed_stream(doc, num, worst_case)

def pdf_load_default_colorspaces(doc, page):
    r""" Class-aware wrapper for `::pdf_load_default_colorspaces()`."""
    return _mupdf.pdf_load_default_colorspaces(doc, page)

def pdf_load_embedded_cmap(doc, ref):
    r""" Class-aware wrapper for `::pdf_load_embedded_cmap()`."""
    return _mupdf.pdf_load_embedded_cmap(doc, ref)

def pdf_load_embedded_file_contents(fs):
    r""" Class-aware wrapper for `::pdf_load_embedded_file_contents()`."""
    return _mupdf.pdf_load_embedded_file_contents(fs)

def pdf_load_encoding(estrings, encoding):
    r"""
    Class-aware wrapper for `::pdf_load_encoding()`.

    This function has out-params. Python/C# wrappers look like:
    	`pdf_load_encoding(const char *encoding)` => const char *estrings
    """
    return _mupdf.pdf_load_encoding(estrings, encoding)

def pdf_load_field_name(field):
    r""" Class-aware wrapper for `::pdf_load_field_name()`."""
    return _mupdf.pdf_load_field_name(field)

def pdf_load_field_name2(field):
    r""" Alternative to `pdf_load_field_name()` that returns a std::string."""
    return _mupdf.pdf_load_field_name2(field)

def pdf_load_function(ref, _in, out):
    r""" Class-aware wrapper for `::pdf_load_function()`."""
    return _mupdf.pdf_load_function(ref, _in, out)

def pdf_load_image(doc, obj):
    r""" Class-aware wrapper for `::pdf_load_image()`."""
    return _mupdf.pdf_load_image(doc, obj)

def pdf_load_inline_image(doc, rdb, dict, file):
    r""" Class-aware wrapper for `::pdf_load_inline_image()`."""
    return _mupdf.pdf_load_inline_image(doc, rdb, dict, file)

def pdf_load_journal(doc, filename):
    r""" Class-aware wrapper for `::pdf_load_journal()`."""
    return _mupdf.pdf_load_journal(doc, filename)

def pdf_load_link_annots(arg_0, arg_1, annots, pagenum, page_ctm):
    r""" Class-aware wrapper for `::pdf_load_link_annots()`."""
    return _mupdf.pdf_load_link_annots(arg_0, arg_1, annots, pagenum, page_ctm)

def pdf_load_links(page):
    r""" Class-aware wrapper for `::pdf_load_links()`."""
    return _mupdf.pdf_load_links(page)

def pdf_load_name_tree(doc, which):
    r""" Class-aware wrapper for `::pdf_load_name_tree()`."""
    return _mupdf.pdf_load_name_tree(doc, which)

def pdf_load_object(doc, num):
    r"""
    Class-aware wrapper for `::pdf_load_object()`.
    	Load a given object.

    	This can cause xref reorganisations (solidifications etc) due to
    	repairs, so all held pdf_xref_entries should be considered
    	invalid after this call (other than the returned one).
    """
    return _mupdf.pdf_load_object(doc, num)

def pdf_load_outline(doc):
    r""" Class-aware wrapper for `::pdf_load_outline()`."""
    return _mupdf.pdf_load_outline(doc)

def pdf_load_page(doc, number):
    r""" Class-aware wrapper for `::pdf_load_page()`."""
    return _mupdf.pdf_load_page(doc, number)

def pdf_load_page_imp(doc, chapter, number):
    r""" Class-aware wrapper for `::pdf_load_page_imp()`."""
    return _mupdf.pdf_load_page_imp(doc, chapter, number)

def pdf_load_page_tree(doc):
    r""" Class-aware wrapper for `::pdf_load_page_tree()`."""
    return _mupdf.pdf_load_page_tree(doc)

def pdf_load_pattern(doc, obj):
    r""" Class-aware wrapper for `::pdf_load_pattern()`."""
    return _mupdf.pdf_load_pattern(doc, obj)

def pdf_load_raw_stream(ref):
    r""" Class-aware wrapper for `::pdf_load_raw_stream()`."""
    return _mupdf.pdf_load_raw_stream(ref)

def pdf_load_raw_stream_number(doc, num):
    r""" Class-aware wrapper for `::pdf_load_raw_stream_number()`."""
    return _mupdf.pdf_load_raw_stream_number(doc, num)

def pdf_load_shading(doc, obj):
    r""" Class-aware wrapper for `::pdf_load_shading()`."""
    return _mupdf.pdf_load_shading(doc, obj)

def pdf_load_stream(ref):
    r""" Class-aware wrapper for `::pdf_load_stream()`."""
    return _mupdf.pdf_load_stream(ref)

def pdf_load_stream_number(doc, num):
    r""" Class-aware wrapper for `::pdf_load_stream_number()`."""
    return _mupdf.pdf_load_stream_number(doc, num)

def pdf_load_stream_or_string_as_utf8(src):
    r""" Class-aware wrapper for `::pdf_load_stream_or_string_as_utf8()`."""
    return _mupdf.pdf_load_stream_or_string_as_utf8(src)

def pdf_load_system_cmap(name):
    r""" Class-aware wrapper for `::pdf_load_system_cmap()`."""
    return _mupdf.pdf_load_system_cmap(name)

def pdf_load_to_unicode(doc, font, strings, collection, cmapstm):
    r"""
    Class-aware wrapper for `::pdf_load_to_unicode()`.

    This function has out-params. Python/C# wrappers look like:
    	`pdf_load_to_unicode(::pdf_document *doc, ::pdf_font_desc *font, char *collection, ::pdf_obj *cmapstm)` => const char *strings
    """
    return _mupdf.pdf_load_to_unicode(doc, font, strings, collection, cmapstm)

def pdf_load_type3_glyphs(doc, fontdesc):
    r""" Class-aware wrapper for `::pdf_load_type3_glyphs()`."""
    return _mupdf.pdf_load_type3_glyphs(doc, fontdesc)

def pdf_load_unencrypted_object(doc, num):
    r""" Class-aware wrapper for `::pdf_load_unencrypted_object()`."""
    return _mupdf.pdf_load_unencrypted_object(doc, num)

def pdf_lookup_cmap(cmap, cpt):
    r""" Class-aware wrapper for `::pdf_lookup_cmap()`."""
    return _mupdf.pdf_lookup_cmap(cmap, cpt)

def pdf_lookup_cmap_full(cmap, cpt, out):
    r"""
    Class-aware wrapper for `::pdf_lookup_cmap_full()`.

    This function has out-params. Python/C# wrappers look like:
    	`pdf_lookup_cmap_full(::pdf_cmap *cmap, unsigned int cpt)` => `(int, int out)`
    """
    return _mupdf.pdf_lookup_cmap_full(cmap, cpt, out)

def pdf_lookup_dest(doc, needle):
    r""" Class-aware wrapper for `::pdf_lookup_dest()`."""
    return _mupdf.pdf_lookup_dest(doc, needle)

def pdf_lookup_field(form, name):
    r""" Class-aware wrapper for `::pdf_lookup_field()`."""
    return _mupdf.pdf_lookup_field(form, name)

def pdf_lookup_metadata(doc, key, ptr, size):
    r""" Class-aware wrapper for `::pdf_lookup_metadata()`."""
    return _mupdf.pdf_lookup_metadata(doc, key, ptr, size)

def pdf_lookup_metadata2(doc, key):
    r"""
    Class-aware wrapper for `::pdf_lookup_metadata2()`.
    C++ alternative to `pdf_lookup_metadata()` that returns a `std::string`
    or calls `fz_throw()` if not found.
    """
    return _mupdf.pdf_lookup_metadata2(doc, key)

def pdf_lookup_name(doc, which, needle):
    r""" Class-aware wrapper for `::pdf_lookup_name()`."""
    return _mupdf.pdf_lookup_name(doc, which, needle)

def pdf_lookup_number(root, needle):
    r""" Class-aware wrapper for `::pdf_lookup_number()`."""
    return _mupdf.pdf_lookup_number(root, needle)

def pdf_lookup_page_loc(doc, needle, parentp, indexp):
    r"""
    Class-aware wrapper for `::pdf_lookup_page_loc()`.

    This function has out-params. Python/C# wrappers look like:
    	`pdf_lookup_page_loc(::pdf_document *doc, int needle, ::pdf_obj **parentp)` => `(pdf_obj *, int indexp)`
    """
    return _mupdf.pdf_lookup_page_loc(doc, needle, parentp, indexp)

def pdf_lookup_page_number(doc, pageobj):
    r""" Class-aware wrapper for `::pdf_lookup_page_number()`."""
    return _mupdf.pdf_lookup_page_number(doc, pageobj)

def pdf_lookup_page_obj(doc, needle):
    r""" Class-aware wrapper for `::pdf_lookup_page_obj()`."""
    return _mupdf.pdf_lookup_page_obj(doc, needle)

def pdf_lookup_substitute_font(mono, serif, bold, italic, len):
    r"""
    Class-aware wrapper for `::pdf_lookup_substitute_font()`.

    This function has out-params. Python/C# wrappers look like:
    	`pdf_lookup_substitute_font(int mono, int serif, int bold, int italic)` => `(const unsigned char *, int len)`
    """
    return _mupdf.pdf_lookup_substitute_font(mono, serif, bold, italic, len)

def pdf_map_one_to_many(cmap, one, many, len):
    r"""
    Class-aware wrapper for `::pdf_map_one_to_many()`.

    This function has out-params. Python/C# wrappers look like:
    	`pdf_map_one_to_many(::pdf_cmap *cmap, unsigned int one, size_t len)` => int many
    """
    return _mupdf.pdf_map_one_to_many(cmap, one, many, len)

def pdf_map_range_to_range(cmap, srclo, srchi, dstlo):
    r""" Class-aware wrapper for `::pdf_map_range_to_range()`."""
    return _mupdf.pdf_map_range_to_range(cmap, srclo, srchi, dstlo)

def pdf_mark_bits_reset(marks):
    r""" Class-aware wrapper for `::pdf_mark_bits_reset()`."""
    return _mupdf.pdf_mark_bits_reset(marks)

def pdf_mark_bits_set(marks, obj):
    r""" Class-aware wrapper for `::pdf_mark_bits_set()`."""
    return _mupdf.pdf_mark_bits_set(marks, obj)

def pdf_mark_list_check(list, obj):
    r""" Class-aware wrapper for `::pdf_mark_list_check()`."""
    return _mupdf.pdf_mark_list_check(list, obj)

def pdf_mark_list_free(list):
    r""" Class-aware wrapper for `::pdf_mark_list_free()`."""
    return _mupdf.pdf_mark_list_free(list)

def pdf_mark_list_init(list):
    r""" Class-aware wrapper for `::pdf_mark_list_init()`."""
    return _mupdf.pdf_mark_list_init(list)

def pdf_mark_list_pop(list):
    r""" Class-aware wrapper for `::pdf_mark_list_pop()`."""
    return _mupdf.pdf_mark_list_pop(list)

def pdf_mark_list_push(list, obj):
    r""" Class-aware wrapper for `::pdf_mark_list_push()`."""
    return _mupdf.pdf_mark_list_push(list, obj)

def pdf_mark_obj(obj):
    r""" Class-aware wrapper for `::pdf_mark_obj()`."""
    return _mupdf.pdf_mark_obj(obj)

def pdf_mark_xref(doc):
    r""" Class-aware wrapper for `::pdf_mark_xref()`."""
    return _mupdf.pdf_mark_xref(doc)

def pdf_metadata(doc):
    r""" Class-aware wrapper for `::pdf_metadata()`."""
    return _mupdf.pdf_metadata(doc)

def pdf_minimize_document(doc):
    r""" Class-aware wrapper for `::pdf_minimize_document()`."""
    return _mupdf.pdf_minimize_document(doc)

def pdf_name_eq(a, b):
    r""" Class-aware wrapper for `::pdf_name_eq()`."""
    return _mupdf.pdf_name_eq(a, b)

def pdf_name_from_line_ending(end):
    r""" Class-aware wrapper for `::pdf_name_from_line_ending()`."""
    return _mupdf.pdf_name_from_line_ending(end)

def pdf_needs_password(doc):
    r""" Class-aware wrapper for `::pdf_needs_password()`."""
    return _mupdf.pdf_needs_password(doc)

def pdf_new_action_from_link(doc, uri):
    r""" Class-aware wrapper for `::pdf_new_action_from_link()`."""
    return _mupdf.pdf_new_action_from_link(doc, uri)

def pdf_new_array(doc, initialcap):
    r""" Class-aware wrapper for `::pdf_new_array()`."""
    return _mupdf.pdf_new_array(doc, initialcap)

def pdf_new_buffer_processor(buffer, ahxencode, newlines):
    r""" Class-aware wrapper for `::pdf_new_buffer_processor()`."""
    return _mupdf.pdf_new_buffer_processor(buffer, ahxencode, newlines)

def pdf_new_cmap():
    r""" Class-aware wrapper for `::pdf_new_cmap()`."""
    return _mupdf.pdf_new_cmap()

def pdf_new_color_filter(doc, chain, struct_parents, transform, options, copts):
    r""" Class-aware wrapper for `::pdf_new_color_filter()`."""
    return _mupdf.pdf_new_color_filter(doc, chain, struct_parents, transform, options, copts)

def pdf_new_date(doc, time):
    r""" Class-aware wrapper for `::pdf_new_date()`."""
    return _mupdf.pdf_new_date(doc, time)

def pdf_new_dest_from_link(doc, uri, is_remote):
    r""" Class-aware wrapper for `::pdf_new_dest_from_link()`."""
    return _mupdf.pdf_new_dest_from_link(doc, uri, is_remote)

def pdf_new_dict(doc, initialcap):
    r""" Class-aware wrapper for `::pdf_new_dict()`."""
    return _mupdf.pdf_new_dict(doc, initialcap)

def pdf_new_display_list_from_annot(annot):
    r""" Class-aware wrapper for `::pdf_new_display_list_from_annot()`."""
    return _mupdf.pdf_new_display_list_from_annot(annot)

def pdf_new_graft_map(dst):
    r""" Class-aware wrapper for `::pdf_new_graft_map()`."""
    return _mupdf.pdf_new_graft_map(dst)

def pdf_new_identity_cmap(wmode, bytes):
    r""" Class-aware wrapper for `::pdf_new_identity_cmap()`."""
    return _mupdf.pdf_new_identity_cmap(wmode, bytes)

def pdf_new_indirect(doc, num, gen):
    r""" Class-aware wrapper for `::pdf_new_indirect()`."""
    return _mupdf.pdf_new_indirect(doc, num, gen)

def pdf_new_int(i):
    r""" Class-aware wrapper for `::pdf_new_int()`."""
    return _mupdf.pdf_new_int(i)

def pdf_new_link(page, rect, uri, obj):
    r""" Class-aware wrapper for `::pdf_new_link()`."""
    return _mupdf.pdf_new_link(page, rect, uri, obj)

def pdf_new_matrix(doc, mtx):
    r""" Class-aware wrapper for `::pdf_new_matrix()`."""
    return _mupdf.pdf_new_matrix(doc, mtx)

def pdf_new_name(str):
    r""" Class-aware wrapper for `::pdf_new_name()`."""
    return _mupdf.pdf_new_name(str)

def pdf_new_output_processor(out, ahxencode, newlines):
    r""" Class-aware wrapper for `::pdf_new_output_processor()`."""
    return _mupdf.pdf_new_output_processor(out, ahxencode, newlines)

def pdf_new_pdf_device(doc, topctm, resources, contents):
    r""" Class-aware wrapper for `::pdf_new_pdf_device()`."""
    return _mupdf.pdf_new_pdf_device(doc, topctm, resources, contents)

def pdf_new_pixmap_from_annot(annot, ctm, cs, seps, alpha):
    r""" Class-aware wrapper for `::pdf_new_pixmap_from_annot()`."""
    return _mupdf.pdf_new_pixmap_from_annot(annot, ctm, cs, seps, alpha)

def pdf_new_pixmap_from_page_contents_with_separations_and_usage(page, ctm, cs, seps, alpha, usage, box):
    r""" Class-aware wrapper for `::pdf_new_pixmap_from_page_contents_with_separations_and_usage()`."""
    return _mupdf.pdf_new_pixmap_from_page_contents_with_separations_and_usage(page, ctm, cs, seps, alpha, usage, box)

def pdf_new_pixmap_from_page_contents_with_usage(page, ctm, cs, alpha, usage, box):
    r""" Class-aware wrapper for `::pdf_new_pixmap_from_page_contents_with_usage()`."""
    return _mupdf.pdf_new_pixmap_from_page_contents_with_usage(page, ctm, cs, alpha, usage, box)

def pdf_new_pixmap_from_page_with_separations_and_usage(page, ctm, cs, seps, alpha, usage, box):
    r""" Class-aware wrapper for `::pdf_new_pixmap_from_page_with_separations_and_usage()`."""
    return _mupdf.pdf_new_pixmap_from_page_with_separations_and_usage(page, ctm, cs, seps, alpha, usage, box)

def pdf_new_pixmap_from_page_with_usage(page, ctm, cs, alpha, usage, box):
    r""" Class-aware wrapper for `::pdf_new_pixmap_from_page_with_usage()`."""
    return _mupdf.pdf_new_pixmap_from_page_with_usage(page, ctm, cs, alpha, usage, box)

def pdf_new_processor(size):
    r""" Class-aware wrapper for `::pdf_new_processor()`."""
    return _mupdf.pdf_new_processor(size)

def pdf_new_real(f):
    r""" Class-aware wrapper for `::pdf_new_real()`."""
    return _mupdf.pdf_new_real(f)

def pdf_new_rect(doc, rect):
    r""" Class-aware wrapper for `::pdf_new_rect()`."""
    return _mupdf.pdf_new_rect(doc, rect)

def pdf_new_run_processor(doc, dev, ctm, struct_parent, usage, gstate, default_cs, cookie):
    r""" Class-aware wrapper for `::pdf_new_run_processor()`."""
    return _mupdf.pdf_new_run_processor(doc, dev, ctm, struct_parent, usage, gstate, default_cs, cookie)

def pdf_new_sanitize_filter(doc, chain, struct_parents, transform, options, sopts):
    r""" Class-aware wrapper for `::pdf_new_sanitize_filter()`."""
    return _mupdf.pdf_new_sanitize_filter(doc, chain, struct_parents, transform, options, sopts)

def pdf_new_string(str, len):
    r""" Class-aware wrapper for `::pdf_new_string()`."""
    return _mupdf.pdf_new_string(str, len)

def pdf_new_text_string(s):
    r""" Class-aware wrapper for `::pdf_new_text_string()`."""
    return _mupdf.pdf_new_text_string(s)

def pdf_new_uri_from_explicit_dest(dest):
    r""" Class-aware wrapper for `::pdf_new_uri_from_explicit_dest()`."""
    return _mupdf.pdf_new_uri_from_explicit_dest(dest)

def pdf_new_uri_from_path_and_explicit_dest(path, dest):
    r""" Class-aware wrapper for `::pdf_new_uri_from_path_and_explicit_dest()`."""
    return _mupdf.pdf_new_uri_from_path_and_explicit_dest(path, dest)

def pdf_new_uri_from_path_and_named_dest(path, name):
    r""" Class-aware wrapper for `::pdf_new_uri_from_path_and_named_dest()`."""
    return _mupdf.pdf_new_uri_from_path_and_named_dest(path, name)

def pdf_new_utf8_from_pdf_stream_obj(src):
    r""" Class-aware wrapper for `::pdf_new_utf8_from_pdf_stream_obj()`."""
    return _mupdf.pdf_new_utf8_from_pdf_stream_obj(src)

def pdf_new_utf8_from_pdf_string(srcptr, srclen):
    r""" Class-aware wrapper for `::pdf_new_utf8_from_pdf_string()`."""
    return _mupdf.pdf_new_utf8_from_pdf_string(srcptr, srclen)

def pdf_new_utf8_from_pdf_string_obj(src):
    r""" Class-aware wrapper for `::pdf_new_utf8_from_pdf_string_obj()`."""
    return _mupdf.pdf_new_utf8_from_pdf_string_obj(src)

def pdf_new_xobject(doc, bbox, matrix, res, buffer):
    r""" Class-aware wrapper for `::pdf_new_xobject()`."""
    return _mupdf.pdf_new_xobject(doc, bbox, matrix, res, buffer)

def pdf_next_annot(annot):
    r""" Class-aware wrapper for `::pdf_next_annot()`."""
    return _mupdf.pdf_next_annot(annot)

def pdf_next_widget(previous):
    r""" Class-aware wrapper for `::pdf_next_widget()`."""
    return _mupdf.pdf_next_widget(previous)

def pdf_obj_is_dirty(obj):
    r""" Class-aware wrapper for `::pdf_obj_is_dirty()`."""
    return _mupdf.pdf_obj_is_dirty(obj)

def pdf_obj_is_incremental(obj):
    r""" Class-aware wrapper for `::pdf_obj_is_incremental()`."""
    return _mupdf.pdf_obj_is_incremental(obj)

def pdf_obj_marked(obj):
    r""" Class-aware wrapper for `::pdf_obj_marked()`."""
    return _mupdf.pdf_obj_marked(obj)

def pdf_obj_memo(obj, bit, memo):
    r"""
    Class-aware wrapper for `::pdf_obj_memo()`.

    This function has out-params. Python/C# wrappers look like:
    	`pdf_obj_memo(::pdf_obj *obj, int bit)` => `(int, int memo)`
    """
    return _mupdf.pdf_obj_memo(obj, bit, memo)

def pdf_obj_num_is_stream(doc, num):
    r""" Class-aware wrapper for `::pdf_obj_num_is_stream()`."""
    return _mupdf.pdf_obj_num_is_stream(doc, num)

def pdf_obj_parent_num(obj):
    r""" Class-aware wrapper for `::pdf_obj_parent_num()`."""
    return _mupdf.pdf_obj_parent_num(obj)

def pdf_obj_refs(ref):
    r""" Class-aware wrapper for `::pdf_obj_refs()`."""
    return _mupdf.pdf_obj_refs(ref)

def pdf_objcmp(a, b):
    r""" Class-aware wrapper for `::pdf_objcmp()`."""
    return _mupdf.pdf_objcmp(a, b)

def pdf_objcmp_deep(a, b):
    r""" Class-aware wrapper for `::pdf_objcmp_deep()`."""
    return _mupdf.pdf_objcmp_deep(a, b)

def pdf_objcmp_resolve(a, b):
    r""" Class-aware wrapper for `::pdf_objcmp_resolve()`."""
    return _mupdf.pdf_objcmp_resolve(a, b)

def pdf_open_contents_stream(doc, obj):
    r""" Class-aware wrapper for `::pdf_open_contents_stream()`."""
    return _mupdf.pdf_open_contents_stream(doc, obj)

def pdf_open_crypt(chain, crypt, num, gen):
    r""" Class-aware wrapper for `::pdf_open_crypt()`."""
    return _mupdf.pdf_open_crypt(chain, crypt, num, gen)

def pdf_open_crypt_with_filter(chain, crypt, name, num, gen):
    r""" Class-aware wrapper for `::pdf_open_crypt_with_filter()`."""
    return _mupdf.pdf_open_crypt_with_filter(chain, crypt, name, num, gen)

def pdf_open_document(filename):
    r""" Class-aware wrapper for `::pdf_open_document()`."""
    return _mupdf.pdf_open_document(filename)

def pdf_open_document_with_stream(file):
    r""" Class-aware wrapper for `::pdf_open_document_with_stream()`."""
    return _mupdf.pdf_open_document_with_stream(file)

def pdf_open_inline_stream(doc, stmobj, length, chain, params):
    r""" Class-aware wrapper for `::pdf_open_inline_stream()`."""
    return _mupdf.pdf_open_inline_stream(doc, stmobj, length, chain, params)

def pdf_open_raw_stream(ref):
    r""" Class-aware wrapper for `::pdf_open_raw_stream()`."""
    return _mupdf.pdf_open_raw_stream(ref)

def pdf_open_raw_stream_number(doc, num):
    r""" Class-aware wrapper for `::pdf_open_raw_stream_number()`."""
    return _mupdf.pdf_open_raw_stream_number(doc, num)

def pdf_open_stream(ref):
    r""" Class-aware wrapper for `::pdf_open_stream()`."""
    return _mupdf.pdf_open_stream(ref)

def pdf_open_stream_number(doc, num):
    r""" Class-aware wrapper for `::pdf_open_stream_number()`."""
    return _mupdf.pdf_open_stream_number(doc, num)

def pdf_open_stream_with_offset(doc, num, dict, stm_ofs):
    r""" Class-aware wrapper for `::pdf_open_stream_with_offset()`."""
    return _mupdf.pdf_open_stream_with_offset(doc, num, dict, stm_ofs)

def pdf_page_contents(page):
    r""" Class-aware wrapper for `::pdf_page_contents()`."""
    return _mupdf.pdf_page_contents(page)

def pdf_page_event_close(page):
    r""" Class-aware wrapper for `::pdf_page_event_close()`."""
    return _mupdf.pdf_page_event_close(page)

def pdf_page_event_open(page):
    r""" Class-aware wrapper for `::pdf_page_event_open()`."""
    return _mupdf.pdf_page_event_open(page)

def pdf_page_from_fz_page(ptr):
    r""" Class-aware wrapper for `::pdf_page_from_fz_page()`."""
    return _mupdf.pdf_page_from_fz_page(ptr)

def pdf_page_group(page):
    r""" Class-aware wrapper for `::pdf_page_group()`."""
    return _mupdf.pdf_page_group(page)

def pdf_page_has_transparency(page):
    r""" Class-aware wrapper for `::pdf_page_has_transparency()`."""
    return _mupdf.pdf_page_has_transparency(page)

def pdf_page_label(doc, page, buf, size):
    r""" Class-aware wrapper for `::pdf_page_label()`."""
    return _mupdf.pdf_page_label(doc, page, buf, size)

def pdf_page_label_imp(doc, chapter, page, buf, size):
    r""" Class-aware wrapper for `::pdf_page_label_imp()`."""
    return _mupdf.pdf_page_label_imp(doc, chapter, page, buf, size)

def pdf_page_obj_transform(pageobj, outbox, outctm):
    r""" Class-aware wrapper for `::pdf_page_obj_transform()`."""
    return _mupdf.pdf_page_obj_transform(pageobj, outbox, outctm)

def pdf_page_obj_transform_box(pageobj, outbox, out, box):
    r""" Class-aware wrapper for `::pdf_page_obj_transform_box()`."""
    return _mupdf.pdf_page_obj_transform_box(pageobj, outbox, out, box)

def pdf_page_presentation(page, transition, duration):
    r"""
    Class-aware wrapper for `::pdf_page_presentation()`.

    This function has out-params. Python/C# wrappers look like:
    	`pdf_page_presentation(::pdf_page *page, ::fz_transition *transition)` => `(fz_transition *, float duration)`
    """
    return _mupdf.pdf_page_presentation(page, transition, duration)

def pdf_page_resources(page):
    r""" Class-aware wrapper for `::pdf_page_resources()`."""
    return _mupdf.pdf_page_resources(page)

def pdf_page_separations(page):
    r""" Class-aware wrapper for `::pdf_page_separations()`."""
    return _mupdf.pdf_page_separations(page)

def pdf_page_transform(page, mediabox, ctm):
    r""" Class-aware wrapper for `::pdf_page_transform()`."""
    return _mupdf.pdf_page_transform(page, mediabox, ctm)

def pdf_page_transform_box(page, mediabox, ctm, box):
    r""" Class-aware wrapper for `::pdf_page_transform_box()`."""
    return _mupdf.pdf_page_transform_box(page, mediabox, ctm, box)

def pdf_page_write(doc, mediabox, presources, pcontents):
    r"""
    Class-aware wrapper for `::pdf_page_write()`.

    This function has out-params. Python/C# wrappers look like:
    	`pdf_page_write(::pdf_document *doc, ::fz_rect mediabox, ::pdf_obj **presources, ::fz_buffer **pcontents)` => `(fz_device *)`
    """
    return _mupdf.pdf_page_write(doc, mediabox, presources, pcontents)

def pdf_parse_array(doc, f, buf):
    r""" Class-aware wrapper for `::pdf_parse_array()`."""
    return _mupdf.pdf_parse_array(doc, f, buf)

def pdf_parse_date(s):
    r""" Class-aware wrapper for `::pdf_parse_date()`."""
    return _mupdf.pdf_parse_date(s)

def pdf_parse_default_appearance(da, font, size, n, color):
    r"""
    Class-aware wrapper for `::pdf_parse_default_appearance()`.

    This function has out-params. Python/C# wrappers look like:
    	`pdf_parse_default_appearance(const char *da, float color[4])` => `(const char *font, float size, int n)`
    """
    return _mupdf.pdf_parse_default_appearance(da, font, size, n, color)

def pdf_parse_dict(doc, f, buf):
    r""" Class-aware wrapper for `::pdf_parse_dict()`."""
    return _mupdf.pdf_parse_dict(doc, f, buf)

def pdf_parse_ind_obj(doc, f, num, gen, stm_ofs, try_repair):
    r"""
    Class-aware wrapper for `::pdf_parse_ind_obj()`.

    This function has out-params. Python/C# wrappers look like:
    	`pdf_parse_ind_obj(::pdf_document *doc, ::fz_stream *f)` => `(pdf_obj *, int num, int gen, int64_t stm_ofs, int try_repair)`
    """
    return _mupdf.pdf_parse_ind_obj(doc, f, num, gen, stm_ofs, try_repair)

def pdf_parse_journal_obj(doc, stm, onum, ostm, newobj):
    r"""
    Class-aware wrapper for `::pdf_parse_journal_obj()`.

    This function has out-params. Python/C# wrappers look like:
    	`pdf_parse_journal_obj(::pdf_document *doc, ::fz_stream *stm, ::fz_buffer **ostm)` => `(pdf_obj *, int onum, int newobj)`
    """
    return _mupdf.pdf_parse_journal_obj(doc, stm, onum, ostm, newobj)

def pdf_parse_stm_obj(doc, f, buf):
    r""" Class-aware wrapper for `::pdf_parse_stm_obj()`."""
    return _mupdf.pdf_parse_stm_obj(doc, f, buf)

def pdf_parse_write_options(opts, args):
    r""" Class-aware wrapper for `::pdf_parse_write_options()`."""
    return _mupdf.pdf_parse_write_options(opts, args)

def pdf_pin_document(obj):
    r""" Class-aware wrapper for `::pdf_pin_document()`."""
    return _mupdf.pdf_pin_document(obj)

def pdf_preview_signature_as_display_list(w, h, lang, signer, appearance_flags, graphic, reason, location):
    r""" Class-aware wrapper for `::pdf_preview_signature_as_display_list()`."""
    return _mupdf.pdf_preview_signature_as_display_list(w, h, lang, signer, appearance_flags, graphic, reason, location)

def pdf_preview_signature_as_pixmap(w, h, lang, signer, appearance_flags, graphic, reason, location):
    r""" Class-aware wrapper for `::pdf_preview_signature_as_pixmap()`."""
    return _mupdf.pdf_preview_signature_as_pixmap(w, h, lang, signer, appearance_flags, graphic, reason, location)

def pdf_print_crypt(out, crypt):
    r""" Class-aware wrapper for `::pdf_print_crypt()`."""
    return _mupdf.pdf_print_crypt(out, crypt)

def pdf_print_default_appearance(buf, nbuf, font, size, n, color):
    r""" Class-aware wrapper for `::pdf_print_default_appearance()`."""
    return _mupdf.pdf_print_default_appearance(buf, nbuf, font, size, n, color)

def pdf_print_encrypted_obj(out, obj, tight, ascii, crypt, num, gen, sep):
    r"""
    Class-aware wrapper for `::pdf_print_encrypted_obj()`.

    This function has out-params. Python/C# wrappers look like:
    	`pdf_print_encrypted_obj(::fz_output *out, ::pdf_obj *obj, int tight, int ascii, ::pdf_crypt *crypt, int num, int gen)` => int sep
    """
    return _mupdf.pdf_print_encrypted_obj(out, obj, tight, ascii, crypt, num, gen, sep)

def pdf_print_font(out, fontdesc):
    r""" Class-aware wrapper for `::pdf_print_font()`."""
    return _mupdf.pdf_print_font(out, fontdesc)

def pdf_print_obj(out, obj, tight, ascii):
    r""" Class-aware wrapper for `::pdf_print_obj()`."""
    return _mupdf.pdf_print_obj(out, obj, tight, ascii)

def pdf_process_annot(proc, annot, cookie):
    r""" Class-aware wrapper for `::pdf_process_annot()`."""
    return _mupdf.pdf_process_annot(proc, annot, cookie)

def pdf_process_contents(proc, doc, res, stm, cookie, out_res):
    r"""
    Class-aware wrapper for `::pdf_process_contents()`.

    This function has out-params. Python/C# wrappers look like:
    	`pdf_process_contents(::pdf_processor *proc, ::pdf_document *doc, ::pdf_obj *res, ::pdf_obj *stm, ::fz_cookie *cookie, ::pdf_obj **out_res)` =>
    """
    return _mupdf.pdf_process_contents(proc, doc, res, stm, cookie, out_res)

def pdf_process_glyph(proc, doc, resources, contents):
    r""" Class-aware wrapper for `::pdf_process_glyph()`."""
    return _mupdf.pdf_process_glyph(proc, doc, resources, contents)

def pdf_process_raw_contents(proc, doc, rdb, stmobj, cookie):
    r""" Class-aware wrapper for `::pdf_process_raw_contents()`."""
    return _mupdf.pdf_process_raw_contents(proc, doc, rdb, stmobj, cookie)

def pdf_processor_pop_resources(proc):
    r""" Class-aware wrapper for `::pdf_processor_pop_resources()`."""
    return _mupdf.pdf_processor_pop_resources(proc)

def pdf_processor_push_resources(proc, res):
    r""" Class-aware wrapper for `::pdf_processor_push_resources()`."""
    return _mupdf.pdf_processor_push_resources(proc, res)

def pdf_progressive_advance(doc, pagenum):
    r""" Class-aware wrapper for `::pdf_progressive_advance()`."""
    return _mupdf.pdf_progressive_advance(doc, pagenum)

def pdf_purge_local_font_resources(doc):
    r""" Class-aware wrapper for `::pdf_purge_local_font_resources()`."""
    return _mupdf.pdf_purge_local_font_resources(doc)

def pdf_purge_locals_from_store(doc):
    r""" Class-aware wrapper for `::pdf_purge_locals_from_store()`."""
    return _mupdf.pdf_purge_locals_from_store(doc)

def pdf_read_journal(doc, stm):
    r""" Class-aware wrapper for `::pdf_read_journal()`."""
    return _mupdf.pdf_read_journal(doc, stm)

def pdf_rearrange_pages(doc, count, pages):
    r""" Class-aware wrapper for `::pdf_rearrange_pages()`."""
    return _mupdf.pdf_rearrange_pages(doc, count, pages)

def pdf_rearrange_pages2(doc, pages):
    r""" Class-aware wrapper for `::pdf_rearrange_pages2()`.   Swig-friendly wrapper for pdf_rearrange_pages()."""
    return _mupdf.pdf_rearrange_pages2(doc, pages)

def pdf_recolor_shade(shade, reshade, opaque):
    r"""
    Class-aware wrapper for `::pdf_recolor_shade()`.
    	Recolor a shade.
    """
    return _mupdf.pdf_recolor_shade(shade, reshade, opaque)

def pdf_redact_page(doc, page, opts):
    r""" Class-aware wrapper for `::pdf_redact_page()`."""
    return _mupdf.pdf_redact_page(doc, page, opts)

def pdf_redo(doc):
    r""" Class-aware wrapper for `::pdf_redo()`."""
    return _mupdf.pdf_redo(doc)

def pdf_remove_item(drop, key):
    r""" Class-aware wrapper for `::pdf_remove_item()`."""
    return _mupdf.pdf_remove_item(drop, key)

def pdf_repair_obj(doc, buf, stmofsp, stmlenp, encrypt, id, page, tmpofs, root):
    r"""
    Class-aware wrapper for `::pdf_repair_obj()`.

    This function has out-params. Python/C# wrappers look like:
    	`pdf_repair_obj(::pdf_document *doc, ::pdf_lexbuf *buf, ::pdf_obj **encrypt, ::pdf_obj **id, ::pdf_obj **page, ::pdf_obj **root)` => `(int, int64_t stmofsp, int64_t stmlenp, int64_t tmpofs)`
    """
    return _mupdf.pdf_repair_obj(doc, buf, stmofsp, stmlenp, encrypt, id, page, tmpofs, root)

def pdf_repair_obj_stms(doc):
    r""" Class-aware wrapper for `::pdf_repair_obj_stms()`."""
    return _mupdf.pdf_repair_obj_stms(doc)

def pdf_repair_trailer(doc):
    r""" Class-aware wrapper for `::pdf_repair_trailer()`."""
    return _mupdf.pdf_repair_trailer(doc)

def pdf_repair_xref(doc):
    r""" Class-aware wrapper for `::pdf_repair_xref()`."""
    return _mupdf.pdf_repair_xref(doc)

def pdf_replace_xref(doc, entries, n):
    r""" Class-aware wrapper for `::pdf_replace_xref()`."""
    return _mupdf.pdf_replace_xref(doc, entries, n)

def pdf_reset_form(doc, fields, exclude):
    r""" Class-aware wrapper for `::pdf_reset_form()`."""
    return _mupdf.pdf_reset_form(doc, fields, exclude)

def pdf_reset_processor(proc):
    r""" Class-aware wrapper for `::pdf_reset_processor()`."""
    return _mupdf.pdf_reset_processor(proc)

def pdf_resolve_indirect(ref):
    r"""
    Class-aware wrapper for `::pdf_resolve_indirect()`.
    	Resolve an indirect object (or chain of objects).

    	This can cause xref reorganisations (solidifications etc) due to
    	repairs, so all held pdf_xref_entries should be considered
    	invalid after this call (other than the returned one).
    """
    return _mupdf.pdf_resolve_indirect(ref)

def pdf_resolve_indirect_chain(ref):
    r""" Class-aware wrapper for `::pdf_resolve_indirect_chain()`."""
    return _mupdf.pdf_resolve_indirect_chain(ref)

def pdf_resolve_link(doc, uri, xp, yp):
    r"""
    Class-aware wrapper for `::pdf_resolve_link()`.

    This function has out-params. Python/C# wrappers look like:
    	`pdf_resolve_link(::pdf_document *doc, const char *uri)` => `(int, float xp, float yp)`
    """
    return _mupdf.pdf_resolve_link(doc, uri, xp, yp)

def pdf_rewrite_images(doc, opts):
    r""" Class-aware wrapper for `::pdf_rewrite_images()`."""
    return _mupdf.pdf_rewrite_images(doc, opts)

def pdf_run_annot(annot, dev, ctm, cookie):
    r""" Class-aware wrapper for `::pdf_run_annot()`."""
    return _mupdf.pdf_run_annot(annot, dev, ctm, cookie)

def pdf_run_document_structure(doc, dev, cookie):
    r""" Class-aware wrapper for `::pdf_run_document_structure()`."""
    return _mupdf.pdf_run_document_structure(doc, dev, cookie)

def pdf_run_glyph(doc, resources, contents, dev, ctm, gstate, default_cs):
    r""" Class-aware wrapper for `::pdf_run_glyph()`."""
    return _mupdf.pdf_run_glyph(doc, resources, contents, dev, ctm, gstate, default_cs)

def pdf_run_page(page, dev, ctm, cookie):
    r""" Class-aware wrapper for `::pdf_run_page()`."""
    return _mupdf.pdf_run_page(page, dev, ctm, cookie)

def pdf_run_page_annots(page, dev, ctm, cookie):
    r""" Class-aware wrapper for `::pdf_run_page_annots()`."""
    return _mupdf.pdf_run_page_annots(page, dev, ctm, cookie)

def pdf_run_page_annots_with_usage(page, dev, ctm, usage, cookie):
    r""" Class-aware wrapper for `::pdf_run_page_annots_with_usage()`."""
    return _mupdf.pdf_run_page_annots_with_usage(page, dev, ctm, usage, cookie)

def pdf_run_page_contents(page, dev, ctm, cookie):
    r""" Class-aware wrapper for `::pdf_run_page_contents()`."""
    return _mupdf.pdf_run_page_contents(page, dev, ctm, cookie)

def pdf_run_page_contents_with_usage(page, dev, ctm, usage, cookie):
    r""" Class-aware wrapper for `::pdf_run_page_contents_with_usage()`."""
    return _mupdf.pdf_run_page_contents_with_usage(page, dev, ctm, usage, cookie)

def pdf_run_page_widgets(page, dev, ctm, cookie):
    r""" Class-aware wrapper for `::pdf_run_page_widgets()`."""
    return _mupdf.pdf_run_page_widgets(page, dev, ctm, cookie)

def pdf_run_page_widgets_with_usage(page, dev, ctm, usage, cookie):
    r""" Class-aware wrapper for `::pdf_run_page_widgets_with_usage()`."""
    return _mupdf.pdf_run_page_widgets_with_usage(page, dev, ctm, usage, cookie)

def pdf_run_page_with_usage(page, dev, ctm, usage, cookie):
    r""" Class-aware wrapper for `::pdf_run_page_with_usage()`."""
    return _mupdf.pdf_run_page_with_usage(page, dev, ctm, usage, cookie)

def pdf_sample_shade_function(shade, n, funcs, func, t0, t1):
    r"""
    Class-aware wrapper for `::pdf_sample_shade_function()`.

    This function has out-params. Python/C# wrappers look like:
    	`pdf_sample_shade_function(float shade[256][33], int n, int funcs, ::pdf_function **func, float t0, float t1)` =>
    """
    return _mupdf.pdf_sample_shade_function(shade, n, funcs, func, t0, t1)

def pdf_save_document(doc, filename, opts):
    r""" Class-aware wrapper for `::pdf_save_document()`."""
    return _mupdf.pdf_save_document(doc, filename, opts)

def pdf_save_journal(doc, filename):
    r""" Class-aware wrapper for `::pdf_save_journal()`."""
    return _mupdf.pdf_save_journal(doc, filename)

def pdf_save_snapshot(doc, filename):
    r""" Class-aware wrapper for `::pdf_save_snapshot()`."""
    return _mupdf.pdf_save_snapshot(doc, filename)

def pdf_select_layer_config(doc, config_num):
    r""" Class-aware wrapper for `::pdf_select_layer_config()`."""
    return _mupdf.pdf_select_layer_config(doc, config_num)

def pdf_select_layer_config_ui(doc, ui):
    r""" Class-aware wrapper for `::pdf_select_layer_config_ui()`."""
    return _mupdf.pdf_select_layer_config_ui(doc, ui)

def pdf_serialise_journal(doc, out):
    r""" Class-aware wrapper for `::pdf_serialise_journal()`."""
    return _mupdf.pdf_serialise_journal(doc, out)

def pdf_set_annot_active(annot, active):
    r""" Class-aware wrapper for `::pdf_set_annot_active()`."""
    return _mupdf.pdf_set_annot_active(annot, active)

def pdf_set_annot_appearance(annot, appearance, state, ctm, bbox, res, contents):
    r""" Class-aware wrapper for `::pdf_set_annot_appearance()`."""
    return _mupdf.pdf_set_annot_appearance(annot, appearance, state, ctm, bbox, res, contents)

def pdf_set_annot_appearance_from_display_list(annot, appearance, state, ctm, list):
    r""" Class-aware wrapper for `::pdf_set_annot_appearance_from_display_list()`."""
    return _mupdf.pdf_set_annot_appearance_from_display_list(annot, appearance, state, ctm, list)

def pdf_set_annot_author(annot, author):
    r""" Class-aware wrapper for `::pdf_set_annot_author()`."""
    return _mupdf.pdf_set_annot_author(annot, author)

def pdf_set_annot_border(annot, width):
    r""" Class-aware wrapper for `::pdf_set_annot_border()`."""
    return _mupdf.pdf_set_annot_border(annot, width)

def pdf_set_annot_border_effect(annot, effect):
    r""" Class-aware wrapper for `::pdf_set_annot_border_effect()`."""
    return _mupdf.pdf_set_annot_border_effect(annot, effect)

def pdf_set_annot_border_effect_intensity(annot, intensity):
    r""" Class-aware wrapper for `::pdf_set_annot_border_effect_intensity()`."""
    return _mupdf.pdf_set_annot_border_effect_intensity(annot, intensity)

def pdf_set_annot_border_style(annot, style):
    r""" Class-aware wrapper for `::pdf_set_annot_border_style()`."""
    return _mupdf.pdf_set_annot_border_style(annot, style)

def pdf_set_annot_border_width(annot, width):
    r""" Class-aware wrapper for `::pdf_set_annot_border_width()`."""
    return _mupdf.pdf_set_annot_border_width(annot, width)

def pdf_set_annot_color(annot, n, color):
    r""" Class-aware wrapper for `::pdf_set_annot_color()`."""
    return _mupdf.pdf_set_annot_color(annot, n, color)

def pdf_set_annot_contents(annot, text):
    r""" Class-aware wrapper for `::pdf_set_annot_contents()`."""
    return _mupdf.pdf_set_annot_contents(annot, text)

def pdf_set_annot_creation_date(annot, time):
    r""" Class-aware wrapper for `::pdf_set_annot_creation_date()`."""
    return _mupdf.pdf_set_annot_creation_date(annot, time)

def pdf_set_annot_default_appearance(annot, font, size, n, color):
    r""" Class-aware wrapper for `::pdf_set_annot_default_appearance()`."""
    return _mupdf.pdf_set_annot_default_appearance(annot, font, size, n, color)

def pdf_set_annot_field_value(doc, widget, text, ignore_trigger_events):
    r""" Class-aware wrapper for `::pdf_set_annot_field_value()`."""
    return _mupdf.pdf_set_annot_field_value(doc, widget, text, ignore_trigger_events)

def pdf_set_annot_filespec(annot, obj):
    r""" Class-aware wrapper for `::pdf_set_annot_filespec()`."""
    return _mupdf.pdf_set_annot_filespec(annot, obj)

def pdf_set_annot_flags(annot, flags):
    r""" Class-aware wrapper for `::pdf_set_annot_flags()`."""
    return _mupdf.pdf_set_annot_flags(annot, flags)

def pdf_set_annot_hidden_for_editing(annot, hidden):
    r""" Class-aware wrapper for `::pdf_set_annot_hidden_for_editing()`."""
    return _mupdf.pdf_set_annot_hidden_for_editing(annot, hidden)

def pdf_set_annot_hot(annot, hot):
    r""" Class-aware wrapper for `::pdf_set_annot_hot()`."""
    return _mupdf.pdf_set_annot_hot(annot, hot)

def pdf_set_annot_icon_name(annot, name):
    r""" Class-aware wrapper for `::pdf_set_annot_icon_name()`."""
    return _mupdf.pdf_set_annot_icon_name(annot, name)

def pdf_set_annot_ink_list(annot, n, count, v):
    r""" Class-aware wrapper for `::pdf_set_annot_ink_list()`."""
    return _mupdf.pdf_set_annot_ink_list(annot, n, count, v)

def pdf_set_annot_interior_color(annot, n, color):
    r""" Class-aware wrapper for `::pdf_set_annot_interior_color()`."""
    return _mupdf.pdf_set_annot_interior_color(annot, n, color)

def pdf_set_annot_is_open(annot, is_open):
    r""" Class-aware wrapper for `::pdf_set_annot_is_open()`."""
    return _mupdf.pdf_set_annot_is_open(annot, is_open)

def pdf_set_annot_language(annot, lang):
    r""" Class-aware wrapper for `::pdf_set_annot_language()`."""
    return _mupdf.pdf_set_annot_language(annot, lang)

def pdf_set_annot_line(annot, a, b):
    r""" Class-aware wrapper for `::pdf_set_annot_line()`."""
    return _mupdf.pdf_set_annot_line(annot, a, b)

def pdf_set_annot_line_end_style(annot, e):
    r""" Class-aware wrapper for `::pdf_set_annot_line_end_style()`."""
    return _mupdf.pdf_set_annot_line_end_style(annot, e)

def pdf_set_annot_line_ending_styles(annot, start_style, end_style):
    r""" Class-aware wrapper for `::pdf_set_annot_line_ending_styles()`."""
    return _mupdf.pdf_set_annot_line_ending_styles(annot, start_style, end_style)

def pdf_set_annot_line_start_style(annot, s):
    r""" Class-aware wrapper for `::pdf_set_annot_line_start_style()`."""
    return _mupdf.pdf_set_annot_line_start_style(annot, s)

def pdf_set_annot_modification_date(annot, time):
    r""" Class-aware wrapper for `::pdf_set_annot_modification_date()`."""
    return _mupdf.pdf_set_annot_modification_date(annot, time)

def pdf_set_annot_opacity(annot, opacity):
    r""" Class-aware wrapper for `::pdf_set_annot_opacity()`."""
    return _mupdf.pdf_set_annot_opacity(annot, opacity)

def pdf_set_annot_popup(annot, rect):
    r""" Class-aware wrapper for `::pdf_set_annot_popup()`."""
    return _mupdf.pdf_set_annot_popup(annot, rect)

def pdf_set_annot_quad_points(annot, n, qv):
    r""" Class-aware wrapper for `::pdf_set_annot_quad_points()`."""
    return _mupdf.pdf_set_annot_quad_points(annot, n, qv)

def pdf_set_annot_quadding(annot, q):
    r""" Class-aware wrapper for `::pdf_set_annot_quadding()`."""
    return _mupdf.pdf_set_annot_quadding(annot, q)

def pdf_set_annot_rect(annot, rect):
    r""" Class-aware wrapper for `::pdf_set_annot_rect()`."""
    return _mupdf.pdf_set_annot_rect(annot, rect)

def pdf_set_annot_resynthesised(annot):
    r""" Class-aware wrapper for `::pdf_set_annot_resynthesised()`."""
    return _mupdf.pdf_set_annot_resynthesised(annot)

def pdf_set_annot_stamp_image(annot, image):
    r""" Class-aware wrapper for `::pdf_set_annot_stamp_image()`."""
    return _mupdf.pdf_set_annot_stamp_image(annot, image)

def pdf_set_annot_vertex(annot, i, p):
    r""" Class-aware wrapper for `::pdf_set_annot_vertex()`."""
    return _mupdf.pdf_set_annot_vertex(annot, i, p)

def pdf_set_annot_vertices(annot, n, v):
    r""" Class-aware wrapper for `::pdf_set_annot_vertices()`."""
    return _mupdf.pdf_set_annot_vertices(annot, n, v)

def pdf_set_choice_field_value(widget, value):
    r""" Class-aware wrapper for `::pdf_set_choice_field_value()`."""
    return _mupdf.pdf_set_choice_field_value(widget, value)

def pdf_set_cmap_wmode(cmap, wmode):
    r""" Class-aware wrapper for `::pdf_set_cmap_wmode()`."""
    return _mupdf.pdf_set_cmap_wmode(cmap, wmode)

def pdf_set_default_hmtx(font, w):
    r""" Class-aware wrapper for `::pdf_set_default_hmtx()`."""
    return _mupdf.pdf_set_default_hmtx(font, w)

def pdf_set_default_vmtx(font, y, w):
    r""" Class-aware wrapper for `::pdf_set_default_vmtx()`."""
    return _mupdf.pdf_set_default_vmtx(font, y, w)

def pdf_set_doc_event_callback(doc, event_cb, free_event_data_cb, data):
    r""" Class-aware wrapper for `::pdf_set_doc_event_callback()`."""
    return _mupdf.pdf_set_doc_event_callback(doc, event_cb, free_event_data_cb, data)

def pdf_set_document_language(doc, lang):
    r""" Class-aware wrapper for `::pdf_set_document_language()`."""
    return _mupdf.pdf_set_document_language(doc, lang)

def pdf_set_field_value(doc, field, text, ignore_trigger_events):
    r""" Class-aware wrapper for `::pdf_set_field_value()`."""
    return _mupdf.pdf_set_field_value(doc, field, text, ignore_trigger_events)

def pdf_set_font_wmode(font, wmode):
    r""" Class-aware wrapper for `::pdf_set_font_wmode()`."""
    return _mupdf.pdf_set_font_wmode(font, wmode)

def pdf_set_int(obj, i):
    r""" Class-aware wrapper for `::pdf_set_int()`."""
    return _mupdf.pdf_set_int(obj, i)

def pdf_set_layer_config_as_default(doc):
    r""" Class-aware wrapper for `::pdf_set_layer_config_as_default()`."""
    return _mupdf.pdf_set_layer_config_as_default(doc)

def pdf_set_obj_memo(obj, bit, memo):
    r""" Class-aware wrapper for `::pdf_set_obj_memo()`."""
    return _mupdf.pdf_set_obj_memo(obj, bit, memo)

def pdf_set_obj_parent(obj, num):
    r""" Class-aware wrapper for `::pdf_set_obj_parent()`."""
    return _mupdf.pdf_set_obj_parent(obj, num)

def pdf_set_page_box(page, box, rect):
    r""" Class-aware wrapper for `::pdf_set_page_box()`."""
    return _mupdf.pdf_set_page_box(page, box, rect)

def pdf_set_page_labels(doc, index, style, prefix, start):
    r""" Class-aware wrapper for `::pdf_set_page_labels()`."""
    return _mupdf.pdf_set_page_labels(doc, index, style, prefix, start)

def pdf_set_populating_xref_trailer(doc, trailer):
    r""" Class-aware wrapper for `::pdf_set_populating_xref_trailer()`."""
    return _mupdf.pdf_set_populating_xref_trailer(doc, trailer)

def pdf_set_str_len(obj, newlen):
    r""" Class-aware wrapper for `::pdf_set_str_len()`."""
    return _mupdf.pdf_set_str_len(obj, newlen)

def pdf_set_text_field_value(widget, value):
    r""" Class-aware wrapper for `::pdf_set_text_field_value()`."""
    return _mupdf.pdf_set_text_field_value(widget, value)

def pdf_set_usecmap(cmap, usecmap):
    r""" Class-aware wrapper for `::pdf_set_usecmap()`."""
    return _mupdf.pdf_set_usecmap(cmap, usecmap)

def pdf_set_widget_editing_state(widget, editing):
    r""" Class-aware wrapper for `::pdf_set_widget_editing_state()`."""
    return _mupdf.pdf_set_widget_editing_state(widget, editing)

def pdf_sign_signature(widget, signer, appearance_flags, graphic, reason, location):
    r""" Class-aware wrapper for `::pdf_sign_signature()`."""
    return _mupdf.pdf_sign_signature(widget, signer, appearance_flags, graphic, reason, location)

def pdf_sign_signature_with_appearance(widget, signer, date, disp_list):
    r""" Class-aware wrapper for `::pdf_sign_signature_with_appearance()`."""
    return _mupdf.pdf_sign_signature_with_appearance(widget, signer, date, disp_list)

def pdf_signature_appearance_signed(rect, lang, img, left_text, right_text, include_logo):
    r""" Class-aware wrapper for `::pdf_signature_appearance_signed()`."""
    return _mupdf.pdf_signature_appearance_signed(rect, lang, img, left_text, right_text, include_logo)

def pdf_signature_appearance_unsigned(rect, lang):
    r""" Class-aware wrapper for `::pdf_signature_appearance_unsigned()`."""
    return _mupdf.pdf_signature_appearance_unsigned(rect, lang)

def pdf_signature_byte_range(doc, signature, byte_range):
    r""" Class-aware wrapper for `::pdf_signature_byte_range()`."""
    return _mupdf.pdf_signature_byte_range(doc, signature, byte_range)

def pdf_signature_contents(doc, signature, contents):
    r"""
    Class-aware wrapper for `::pdf_signature_contents()`.

    This function has out-params. Python/C# wrappers look like:
    	`pdf_signature_contents(::pdf_document *doc, ::pdf_obj *signature)` => `(size_t, char *contents)`
    """
    return _mupdf.pdf_signature_contents(doc, signature, contents)

def pdf_signature_drop_distinguished_name(name):
    r""" Class-aware wrapper for `::pdf_signature_drop_distinguished_name()`."""
    return _mupdf.pdf_signature_drop_distinguished_name(name)

def pdf_signature_error_description(err):
    r""" Class-aware wrapper for `::pdf_signature_error_description()`."""
    return _mupdf.pdf_signature_error_description(err)

def pdf_signature_format_distinguished_name(name):
    r""" Class-aware wrapper for `::pdf_signature_format_distinguished_name()`."""
    return _mupdf.pdf_signature_format_distinguished_name(name)

def pdf_signature_hash_bytes(doc, signature):
    r""" Class-aware wrapper for `::pdf_signature_hash_bytes()`."""
    return _mupdf.pdf_signature_hash_bytes(doc, signature)

def pdf_signature_incremental_change_since_signing(doc, signature):
    r""" Class-aware wrapper for `::pdf_signature_incremental_change_since_signing()`."""
    return _mupdf.pdf_signature_incremental_change_since_signing(doc, signature)

def pdf_signature_info(name, dn, reason, location, date, include_labels):
    r""" Class-aware wrapper for `::pdf_signature_info()`."""
    return _mupdf.pdf_signature_info(name, dn, reason, location, date, include_labels)

def pdf_signature_is_signed(doc, field):
    r""" Class-aware wrapper for `::pdf_signature_is_signed()`."""
    return _mupdf.pdf_signature_is_signed(doc, field)

def pdf_signature_set_value(doc, field, signer, stime):
    r""" Class-aware wrapper for `::pdf_signature_set_value()`."""
    return _mupdf.pdf_signature_set_value(doc, field, signer, stime)

def pdf_sort_cmap(cmap):
    r""" Class-aware wrapper for `::pdf_sort_cmap()`."""
    return _mupdf.pdf_sort_cmap(cmap)

def pdf_sort_dict(dict):
    r""" Class-aware wrapper for `::pdf_sort_dict()`."""
    return _mupdf.pdf_sort_dict(dict)

def pdf_specifics(doc):
    r""" Class-aware wrapper for `::pdf_specifics()`."""
    return _mupdf.pdf_specifics(doc)

def pdf_sprint_obj(buf, cap, len, obj, tight, ascii):
    r"""
    Class-aware wrapper for `::pdf_sprint_obj()`.

    This function has out-params. Python/C# wrappers look like:
    	`pdf_sprint_obj(char *buf, size_t cap, ::pdf_obj *obj, int tight, int ascii)` => `(char *, size_t len)`
    """
    return _mupdf.pdf_sprint_obj(buf, cap, len, obj, tight, ascii)

def pdf_store_item(key, val, itemsize):
    r""" Class-aware wrapper for `::pdf_store_item()`."""
    return _mupdf.pdf_store_item(key, val, itemsize)

def pdf_string_from_annot_type(type):
    r""" Class-aware wrapper for `::pdf_string_from_annot_type()`."""
    return _mupdf.pdf_string_from_annot_type(type)

def pdf_string_from_line_ending(end):
    r""" Class-aware wrapper for `::pdf_string_from_line_ending()`."""
    return _mupdf.pdf_string_from_line_ending(end)

def pdf_structure_type(role_map, tag):
    r""" Class-aware wrapper for `::pdf_structure_type()`."""
    return _mupdf.pdf_structure_type(role_map, tag)

def pdf_subset_fonts(doc, pages_len, pages):
    r""" Class-aware wrapper for `::pdf_subset_fonts()`."""
    return _mupdf.pdf_subset_fonts(doc, pages_len, pages)

def pdf_subset_fonts2(doc, pages):
    r""" Class-aware wrapper for `::pdf_subset_fonts2()`.   Swig-friendly wrapper for pdf_subset_fonts()."""
    return _mupdf.pdf_subset_fonts2(doc, pages)

def pdf_text_widget_format(tw):
    r""" Class-aware wrapper for `::pdf_text_widget_format()`."""
    return _mupdf.pdf_text_widget_format(tw)

def pdf_text_widget_max_len(tw):
    r""" Class-aware wrapper for `::pdf_text_widget_max_len()`."""
    return _mupdf.pdf_text_widget_max_len(tw)

def pdf_to_bool(obj):
    r""" Class-aware wrapper for `::pdf_to_bool()`."""
    return _mupdf.pdf_to_bool(obj)

def pdf_to_bool_default(obj, _def):
    r""" Class-aware wrapper for `::pdf_to_bool_default()`."""
    return _mupdf.pdf_to_bool_default(obj, _def)

def pdf_to_date(time):
    r""" Class-aware wrapper for `::pdf_to_date()`."""
    return _mupdf.pdf_to_date(time)

def pdf_to_gen(obj):
    r""" Class-aware wrapper for `::pdf_to_gen()`."""
    return _mupdf.pdf_to_gen(obj)

def pdf_to_int(obj):
    r""" Class-aware wrapper for `::pdf_to_int()`."""
    return _mupdf.pdf_to_int(obj)

def pdf_to_int64(obj):
    r""" Class-aware wrapper for `::pdf_to_int64()`."""
    return _mupdf.pdf_to_int64(obj)

def pdf_to_int_default(obj, _def):
    r""" Class-aware wrapper for `::pdf_to_int_default()`."""
    return _mupdf.pdf_to_int_default(obj, _def)

def pdf_to_matrix(array):
    r""" Class-aware wrapper for `::pdf_to_matrix()`."""
    return _mupdf.pdf_to_matrix(array)

def pdf_to_name(obj):
    r""" Class-aware wrapper for `::pdf_to_name()`."""
    return _mupdf.pdf_to_name(obj)

def pdf_to_num(obj):
    r""" Class-aware wrapper for `::pdf_to_num()`."""
    return _mupdf.pdf_to_num(obj)

def pdf_to_quad(array, offset):
    r""" Class-aware wrapper for `::pdf_to_quad()`."""
    return _mupdf.pdf_to_quad(array, offset)

def pdf_to_real(obj):
    r""" Class-aware wrapper for `::pdf_to_real()`."""
    return _mupdf.pdf_to_real(obj)

def pdf_to_real_default(obj, _def):
    r""" Class-aware wrapper for `::pdf_to_real_default()`."""
    return _mupdf.pdf_to_real_default(obj, _def)

def pdf_to_rect(array):
    r""" Class-aware wrapper for `::pdf_to_rect()`."""
    return _mupdf.pdf_to_rect(array)

def pdf_to_str_buf(obj):
    r""" Class-aware wrapper for `::pdf_to_str_buf()`."""
    return _mupdf.pdf_to_str_buf(obj)

def pdf_to_str_len(obj):
    r""" Class-aware wrapper for `::pdf_to_str_len()`."""
    return _mupdf.pdf_to_str_len(obj)

def pdf_to_string(obj, sizep):
    r"""
    Class-aware wrapper for `::pdf_to_string()`.

    This function has out-params. Python/C# wrappers look like:
    	`pdf_to_string(::pdf_obj *obj)` => `(const char *, size_t sizep)`
    """
    return _mupdf.pdf_to_string(obj, sizep)

def pdf_to_text_string(obj):
    r""" Class-aware wrapper for `::pdf_to_text_string()`."""
    return _mupdf.pdf_to_text_string(obj)

def pdf_toggle_layer_config_ui(doc, ui):
    r""" Class-aware wrapper for `::pdf_toggle_layer_config_ui()`."""
    return _mupdf.pdf_toggle_layer_config_ui(doc, ui)

def pdf_toggle_widget(widget):
    r""" Class-aware wrapper for `::pdf_toggle_widget()`."""
    return _mupdf.pdf_toggle_widget(widget)

def pdf_tos_get_text(tos):
    r""" Class-aware wrapper for `::pdf_tos_get_text()`."""
    return _mupdf.pdf_tos_get_text(tos)

def pdf_tos_make_trm(tos, text, fontdesc, cid, trm):
    r""" Class-aware wrapper for `::pdf_tos_make_trm()`."""
    return _mupdf.pdf_tos_make_trm(tos, text, fontdesc, cid, trm)

def pdf_tos_move_after_char(tos):
    r""" Class-aware wrapper for `::pdf_tos_move_after_char()`."""
    return _mupdf.pdf_tos_move_after_char(tos)

def pdf_tos_newline(tos, leading):
    r""" Class-aware wrapper for `::pdf_tos_newline()`."""
    return _mupdf.pdf_tos_newline(tos, leading)

def pdf_tos_reset(tos, render):
    r""" Class-aware wrapper for `::pdf_tos_reset()`."""
    return _mupdf.pdf_tos_reset(tos, render)

def pdf_tos_restore(tos, save):
    r""" Class-aware wrapper for `::pdf_tos_restore()`."""
    return _mupdf.pdf_tos_restore(tos, save)

def pdf_tos_save(tos, save):
    r""" Class-aware wrapper for `::pdf_tos_save()`."""
    return _mupdf.pdf_tos_save(tos, save)

def pdf_tos_set_matrix(tos, a, b, c, d, e, f):
    r""" Class-aware wrapper for `::pdf_tos_set_matrix()`."""
    return _mupdf.pdf_tos_set_matrix(tos, a, b, c, d, e, f)

def pdf_tos_translate(tos, tx, ty):
    r""" Class-aware wrapper for `::pdf_tos_translate()`."""
    return _mupdf.pdf_tos_translate(tos, tx, ty)

def pdf_trailer(doc):
    r""" Class-aware wrapper for `::pdf_trailer()`."""
    return _mupdf.pdf_trailer(doc)

def pdf_undo(doc):
    r""" Class-aware wrapper for `::pdf_undo()`."""
    return _mupdf.pdf_undo(doc)

def pdf_undoredo_state(doc, steps):
    r"""
    Class-aware wrapper for `::pdf_undoredo_state()`.

    This function has out-params. Python/C# wrappers look like:
    	`pdf_undoredo_state(::pdf_document *doc)` => `(int, int steps)`
    """
    return _mupdf.pdf_undoredo_state(doc, steps)

def pdf_undoredo_step(doc, step):
    r""" Class-aware wrapper for `::pdf_undoredo_step()`."""
    return _mupdf.pdf_undoredo_step(doc, step)

def pdf_unmark_obj(obj):
    r""" Class-aware wrapper for `::pdf_unmark_obj()`."""
    return _mupdf.pdf_unmark_obj(obj)

def pdf_update_annot(annot):
    r""" Class-aware wrapper for `::pdf_update_annot()`."""
    return _mupdf.pdf_update_annot(annot)

def pdf_update_default_colorspaces(old_cs, res):
    r""" Class-aware wrapper for `::pdf_update_default_colorspaces()`."""
    return _mupdf.pdf_update_default_colorspaces(old_cs, res)

def pdf_update_object(doc, num, obj):
    r""" Class-aware wrapper for `::pdf_update_object()`."""
    return _mupdf.pdf_update_object(doc, num, obj)

def pdf_update_page(page):
    r""" Class-aware wrapper for `::pdf_update_page()`."""
    return _mupdf.pdf_update_page(page)

def pdf_update_stream(doc, ref, buf, compressed):
    r""" Class-aware wrapper for `::pdf_update_stream()`."""
    return _mupdf.pdf_update_stream(doc, ref, buf, compressed)

def pdf_update_widget(widget):
    r""" Class-aware wrapper for `::pdf_update_widget()`."""
    return _mupdf.pdf_update_widget(widget)

def pdf_update_xobject(doc, xobj, bbox, mat, res, buffer):
    r""" Class-aware wrapper for `::pdf_update_xobject()`."""
    return _mupdf.pdf_update_xobject(doc, xobj, bbox, mat, res, buffer)

def pdf_validate_change_history(doc):
    r""" Class-aware wrapper for `::pdf_validate_change_history()`."""
    return _mupdf.pdf_validate_change_history(doc)

def pdf_validate_changes(doc, version):
    r""" Class-aware wrapper for `::pdf_validate_changes()`."""
    return _mupdf.pdf_validate_changes(doc, version)

def pdf_validate_signature(widget):
    r""" Class-aware wrapper for `::pdf_validate_signature()`."""
    return _mupdf.pdf_validate_signature(widget)

def pdf_verify_embedded_file_checksum(fs):
    r""" Class-aware wrapper for `::pdf_verify_embedded_file_checksum()`."""
    return _mupdf.pdf_verify_embedded_file_checksum(fs)

def pdf_version(doc):
    r""" Class-aware wrapper for `::pdf_version()`."""
    return _mupdf.pdf_version(doc)

def pdf_walk_tree(tree, kid_name, arrive, leave, arg, names, values):
    r"""
    Class-aware wrapper for `::pdf_walk_tree()`.

    This function has out-params. Python/C# wrappers look like:
    	`pdf_walk_tree(::pdf_obj *tree, ::pdf_obj *kid_name, void (*arrive)(::fz_context *, ::pdf_obj *, void *, ::pdf_obj **), void (*leave)(::fz_context *, ::pdf_obj *, void *), void *arg, ::pdf_obj **names, ::pdf_obj **values)` => `()`
    """
    return _mupdf.pdf_walk_tree(tree, kid_name, arrive, leave, arg, names, values)

def pdf_was_pure_xfa(doc):
    r""" Class-aware wrapper for `::pdf_was_pure_xfa()`."""
    return _mupdf.pdf_was_pure_xfa(doc)

def pdf_was_repaired(doc):
    r""" Class-aware wrapper for `::pdf_was_repaired()`."""
    return _mupdf.pdf_was_repaired(doc)

def pdf_widget_is_readonly(widget):
    r""" Class-aware wrapper for `::pdf_widget_is_readonly()`."""
    return _mupdf.pdf_widget_is_readonly(widget)

def pdf_widget_is_signed(widget):
    r""" Class-aware wrapper for `::pdf_widget_is_signed()`."""
    return _mupdf.pdf_widget_is_signed(widget)

def pdf_widget_type(widget):
    r""" Class-aware wrapper for `::pdf_widget_type()`."""
    return _mupdf.pdf_widget_type(widget)

def pdf_write_digest(out, byte_range, field, digest_offset, digest_length, signer):
    r""" Class-aware wrapper for `::pdf_write_digest()`."""
    return _mupdf.pdf_write_digest(out, byte_range, field, digest_offset, digest_length, signer)

def pdf_write_document(doc, out, opts):
    r""" Class-aware wrapper for `::pdf_write_document()`."""
    return _mupdf.pdf_write_document(doc, out, opts)

def pdf_write_journal(doc, out):
    r""" Class-aware wrapper for `::pdf_write_journal()`."""
    return _mupdf.pdf_write_journal(doc, out)

def pdf_write_snapshot(doc, out):
    r""" Class-aware wrapper for `::pdf_write_snapshot()`."""
    return _mupdf.pdf_write_snapshot(doc, out)

def pdf_xobject_bbox(xobj):
    r""" Class-aware wrapper for `::pdf_xobject_bbox()`."""
    return _mupdf.pdf_xobject_bbox(xobj)

def pdf_xobject_colorspace(xobj):
    r""" Class-aware wrapper for `::pdf_xobject_colorspace()`."""
    return _mupdf.pdf_xobject_colorspace(xobj)

def pdf_xobject_isolated(xobj):
    r""" Class-aware wrapper for `::pdf_xobject_isolated()`."""
    return _mupdf.pdf_xobject_isolated(xobj)

def pdf_xobject_knockout(xobj):
    r""" Class-aware wrapper for `::pdf_xobject_knockout()`."""
    return _mupdf.pdf_xobject_knockout(xobj)

def pdf_xobject_matrix(xobj):
    r""" Class-aware wrapper for `::pdf_xobject_matrix()`."""
    return _mupdf.pdf_xobject_matrix(xobj)

def pdf_xobject_resources(xobj):
    r""" Class-aware wrapper for `::pdf_xobject_resources()`."""
    return _mupdf.pdf_xobject_resources(xobj)

def pdf_xobject_transparency(xobj):
    r""" Class-aware wrapper for `::pdf_xobject_transparency()`."""
    return _mupdf.pdf_xobject_transparency(xobj)

def pdf_xref_ensure_incremental_object(doc, num):
    r""" Class-aware wrapper for `::pdf_xref_ensure_incremental_object()`."""
    return _mupdf.pdf_xref_ensure_incremental_object(doc, num)

def pdf_xref_ensure_local_object(doc, num):
    r""" Class-aware wrapper for `::pdf_xref_ensure_local_object()`."""
    return _mupdf.pdf_xref_ensure_local_object(doc, num)

def pdf_xref_entry_map(doc, fn, arg):
    r""" Class-aware wrapper for `::pdf_xref_entry_map()`."""
    return _mupdf.pdf_xref_entry_map(doc, fn, arg)

def pdf_xref_is_incremental(doc, num):
    r""" Class-aware wrapper for `::pdf_xref_is_incremental()`."""
    return _mupdf.pdf_xref_is_incremental(doc, num)

def pdf_xref_len(doc):
    r""" Class-aware wrapper for `::pdf_xref_len()`."""
    return _mupdf.pdf_xref_len(doc)

def pdf_xref_obj_is_unsaved_signature(doc, obj):
    r""" Class-aware wrapper for `::pdf_xref_obj_is_unsaved_signature()`."""
    return _mupdf.pdf_xref_obj_is_unsaved_signature(doc, obj)

def pdf_xref_remove_unsaved_signature(doc, field):
    r""" Class-aware wrapper for `::pdf_xref_remove_unsaved_signature()`."""
    return _mupdf.pdf_xref_remove_unsaved_signature(doc, field)

def pdf_xref_store_unsaved_signature(doc, field, signer):
    r""" Class-aware wrapper for `::pdf_xref_store_unsaved_signature()`."""
    return _mupdf.pdf_xref_store_unsaved_signature(doc, field, signer)

def internal_env_flag(name):
    r""" Internal use only. Looks at environmental variable <name>; returns 0 if unset else int value."""
    return _mupdf.internal_env_flag(name)

def internal_env_flag_check_unset(if_, name):
    r""" Internal use only. Looks at environmental variable <name>; returns 0 if unset else int value."""
    return _mupdf.internal_env_flag_check_unset(if_, name)

def internal_context_get():
    r""" Internal use only. Returns `fz_context*` for use by current thread."""
    return _mupdf.internal_context_get()
class FzErrorBase(Exception):
    r""" Base class for exceptions."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    m_code = property(_mupdf.FzErrorBase_m_code_get, _mupdf.FzErrorBase_m_code_set)
    m_text = property(_mupdf.FzErrorBase_m_text_get, _mupdf.FzErrorBase_m_text_set)
    m_what = property(_mupdf.FzErrorBase_m_what_get, _mupdf.FzErrorBase_m_what_set)

    def what(self):
        return _mupdf.FzErrorBase_what(self)

    def __init__(self, code, text):
        _mupdf.FzErrorBase_swiginit(self, _mupdf.new_FzErrorBase(code, text))
    __swig_destroy__ = _mupdf.delete_FzErrorBase

# Register FzErrorBase in _mupdf:
_mupdf.FzErrorBase_swigregister(FzErrorBase)
class FzErrorNone(FzErrorBase):
    r""" For `FZ_ERROR_NONE`."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, message):
        _mupdf.FzErrorNone_swiginit(self, _mupdf.new_FzErrorNone(message))
    __swig_destroy__ = _mupdf.delete_FzErrorNone

# Register FzErrorNone in _mupdf:
_mupdf.FzErrorNone_swigregister(FzErrorNone)
class FzErrorGeneric(FzErrorBase):
    r""" For `FZ_ERROR_GENERIC`."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, message):
        _mupdf.FzErrorGeneric_swiginit(self, _mupdf.new_FzErrorGeneric(message))
    __swig_destroy__ = _mupdf.delete_FzErrorGeneric

# Register FzErrorGeneric in _mupdf:
_mupdf.FzErrorGeneric_swigregister(FzErrorGeneric)
class FzErrorSystem(FzErrorBase):
    r""" For `FZ_ERROR_SYSTEM`."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, message):
        _mupdf.FzErrorSystem_swiginit(self, _mupdf.new_FzErrorSystem(message))
    __swig_destroy__ = _mupdf.delete_FzErrorSystem

# Register FzErrorSystem in _mupdf:
_mupdf.FzErrorSystem_swigregister(FzErrorSystem)
class FzErrorLibrary(FzErrorBase):
    r""" For `FZ_ERROR_LIBRARY`."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, message):
        _mupdf.FzErrorLibrary_swiginit(self, _mupdf.new_FzErrorLibrary(message))
    __swig_destroy__ = _mupdf.delete_FzErrorLibrary

# Register FzErrorLibrary in _mupdf:
_mupdf.FzErrorLibrary_swigregister(FzErrorLibrary)
class FzErrorArgument(FzErrorBase):
    r""" For `FZ_ERROR_ARGUMENT`."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, message):
        _mupdf.FzErrorArgument_swiginit(self, _mupdf.new_FzErrorArgument(message))
    __swig_destroy__ = _mupdf.delete_FzErrorArgument

# Register FzErrorArgument in _mupdf:
_mupdf.FzErrorArgument_swigregister(FzErrorArgument)
class FzErrorLimit(FzErrorBase):
    r""" For `FZ_ERROR_LIMIT`."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, message):
        _mupdf.FzErrorLimit_swiginit(self, _mupdf.new_FzErrorLimit(message))
    __swig_destroy__ = _mupdf.delete_FzErrorLimit

# Register FzErrorLimit in _mupdf:
_mupdf.FzErrorLimit_swigregister(FzErrorLimit)
class FzErrorUnsupported(FzErrorBase):
    r""" For `FZ_ERROR_UNSUPPORTED`."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, message):
        _mupdf.FzErrorUnsupported_swiginit(self, _mupdf.new_FzErrorUnsupported(message))
    __swig_destroy__ = _mupdf.delete_FzErrorUnsupported

# Register FzErrorUnsupported in _mupdf:
_mupdf.FzErrorUnsupported_swigregister(FzErrorUnsupported)
class FzErrorFormat(FzErrorBase):
    r""" For `FZ_ERROR_FORMAT`."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, message):
        _mupdf.FzErrorFormat_swiginit(self, _mupdf.new_FzErrorFormat(message))
    __swig_destroy__ = _mupdf.delete_FzErrorFormat

# Register FzErrorFormat in _mupdf:
_mupdf.FzErrorFormat_swigregister(FzErrorFormat)
class FzErrorSyntax(FzErrorBase):
    r""" For `FZ_ERROR_SYNTAX`."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, message):
        _mupdf.FzErrorSyntax_swiginit(self, _mupdf.new_FzErrorSyntax(message))
    __swig_destroy__ = _mupdf.delete_FzErrorSyntax

# Register FzErrorSyntax in _mupdf:
_mupdf.FzErrorSyntax_swigregister(FzErrorSyntax)
class FzErrorTrylater(FzErrorBase):
    r""" For `FZ_ERROR_TRYLATER`."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, message):
        _mupdf.FzErrorTrylater_swiginit(self, _mupdf.new_FzErrorTrylater(message))
    __swig_destroy__ = _mupdf.delete_FzErrorTrylater

# Register FzErrorTrylater in _mupdf:
_mupdf.FzErrorTrylater_swigregister(FzErrorTrylater)
class FzErrorAbort(FzErrorBase):
    r""" For `FZ_ERROR_ABORT`."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, message):
        _mupdf.FzErrorAbort_swiginit(self, _mupdf.new_FzErrorAbort(message))
    __swig_destroy__ = _mupdf.delete_FzErrorAbort

# Register FzErrorAbort in _mupdf:
_mupdf.FzErrorAbort_swigregister(FzErrorAbort)
class FzErrorRepaired(FzErrorBase):
    r""" For `FZ_ERROR_REPAIRED`."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, message):
        _mupdf.FzErrorRepaired_swiginit(self, _mupdf.new_FzErrorRepaired(message))
    __swig_destroy__ = _mupdf.delete_FzErrorRepaired

# Register FzErrorRepaired in _mupdf:
_mupdf.FzErrorRepaired_swigregister(FzErrorRepaired)

def internal_throw_exception(ctx):
    r""" Throw exception appropriate for error in `ctx`."""
    return _mupdf.internal_throw_exception(ctx)

def to_stdstring(s):
    return _mupdf.to_stdstring(s)

def py_repr(x):
    return _mupdf.py_repr(x)

def py_str(x):
    return _mupdf.py_str(x)

def ll_fz_buffer_to_bytes_internal(buffer, clear):
    return _mupdf.ll_fz_buffer_to_bytes_internal(buffer, clear)

def python_memoryview_from_memory(data, size, writable):
    return _mupdf.python_memoryview_from_memory(data, size, writable)

def ll_fz_buffer_storage_memoryview(buffer, writable):
    return _mupdf.ll_fz_buffer_storage_memoryview(buffer, writable)

def raw_to_python_bytes(*args):
    return _mupdf.raw_to_python_bytes(*args)

def python_buffer_data(PYTHON_BUFFER_DATA):
    return _mupdf.python_buffer_data(PYTHON_BUFFER_DATA)

def python_mutable_buffer_data(PYTHON_BUFFER_MUTABLE_DATA):
    return _mupdf.python_mutable_buffer_data(PYTHON_BUFFER_MUTABLE_DATA)

def obj_enum_to_obj(n):
    return _mupdf.obj_enum_to_obj(n)

def ll_pdf_set_annot_color2(annot, n, color0, color1, color2, color3):
    return _mupdf.ll_pdf_set_annot_color2(annot, n, color0, color1, color2, color3)

def ll_pdf_set_annot_interior_color2(annot, n, color0, color1, color2, color3):
    return _mupdf.ll_pdf_set_annot_interior_color2(annot, n, color0, color1, color2, color3)

def ll_fz_fill_text2(dev, text, ctm, colorspace, color0, color1, color2, color3, alpha, color_params):
    return _mupdf.ll_fz_fill_text2(dev, text, ctm, colorspace, color0, color1, color2, color3, alpha, color_params)

def fz_memrnd2(length):
    return _mupdf.fz_memrnd2(length)

def ll_fz_pixmap_copy(pm, src, n):
    return _mupdf.ll_fz_pixmap_copy(pm, src, n)

def ll_fz_pixmap_copy_raw(pm, samples):
    return _mupdf.ll_fz_pixmap_copy_raw(pm, samples)

def fz_runetochar2(rune):
    return _mupdf.fz_runetochar2(rune)

def ll_fz_make_bookmark2(doc, loc):
    return _mupdf.ll_fz_make_bookmark2(doc, loc)

def ll_fz_lookup_bookmark2(doc, mark):
    return _mupdf.ll_fz_lookup_bookmark2(doc, mark)

def fz_lookup_bookmark2(doc, mark):
    return _mupdf.fz_lookup_bookmark2(doc, mark)
class fz_convert_color2_v(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    v0 = property(_mupdf.fz_convert_color2_v_v0_get, _mupdf.fz_convert_color2_v_v0_set)
    v1 = property(_mupdf.fz_convert_color2_v_v1_get, _mupdf.fz_convert_color2_v_v1_set)
    v2 = property(_mupdf.fz_convert_color2_v_v2_get, _mupdf.fz_convert_color2_v_v2_set)
    v3 = property(_mupdf.fz_convert_color2_v_v3_get, _mupdf.fz_convert_color2_v_v3_set)

    def __init__(self):
        _mupdf.fz_convert_color2_v_swiginit(self, _mupdf.new_fz_convert_color2_v())
    __swig_destroy__ = _mupdf.delete_fz_convert_color2_v

# Register fz_convert_color2_v in _mupdf:
_mupdf.fz_convert_color2_v_swigregister(fz_convert_color2_v)

def ll_fz_convert_color2(*args):
    return _mupdf.ll_fz_convert_color2(*args)
class DiagnosticCallback(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, description):
        if self.__class__ == DiagnosticCallback:
            _self = None
        else:
            _self = self
        _mupdf.DiagnosticCallback_swiginit(self, _mupdf.new_DiagnosticCallback(_self, description))

    def _print(self, message):
        return _mupdf.DiagnosticCallback__print(self, message)
    __swig_destroy__ = _mupdf.delete_DiagnosticCallback

    @staticmethod
    def s_print(self0, message):
        return _mupdf.DiagnosticCallback_s_print(self0, message)
    m_description = property(_mupdf.DiagnosticCallback_m_description_get, _mupdf.DiagnosticCallback_m_description_set)
    def __disown__(self):
        self.this.disown()
        _mupdf.disown_DiagnosticCallback(self)
        return weakref.proxy(self)

# Register DiagnosticCallback in _mupdf:
_mupdf.DiagnosticCallback_swigregister(DiagnosticCallback)
class StoryPositionsCallback(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        if self.__class__ == StoryPositionsCallback:
            _self = None
        else:
            _self = self
        _mupdf.StoryPositionsCallback_swiginit(self, _mupdf.new_StoryPositionsCallback(_self, ))

    def call(self, position):
        return _mupdf.StoryPositionsCallback_call(self, position)

    @staticmethod
    def s_call(ctx, self0, position):
        return _mupdf.StoryPositionsCallback_s_call(ctx, self0, position)
    __swig_destroy__ = _mupdf.delete_StoryPositionsCallback
    def __disown__(self):
        self.this.disown()
        _mupdf.disown_StoryPositionsCallback(self)
        return weakref.proxy(self)

# Register StoryPositionsCallback in _mupdf:
_mupdf.StoryPositionsCallback_swigregister(StoryPositionsCallback)

def ll_fz_story_positions_director(story, cb):
    return _mupdf.ll_fz_story_positions_director(story, cb)

def Pixmap_set_alpha_helper(balen, n, data_len, zero_out, data, pix, premultiply, bground, colors, bgcolor):
    return _mupdf.Pixmap_set_alpha_helper(balen, n, data_len, zero_out, data, pix, premultiply, bground, colors, bgcolor)

def page_merge_helper(old_annots, graft_map, doc_des, new_annots, n):
    return _mupdf.page_merge_helper(old_annots, graft_map, doc_des, new_annots, n)
class ll_fz_bidi_fragment_text_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    baseDir = property(_mupdf.ll_fz_bidi_fragment_text_outparams_baseDir_get, _mupdf.ll_fz_bidi_fragment_text_outparams_baseDir_set)

    def __init__(self):
        _mupdf.ll_fz_bidi_fragment_text_outparams_swiginit(self, _mupdf.new_ll_fz_bidi_fragment_text_outparams())
    __swig_destroy__ = _mupdf.delete_ll_fz_bidi_fragment_text_outparams

# Register ll_fz_bidi_fragment_text_outparams in _mupdf:
_mupdf.ll_fz_bidi_fragment_text_outparams_swigregister(ll_fz_bidi_fragment_text_outparams)

def ll_fz_bidi_fragment_text_outparams_fn(text, textlen, callback, arg, flags, outparams):
    return _mupdf.ll_fz_bidi_fragment_text_outparams_fn(text, textlen, callback, arg, flags, outparams)
class ll_fz_bitmap_details_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    w = property(_mupdf.ll_fz_bitmap_details_outparams_w_get, _mupdf.ll_fz_bitmap_details_outparams_w_set)
    h = property(_mupdf.ll_fz_bitmap_details_outparams_h_get, _mupdf.ll_fz_bitmap_details_outparams_h_set)
    n = property(_mupdf.ll_fz_bitmap_details_outparams_n_get, _mupdf.ll_fz_bitmap_details_outparams_n_set)
    stride = property(_mupdf.ll_fz_bitmap_details_outparams_stride_get, _mupdf.ll_fz_bitmap_details_outparams_stride_set)

    def __init__(self):
        _mupdf.ll_fz_bitmap_details_outparams_swiginit(self, _mupdf.new_ll_fz_bitmap_details_outparams())
    __swig_destroy__ = _mupdf.delete_ll_fz_bitmap_details_outparams

# Register ll_fz_bitmap_details_outparams in _mupdf:
_mupdf.ll_fz_bitmap_details_outparams_swigregister(ll_fz_bitmap_details_outparams)

def ll_fz_bitmap_details_outparams_fn(bitmap, outparams):
    return _mupdf.ll_fz_bitmap_details_outparams_fn(bitmap, outparams)
class ll_fz_buffer_extract_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    data = property(_mupdf.ll_fz_buffer_extract_outparams_data_get, _mupdf.ll_fz_buffer_extract_outparams_data_set)

    def __init__(self):
        _mupdf.ll_fz_buffer_extract_outparams_swiginit(self, _mupdf.new_ll_fz_buffer_extract_outparams())
    __swig_destroy__ = _mupdf.delete_ll_fz_buffer_extract_outparams

# Register ll_fz_buffer_extract_outparams in _mupdf:
_mupdf.ll_fz_buffer_extract_outparams_swigregister(ll_fz_buffer_extract_outparams)

def ll_fz_buffer_extract_outparams_fn(buf, outparams):
    return _mupdf.ll_fz_buffer_extract_outparams_fn(buf, outparams)
class ll_fz_buffer_storage_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    datap = property(_mupdf.ll_fz_buffer_storage_outparams_datap_get, _mupdf.ll_fz_buffer_storage_outparams_datap_set)

    def __init__(self):
        _mupdf.ll_fz_buffer_storage_outparams_swiginit(self, _mupdf.new_ll_fz_buffer_storage_outparams())
    __swig_destroy__ = _mupdf.delete_ll_fz_buffer_storage_outparams

# Register ll_fz_buffer_storage_outparams in _mupdf:
_mupdf.ll_fz_buffer_storage_outparams_swigregister(ll_fz_buffer_storage_outparams)

def ll_fz_buffer_storage_outparams_fn(buf, outparams):
    return _mupdf.ll_fz_buffer_storage_outparams_fn(buf, outparams)
class ll_fz_chartorune_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    rune = property(_mupdf.ll_fz_chartorune_outparams_rune_get, _mupdf.ll_fz_chartorune_outparams_rune_set)

    def __init__(self):
        _mupdf.ll_fz_chartorune_outparams_swiginit(self, _mupdf.new_ll_fz_chartorune_outparams())
    __swig_destroy__ = _mupdf.delete_ll_fz_chartorune_outparams

# Register ll_fz_chartorune_outparams in _mupdf:
_mupdf.ll_fz_chartorune_outparams_swigregister(ll_fz_chartorune_outparams)

def ll_fz_chartorune_outparams_fn(str, outparams):
    return _mupdf.ll_fz_chartorune_outparams_fn(str, outparams)
class ll_fz_clamp_color_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    out = property(_mupdf.ll_fz_clamp_color_outparams_out_get, _mupdf.ll_fz_clamp_color_outparams_out_set)

    def __init__(self):
        _mupdf.ll_fz_clamp_color_outparams_swiginit(self, _mupdf.new_ll_fz_clamp_color_outparams())
    __swig_destroy__ = _mupdf.delete_ll_fz_clamp_color_outparams

# Register ll_fz_clamp_color_outparams in _mupdf:
_mupdf.ll_fz_clamp_color_outparams_swigregister(ll_fz_clamp_color_outparams)

def ll_fz_clamp_color_outparams_fn(cs, _in, outparams):
    return _mupdf.ll_fz_clamp_color_outparams_fn(cs, _in, outparams)
class ll_fz_convert_color_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    dv = property(_mupdf.ll_fz_convert_color_outparams_dv_get, _mupdf.ll_fz_convert_color_outparams_dv_set)

    def __init__(self):
        _mupdf.ll_fz_convert_color_outparams_swiginit(self, _mupdf.new_ll_fz_convert_color_outparams())
    __swig_destroy__ = _mupdf.delete_ll_fz_convert_color_outparams

# Register ll_fz_convert_color_outparams in _mupdf:
_mupdf.ll_fz_convert_color_outparams_swigregister(ll_fz_convert_color_outparams)

def ll_fz_convert_color_outparams_fn(ss, sv, ds, _is, params, outparams):
    return _mupdf.ll_fz_convert_color_outparams_fn(ss, sv, ds, _is, params, outparams)
class ll_fz_convert_error_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    code = property(_mupdf.ll_fz_convert_error_outparams_code_get, _mupdf.ll_fz_convert_error_outparams_code_set)

    def __init__(self):
        _mupdf.ll_fz_convert_error_outparams_swiginit(self, _mupdf.new_ll_fz_convert_error_outparams())
    __swig_destroy__ = _mupdf.delete_ll_fz_convert_error_outparams

# Register ll_fz_convert_error_outparams in _mupdf:
_mupdf.ll_fz_convert_error_outparams_swigregister(ll_fz_convert_error_outparams)

def ll_fz_convert_error_outparams_fn(outparams):
    return _mupdf.ll_fz_convert_error_outparams_fn(outparams)
class ll_fz_convert_separation_colors_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    dst_color = property(_mupdf.ll_fz_convert_separation_colors_outparams_dst_color_get, _mupdf.ll_fz_convert_separation_colors_outparams_dst_color_set)

    def __init__(self):
        _mupdf.ll_fz_convert_separation_colors_outparams_swiginit(self, _mupdf.new_ll_fz_convert_separation_colors_outparams())
    __swig_destroy__ = _mupdf.delete_ll_fz_convert_separation_colors_outparams

# Register ll_fz_convert_separation_colors_outparams in _mupdf:
_mupdf.ll_fz_convert_separation_colors_outparams_swigregister(ll_fz_convert_separation_colors_outparams)

def ll_fz_convert_separation_colors_outparams_fn(src_cs, src_color, dst_seps, dst_cs, color_params, outparams):
    return _mupdf.ll_fz_convert_separation_colors_outparams_fn(src_cs, src_color, dst_seps, dst_cs, color_params, outparams)
class ll_fz_decomp_image_from_stream_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    l2extra = property(_mupdf.ll_fz_decomp_image_from_stream_outparams_l2extra_get, _mupdf.ll_fz_decomp_image_from_stream_outparams_l2extra_set)

    def __init__(self):
        _mupdf.ll_fz_decomp_image_from_stream_outparams_swiginit(self, _mupdf.new_ll_fz_decomp_image_from_stream_outparams())
    __swig_destroy__ = _mupdf.delete_ll_fz_decomp_image_from_stream_outparams

# Register ll_fz_decomp_image_from_stream_outparams in _mupdf:
_mupdf.ll_fz_decomp_image_from_stream_outparams_swigregister(ll_fz_decomp_image_from_stream_outparams)

def ll_fz_decomp_image_from_stream_outparams_fn(stm, image, subarea, indexed, l2factor, outparams):
    return _mupdf.ll_fz_decomp_image_from_stream_outparams_fn(stm, image, subarea, indexed, l2factor, outparams)
class ll_fz_deflate_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    compressed_length = property(_mupdf.ll_fz_deflate_outparams_compressed_length_get, _mupdf.ll_fz_deflate_outparams_compressed_length_set)

    def __init__(self):
        _mupdf.ll_fz_deflate_outparams_swiginit(self, _mupdf.new_ll_fz_deflate_outparams())
    __swig_destroy__ = _mupdf.delete_ll_fz_deflate_outparams

# Register ll_fz_deflate_outparams in _mupdf:
_mupdf.ll_fz_deflate_outparams_swigregister(ll_fz_deflate_outparams)

def ll_fz_deflate_outparams_fn(dest, source, source_length, level, outparams):
    return _mupdf.ll_fz_deflate_outparams_fn(dest, source, source_length, level, outparams)
class ll_fz_dom_get_attribute_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    att = property(_mupdf.ll_fz_dom_get_attribute_outparams_att_get, _mupdf.ll_fz_dom_get_attribute_outparams_att_set)

    def __init__(self):
        _mupdf.ll_fz_dom_get_attribute_outparams_swiginit(self, _mupdf.new_ll_fz_dom_get_attribute_outparams())
    __swig_destroy__ = _mupdf.delete_ll_fz_dom_get_attribute_outparams

# Register ll_fz_dom_get_attribute_outparams in _mupdf:
_mupdf.ll_fz_dom_get_attribute_outparams_swigregister(ll_fz_dom_get_attribute_outparams)

def ll_fz_dom_get_attribute_outparams_fn(elt, i, outparams):
    return _mupdf.ll_fz_dom_get_attribute_outparams_fn(elt, i, outparams)
class ll_fz_drop_imp_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    refs = property(_mupdf.ll_fz_drop_imp_outparams_refs_get, _mupdf.ll_fz_drop_imp_outparams_refs_set)

    def __init__(self):
        _mupdf.ll_fz_drop_imp_outparams_swiginit(self, _mupdf.new_ll_fz_drop_imp_outparams())
    __swig_destroy__ = _mupdf.delete_ll_fz_drop_imp_outparams

# Register ll_fz_drop_imp_outparams in _mupdf:
_mupdf.ll_fz_drop_imp_outparams_swigregister(ll_fz_drop_imp_outparams)

def ll_fz_drop_imp_outparams_fn(p, outparams):
    return _mupdf.ll_fz_drop_imp_outparams_fn(p, outparams)
class ll_fz_drop_imp16_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    refs = property(_mupdf.ll_fz_drop_imp16_outparams_refs_get, _mupdf.ll_fz_drop_imp16_outparams_refs_set)

    def __init__(self):
        _mupdf.ll_fz_drop_imp16_outparams_swiginit(self, _mupdf.new_ll_fz_drop_imp16_outparams())
    __swig_destroy__ = _mupdf.delete_ll_fz_drop_imp16_outparams

# Register ll_fz_drop_imp16_outparams in _mupdf:
_mupdf.ll_fz_drop_imp16_outparams_swigregister(ll_fz_drop_imp16_outparams)

def ll_fz_drop_imp16_outparams_fn(p, outparams):
    return _mupdf.ll_fz_drop_imp16_outparams_fn(p, outparams)
class ll_fz_encode_character_with_fallback_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    out_font = property(_mupdf.ll_fz_encode_character_with_fallback_outparams_out_font_get, _mupdf.ll_fz_encode_character_with_fallback_outparams_out_font_set)

    def __init__(self):
        _mupdf.ll_fz_encode_character_with_fallback_outparams_swiginit(self, _mupdf.new_ll_fz_encode_character_with_fallback_outparams())
    __swig_destroy__ = _mupdf.delete_ll_fz_encode_character_with_fallback_outparams

# Register ll_fz_encode_character_with_fallback_outparams in _mupdf:
_mupdf.ll_fz_encode_character_with_fallback_outparams_swigregister(ll_fz_encode_character_with_fallback_outparams)

def ll_fz_encode_character_with_fallback_outparams_fn(font, unicode, script, language, outparams):
    return _mupdf.ll_fz_encode_character_with_fallback_outparams_fn(font, unicode, script, language, outparams)
class ll_fz_error_callback_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    user = property(_mupdf.ll_fz_error_callback_outparams_user_get, _mupdf.ll_fz_error_callback_outparams_user_set)

    def __init__(self):
        _mupdf.ll_fz_error_callback_outparams_swiginit(self, _mupdf.new_ll_fz_error_callback_outparams())
    __swig_destroy__ = _mupdf.delete_ll_fz_error_callback_outparams

# Register ll_fz_error_callback_outparams in _mupdf:
_mupdf.ll_fz_error_callback_outparams_swigregister(ll_fz_error_callback_outparams)

def ll_fz_error_callback_outparams_fn(outparams):
    return _mupdf.ll_fz_error_callback_outparams_fn(outparams)
class ll_fz_eval_function_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    out = property(_mupdf.ll_fz_eval_function_outparams_out_get, _mupdf.ll_fz_eval_function_outparams_out_set)

    def __init__(self):
        _mupdf.ll_fz_eval_function_outparams_swiginit(self, _mupdf.new_ll_fz_eval_function_outparams())
    __swig_destroy__ = _mupdf.delete_ll_fz_eval_function_outparams

# Register ll_fz_eval_function_outparams in _mupdf:
_mupdf.ll_fz_eval_function_outparams_swigregister(ll_fz_eval_function_outparams)

def ll_fz_eval_function_outparams_fn(func, _in, inlen, outlen, outparams):
    return _mupdf.ll_fz_eval_function_outparams_fn(func, _in, inlen, outlen, outparams)
class ll_fz_fill_pixmap_with_color_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    color = property(_mupdf.ll_fz_fill_pixmap_with_color_outparams_color_get, _mupdf.ll_fz_fill_pixmap_with_color_outparams_color_set)

    def __init__(self):
        _mupdf.ll_fz_fill_pixmap_with_color_outparams_swiginit(self, _mupdf.new_ll_fz_fill_pixmap_with_color_outparams())
    __swig_destroy__ = _mupdf.delete_ll_fz_fill_pixmap_with_color_outparams

# Register ll_fz_fill_pixmap_with_color_outparams in _mupdf:
_mupdf.ll_fz_fill_pixmap_with_color_outparams_swigregister(ll_fz_fill_pixmap_with_color_outparams)

def ll_fz_fill_pixmap_with_color_outparams_fn(pix, colorspace, color_params, outparams):
    return _mupdf.ll_fz_fill_pixmap_with_color_outparams_fn(pix, colorspace, color_params, outparams)
class ll_fz_get_pixmap_from_image_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    w = property(_mupdf.ll_fz_get_pixmap_from_image_outparams_w_get, _mupdf.ll_fz_get_pixmap_from_image_outparams_w_set)
    h = property(_mupdf.ll_fz_get_pixmap_from_image_outparams_h_get, _mupdf.ll_fz_get_pixmap_from_image_outparams_h_set)

    def __init__(self):
        _mupdf.ll_fz_get_pixmap_from_image_outparams_swiginit(self, _mupdf.new_ll_fz_get_pixmap_from_image_outparams())
    __swig_destroy__ = _mupdf.delete_ll_fz_get_pixmap_from_image_outparams

# Register ll_fz_get_pixmap_from_image_outparams in _mupdf:
_mupdf.ll_fz_get_pixmap_from_image_outparams_swigregister(ll_fz_get_pixmap_from_image_outparams)

def ll_fz_get_pixmap_from_image_outparams_fn(image, subarea, ctm, outparams):
    return _mupdf.ll_fz_get_pixmap_from_image_outparams_fn(image, subarea, ctm, outparams)
class ll_fz_getopt_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    nargv = property(_mupdf.ll_fz_getopt_outparams_nargv_get, _mupdf.ll_fz_getopt_outparams_nargv_set)

    def __init__(self):
        _mupdf.ll_fz_getopt_outparams_swiginit(self, _mupdf.new_ll_fz_getopt_outparams())
    __swig_destroy__ = _mupdf.delete_ll_fz_getopt_outparams

# Register ll_fz_getopt_outparams in _mupdf:
_mupdf.ll_fz_getopt_outparams_swigregister(ll_fz_getopt_outparams)

def ll_fz_getopt_outparams_fn(nargc, ostr, outparams):
    return _mupdf.ll_fz_getopt_outparams_fn(nargc, ostr, outparams)
class ll_fz_getopt_long_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    nargv = property(_mupdf.ll_fz_getopt_long_outparams_nargv_get, _mupdf.ll_fz_getopt_long_outparams_nargv_set)

    def __init__(self):
        _mupdf.ll_fz_getopt_long_outparams_swiginit(self, _mupdf.new_ll_fz_getopt_long_outparams())
    __swig_destroy__ = _mupdf.delete_ll_fz_getopt_long_outparams

# Register ll_fz_getopt_long_outparams in _mupdf:
_mupdf.ll_fz_getopt_long_outparams_swigregister(ll_fz_getopt_long_outparams)

def ll_fz_getopt_long_outparams_fn(nargc, ostr, longopts, outparams):
    return _mupdf.ll_fz_getopt_long_outparams_fn(nargc, ostr, longopts, outparams)
class ll_fz_grisu_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    exp = property(_mupdf.ll_fz_grisu_outparams_exp_get, _mupdf.ll_fz_grisu_outparams_exp_set)

    def __init__(self):
        _mupdf.ll_fz_grisu_outparams_swiginit(self, _mupdf.new_ll_fz_grisu_outparams())
    __swig_destroy__ = _mupdf.delete_ll_fz_grisu_outparams

# Register ll_fz_grisu_outparams in _mupdf:
_mupdf.ll_fz_grisu_outparams_swigregister(ll_fz_grisu_outparams)

def ll_fz_grisu_outparams_fn(f, s, outparams):
    return _mupdf.ll_fz_grisu_outparams_fn(f, s, outparams)
class ll_fz_has_option_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    val = property(_mupdf.ll_fz_has_option_outparams_val_get, _mupdf.ll_fz_has_option_outparams_val_set)

    def __init__(self):
        _mupdf.ll_fz_has_option_outparams_swiginit(self, _mupdf.new_ll_fz_has_option_outparams())
    __swig_destroy__ = _mupdf.delete_ll_fz_has_option_outparams

# Register ll_fz_has_option_outparams in _mupdf:
_mupdf.ll_fz_has_option_outparams_swigregister(ll_fz_has_option_outparams)

def ll_fz_has_option_outparams_fn(opts, key, outparams):
    return _mupdf.ll_fz_has_option_outparams_fn(opts, key, outparams)
class ll_fz_image_resolution_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    xres = property(_mupdf.ll_fz_image_resolution_outparams_xres_get, _mupdf.ll_fz_image_resolution_outparams_xres_set)
    yres = property(_mupdf.ll_fz_image_resolution_outparams_yres_get, _mupdf.ll_fz_image_resolution_outparams_yres_set)

    def __init__(self):
        _mupdf.ll_fz_image_resolution_outparams_swiginit(self, _mupdf.new_ll_fz_image_resolution_outparams())
    __swig_destroy__ = _mupdf.delete_ll_fz_image_resolution_outparams

# Register ll_fz_image_resolution_outparams in _mupdf:
_mupdf.ll_fz_image_resolution_outparams_swigregister(ll_fz_image_resolution_outparams)

def ll_fz_image_resolution_outparams_fn(image, outparams):
    return _mupdf.ll_fz_image_resolution_outparams_fn(image, outparams)
class ll_fz_keep_imp_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    refs = property(_mupdf.ll_fz_keep_imp_outparams_refs_get, _mupdf.ll_fz_keep_imp_outparams_refs_set)

    def __init__(self):
        _mupdf.ll_fz_keep_imp_outparams_swiginit(self, _mupdf.new_ll_fz_keep_imp_outparams())
    __swig_destroy__ = _mupdf.delete_ll_fz_keep_imp_outparams

# Register ll_fz_keep_imp_outparams in _mupdf:
_mupdf.ll_fz_keep_imp_outparams_swigregister(ll_fz_keep_imp_outparams)

def ll_fz_keep_imp_outparams_fn(p, outparams):
    return _mupdf.ll_fz_keep_imp_outparams_fn(p, outparams)
class ll_fz_keep_imp16_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    refs = property(_mupdf.ll_fz_keep_imp16_outparams_refs_get, _mupdf.ll_fz_keep_imp16_outparams_refs_set)

    def __init__(self):
        _mupdf.ll_fz_keep_imp16_outparams_swiginit(self, _mupdf.new_ll_fz_keep_imp16_outparams())
    __swig_destroy__ = _mupdf.delete_ll_fz_keep_imp16_outparams

# Register ll_fz_keep_imp16_outparams in _mupdf:
_mupdf.ll_fz_keep_imp16_outparams_swigregister(ll_fz_keep_imp16_outparams)

def ll_fz_keep_imp16_outparams_fn(p, outparams):
    return _mupdf.ll_fz_keep_imp16_outparams_fn(p, outparams)
class ll_fz_keep_imp_locked_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    refs = property(_mupdf.ll_fz_keep_imp_locked_outparams_refs_get, _mupdf.ll_fz_keep_imp_locked_outparams_refs_set)

    def __init__(self):
        _mupdf.ll_fz_keep_imp_locked_outparams_swiginit(self, _mupdf.new_ll_fz_keep_imp_locked_outparams())
    __swig_destroy__ = _mupdf.delete_ll_fz_keep_imp_locked_outparams

# Register ll_fz_keep_imp_locked_outparams in _mupdf:
_mupdf.ll_fz_keep_imp_locked_outparams_swigregister(ll_fz_keep_imp_locked_outparams)

def ll_fz_keep_imp_locked_outparams_fn(p, outparams):
    return _mupdf.ll_fz_keep_imp_locked_outparams_fn(p, outparams)
class ll_fz_lookup_base14_font_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    len = property(_mupdf.ll_fz_lookup_base14_font_outparams_len_get, _mupdf.ll_fz_lookup_base14_font_outparams_len_set)

    def __init__(self):
        _mupdf.ll_fz_lookup_base14_font_outparams_swiginit(self, _mupdf.new_ll_fz_lookup_base14_font_outparams())
    __swig_destroy__ = _mupdf.delete_ll_fz_lookup_base14_font_outparams

# Register ll_fz_lookup_base14_font_outparams in _mupdf:
_mupdf.ll_fz_lookup_base14_font_outparams_swigregister(ll_fz_lookup_base14_font_outparams)

def ll_fz_lookup_base14_font_outparams_fn(name, outparams):
    return _mupdf.ll_fz_lookup_base14_font_outparams_fn(name, outparams)
class ll_fz_lookup_builtin_font_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    len = property(_mupdf.ll_fz_lookup_builtin_font_outparams_len_get, _mupdf.ll_fz_lookup_builtin_font_outparams_len_set)

    def __init__(self):
        _mupdf.ll_fz_lookup_builtin_font_outparams_swiginit(self, _mupdf.new_ll_fz_lookup_builtin_font_outparams())
    __swig_destroy__ = _mupdf.delete_ll_fz_lookup_builtin_font_outparams

# Register ll_fz_lookup_builtin_font_outparams in _mupdf:
_mupdf.ll_fz_lookup_builtin_font_outparams_swigregister(ll_fz_lookup_builtin_font_outparams)

def ll_fz_lookup_builtin_font_outparams_fn(name, bold, italic, outparams):
    return _mupdf.ll_fz_lookup_builtin_font_outparams_fn(name, bold, italic, outparams)
class ll_fz_lookup_cjk_font_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    len = property(_mupdf.ll_fz_lookup_cjk_font_outparams_len_get, _mupdf.ll_fz_lookup_cjk_font_outparams_len_set)
    index = property(_mupdf.ll_fz_lookup_cjk_font_outparams_index_get, _mupdf.ll_fz_lookup_cjk_font_outparams_index_set)

    def __init__(self):
        _mupdf.ll_fz_lookup_cjk_font_outparams_swiginit(self, _mupdf.new_ll_fz_lookup_cjk_font_outparams())
    __swig_destroy__ = _mupdf.delete_ll_fz_lookup_cjk_font_outparams

# Register ll_fz_lookup_cjk_font_outparams in _mupdf:
_mupdf.ll_fz_lookup_cjk_font_outparams_swigregister(ll_fz_lookup_cjk_font_outparams)

def ll_fz_lookup_cjk_font_outparams_fn(ordering, outparams):
    return _mupdf.ll_fz_lookup_cjk_font_outparams_fn(ordering, outparams)
class ll_fz_lookup_cjk_font_by_language_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    len = property(_mupdf.ll_fz_lookup_cjk_font_by_language_outparams_len_get, _mupdf.ll_fz_lookup_cjk_font_by_language_outparams_len_set)
    subfont = property(_mupdf.ll_fz_lookup_cjk_font_by_language_outparams_subfont_get, _mupdf.ll_fz_lookup_cjk_font_by_language_outparams_subfont_set)

    def __init__(self):
        _mupdf.ll_fz_lookup_cjk_font_by_language_outparams_swiginit(self, _mupdf.new_ll_fz_lookup_cjk_font_by_language_outparams())
    __swig_destroy__ = _mupdf.delete_ll_fz_lookup_cjk_font_by_language_outparams

# Register ll_fz_lookup_cjk_font_by_language_outparams in _mupdf:
_mupdf.ll_fz_lookup_cjk_font_by_language_outparams_swigregister(ll_fz_lookup_cjk_font_by_language_outparams)

def ll_fz_lookup_cjk_font_by_language_outparams_fn(lang, outparams):
    return _mupdf.ll_fz_lookup_cjk_font_by_language_outparams_fn(lang, outparams)
class ll_fz_lookup_noto_boxes_font_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    len = property(_mupdf.ll_fz_lookup_noto_boxes_font_outparams_len_get, _mupdf.ll_fz_lookup_noto_boxes_font_outparams_len_set)

    def __init__(self):
        _mupdf.ll_fz_lookup_noto_boxes_font_outparams_swiginit(self, _mupdf.new_ll_fz_lookup_noto_boxes_font_outparams())
    __swig_destroy__ = _mupdf.delete_ll_fz_lookup_noto_boxes_font_outparams

# Register ll_fz_lookup_noto_boxes_font_outparams in _mupdf:
_mupdf.ll_fz_lookup_noto_boxes_font_outparams_swigregister(ll_fz_lookup_noto_boxes_font_outparams)

def ll_fz_lookup_noto_boxes_font_outparams_fn(outparams):
    return _mupdf.ll_fz_lookup_noto_boxes_font_outparams_fn(outparams)
class ll_fz_lookup_noto_emoji_font_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    len = property(_mupdf.ll_fz_lookup_noto_emoji_font_outparams_len_get, _mupdf.ll_fz_lookup_noto_emoji_font_outparams_len_set)

    def __init__(self):
        _mupdf.ll_fz_lookup_noto_emoji_font_outparams_swiginit(self, _mupdf.new_ll_fz_lookup_noto_emoji_font_outparams())
    __swig_destroy__ = _mupdf.delete_ll_fz_lookup_noto_emoji_font_outparams

# Register ll_fz_lookup_noto_emoji_font_outparams in _mupdf:
_mupdf.ll_fz_lookup_noto_emoji_font_outparams_swigregister(ll_fz_lookup_noto_emoji_font_outparams)

def ll_fz_lookup_noto_emoji_font_outparams_fn(outparams):
    return _mupdf.ll_fz_lookup_noto_emoji_font_outparams_fn(outparams)
class ll_fz_lookup_noto_font_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    len = property(_mupdf.ll_fz_lookup_noto_font_outparams_len_get, _mupdf.ll_fz_lookup_noto_font_outparams_len_set)
    subfont = property(_mupdf.ll_fz_lookup_noto_font_outparams_subfont_get, _mupdf.ll_fz_lookup_noto_font_outparams_subfont_set)

    def __init__(self):
        _mupdf.ll_fz_lookup_noto_font_outparams_swiginit(self, _mupdf.new_ll_fz_lookup_noto_font_outparams())
    __swig_destroy__ = _mupdf.delete_ll_fz_lookup_noto_font_outparams

# Register ll_fz_lookup_noto_font_outparams in _mupdf:
_mupdf.ll_fz_lookup_noto_font_outparams_swigregister(ll_fz_lookup_noto_font_outparams)

def ll_fz_lookup_noto_font_outparams_fn(script, lang, outparams):
    return _mupdf.ll_fz_lookup_noto_font_outparams_fn(script, lang, outparams)
class ll_fz_lookup_noto_math_font_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    len = property(_mupdf.ll_fz_lookup_noto_math_font_outparams_len_get, _mupdf.ll_fz_lookup_noto_math_font_outparams_len_set)

    def __init__(self):
        _mupdf.ll_fz_lookup_noto_math_font_outparams_swiginit(self, _mupdf.new_ll_fz_lookup_noto_math_font_outparams())
    __swig_destroy__ = _mupdf.delete_ll_fz_lookup_noto_math_font_outparams

# Register ll_fz_lookup_noto_math_font_outparams in _mupdf:
_mupdf.ll_fz_lookup_noto_math_font_outparams_swigregister(ll_fz_lookup_noto_math_font_outparams)

def ll_fz_lookup_noto_math_font_outparams_fn(outparams):
    return _mupdf.ll_fz_lookup_noto_math_font_outparams_fn(outparams)
class ll_fz_lookup_noto_music_font_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    len = property(_mupdf.ll_fz_lookup_noto_music_font_outparams_len_get, _mupdf.ll_fz_lookup_noto_music_font_outparams_len_set)

    def __init__(self):
        _mupdf.ll_fz_lookup_noto_music_font_outparams_swiginit(self, _mupdf.new_ll_fz_lookup_noto_music_font_outparams())
    __swig_destroy__ = _mupdf.delete_ll_fz_lookup_noto_music_font_outparams

# Register ll_fz_lookup_noto_music_font_outparams in _mupdf:
_mupdf.ll_fz_lookup_noto_music_font_outparams_swigregister(ll_fz_lookup_noto_music_font_outparams)

def ll_fz_lookup_noto_music_font_outparams_fn(outparams):
    return _mupdf.ll_fz_lookup_noto_music_font_outparams_fn(outparams)
class ll_fz_lookup_noto_symbol1_font_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    len = property(_mupdf.ll_fz_lookup_noto_symbol1_font_outparams_len_get, _mupdf.ll_fz_lookup_noto_symbol1_font_outparams_len_set)

    def __init__(self):
        _mupdf.ll_fz_lookup_noto_symbol1_font_outparams_swiginit(self, _mupdf.new_ll_fz_lookup_noto_symbol1_font_outparams())
    __swig_destroy__ = _mupdf.delete_ll_fz_lookup_noto_symbol1_font_outparams

# Register ll_fz_lookup_noto_symbol1_font_outparams in _mupdf:
_mupdf.ll_fz_lookup_noto_symbol1_font_outparams_swigregister(ll_fz_lookup_noto_symbol1_font_outparams)

def ll_fz_lookup_noto_symbol1_font_outparams_fn(outparams):
    return _mupdf.ll_fz_lookup_noto_symbol1_font_outparams_fn(outparams)
class ll_fz_lookup_noto_symbol2_font_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    len = property(_mupdf.ll_fz_lookup_noto_symbol2_font_outparams_len_get, _mupdf.ll_fz_lookup_noto_symbol2_font_outparams_len_set)

    def __init__(self):
        _mupdf.ll_fz_lookup_noto_symbol2_font_outparams_swiginit(self, _mupdf.new_ll_fz_lookup_noto_symbol2_font_outparams())
    __swig_destroy__ = _mupdf.delete_ll_fz_lookup_noto_symbol2_font_outparams

# Register ll_fz_lookup_noto_symbol2_font_outparams in _mupdf:
_mupdf.ll_fz_lookup_noto_symbol2_font_outparams_swigregister(ll_fz_lookup_noto_symbol2_font_outparams)

def ll_fz_lookup_noto_symbol2_font_outparams_fn(outparams):
    return _mupdf.ll_fz_lookup_noto_symbol2_font_outparams_fn(outparams)
class ll_fz_new_deflated_data_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    compressed_length = property(_mupdf.ll_fz_new_deflated_data_outparams_compressed_length_get, _mupdf.ll_fz_new_deflated_data_outparams_compressed_length_set)

    def __init__(self):
        _mupdf.ll_fz_new_deflated_data_outparams_swiginit(self, _mupdf.new_ll_fz_new_deflated_data_outparams())
    __swig_destroy__ = _mupdf.delete_ll_fz_new_deflated_data_outparams

# Register ll_fz_new_deflated_data_outparams in _mupdf:
_mupdf.ll_fz_new_deflated_data_outparams_swigregister(ll_fz_new_deflated_data_outparams)

def ll_fz_new_deflated_data_outparams_fn(source, source_length, level, outparams):
    return _mupdf.ll_fz_new_deflated_data_outparams_fn(source, source_length, level, outparams)
class ll_fz_new_deflated_data_from_buffer_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    compressed_length = property(_mupdf.ll_fz_new_deflated_data_from_buffer_outparams_compressed_length_get, _mupdf.ll_fz_new_deflated_data_from_buffer_outparams_compressed_length_set)

    def __init__(self):
        _mupdf.ll_fz_new_deflated_data_from_buffer_outparams_swiginit(self, _mupdf.new_ll_fz_new_deflated_data_from_buffer_outparams())
    __swig_destroy__ = _mupdf.delete_ll_fz_new_deflated_data_from_buffer_outparams

# Register ll_fz_new_deflated_data_from_buffer_outparams in _mupdf:
_mupdf.ll_fz_new_deflated_data_from_buffer_outparams_swigregister(ll_fz_new_deflated_data_from_buffer_outparams)

def ll_fz_new_deflated_data_from_buffer_outparams_fn(buffer, level, outparams):
    return _mupdf.ll_fz_new_deflated_data_from_buffer_outparams_fn(buffer, level, outparams)
class ll_fz_new_display_list_from_svg_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    w = property(_mupdf.ll_fz_new_display_list_from_svg_outparams_w_get, _mupdf.ll_fz_new_display_list_from_svg_outparams_w_set)
    h = property(_mupdf.ll_fz_new_display_list_from_svg_outparams_h_get, _mupdf.ll_fz_new_display_list_from_svg_outparams_h_set)

    def __init__(self):
        _mupdf.ll_fz_new_display_list_from_svg_outparams_swiginit(self, _mupdf.new_ll_fz_new_display_list_from_svg_outparams())
    __swig_destroy__ = _mupdf.delete_ll_fz_new_display_list_from_svg_outparams

# Register ll_fz_new_display_list_from_svg_outparams in _mupdf:
_mupdf.ll_fz_new_display_list_from_svg_outparams_swigregister(ll_fz_new_display_list_from_svg_outparams)

def ll_fz_new_display_list_from_svg_outparams_fn(buf, base_uri, dir, outparams):
    return _mupdf.ll_fz_new_display_list_from_svg_outparams_fn(buf, base_uri, dir, outparams)
class ll_fz_new_display_list_from_svg_xml_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    w = property(_mupdf.ll_fz_new_display_list_from_svg_xml_outparams_w_get, _mupdf.ll_fz_new_display_list_from_svg_xml_outparams_w_set)
    h = property(_mupdf.ll_fz_new_display_list_from_svg_xml_outparams_h_get, _mupdf.ll_fz_new_display_list_from_svg_xml_outparams_h_set)

    def __init__(self):
        _mupdf.ll_fz_new_display_list_from_svg_xml_outparams_swiginit(self, _mupdf.new_ll_fz_new_display_list_from_svg_xml_outparams())
    __swig_destroy__ = _mupdf.delete_ll_fz_new_display_list_from_svg_xml_outparams

# Register ll_fz_new_display_list_from_svg_xml_outparams in _mupdf:
_mupdf.ll_fz_new_display_list_from_svg_xml_outparams_swigregister(ll_fz_new_display_list_from_svg_xml_outparams)

def ll_fz_new_display_list_from_svg_xml_outparams_fn(xmldoc, xml, base_uri, dir, outparams):
    return _mupdf.ll_fz_new_display_list_from_svg_xml_outparams_fn(xmldoc, xml, base_uri, dir, outparams)
class ll_fz_new_draw_device_with_options_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    pixmap = property(_mupdf.ll_fz_new_draw_device_with_options_outparams_pixmap_get, _mupdf.ll_fz_new_draw_device_with_options_outparams_pixmap_set)

    def __init__(self):
        _mupdf.ll_fz_new_draw_device_with_options_outparams_swiginit(self, _mupdf.new_ll_fz_new_draw_device_with_options_outparams())
    __swig_destroy__ = _mupdf.delete_ll_fz_new_draw_device_with_options_outparams

# Register ll_fz_new_draw_device_with_options_outparams in _mupdf:
_mupdf.ll_fz_new_draw_device_with_options_outparams_swigregister(ll_fz_new_draw_device_with_options_outparams)

def ll_fz_new_draw_device_with_options_outparams_fn(options, mediabox, outparams):
    return _mupdf.ll_fz_new_draw_device_with_options_outparams_fn(options, mediabox, outparams)
class ll_fz_new_svg_device_with_id_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    id = property(_mupdf.ll_fz_new_svg_device_with_id_outparams_id_get, _mupdf.ll_fz_new_svg_device_with_id_outparams_id_set)

    def __init__(self):
        _mupdf.ll_fz_new_svg_device_with_id_outparams_swiginit(self, _mupdf.new_ll_fz_new_svg_device_with_id_outparams())
    __swig_destroy__ = _mupdf.delete_ll_fz_new_svg_device_with_id_outparams

# Register ll_fz_new_svg_device_with_id_outparams in _mupdf:
_mupdf.ll_fz_new_svg_device_with_id_outparams_swigregister(ll_fz_new_svg_device_with_id_outparams)

def ll_fz_new_svg_device_with_id_outparams_fn(out, page_width, page_height, text_format, reuse_images, outparams):
    return _mupdf.ll_fz_new_svg_device_with_id_outparams_fn(out, page_width, page_height, text_format, reuse_images, outparams)
class ll_fz_new_test_device_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    is_color = property(_mupdf.ll_fz_new_test_device_outparams_is_color_get, _mupdf.ll_fz_new_test_device_outparams_is_color_set)

    def __init__(self):
        _mupdf.ll_fz_new_test_device_outparams_swiginit(self, _mupdf.new_ll_fz_new_test_device_outparams())
    __swig_destroy__ = _mupdf.delete_ll_fz_new_test_device_outparams

# Register ll_fz_new_test_device_outparams in _mupdf:
_mupdf.ll_fz_new_test_device_outparams_swigregister(ll_fz_new_test_device_outparams)

def ll_fz_new_test_device_outparams_fn(threshold, options, passthrough, outparams):
    return _mupdf.ll_fz_new_test_device_outparams_fn(threshold, options, passthrough, outparams)
class ll_fz_open_image_decomp_stream_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    l2factor = property(_mupdf.ll_fz_open_image_decomp_stream_outparams_l2factor_get, _mupdf.ll_fz_open_image_decomp_stream_outparams_l2factor_set)

    def __init__(self):
        _mupdf.ll_fz_open_image_decomp_stream_outparams_swiginit(self, _mupdf.new_ll_fz_open_image_decomp_stream_outparams())
    __swig_destroy__ = _mupdf.delete_ll_fz_open_image_decomp_stream_outparams

# Register ll_fz_open_image_decomp_stream_outparams in _mupdf:
_mupdf.ll_fz_open_image_decomp_stream_outparams_swigregister(ll_fz_open_image_decomp_stream_outparams)

def ll_fz_open_image_decomp_stream_outparams_fn(arg_0, arg_1, outparams):
    return _mupdf.ll_fz_open_image_decomp_stream_outparams_fn(arg_0, arg_1, outparams)
class ll_fz_open_image_decomp_stream_from_buffer_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    l2factor = property(_mupdf.ll_fz_open_image_decomp_stream_from_buffer_outparams_l2factor_get, _mupdf.ll_fz_open_image_decomp_stream_from_buffer_outparams_l2factor_set)

    def __init__(self):
        _mupdf.ll_fz_open_image_decomp_stream_from_buffer_outparams_swiginit(self, _mupdf.new_ll_fz_open_image_decomp_stream_from_buffer_outparams())
    __swig_destroy__ = _mupdf.delete_ll_fz_open_image_decomp_stream_from_buffer_outparams

# Register ll_fz_open_image_decomp_stream_from_buffer_outparams in _mupdf:
_mupdf.ll_fz_open_image_decomp_stream_from_buffer_outparams_swigregister(ll_fz_open_image_decomp_stream_from_buffer_outparams)

def ll_fz_open_image_decomp_stream_from_buffer_outparams_fn(arg_0, outparams):
    return _mupdf.ll_fz_open_image_decomp_stream_from_buffer_outparams_fn(arg_0, outparams)
class ll_fz_page_presentation_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    duration = property(_mupdf.ll_fz_page_presentation_outparams_duration_get, _mupdf.ll_fz_page_presentation_outparams_duration_set)

    def __init__(self):
        _mupdf.ll_fz_page_presentation_outparams_swiginit(self, _mupdf.new_ll_fz_page_presentation_outparams())
    __swig_destroy__ = _mupdf.delete_ll_fz_page_presentation_outparams

# Register ll_fz_page_presentation_outparams in _mupdf:
_mupdf.ll_fz_page_presentation_outparams_swigregister(ll_fz_page_presentation_outparams)

def ll_fz_page_presentation_outparams_fn(page, transition, outparams):
    return _mupdf.ll_fz_page_presentation_outparams_fn(page, transition, outparams)
class ll_fz_paint_shade_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    cache = property(_mupdf.ll_fz_paint_shade_outparams_cache_get, _mupdf.ll_fz_paint_shade_outparams_cache_set)

    def __init__(self):
        _mupdf.ll_fz_paint_shade_outparams_swiginit(self, _mupdf.new_ll_fz_paint_shade_outparams())
    __swig_destroy__ = _mupdf.delete_ll_fz_paint_shade_outparams

# Register ll_fz_paint_shade_outparams in _mupdf:
_mupdf.ll_fz_paint_shade_outparams_swigregister(ll_fz_paint_shade_outparams)

def ll_fz_paint_shade_outparams_fn(shade, override_cs, ctm, dest, color_params, bbox, eop, outparams):
    return _mupdf.ll_fz_paint_shade_outparams_fn(shade, override_cs, ctm, dest, color_params, bbox, eop, outparams)
class ll_fz_parse_page_range_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    a = property(_mupdf.ll_fz_parse_page_range_outparams_a_get, _mupdf.ll_fz_parse_page_range_outparams_a_set)
    b = property(_mupdf.ll_fz_parse_page_range_outparams_b_get, _mupdf.ll_fz_parse_page_range_outparams_b_set)

    def __init__(self):
        _mupdf.ll_fz_parse_page_range_outparams_swiginit(self, _mupdf.new_ll_fz_parse_page_range_outparams())
    __swig_destroy__ = _mupdf.delete_ll_fz_parse_page_range_outparams

# Register ll_fz_parse_page_range_outparams in _mupdf:
_mupdf.ll_fz_parse_page_range_outparams_swigregister(ll_fz_parse_page_range_outparams)

def ll_fz_parse_page_range_outparams_fn(s, n, outparams):
    return _mupdf.ll_fz_parse_page_range_outparams_fn(s, n, outparams)
class ll_fz_read_best_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    truncated = property(_mupdf.ll_fz_read_best_outparams_truncated_get, _mupdf.ll_fz_read_best_outparams_truncated_set)

    def __init__(self):
        _mupdf.ll_fz_read_best_outparams_swiginit(self, _mupdf.new_ll_fz_read_best_outparams())
    __swig_destroy__ = _mupdf.delete_ll_fz_read_best_outparams

# Register ll_fz_read_best_outparams in _mupdf:
_mupdf.ll_fz_read_best_outparams_swigregister(ll_fz_read_best_outparams)

def ll_fz_read_best_outparams_fn(stm, initial, worst_case, outparams):
    return _mupdf.ll_fz_read_best_outparams_fn(stm, initial, worst_case, outparams)
class ll_fz_resolve_link_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    xp = property(_mupdf.ll_fz_resolve_link_outparams_xp_get, _mupdf.ll_fz_resolve_link_outparams_xp_set)
    yp = property(_mupdf.ll_fz_resolve_link_outparams_yp_get, _mupdf.ll_fz_resolve_link_outparams_yp_set)

    def __init__(self):
        _mupdf.ll_fz_resolve_link_outparams_swiginit(self, _mupdf.new_ll_fz_resolve_link_outparams())
    __swig_destroy__ = _mupdf.delete_ll_fz_resolve_link_outparams

# Register ll_fz_resolve_link_outparams in _mupdf:
_mupdf.ll_fz_resolve_link_outparams_swigregister(ll_fz_resolve_link_outparams)

def ll_fz_resolve_link_outparams_fn(doc, uri, outparams):
    return _mupdf.ll_fz_resolve_link_outparams_fn(doc, uri, outparams)
class ll_fz_search_chapter_page_number_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    hit_mark = property(_mupdf.ll_fz_search_chapter_page_number_outparams_hit_mark_get, _mupdf.ll_fz_search_chapter_page_number_outparams_hit_mark_set)

    def __init__(self):
        _mupdf.ll_fz_search_chapter_page_number_outparams_swiginit(self, _mupdf.new_ll_fz_search_chapter_page_number_outparams())
    __swig_destroy__ = _mupdf.delete_ll_fz_search_chapter_page_number_outparams

# Register ll_fz_search_chapter_page_number_outparams in _mupdf:
_mupdf.ll_fz_search_chapter_page_number_outparams_swigregister(ll_fz_search_chapter_page_number_outparams)

def ll_fz_search_chapter_page_number_outparams_fn(doc, chapter, page, needle, hit_bbox, hit_max, outparams):
    return _mupdf.ll_fz_search_chapter_page_number_outparams_fn(doc, chapter, page, needle, hit_bbox, hit_max, outparams)
class ll_fz_search_display_list_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    hit_mark = property(_mupdf.ll_fz_search_display_list_outparams_hit_mark_get, _mupdf.ll_fz_search_display_list_outparams_hit_mark_set)

    def __init__(self):
        _mupdf.ll_fz_search_display_list_outparams_swiginit(self, _mupdf.new_ll_fz_search_display_list_outparams())
    __swig_destroy__ = _mupdf.delete_ll_fz_search_display_list_outparams

# Register ll_fz_search_display_list_outparams in _mupdf:
_mupdf.ll_fz_search_display_list_outparams_swigregister(ll_fz_search_display_list_outparams)

def ll_fz_search_display_list_outparams_fn(list, needle, hit_bbox, hit_max, outparams):
    return _mupdf.ll_fz_search_display_list_outparams_fn(list, needle, hit_bbox, hit_max, outparams)
class ll_fz_search_page_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    hit_mark = property(_mupdf.ll_fz_search_page_outparams_hit_mark_get, _mupdf.ll_fz_search_page_outparams_hit_mark_set)

    def __init__(self):
        _mupdf.ll_fz_search_page_outparams_swiginit(self, _mupdf.new_ll_fz_search_page_outparams())
    __swig_destroy__ = _mupdf.delete_ll_fz_search_page_outparams

# Register ll_fz_search_page_outparams in _mupdf:
_mupdf.ll_fz_search_page_outparams_swigregister(ll_fz_search_page_outparams)

def ll_fz_search_page_outparams_fn(page, needle, hit_bbox, hit_max, outparams):
    return _mupdf.ll_fz_search_page_outparams_fn(page, needle, hit_bbox, hit_max, outparams)
class ll_fz_search_page_number_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    hit_mark = property(_mupdf.ll_fz_search_page_number_outparams_hit_mark_get, _mupdf.ll_fz_search_page_number_outparams_hit_mark_set)

    def __init__(self):
        _mupdf.ll_fz_search_page_number_outparams_swiginit(self, _mupdf.new_ll_fz_search_page_number_outparams())
    __swig_destroy__ = _mupdf.delete_ll_fz_search_page_number_outparams

# Register ll_fz_search_page_number_outparams in _mupdf:
_mupdf.ll_fz_search_page_number_outparams_swigregister(ll_fz_search_page_number_outparams)

def ll_fz_search_page_number_outparams_fn(doc, number, needle, hit_bbox, hit_max, outparams):
    return _mupdf.ll_fz_search_page_number_outparams_fn(doc, number, needle, hit_bbox, hit_max, outparams)
class ll_fz_search_stext_page_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    hit_mark = property(_mupdf.ll_fz_search_stext_page_outparams_hit_mark_get, _mupdf.ll_fz_search_stext_page_outparams_hit_mark_set)

    def __init__(self):
        _mupdf.ll_fz_search_stext_page_outparams_swiginit(self, _mupdf.new_ll_fz_search_stext_page_outparams())
    __swig_destroy__ = _mupdf.delete_ll_fz_search_stext_page_outparams

# Register ll_fz_search_stext_page_outparams in _mupdf:
_mupdf.ll_fz_search_stext_page_outparams_swigregister(ll_fz_search_stext_page_outparams)

def ll_fz_search_stext_page_outparams_fn(text, needle, hit_bbox, hit_max, outparams):
    return _mupdf.ll_fz_search_stext_page_outparams_fn(text, needle, hit_bbox, hit_max, outparams)
class ll_fz_separation_equivalent_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    dst_color = property(_mupdf.ll_fz_separation_equivalent_outparams_dst_color_get, _mupdf.ll_fz_separation_equivalent_outparams_dst_color_set)

    def __init__(self):
        _mupdf.ll_fz_separation_equivalent_outparams_swiginit(self, _mupdf.new_ll_fz_separation_equivalent_outparams())
    __swig_destroy__ = _mupdf.delete_ll_fz_separation_equivalent_outparams

# Register ll_fz_separation_equivalent_outparams in _mupdf:
_mupdf.ll_fz_separation_equivalent_outparams_swigregister(ll_fz_separation_equivalent_outparams)

def ll_fz_separation_equivalent_outparams_fn(seps, idx, dst_cs, prf, color_params, outparams):
    return _mupdf.ll_fz_separation_equivalent_outparams_fn(seps, idx, dst_cs, prf, color_params, outparams)
class ll_fz_store_scavenge_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    phase = property(_mupdf.ll_fz_store_scavenge_outparams_phase_get, _mupdf.ll_fz_store_scavenge_outparams_phase_set)

    def __init__(self):
        _mupdf.ll_fz_store_scavenge_outparams_swiginit(self, _mupdf.new_ll_fz_store_scavenge_outparams())
    __swig_destroy__ = _mupdf.delete_ll_fz_store_scavenge_outparams

# Register ll_fz_store_scavenge_outparams in _mupdf:
_mupdf.ll_fz_store_scavenge_outparams_swigregister(ll_fz_store_scavenge_outparams)

def ll_fz_store_scavenge_outparams_fn(size, outparams):
    return _mupdf.ll_fz_store_scavenge_outparams_fn(size, outparams)
class ll_fz_store_scavenge_external_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    phase = property(_mupdf.ll_fz_store_scavenge_external_outparams_phase_get, _mupdf.ll_fz_store_scavenge_external_outparams_phase_set)

    def __init__(self):
        _mupdf.ll_fz_store_scavenge_external_outparams_swiginit(self, _mupdf.new_ll_fz_store_scavenge_external_outparams())
    __swig_destroy__ = _mupdf.delete_ll_fz_store_scavenge_external_outparams

# Register ll_fz_store_scavenge_external_outparams in _mupdf:
_mupdf.ll_fz_store_scavenge_external_outparams_swigregister(ll_fz_store_scavenge_external_outparams)

def ll_fz_store_scavenge_external_outparams_fn(size, outparams):
    return _mupdf.ll_fz_store_scavenge_external_outparams_fn(size, outparams)
class ll_fz_strsep_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    stringp = property(_mupdf.ll_fz_strsep_outparams_stringp_get, _mupdf.ll_fz_strsep_outparams_stringp_set)

    def __init__(self):
        _mupdf.ll_fz_strsep_outparams_swiginit(self, _mupdf.new_ll_fz_strsep_outparams())
    __swig_destroy__ = _mupdf.delete_ll_fz_strsep_outparams

# Register ll_fz_strsep_outparams in _mupdf:
_mupdf.ll_fz_strsep_outparams_swigregister(ll_fz_strsep_outparams)

def ll_fz_strsep_outparams_fn(delim, outparams):
    return _mupdf.ll_fz_strsep_outparams_fn(delim, outparams)
class ll_fz_strtof_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    es = property(_mupdf.ll_fz_strtof_outparams_es_get, _mupdf.ll_fz_strtof_outparams_es_set)

    def __init__(self):
        _mupdf.ll_fz_strtof_outparams_swiginit(self, _mupdf.new_ll_fz_strtof_outparams())
    __swig_destroy__ = _mupdf.delete_ll_fz_strtof_outparams

# Register ll_fz_strtof_outparams in _mupdf:
_mupdf.ll_fz_strtof_outparams_swigregister(ll_fz_strtof_outparams)

def ll_fz_strtof_outparams_fn(s, outparams):
    return _mupdf.ll_fz_strtof_outparams_fn(s, outparams)
class ll_fz_subset_cff_for_gids_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    gids = property(_mupdf.ll_fz_subset_cff_for_gids_outparams_gids_get, _mupdf.ll_fz_subset_cff_for_gids_outparams_gids_set)

    def __init__(self):
        _mupdf.ll_fz_subset_cff_for_gids_outparams_swiginit(self, _mupdf.new_ll_fz_subset_cff_for_gids_outparams())
    __swig_destroy__ = _mupdf.delete_ll_fz_subset_cff_for_gids_outparams

# Register ll_fz_subset_cff_for_gids_outparams in _mupdf:
_mupdf.ll_fz_subset_cff_for_gids_outparams_swigregister(ll_fz_subset_cff_for_gids_outparams)

def ll_fz_subset_cff_for_gids_outparams_fn(orig, num_gids, symbolic, cidfont, outparams):
    return _mupdf.ll_fz_subset_cff_for_gids_outparams_fn(orig, num_gids, symbolic, cidfont, outparams)
class ll_fz_subset_ttf_for_gids_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    gids = property(_mupdf.ll_fz_subset_ttf_for_gids_outparams_gids_get, _mupdf.ll_fz_subset_ttf_for_gids_outparams_gids_set)

    def __init__(self):
        _mupdf.ll_fz_subset_ttf_for_gids_outparams_swiginit(self, _mupdf.new_ll_fz_subset_ttf_for_gids_outparams())
    __swig_destroy__ = _mupdf.delete_ll_fz_subset_ttf_for_gids_outparams

# Register ll_fz_subset_ttf_for_gids_outparams in _mupdf:
_mupdf.ll_fz_subset_ttf_for_gids_outparams_swigregister(ll_fz_subset_ttf_for_gids_outparams)

def ll_fz_subset_ttf_for_gids_outparams_fn(orig, num_gids, symbolic, cidfont, outparams):
    return _mupdf.ll_fz_subset_ttf_for_gids_outparams_fn(orig, num_gids, symbolic, cidfont, outparams)
class ll_fz_warning_callback_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    user = property(_mupdf.ll_fz_warning_callback_outparams_user_get, _mupdf.ll_fz_warning_callback_outparams_user_set)

    def __init__(self):
        _mupdf.ll_fz_warning_callback_outparams_swiginit(self, _mupdf.new_ll_fz_warning_callback_outparams())
    __swig_destroy__ = _mupdf.delete_ll_fz_warning_callback_outparams

# Register ll_fz_warning_callback_outparams in _mupdf:
_mupdf.ll_fz_warning_callback_outparams_swigregister(ll_fz_warning_callback_outparams)

def ll_fz_warning_callback_outparams_fn(outparams):
    return _mupdf.ll_fz_warning_callback_outparams_fn(outparams)
class ll_pdf_annot_MK_BC_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    n = property(_mupdf.ll_pdf_annot_MK_BC_outparams_n_get, _mupdf.ll_pdf_annot_MK_BC_outparams_n_set)

    def __init__(self):
        _mupdf.ll_pdf_annot_MK_BC_outparams_swiginit(self, _mupdf.new_ll_pdf_annot_MK_BC_outparams())
    __swig_destroy__ = _mupdf.delete_ll_pdf_annot_MK_BC_outparams

# Register ll_pdf_annot_MK_BC_outparams in _mupdf:
_mupdf.ll_pdf_annot_MK_BC_outparams_swigregister(ll_pdf_annot_MK_BC_outparams)

def ll_pdf_annot_MK_BC_outparams_fn(annot, color, outparams):
    return _mupdf.ll_pdf_annot_MK_BC_outparams_fn(annot, color, outparams)
class ll_pdf_annot_MK_BG_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    n = property(_mupdf.ll_pdf_annot_MK_BG_outparams_n_get, _mupdf.ll_pdf_annot_MK_BG_outparams_n_set)

    def __init__(self):
        _mupdf.ll_pdf_annot_MK_BG_outparams_swiginit(self, _mupdf.new_ll_pdf_annot_MK_BG_outparams())
    __swig_destroy__ = _mupdf.delete_ll_pdf_annot_MK_BG_outparams

# Register ll_pdf_annot_MK_BG_outparams in _mupdf:
_mupdf.ll_pdf_annot_MK_BG_outparams_swigregister(ll_pdf_annot_MK_BG_outparams)

def ll_pdf_annot_MK_BG_outparams_fn(annot, color, outparams):
    return _mupdf.ll_pdf_annot_MK_BG_outparams_fn(annot, color, outparams)
class ll_pdf_annot_color_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    n = property(_mupdf.ll_pdf_annot_color_outparams_n_get, _mupdf.ll_pdf_annot_color_outparams_n_set)

    def __init__(self):
        _mupdf.ll_pdf_annot_color_outparams_swiginit(self, _mupdf.new_ll_pdf_annot_color_outparams())
    __swig_destroy__ = _mupdf.delete_ll_pdf_annot_color_outparams

# Register ll_pdf_annot_color_outparams in _mupdf:
_mupdf.ll_pdf_annot_color_outparams_swigregister(ll_pdf_annot_color_outparams)

def ll_pdf_annot_color_outparams_fn(annot, color, outparams):
    return _mupdf.ll_pdf_annot_color_outparams_fn(annot, color, outparams)
class ll_pdf_annot_default_appearance_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    font = property(_mupdf.ll_pdf_annot_default_appearance_outparams_font_get, _mupdf.ll_pdf_annot_default_appearance_outparams_font_set)
    size = property(_mupdf.ll_pdf_annot_default_appearance_outparams_size_get, _mupdf.ll_pdf_annot_default_appearance_outparams_size_set)
    n = property(_mupdf.ll_pdf_annot_default_appearance_outparams_n_get, _mupdf.ll_pdf_annot_default_appearance_outparams_n_set)

    def __init__(self):
        _mupdf.ll_pdf_annot_default_appearance_outparams_swiginit(self, _mupdf.new_ll_pdf_annot_default_appearance_outparams())
    __swig_destroy__ = _mupdf.delete_ll_pdf_annot_default_appearance_outparams

# Register ll_pdf_annot_default_appearance_outparams in _mupdf:
_mupdf.ll_pdf_annot_default_appearance_outparams_swigregister(ll_pdf_annot_default_appearance_outparams)

def ll_pdf_annot_default_appearance_outparams_fn(annot, color, outparams):
    return _mupdf.ll_pdf_annot_default_appearance_outparams_fn(annot, color, outparams)
class ll_pdf_annot_interior_color_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    n = property(_mupdf.ll_pdf_annot_interior_color_outparams_n_get, _mupdf.ll_pdf_annot_interior_color_outparams_n_set)

    def __init__(self):
        _mupdf.ll_pdf_annot_interior_color_outparams_swiginit(self, _mupdf.new_ll_pdf_annot_interior_color_outparams())
    __swig_destroy__ = _mupdf.delete_ll_pdf_annot_interior_color_outparams

# Register ll_pdf_annot_interior_color_outparams in _mupdf:
_mupdf.ll_pdf_annot_interior_color_outparams_swigregister(ll_pdf_annot_interior_color_outparams)

def ll_pdf_annot_interior_color_outparams_fn(annot, color, outparams):
    return _mupdf.ll_pdf_annot_interior_color_outparams_fn(annot, color, outparams)
class ll_pdf_annot_line_ending_styles_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    start_style = property(_mupdf.ll_pdf_annot_line_ending_styles_outparams_start_style_get, _mupdf.ll_pdf_annot_line_ending_styles_outparams_start_style_set)
    end_style = property(_mupdf.ll_pdf_annot_line_ending_styles_outparams_end_style_get, _mupdf.ll_pdf_annot_line_ending_styles_outparams_end_style_set)

    def __init__(self):
        _mupdf.ll_pdf_annot_line_ending_styles_outparams_swiginit(self, _mupdf.new_ll_pdf_annot_line_ending_styles_outparams())
    __swig_destroy__ = _mupdf.delete_ll_pdf_annot_line_ending_styles_outparams

# Register ll_pdf_annot_line_ending_styles_outparams in _mupdf:
_mupdf.ll_pdf_annot_line_ending_styles_outparams_swigregister(ll_pdf_annot_line_ending_styles_outparams)

def ll_pdf_annot_line_ending_styles_outparams_fn(annot, outparams):
    return _mupdf.ll_pdf_annot_line_ending_styles_outparams_fn(annot, outparams)
class ll_pdf_array_get_string_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    sizep = property(_mupdf.ll_pdf_array_get_string_outparams_sizep_get, _mupdf.ll_pdf_array_get_string_outparams_sizep_set)

    def __init__(self):
        _mupdf.ll_pdf_array_get_string_outparams_swiginit(self, _mupdf.new_ll_pdf_array_get_string_outparams())
    __swig_destroy__ = _mupdf.delete_ll_pdf_array_get_string_outparams

# Register ll_pdf_array_get_string_outparams in _mupdf:
_mupdf.ll_pdf_array_get_string_outparams_swigregister(ll_pdf_array_get_string_outparams)

def ll_pdf_array_get_string_outparams_fn(array, index, outparams):
    return _mupdf.ll_pdf_array_get_string_outparams_fn(array, index, outparams)
class ll_pdf_count_q_balance_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    prepend = property(_mupdf.ll_pdf_count_q_balance_outparams_prepend_get, _mupdf.ll_pdf_count_q_balance_outparams_prepend_set)
    append = property(_mupdf.ll_pdf_count_q_balance_outparams_append_get, _mupdf.ll_pdf_count_q_balance_outparams_append_set)

    def __init__(self):
        _mupdf.ll_pdf_count_q_balance_outparams_swiginit(self, _mupdf.new_ll_pdf_count_q_balance_outparams())
    __swig_destroy__ = _mupdf.delete_ll_pdf_count_q_balance_outparams

# Register ll_pdf_count_q_balance_outparams in _mupdf:
_mupdf.ll_pdf_count_q_balance_outparams_swigregister(ll_pdf_count_q_balance_outparams)

def ll_pdf_count_q_balance_outparams_fn(doc, res, stm, outparams):
    return _mupdf.ll_pdf_count_q_balance_outparams_fn(doc, res, stm, outparams)
class ll_pdf_decode_cmap_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    cpt = property(_mupdf.ll_pdf_decode_cmap_outparams_cpt_get, _mupdf.ll_pdf_decode_cmap_outparams_cpt_set)

    def __init__(self):
        _mupdf.ll_pdf_decode_cmap_outparams_swiginit(self, _mupdf.new_ll_pdf_decode_cmap_outparams())
    __swig_destroy__ = _mupdf.delete_ll_pdf_decode_cmap_outparams

# Register ll_pdf_decode_cmap_outparams in _mupdf:
_mupdf.ll_pdf_decode_cmap_outparams_swigregister(ll_pdf_decode_cmap_outparams)

def ll_pdf_decode_cmap_outparams_fn(cmap, s, e, outparams):
    return _mupdf.ll_pdf_decode_cmap_outparams_fn(cmap, s, e, outparams)
class ll_pdf_dict_get_inheritable_string_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    sizep = property(_mupdf.ll_pdf_dict_get_inheritable_string_outparams_sizep_get, _mupdf.ll_pdf_dict_get_inheritable_string_outparams_sizep_set)

    def __init__(self):
        _mupdf.ll_pdf_dict_get_inheritable_string_outparams_swiginit(self, _mupdf.new_ll_pdf_dict_get_inheritable_string_outparams())
    __swig_destroy__ = _mupdf.delete_ll_pdf_dict_get_inheritable_string_outparams

# Register ll_pdf_dict_get_inheritable_string_outparams in _mupdf:
_mupdf.ll_pdf_dict_get_inheritable_string_outparams_swigregister(ll_pdf_dict_get_inheritable_string_outparams)

def ll_pdf_dict_get_inheritable_string_outparams_fn(dict, key, outparams):
    return _mupdf.ll_pdf_dict_get_inheritable_string_outparams_fn(dict, key, outparams)
class ll_pdf_dict_get_put_drop_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    old_val = property(_mupdf.ll_pdf_dict_get_put_drop_outparams_old_val_get, _mupdf.ll_pdf_dict_get_put_drop_outparams_old_val_set)

    def __init__(self):
        _mupdf.ll_pdf_dict_get_put_drop_outparams_swiginit(self, _mupdf.new_ll_pdf_dict_get_put_drop_outparams())
    __swig_destroy__ = _mupdf.delete_ll_pdf_dict_get_put_drop_outparams

# Register ll_pdf_dict_get_put_drop_outparams in _mupdf:
_mupdf.ll_pdf_dict_get_put_drop_outparams_swigregister(ll_pdf_dict_get_put_drop_outparams)

def ll_pdf_dict_get_put_drop_outparams_fn(dict, key, val, outparams):
    return _mupdf.ll_pdf_dict_get_put_drop_outparams_fn(dict, key, val, outparams)
class ll_pdf_dict_get_string_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    sizep = property(_mupdf.ll_pdf_dict_get_string_outparams_sizep_get, _mupdf.ll_pdf_dict_get_string_outparams_sizep_set)

    def __init__(self):
        _mupdf.ll_pdf_dict_get_string_outparams_swiginit(self, _mupdf.new_ll_pdf_dict_get_string_outparams())
    __swig_destroy__ = _mupdf.delete_ll_pdf_dict_get_string_outparams

# Register ll_pdf_dict_get_string_outparams in _mupdf:
_mupdf.ll_pdf_dict_get_string_outparams_swigregister(ll_pdf_dict_get_string_outparams)

def ll_pdf_dict_get_string_outparams_fn(dict, key, outparams):
    return _mupdf.ll_pdf_dict_get_string_outparams_fn(dict, key, outparams)
class ll_pdf_edit_text_field_value_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    selStart = property(_mupdf.ll_pdf_edit_text_field_value_outparams_selStart_get, _mupdf.ll_pdf_edit_text_field_value_outparams_selStart_set)
    selEnd = property(_mupdf.ll_pdf_edit_text_field_value_outparams_selEnd_get, _mupdf.ll_pdf_edit_text_field_value_outparams_selEnd_set)
    newvalue = property(_mupdf.ll_pdf_edit_text_field_value_outparams_newvalue_get, _mupdf.ll_pdf_edit_text_field_value_outparams_newvalue_set)

    def __init__(self):
        _mupdf.ll_pdf_edit_text_field_value_outparams_swiginit(self, _mupdf.new_ll_pdf_edit_text_field_value_outparams())
    __swig_destroy__ = _mupdf.delete_ll_pdf_edit_text_field_value_outparams

# Register ll_pdf_edit_text_field_value_outparams in _mupdf:
_mupdf.ll_pdf_edit_text_field_value_outparams_swigregister(ll_pdf_edit_text_field_value_outparams)

def ll_pdf_edit_text_field_value_outparams_fn(widget, value, change, outparams):
    return _mupdf.ll_pdf_edit_text_field_value_outparams_fn(widget, value, change, outparams)
class ll_pdf_eval_function_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    out = property(_mupdf.ll_pdf_eval_function_outparams_out_get, _mupdf.ll_pdf_eval_function_outparams_out_set)

    def __init__(self):
        _mupdf.ll_pdf_eval_function_outparams_swiginit(self, _mupdf.new_ll_pdf_eval_function_outparams())
    __swig_destroy__ = _mupdf.delete_ll_pdf_eval_function_outparams

# Register ll_pdf_eval_function_outparams in _mupdf:
_mupdf.ll_pdf_eval_function_outparams_swigregister(ll_pdf_eval_function_outparams)

def ll_pdf_eval_function_outparams_fn(func, _in, inlen, outlen, outparams):
    return _mupdf.ll_pdf_eval_function_outparams_fn(func, _in, inlen, outlen, outparams)
class ll_pdf_field_event_validate_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    newvalue = property(_mupdf.ll_pdf_field_event_validate_outparams_newvalue_get, _mupdf.ll_pdf_field_event_validate_outparams_newvalue_set)

    def __init__(self):
        _mupdf.ll_pdf_field_event_validate_outparams_swiginit(self, _mupdf.new_ll_pdf_field_event_validate_outparams())
    __swig_destroy__ = _mupdf.delete_ll_pdf_field_event_validate_outparams

# Register ll_pdf_field_event_validate_outparams in _mupdf:
_mupdf.ll_pdf_field_event_validate_outparams_swigregister(ll_pdf_field_event_validate_outparams)

def ll_pdf_field_event_validate_outparams_fn(doc, field, value, outparams):
    return _mupdf.ll_pdf_field_event_validate_outparams_fn(doc, field, value, outparams)
class ll_pdf_js_event_result_validate_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    newvalue = property(_mupdf.ll_pdf_js_event_result_validate_outparams_newvalue_get, _mupdf.ll_pdf_js_event_result_validate_outparams_newvalue_set)

    def __init__(self):
        _mupdf.ll_pdf_js_event_result_validate_outparams_swiginit(self, _mupdf.new_ll_pdf_js_event_result_validate_outparams())
    __swig_destroy__ = _mupdf.delete_ll_pdf_js_event_result_validate_outparams

# Register ll_pdf_js_event_result_validate_outparams in _mupdf:
_mupdf.ll_pdf_js_event_result_validate_outparams_swigregister(ll_pdf_js_event_result_validate_outparams)

def ll_pdf_js_event_result_validate_outparams_fn(js, outparams):
    return _mupdf.ll_pdf_js_event_result_validate_outparams_fn(js, outparams)
class ll_pdf_js_execute_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    result = property(_mupdf.ll_pdf_js_execute_outparams_result_get, _mupdf.ll_pdf_js_execute_outparams_result_set)

    def __init__(self):
        _mupdf.ll_pdf_js_execute_outparams_swiginit(self, _mupdf.new_ll_pdf_js_execute_outparams())
    __swig_destroy__ = _mupdf.delete_ll_pdf_js_execute_outparams

# Register ll_pdf_js_execute_outparams in _mupdf:
_mupdf.ll_pdf_js_execute_outparams_swigregister(ll_pdf_js_execute_outparams)

def ll_pdf_js_execute_outparams_fn(js, name, code, outparams):
    return _mupdf.ll_pdf_js_execute_outparams_fn(js, name, code, outparams)
class ll_pdf_load_encoding_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    estrings = property(_mupdf.ll_pdf_load_encoding_outparams_estrings_get, _mupdf.ll_pdf_load_encoding_outparams_estrings_set)

    def __init__(self):
        _mupdf.ll_pdf_load_encoding_outparams_swiginit(self, _mupdf.new_ll_pdf_load_encoding_outparams())
    __swig_destroy__ = _mupdf.delete_ll_pdf_load_encoding_outparams

# Register ll_pdf_load_encoding_outparams in _mupdf:
_mupdf.ll_pdf_load_encoding_outparams_swigregister(ll_pdf_load_encoding_outparams)

def ll_pdf_load_encoding_outparams_fn(encoding, outparams):
    return _mupdf.ll_pdf_load_encoding_outparams_fn(encoding, outparams)
class ll_pdf_load_to_unicode_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    strings = property(_mupdf.ll_pdf_load_to_unicode_outparams_strings_get, _mupdf.ll_pdf_load_to_unicode_outparams_strings_set)

    def __init__(self):
        _mupdf.ll_pdf_load_to_unicode_outparams_swiginit(self, _mupdf.new_ll_pdf_load_to_unicode_outparams())
    __swig_destroy__ = _mupdf.delete_ll_pdf_load_to_unicode_outparams

# Register ll_pdf_load_to_unicode_outparams in _mupdf:
_mupdf.ll_pdf_load_to_unicode_outparams_swigregister(ll_pdf_load_to_unicode_outparams)

def ll_pdf_load_to_unicode_outparams_fn(doc, font, collection, cmapstm, outparams):
    return _mupdf.ll_pdf_load_to_unicode_outparams_fn(doc, font, collection, cmapstm, outparams)
class ll_pdf_lookup_cmap_full_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    out = property(_mupdf.ll_pdf_lookup_cmap_full_outparams_out_get, _mupdf.ll_pdf_lookup_cmap_full_outparams_out_set)

    def __init__(self):
        _mupdf.ll_pdf_lookup_cmap_full_outparams_swiginit(self, _mupdf.new_ll_pdf_lookup_cmap_full_outparams())
    __swig_destroy__ = _mupdf.delete_ll_pdf_lookup_cmap_full_outparams

# Register ll_pdf_lookup_cmap_full_outparams in _mupdf:
_mupdf.ll_pdf_lookup_cmap_full_outparams_swigregister(ll_pdf_lookup_cmap_full_outparams)

def ll_pdf_lookup_cmap_full_outparams_fn(cmap, cpt, outparams):
    return _mupdf.ll_pdf_lookup_cmap_full_outparams_fn(cmap, cpt, outparams)
class ll_pdf_lookup_page_loc_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    parentp = property(_mupdf.ll_pdf_lookup_page_loc_outparams_parentp_get, _mupdf.ll_pdf_lookup_page_loc_outparams_parentp_set)
    indexp = property(_mupdf.ll_pdf_lookup_page_loc_outparams_indexp_get, _mupdf.ll_pdf_lookup_page_loc_outparams_indexp_set)

    def __init__(self):
        _mupdf.ll_pdf_lookup_page_loc_outparams_swiginit(self, _mupdf.new_ll_pdf_lookup_page_loc_outparams())
    __swig_destroy__ = _mupdf.delete_ll_pdf_lookup_page_loc_outparams

# Register ll_pdf_lookup_page_loc_outparams in _mupdf:
_mupdf.ll_pdf_lookup_page_loc_outparams_swigregister(ll_pdf_lookup_page_loc_outparams)

def ll_pdf_lookup_page_loc_outparams_fn(doc, needle, outparams):
    return _mupdf.ll_pdf_lookup_page_loc_outparams_fn(doc, needle, outparams)
class ll_pdf_lookup_substitute_font_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    len = property(_mupdf.ll_pdf_lookup_substitute_font_outparams_len_get, _mupdf.ll_pdf_lookup_substitute_font_outparams_len_set)

    def __init__(self):
        _mupdf.ll_pdf_lookup_substitute_font_outparams_swiginit(self, _mupdf.new_ll_pdf_lookup_substitute_font_outparams())
    __swig_destroy__ = _mupdf.delete_ll_pdf_lookup_substitute_font_outparams

# Register ll_pdf_lookup_substitute_font_outparams in _mupdf:
_mupdf.ll_pdf_lookup_substitute_font_outparams_swigregister(ll_pdf_lookup_substitute_font_outparams)

def ll_pdf_lookup_substitute_font_outparams_fn(mono, serif, bold, italic, outparams):
    return _mupdf.ll_pdf_lookup_substitute_font_outparams_fn(mono, serif, bold, italic, outparams)
class ll_pdf_map_one_to_many_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    many = property(_mupdf.ll_pdf_map_one_to_many_outparams_many_get, _mupdf.ll_pdf_map_one_to_many_outparams_many_set)

    def __init__(self):
        _mupdf.ll_pdf_map_one_to_many_outparams_swiginit(self, _mupdf.new_ll_pdf_map_one_to_many_outparams())
    __swig_destroy__ = _mupdf.delete_ll_pdf_map_one_to_many_outparams

# Register ll_pdf_map_one_to_many_outparams in _mupdf:
_mupdf.ll_pdf_map_one_to_many_outparams_swigregister(ll_pdf_map_one_to_many_outparams)

def ll_pdf_map_one_to_many_outparams_fn(cmap, one, len, outparams):
    return _mupdf.ll_pdf_map_one_to_many_outparams_fn(cmap, one, len, outparams)
class ll_pdf_obj_memo_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    memo = property(_mupdf.ll_pdf_obj_memo_outparams_memo_get, _mupdf.ll_pdf_obj_memo_outparams_memo_set)

    def __init__(self):
        _mupdf.ll_pdf_obj_memo_outparams_swiginit(self, _mupdf.new_ll_pdf_obj_memo_outparams())
    __swig_destroy__ = _mupdf.delete_ll_pdf_obj_memo_outparams

# Register ll_pdf_obj_memo_outparams in _mupdf:
_mupdf.ll_pdf_obj_memo_outparams_swigregister(ll_pdf_obj_memo_outparams)

def ll_pdf_obj_memo_outparams_fn(obj, bit, outparams):
    return _mupdf.ll_pdf_obj_memo_outparams_fn(obj, bit, outparams)
class ll_pdf_page_presentation_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    duration = property(_mupdf.ll_pdf_page_presentation_outparams_duration_get, _mupdf.ll_pdf_page_presentation_outparams_duration_set)

    def __init__(self):
        _mupdf.ll_pdf_page_presentation_outparams_swiginit(self, _mupdf.new_ll_pdf_page_presentation_outparams())
    __swig_destroy__ = _mupdf.delete_ll_pdf_page_presentation_outparams

# Register ll_pdf_page_presentation_outparams in _mupdf:
_mupdf.ll_pdf_page_presentation_outparams_swigregister(ll_pdf_page_presentation_outparams)

def ll_pdf_page_presentation_outparams_fn(page, transition, outparams):
    return _mupdf.ll_pdf_page_presentation_outparams_fn(page, transition, outparams)
class ll_pdf_page_write_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    presources = property(_mupdf.ll_pdf_page_write_outparams_presources_get, _mupdf.ll_pdf_page_write_outparams_presources_set)
    pcontents = property(_mupdf.ll_pdf_page_write_outparams_pcontents_get, _mupdf.ll_pdf_page_write_outparams_pcontents_set)

    def __init__(self):
        _mupdf.ll_pdf_page_write_outparams_swiginit(self, _mupdf.new_ll_pdf_page_write_outparams())
    __swig_destroy__ = _mupdf.delete_ll_pdf_page_write_outparams

# Register ll_pdf_page_write_outparams in _mupdf:
_mupdf.ll_pdf_page_write_outparams_swigregister(ll_pdf_page_write_outparams)

def ll_pdf_page_write_outparams_fn(doc, mediabox, outparams):
    return _mupdf.ll_pdf_page_write_outparams_fn(doc, mediabox, outparams)
class ll_pdf_parse_default_appearance_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    font = property(_mupdf.ll_pdf_parse_default_appearance_outparams_font_get, _mupdf.ll_pdf_parse_default_appearance_outparams_font_set)
    size = property(_mupdf.ll_pdf_parse_default_appearance_outparams_size_get, _mupdf.ll_pdf_parse_default_appearance_outparams_size_set)
    n = property(_mupdf.ll_pdf_parse_default_appearance_outparams_n_get, _mupdf.ll_pdf_parse_default_appearance_outparams_n_set)

    def __init__(self):
        _mupdf.ll_pdf_parse_default_appearance_outparams_swiginit(self, _mupdf.new_ll_pdf_parse_default_appearance_outparams())
    __swig_destroy__ = _mupdf.delete_ll_pdf_parse_default_appearance_outparams

# Register ll_pdf_parse_default_appearance_outparams in _mupdf:
_mupdf.ll_pdf_parse_default_appearance_outparams_swigregister(ll_pdf_parse_default_appearance_outparams)

def ll_pdf_parse_default_appearance_outparams_fn(da, color, outparams):
    return _mupdf.ll_pdf_parse_default_appearance_outparams_fn(da, color, outparams)
class ll_pdf_parse_ind_obj_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    num = property(_mupdf.ll_pdf_parse_ind_obj_outparams_num_get, _mupdf.ll_pdf_parse_ind_obj_outparams_num_set)
    gen = property(_mupdf.ll_pdf_parse_ind_obj_outparams_gen_get, _mupdf.ll_pdf_parse_ind_obj_outparams_gen_set)
    stm_ofs = property(_mupdf.ll_pdf_parse_ind_obj_outparams_stm_ofs_get, _mupdf.ll_pdf_parse_ind_obj_outparams_stm_ofs_set)
    try_repair = property(_mupdf.ll_pdf_parse_ind_obj_outparams_try_repair_get, _mupdf.ll_pdf_parse_ind_obj_outparams_try_repair_set)

    def __init__(self):
        _mupdf.ll_pdf_parse_ind_obj_outparams_swiginit(self, _mupdf.new_ll_pdf_parse_ind_obj_outparams())
    __swig_destroy__ = _mupdf.delete_ll_pdf_parse_ind_obj_outparams

# Register ll_pdf_parse_ind_obj_outparams in _mupdf:
_mupdf.ll_pdf_parse_ind_obj_outparams_swigregister(ll_pdf_parse_ind_obj_outparams)

def ll_pdf_parse_ind_obj_outparams_fn(doc, f, outparams):
    return _mupdf.ll_pdf_parse_ind_obj_outparams_fn(doc, f, outparams)
class ll_pdf_parse_journal_obj_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    onum = property(_mupdf.ll_pdf_parse_journal_obj_outparams_onum_get, _mupdf.ll_pdf_parse_journal_obj_outparams_onum_set)
    ostm = property(_mupdf.ll_pdf_parse_journal_obj_outparams_ostm_get, _mupdf.ll_pdf_parse_journal_obj_outparams_ostm_set)
    newobj = property(_mupdf.ll_pdf_parse_journal_obj_outparams_newobj_get, _mupdf.ll_pdf_parse_journal_obj_outparams_newobj_set)

    def __init__(self):
        _mupdf.ll_pdf_parse_journal_obj_outparams_swiginit(self, _mupdf.new_ll_pdf_parse_journal_obj_outparams())
    __swig_destroy__ = _mupdf.delete_ll_pdf_parse_journal_obj_outparams

# Register ll_pdf_parse_journal_obj_outparams in _mupdf:
_mupdf.ll_pdf_parse_journal_obj_outparams_swigregister(ll_pdf_parse_journal_obj_outparams)

def ll_pdf_parse_journal_obj_outparams_fn(doc, stm, outparams):
    return _mupdf.ll_pdf_parse_journal_obj_outparams_fn(doc, stm, outparams)
class ll_pdf_print_encrypted_obj_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    sep = property(_mupdf.ll_pdf_print_encrypted_obj_outparams_sep_get, _mupdf.ll_pdf_print_encrypted_obj_outparams_sep_set)

    def __init__(self):
        _mupdf.ll_pdf_print_encrypted_obj_outparams_swiginit(self, _mupdf.new_ll_pdf_print_encrypted_obj_outparams())
    __swig_destroy__ = _mupdf.delete_ll_pdf_print_encrypted_obj_outparams

# Register ll_pdf_print_encrypted_obj_outparams in _mupdf:
_mupdf.ll_pdf_print_encrypted_obj_outparams_swigregister(ll_pdf_print_encrypted_obj_outparams)

def ll_pdf_print_encrypted_obj_outparams_fn(out, obj, tight, ascii, crypt, num, gen, outparams):
    return _mupdf.ll_pdf_print_encrypted_obj_outparams_fn(out, obj, tight, ascii, crypt, num, gen, outparams)
class ll_pdf_process_contents_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    out_res = property(_mupdf.ll_pdf_process_contents_outparams_out_res_get, _mupdf.ll_pdf_process_contents_outparams_out_res_set)

    def __init__(self):
        _mupdf.ll_pdf_process_contents_outparams_swiginit(self, _mupdf.new_ll_pdf_process_contents_outparams())
    __swig_destroy__ = _mupdf.delete_ll_pdf_process_contents_outparams

# Register ll_pdf_process_contents_outparams in _mupdf:
_mupdf.ll_pdf_process_contents_outparams_swigregister(ll_pdf_process_contents_outparams)

def ll_pdf_process_contents_outparams_fn(proc, doc, res, stm, cookie, outparams):
    return _mupdf.ll_pdf_process_contents_outparams_fn(proc, doc, res, stm, cookie, outparams)
class ll_pdf_repair_obj_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    stmofsp = property(_mupdf.ll_pdf_repair_obj_outparams_stmofsp_get, _mupdf.ll_pdf_repair_obj_outparams_stmofsp_set)
    stmlenp = property(_mupdf.ll_pdf_repair_obj_outparams_stmlenp_get, _mupdf.ll_pdf_repair_obj_outparams_stmlenp_set)
    encrypt = property(_mupdf.ll_pdf_repair_obj_outparams_encrypt_get, _mupdf.ll_pdf_repair_obj_outparams_encrypt_set)
    id = property(_mupdf.ll_pdf_repair_obj_outparams_id_get, _mupdf.ll_pdf_repair_obj_outparams_id_set)
    page = property(_mupdf.ll_pdf_repair_obj_outparams_page_get, _mupdf.ll_pdf_repair_obj_outparams_page_set)
    tmpofs = property(_mupdf.ll_pdf_repair_obj_outparams_tmpofs_get, _mupdf.ll_pdf_repair_obj_outparams_tmpofs_set)
    root = property(_mupdf.ll_pdf_repair_obj_outparams_root_get, _mupdf.ll_pdf_repair_obj_outparams_root_set)

    def __init__(self):
        _mupdf.ll_pdf_repair_obj_outparams_swiginit(self, _mupdf.new_ll_pdf_repair_obj_outparams())
    __swig_destroy__ = _mupdf.delete_ll_pdf_repair_obj_outparams

# Register ll_pdf_repair_obj_outparams in _mupdf:
_mupdf.ll_pdf_repair_obj_outparams_swigregister(ll_pdf_repair_obj_outparams)

def ll_pdf_repair_obj_outparams_fn(doc, buf, outparams):
    return _mupdf.ll_pdf_repair_obj_outparams_fn(doc, buf, outparams)
class ll_pdf_resolve_link_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    xp = property(_mupdf.ll_pdf_resolve_link_outparams_xp_get, _mupdf.ll_pdf_resolve_link_outparams_xp_set)
    yp = property(_mupdf.ll_pdf_resolve_link_outparams_yp_get, _mupdf.ll_pdf_resolve_link_outparams_yp_set)

    def __init__(self):
        _mupdf.ll_pdf_resolve_link_outparams_swiginit(self, _mupdf.new_ll_pdf_resolve_link_outparams())
    __swig_destroy__ = _mupdf.delete_ll_pdf_resolve_link_outparams

# Register ll_pdf_resolve_link_outparams in _mupdf:
_mupdf.ll_pdf_resolve_link_outparams_swigregister(ll_pdf_resolve_link_outparams)

def ll_pdf_resolve_link_outparams_fn(doc, uri, outparams):
    return _mupdf.ll_pdf_resolve_link_outparams_fn(doc, uri, outparams)
class ll_pdf_sample_shade_function_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    func = property(_mupdf.ll_pdf_sample_shade_function_outparams_func_get, _mupdf.ll_pdf_sample_shade_function_outparams_func_set)

    def __init__(self):
        _mupdf.ll_pdf_sample_shade_function_outparams_swiginit(self, _mupdf.new_ll_pdf_sample_shade_function_outparams())
    __swig_destroy__ = _mupdf.delete_ll_pdf_sample_shade_function_outparams

# Register ll_pdf_sample_shade_function_outparams in _mupdf:
_mupdf.ll_pdf_sample_shade_function_outparams_swigregister(ll_pdf_sample_shade_function_outparams)

def ll_pdf_sample_shade_function_outparams_fn(shade, n, funcs, t0, t1, outparams):
    return _mupdf.ll_pdf_sample_shade_function_outparams_fn(shade, n, funcs, t0, t1, outparams)
class ll_pdf_signature_contents_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    contents = property(_mupdf.ll_pdf_signature_contents_outparams_contents_get, _mupdf.ll_pdf_signature_contents_outparams_contents_set)

    def __init__(self):
        _mupdf.ll_pdf_signature_contents_outparams_swiginit(self, _mupdf.new_ll_pdf_signature_contents_outparams())
    __swig_destroy__ = _mupdf.delete_ll_pdf_signature_contents_outparams

# Register ll_pdf_signature_contents_outparams in _mupdf:
_mupdf.ll_pdf_signature_contents_outparams_swigregister(ll_pdf_signature_contents_outparams)

def ll_pdf_signature_contents_outparams_fn(doc, signature, outparams):
    return _mupdf.ll_pdf_signature_contents_outparams_fn(doc, signature, outparams)
class ll_pdf_sprint_obj_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    len = property(_mupdf.ll_pdf_sprint_obj_outparams_len_get, _mupdf.ll_pdf_sprint_obj_outparams_len_set)

    def __init__(self):
        _mupdf.ll_pdf_sprint_obj_outparams_swiginit(self, _mupdf.new_ll_pdf_sprint_obj_outparams())
    __swig_destroy__ = _mupdf.delete_ll_pdf_sprint_obj_outparams

# Register ll_pdf_sprint_obj_outparams in _mupdf:
_mupdf.ll_pdf_sprint_obj_outparams_swigregister(ll_pdf_sprint_obj_outparams)

def ll_pdf_sprint_obj_outparams_fn(buf, cap, obj, tight, ascii, outparams):
    return _mupdf.ll_pdf_sprint_obj_outparams_fn(buf, cap, obj, tight, ascii, outparams)
class ll_pdf_to_string_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    sizep = property(_mupdf.ll_pdf_to_string_outparams_sizep_get, _mupdf.ll_pdf_to_string_outparams_sizep_set)

    def __init__(self):
        _mupdf.ll_pdf_to_string_outparams_swiginit(self, _mupdf.new_ll_pdf_to_string_outparams())
    __swig_destroy__ = _mupdf.delete_ll_pdf_to_string_outparams

# Register ll_pdf_to_string_outparams in _mupdf:
_mupdf.ll_pdf_to_string_outparams_swigregister(ll_pdf_to_string_outparams)

def ll_pdf_to_string_outparams_fn(obj, outparams):
    return _mupdf.ll_pdf_to_string_outparams_fn(obj, outparams)
class ll_pdf_undoredo_state_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    steps = property(_mupdf.ll_pdf_undoredo_state_outparams_steps_get, _mupdf.ll_pdf_undoredo_state_outparams_steps_set)

    def __init__(self):
        _mupdf.ll_pdf_undoredo_state_outparams_swiginit(self, _mupdf.new_ll_pdf_undoredo_state_outparams())
    __swig_destroy__ = _mupdf.delete_ll_pdf_undoredo_state_outparams

# Register ll_pdf_undoredo_state_outparams in _mupdf:
_mupdf.ll_pdf_undoredo_state_outparams_swigregister(ll_pdf_undoredo_state_outparams)

def ll_pdf_undoredo_state_outparams_fn(doc, outparams):
    return _mupdf.ll_pdf_undoredo_state_outparams_fn(doc, outparams)
class ll_pdf_walk_tree_outparams(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    names = property(_mupdf.ll_pdf_walk_tree_outparams_names_get, _mupdf.ll_pdf_walk_tree_outparams_names_set)
    values = property(_mupdf.ll_pdf_walk_tree_outparams_values_get, _mupdf.ll_pdf_walk_tree_outparams_values_set)

    def __init__(self):
        _mupdf.ll_pdf_walk_tree_outparams_swiginit(self, _mupdf.new_ll_pdf_walk_tree_outparams())
    __swig_destroy__ = _mupdf.delete_ll_pdf_walk_tree_outparams

# Register ll_pdf_walk_tree_outparams in _mupdf:
_mupdf.ll_pdf_walk_tree_outparams_swigregister(ll_pdf_walk_tree_outparams)

def ll_pdf_walk_tree_outparams_fn(tree, kid_name, arrive, leave, arg, outparams):
    return _mupdf.ll_pdf_walk_tree_outparams_fn(tree, kid_name, arrive, leave, arg, outparams)
UCDN_EAST_ASIAN_F = _mupdf.UCDN_EAST_ASIAN_F
UCDN_EAST_ASIAN_H = _mupdf.UCDN_EAST_ASIAN_H
UCDN_EAST_ASIAN_W = _mupdf.UCDN_EAST_ASIAN_W
UCDN_EAST_ASIAN_NA = _mupdf.UCDN_EAST_ASIAN_NA
UCDN_EAST_ASIAN_A = _mupdf.UCDN_EAST_ASIAN_A
UCDN_EAST_ASIAN_N = _mupdf.UCDN_EAST_ASIAN_N
UCDN_SCRIPT_COMMON = _mupdf.UCDN_SCRIPT_COMMON
UCDN_SCRIPT_LATIN = _mupdf.UCDN_SCRIPT_LATIN
UCDN_SCRIPT_GREEK = _mupdf.UCDN_SCRIPT_GREEK
UCDN_SCRIPT_CYRILLIC = _mupdf.UCDN_SCRIPT_CYRILLIC
UCDN_SCRIPT_ARMENIAN = _mupdf.UCDN_SCRIPT_ARMENIAN
UCDN_SCRIPT_HEBREW = _mupdf.UCDN_SCRIPT_HEBREW
UCDN_SCRIPT_ARABIC = _mupdf.UCDN_SCRIPT_ARABIC
UCDN_SCRIPT_SYRIAC = _mupdf.UCDN_SCRIPT_SYRIAC
UCDN_SCRIPT_THAANA = _mupdf.UCDN_SCRIPT_THAANA
UCDN_SCRIPT_DEVANAGARI = _mupdf.UCDN_SCRIPT_DEVANAGARI
UCDN_SCRIPT_BENGALI = _mupdf.UCDN_SCRIPT_BENGALI
UCDN_SCRIPT_GURMUKHI = _mupdf.UCDN_SCRIPT_GURMUKHI
UCDN_SCRIPT_GUJARATI = _mupdf.UCDN_SCRIPT_GUJARATI
UCDN_SCRIPT_ORIYA = _mupdf.UCDN_SCRIPT_ORIYA
UCDN_SCRIPT_TAMIL = _mupdf.UCDN_SCRIPT_TAMIL
UCDN_SCRIPT_TELUGU = _mupdf.UCDN_SCRIPT_TELUGU
UCDN_SCRIPT_KANNADA = _mupdf.UCDN_SCRIPT_KANNADA
UCDN_SCRIPT_MALAYALAM = _mupdf.UCDN_SCRIPT_MALAYALAM
UCDN_SCRIPT_SINHALA = _mupdf.UCDN_SCRIPT_SINHALA
UCDN_SCRIPT_THAI = _mupdf.UCDN_SCRIPT_THAI
UCDN_SCRIPT_LAO = _mupdf.UCDN_SCRIPT_LAO
UCDN_SCRIPT_TIBETAN = _mupdf.UCDN_SCRIPT_TIBETAN
UCDN_SCRIPT_MYANMAR = _mupdf.UCDN_SCRIPT_MYANMAR
UCDN_SCRIPT_GEORGIAN = _mupdf.UCDN_SCRIPT_GEORGIAN
UCDN_SCRIPT_HANGUL = _mupdf.UCDN_SCRIPT_HANGUL
UCDN_SCRIPT_ETHIOPIC = _mupdf.UCDN_SCRIPT_ETHIOPIC
UCDN_SCRIPT_CHEROKEE = _mupdf.UCDN_SCRIPT_CHEROKEE
UCDN_SCRIPT_CANADIAN_ABORIGINAL = _mupdf.UCDN_SCRIPT_CANADIAN_ABORIGINAL
UCDN_SCRIPT_OGHAM = _mupdf.UCDN_SCRIPT_OGHAM
UCDN_SCRIPT_RUNIC = _mupdf.UCDN_SCRIPT_RUNIC
UCDN_SCRIPT_KHMER = _mupdf.UCDN_SCRIPT_KHMER
UCDN_SCRIPT_MONGOLIAN = _mupdf.UCDN_SCRIPT_MONGOLIAN
UCDN_SCRIPT_HIRAGANA = _mupdf.UCDN_SCRIPT_HIRAGANA
UCDN_SCRIPT_KATAKANA = _mupdf.UCDN_SCRIPT_KATAKANA
UCDN_SCRIPT_BOPOMOFO = _mupdf.UCDN_SCRIPT_BOPOMOFO
UCDN_SCRIPT_HAN = _mupdf.UCDN_SCRIPT_HAN
UCDN_SCRIPT_YI = _mupdf.UCDN_SCRIPT_YI
UCDN_SCRIPT_OLD_ITALIC = _mupdf.UCDN_SCRIPT_OLD_ITALIC
UCDN_SCRIPT_GOTHIC = _mupdf.UCDN_SCRIPT_GOTHIC
UCDN_SCRIPT_DESERET = _mupdf.UCDN_SCRIPT_DESERET
UCDN_SCRIPT_INHERITED = _mupdf.UCDN_SCRIPT_INHERITED
UCDN_SCRIPT_TAGALOG = _mupdf.UCDN_SCRIPT_TAGALOG
UCDN_SCRIPT_HANUNOO = _mupdf.UCDN_SCRIPT_HANUNOO
UCDN_SCRIPT_BUHID = _mupdf.UCDN_SCRIPT_BUHID
UCDN_SCRIPT_TAGBANWA = _mupdf.UCDN_SCRIPT_TAGBANWA
UCDN_SCRIPT_LIMBU = _mupdf.UCDN_SCRIPT_LIMBU
UCDN_SCRIPT_TAI_LE = _mupdf.UCDN_SCRIPT_TAI_LE
UCDN_SCRIPT_LINEAR_B = _mupdf.UCDN_SCRIPT_LINEAR_B
UCDN_SCRIPT_UGARITIC = _mupdf.UCDN_SCRIPT_UGARITIC
UCDN_SCRIPT_SHAVIAN = _mupdf.UCDN_SCRIPT_SHAVIAN
UCDN_SCRIPT_OSMANYA = _mupdf.UCDN_SCRIPT_OSMANYA
UCDN_SCRIPT_CYPRIOT = _mupdf.UCDN_SCRIPT_CYPRIOT
UCDN_SCRIPT_BRAILLE = _mupdf.UCDN_SCRIPT_BRAILLE
UCDN_SCRIPT_BUGINESE = _mupdf.UCDN_SCRIPT_BUGINESE
UCDN_SCRIPT_COPTIC = _mupdf.UCDN_SCRIPT_COPTIC
UCDN_SCRIPT_NEW_TAI_LUE = _mupdf.UCDN_SCRIPT_NEW_TAI_LUE
UCDN_SCRIPT_GLAGOLITIC = _mupdf.UCDN_SCRIPT_GLAGOLITIC
UCDN_SCRIPT_TIFINAGH = _mupdf.UCDN_SCRIPT_TIFINAGH
UCDN_SCRIPT_SYLOTI_NAGRI = _mupdf.UCDN_SCRIPT_SYLOTI_NAGRI
UCDN_SCRIPT_OLD_PERSIAN = _mupdf.UCDN_SCRIPT_OLD_PERSIAN
UCDN_SCRIPT_KHAROSHTHI = _mupdf.UCDN_SCRIPT_KHAROSHTHI
UCDN_SCRIPT_BALINESE = _mupdf.UCDN_SCRIPT_BALINESE
UCDN_SCRIPT_CUNEIFORM = _mupdf.UCDN_SCRIPT_CUNEIFORM
UCDN_SCRIPT_PHOENICIAN = _mupdf.UCDN_SCRIPT_PHOENICIAN
UCDN_SCRIPT_PHAGS_PA = _mupdf.UCDN_SCRIPT_PHAGS_PA
UCDN_SCRIPT_NKO = _mupdf.UCDN_SCRIPT_NKO
UCDN_SCRIPT_SUNDANESE = _mupdf.UCDN_SCRIPT_SUNDANESE
UCDN_SCRIPT_LEPCHA = _mupdf.UCDN_SCRIPT_LEPCHA
UCDN_SCRIPT_OL_CHIKI = _mupdf.UCDN_SCRIPT_OL_CHIKI
UCDN_SCRIPT_VAI = _mupdf.UCDN_SCRIPT_VAI
UCDN_SCRIPT_SAURASHTRA = _mupdf.UCDN_SCRIPT_SAURASHTRA
UCDN_SCRIPT_KAYAH_LI = _mupdf.UCDN_SCRIPT_KAYAH_LI
UCDN_SCRIPT_REJANG = _mupdf.UCDN_SCRIPT_REJANG
UCDN_SCRIPT_LYCIAN = _mupdf.UCDN_SCRIPT_LYCIAN
UCDN_SCRIPT_CARIAN = _mupdf.UCDN_SCRIPT_CARIAN
UCDN_SCRIPT_LYDIAN = _mupdf.UCDN_SCRIPT_LYDIAN
UCDN_SCRIPT_CHAM = _mupdf.UCDN_SCRIPT_CHAM
UCDN_SCRIPT_TAI_THAM = _mupdf.UCDN_SCRIPT_TAI_THAM
UCDN_SCRIPT_TAI_VIET = _mupdf.UCDN_SCRIPT_TAI_VIET
UCDN_SCRIPT_AVESTAN = _mupdf.UCDN_SCRIPT_AVESTAN
UCDN_SCRIPT_EGYPTIAN_HIEROGLYPHS = _mupdf.UCDN_SCRIPT_EGYPTIAN_HIEROGLYPHS
UCDN_SCRIPT_SAMARITAN = _mupdf.UCDN_SCRIPT_SAMARITAN
UCDN_SCRIPT_LISU = _mupdf.UCDN_SCRIPT_LISU
UCDN_SCRIPT_BAMUM = _mupdf.UCDN_SCRIPT_BAMUM
UCDN_SCRIPT_JAVANESE = _mupdf.UCDN_SCRIPT_JAVANESE
UCDN_SCRIPT_MEETEI_MAYEK = _mupdf.UCDN_SCRIPT_MEETEI_MAYEK
UCDN_SCRIPT_IMPERIAL_ARAMAIC = _mupdf.UCDN_SCRIPT_IMPERIAL_ARAMAIC
UCDN_SCRIPT_OLD_SOUTH_ARABIAN = _mupdf.UCDN_SCRIPT_OLD_SOUTH_ARABIAN
UCDN_SCRIPT_INSCRIPTIONAL_PARTHIAN = _mupdf.UCDN_SCRIPT_INSCRIPTIONAL_PARTHIAN
UCDN_SCRIPT_INSCRIPTIONAL_PAHLAVI = _mupdf.UCDN_SCRIPT_INSCRIPTIONAL_PAHLAVI
UCDN_SCRIPT_OLD_TURKIC = _mupdf.UCDN_SCRIPT_OLD_TURKIC
UCDN_SCRIPT_KAITHI = _mupdf.UCDN_SCRIPT_KAITHI
UCDN_SCRIPT_BATAK = _mupdf.UCDN_SCRIPT_BATAK
UCDN_SCRIPT_BRAHMI = _mupdf.UCDN_SCRIPT_BRAHMI
UCDN_SCRIPT_MANDAIC = _mupdf.UCDN_SCRIPT_MANDAIC
UCDN_SCRIPT_CHAKMA = _mupdf.UCDN_SCRIPT_CHAKMA
UCDN_SCRIPT_MEROITIC_CURSIVE = _mupdf.UCDN_SCRIPT_MEROITIC_CURSIVE
UCDN_SCRIPT_MEROITIC_HIEROGLYPHS = _mupdf.UCDN_SCRIPT_MEROITIC_HIEROGLYPHS
UCDN_SCRIPT_MIAO = _mupdf.UCDN_SCRIPT_MIAO
UCDN_SCRIPT_SHARADA = _mupdf.UCDN_SCRIPT_SHARADA
UCDN_SCRIPT_SORA_SOMPENG = _mupdf.UCDN_SCRIPT_SORA_SOMPENG
UCDN_SCRIPT_TAKRI = _mupdf.UCDN_SCRIPT_TAKRI
UCDN_SCRIPT_UNKNOWN = _mupdf.UCDN_SCRIPT_UNKNOWN
UCDN_SCRIPT_BASSA_VAH = _mupdf.UCDN_SCRIPT_BASSA_VAH
UCDN_SCRIPT_CAUCASIAN_ALBANIAN = _mupdf.UCDN_SCRIPT_CAUCASIAN_ALBANIAN
UCDN_SCRIPT_DUPLOYAN = _mupdf.UCDN_SCRIPT_DUPLOYAN
UCDN_SCRIPT_ELBASAN = _mupdf.UCDN_SCRIPT_ELBASAN
UCDN_SCRIPT_GRANTHA = _mupdf.UCDN_SCRIPT_GRANTHA
UCDN_SCRIPT_KHOJKI = _mupdf.UCDN_SCRIPT_KHOJKI
UCDN_SCRIPT_KHUDAWADI = _mupdf.UCDN_SCRIPT_KHUDAWADI
UCDN_SCRIPT_LINEAR_A = _mupdf.UCDN_SCRIPT_LINEAR_A
UCDN_SCRIPT_MAHAJANI = _mupdf.UCDN_SCRIPT_MAHAJANI
UCDN_SCRIPT_MANICHAEAN = _mupdf.UCDN_SCRIPT_MANICHAEAN
UCDN_SCRIPT_MENDE_KIKAKUI = _mupdf.UCDN_SCRIPT_MENDE_KIKAKUI
UCDN_SCRIPT_MODI = _mupdf.UCDN_SCRIPT_MODI
UCDN_SCRIPT_MRO = _mupdf.UCDN_SCRIPT_MRO
UCDN_SCRIPT_NABATAEAN = _mupdf.UCDN_SCRIPT_NABATAEAN
UCDN_SCRIPT_OLD_NORTH_ARABIAN = _mupdf.UCDN_SCRIPT_OLD_NORTH_ARABIAN
UCDN_SCRIPT_OLD_PERMIC = _mupdf.UCDN_SCRIPT_OLD_PERMIC
UCDN_SCRIPT_PAHAWH_HMONG = _mupdf.UCDN_SCRIPT_PAHAWH_HMONG
UCDN_SCRIPT_PALMYRENE = _mupdf.UCDN_SCRIPT_PALMYRENE
UCDN_SCRIPT_PAU_CIN_HAU = _mupdf.UCDN_SCRIPT_PAU_CIN_HAU
UCDN_SCRIPT_PSALTER_PAHLAVI = _mupdf.UCDN_SCRIPT_PSALTER_PAHLAVI
UCDN_SCRIPT_SIDDHAM = _mupdf.UCDN_SCRIPT_SIDDHAM
UCDN_SCRIPT_TIRHUTA = _mupdf.UCDN_SCRIPT_TIRHUTA
UCDN_SCRIPT_WARANG_CITI = _mupdf.UCDN_SCRIPT_WARANG_CITI
UCDN_SCRIPT_AHOM = _mupdf.UCDN_SCRIPT_AHOM
UCDN_SCRIPT_ANATOLIAN_HIEROGLYPHS = _mupdf.UCDN_SCRIPT_ANATOLIAN_HIEROGLYPHS
UCDN_SCRIPT_HATRAN = _mupdf.UCDN_SCRIPT_HATRAN
UCDN_SCRIPT_MULTANI = _mupdf.UCDN_SCRIPT_MULTANI
UCDN_SCRIPT_OLD_HUNGARIAN = _mupdf.UCDN_SCRIPT_OLD_HUNGARIAN
UCDN_SCRIPT_SIGNWRITING = _mupdf.UCDN_SCRIPT_SIGNWRITING
UCDN_SCRIPT_ADLAM = _mupdf.UCDN_SCRIPT_ADLAM
UCDN_SCRIPT_BHAIKSUKI = _mupdf.UCDN_SCRIPT_BHAIKSUKI
UCDN_SCRIPT_MARCHEN = _mupdf.UCDN_SCRIPT_MARCHEN
UCDN_SCRIPT_NEWA = _mupdf.UCDN_SCRIPT_NEWA
UCDN_SCRIPT_OSAGE = _mupdf.UCDN_SCRIPT_OSAGE
UCDN_SCRIPT_TANGUT = _mupdf.UCDN_SCRIPT_TANGUT
UCDN_SCRIPT_MASARAM_GONDI = _mupdf.UCDN_SCRIPT_MASARAM_GONDI
UCDN_SCRIPT_NUSHU = _mupdf.UCDN_SCRIPT_NUSHU
UCDN_SCRIPT_SOYOMBO = _mupdf.UCDN_SCRIPT_SOYOMBO
UCDN_SCRIPT_ZANABAZAR_SQUARE = _mupdf.UCDN_SCRIPT_ZANABAZAR_SQUARE
UCDN_SCRIPT_DOGRA = _mupdf.UCDN_SCRIPT_DOGRA
UCDN_SCRIPT_GUNJALA_GONDI = _mupdf.UCDN_SCRIPT_GUNJALA_GONDI
UCDN_SCRIPT_HANIFI_ROHINGYA = _mupdf.UCDN_SCRIPT_HANIFI_ROHINGYA
UCDN_SCRIPT_MAKASAR = _mupdf.UCDN_SCRIPT_MAKASAR
UCDN_SCRIPT_MEDEFAIDRIN = _mupdf.UCDN_SCRIPT_MEDEFAIDRIN
UCDN_SCRIPT_OLD_SOGDIAN = _mupdf.UCDN_SCRIPT_OLD_SOGDIAN
UCDN_SCRIPT_SOGDIAN = _mupdf.UCDN_SCRIPT_SOGDIAN
UCDN_SCRIPT_ELYMAIC = _mupdf.UCDN_SCRIPT_ELYMAIC
UCDN_SCRIPT_NANDINAGARI = _mupdf.UCDN_SCRIPT_NANDINAGARI
UCDN_SCRIPT_NYIAKENG_PUACHUE_HMONG = _mupdf.UCDN_SCRIPT_NYIAKENG_PUACHUE_HMONG
UCDN_SCRIPT_WANCHO = _mupdf.UCDN_SCRIPT_WANCHO
UCDN_SCRIPT_CHORASMIAN = _mupdf.UCDN_SCRIPT_CHORASMIAN
UCDN_SCRIPT_DIVES_AKURU = _mupdf.UCDN_SCRIPT_DIVES_AKURU
UCDN_SCRIPT_KHITAN_SMALL_SCRIPT = _mupdf.UCDN_SCRIPT_KHITAN_SMALL_SCRIPT
UCDN_SCRIPT_YEZIDI = _mupdf.UCDN_SCRIPT_YEZIDI
UCDN_SCRIPT_VITHKUQI = _mupdf.UCDN_SCRIPT_VITHKUQI
UCDN_SCRIPT_OLD_UYGHUR = _mupdf.UCDN_SCRIPT_OLD_UYGHUR
UCDN_SCRIPT_CYPRO_MINOAN = _mupdf.UCDN_SCRIPT_CYPRO_MINOAN
UCDN_SCRIPT_TANGSA = _mupdf.UCDN_SCRIPT_TANGSA
UCDN_SCRIPT_TOTO = _mupdf.UCDN_SCRIPT_TOTO
UCDN_SCRIPT_KAWI = _mupdf.UCDN_SCRIPT_KAWI
UCDN_SCRIPT_NAG_MUNDARI = _mupdf.UCDN_SCRIPT_NAG_MUNDARI
UCDN_LAST_SCRIPT = _mupdf.UCDN_LAST_SCRIPT
UCDN_LINEBREAK_CLASS_OP = _mupdf.UCDN_LINEBREAK_CLASS_OP
UCDN_LINEBREAK_CLASS_CL = _mupdf.UCDN_LINEBREAK_CLASS_CL
UCDN_LINEBREAK_CLASS_CP = _mupdf.UCDN_LINEBREAK_CLASS_CP
UCDN_LINEBREAK_CLASS_QU = _mupdf.UCDN_LINEBREAK_CLASS_QU
UCDN_LINEBREAK_CLASS_GL = _mupdf.UCDN_LINEBREAK_CLASS_GL
UCDN_LINEBREAK_CLASS_NS = _mupdf.UCDN_LINEBREAK_CLASS_NS
UCDN_LINEBREAK_CLASS_EX = _mupdf.UCDN_LINEBREAK_CLASS_EX
UCDN_LINEBREAK_CLASS_SY = _mupdf.UCDN_LINEBREAK_CLASS_SY
UCDN_LINEBREAK_CLASS_IS = _mupdf.UCDN_LINEBREAK_CLASS_IS
UCDN_LINEBREAK_CLASS_PR = _mupdf.UCDN_LINEBREAK_CLASS_PR
UCDN_LINEBREAK_CLASS_PO = _mupdf.UCDN_LINEBREAK_CLASS_PO
UCDN_LINEBREAK_CLASS_NU = _mupdf.UCDN_LINEBREAK_CLASS_NU
UCDN_LINEBREAK_CLASS_AL = _mupdf.UCDN_LINEBREAK_CLASS_AL
UCDN_LINEBREAK_CLASS_HL = _mupdf.UCDN_LINEBREAK_CLASS_HL
UCDN_LINEBREAK_CLASS_ID = _mupdf.UCDN_LINEBREAK_CLASS_ID
UCDN_LINEBREAK_CLASS_IN = _mupdf.UCDN_LINEBREAK_CLASS_IN
UCDN_LINEBREAK_CLASS_HY = _mupdf.UCDN_LINEBREAK_CLASS_HY
UCDN_LINEBREAK_CLASS_BA = _mupdf.UCDN_LINEBREAK_CLASS_BA
UCDN_LINEBREAK_CLASS_BB = _mupdf.UCDN_LINEBREAK_CLASS_BB
UCDN_LINEBREAK_CLASS_B2 = _mupdf.UCDN_LINEBREAK_CLASS_B2
UCDN_LINEBREAK_CLASS_ZW = _mupdf.UCDN_LINEBREAK_CLASS_ZW
UCDN_LINEBREAK_CLASS_CM = _mupdf.UCDN_LINEBREAK_CLASS_CM
UCDN_LINEBREAK_CLASS_WJ = _mupdf.UCDN_LINEBREAK_CLASS_WJ
UCDN_LINEBREAK_CLASS_H2 = _mupdf.UCDN_LINEBREAK_CLASS_H2
UCDN_LINEBREAK_CLASS_H3 = _mupdf.UCDN_LINEBREAK_CLASS_H3
UCDN_LINEBREAK_CLASS_JL = _mupdf.UCDN_LINEBREAK_CLASS_JL
UCDN_LINEBREAK_CLASS_JV = _mupdf.UCDN_LINEBREAK_CLASS_JV
UCDN_LINEBREAK_CLASS_JT = _mupdf.UCDN_LINEBREAK_CLASS_JT
UCDN_LINEBREAK_CLASS_RI = _mupdf.UCDN_LINEBREAK_CLASS_RI
UCDN_LINEBREAK_CLASS_AI = _mupdf.UCDN_LINEBREAK_CLASS_AI
UCDN_LINEBREAK_CLASS_BK = _mupdf.UCDN_LINEBREAK_CLASS_BK
UCDN_LINEBREAK_CLASS_CB = _mupdf.UCDN_LINEBREAK_CLASS_CB
UCDN_LINEBREAK_CLASS_CJ = _mupdf.UCDN_LINEBREAK_CLASS_CJ
UCDN_LINEBREAK_CLASS_CR = _mupdf.UCDN_LINEBREAK_CLASS_CR
UCDN_LINEBREAK_CLASS_LF = _mupdf.UCDN_LINEBREAK_CLASS_LF
UCDN_LINEBREAK_CLASS_NL = _mupdf.UCDN_LINEBREAK_CLASS_NL
UCDN_LINEBREAK_CLASS_SA = _mupdf.UCDN_LINEBREAK_CLASS_SA
UCDN_LINEBREAK_CLASS_SG = _mupdf.UCDN_LINEBREAK_CLASS_SG
UCDN_LINEBREAK_CLASS_SP = _mupdf.UCDN_LINEBREAK_CLASS_SP
UCDN_LINEBREAK_CLASS_XX = _mupdf.UCDN_LINEBREAK_CLASS_XX
UCDN_LINEBREAK_CLASS_ZWJ = _mupdf.UCDN_LINEBREAK_CLASS_ZWJ
UCDN_LINEBREAK_CLASS_EB = _mupdf.UCDN_LINEBREAK_CLASS_EB
UCDN_LINEBREAK_CLASS_EM = _mupdf.UCDN_LINEBREAK_CLASS_EM
UCDN_GENERAL_CATEGORY_CC = _mupdf.UCDN_GENERAL_CATEGORY_CC
UCDN_GENERAL_CATEGORY_CF = _mupdf.UCDN_GENERAL_CATEGORY_CF
UCDN_GENERAL_CATEGORY_CN = _mupdf.UCDN_GENERAL_CATEGORY_CN
UCDN_GENERAL_CATEGORY_CO = _mupdf.UCDN_GENERAL_CATEGORY_CO
UCDN_GENERAL_CATEGORY_CS = _mupdf.UCDN_GENERAL_CATEGORY_CS
UCDN_GENERAL_CATEGORY_LL = _mupdf.UCDN_GENERAL_CATEGORY_LL
UCDN_GENERAL_CATEGORY_LM = _mupdf.UCDN_GENERAL_CATEGORY_LM
UCDN_GENERAL_CATEGORY_LO = _mupdf.UCDN_GENERAL_CATEGORY_LO
UCDN_GENERAL_CATEGORY_LT = _mupdf.UCDN_GENERAL_CATEGORY_LT
UCDN_GENERAL_CATEGORY_LU = _mupdf.UCDN_GENERAL_CATEGORY_LU
UCDN_GENERAL_CATEGORY_MC = _mupdf.UCDN_GENERAL_CATEGORY_MC
UCDN_GENERAL_CATEGORY_ME = _mupdf.UCDN_GENERAL_CATEGORY_ME
UCDN_GENERAL_CATEGORY_MN = _mupdf.UCDN_GENERAL_CATEGORY_MN
UCDN_GENERAL_CATEGORY_ND = _mupdf.UCDN_GENERAL_CATEGORY_ND
UCDN_GENERAL_CATEGORY_NL = _mupdf.UCDN_GENERAL_CATEGORY_NL
UCDN_GENERAL_CATEGORY_NO = _mupdf.UCDN_GENERAL_CATEGORY_NO
UCDN_GENERAL_CATEGORY_PC = _mupdf.UCDN_GENERAL_CATEGORY_PC
UCDN_GENERAL_CATEGORY_PD = _mupdf.UCDN_GENERAL_CATEGORY_PD
UCDN_GENERAL_CATEGORY_PE = _mupdf.UCDN_GENERAL_CATEGORY_PE
UCDN_GENERAL_CATEGORY_PF = _mupdf.UCDN_GENERAL_CATEGORY_PF
UCDN_GENERAL_CATEGORY_PI = _mupdf.UCDN_GENERAL_CATEGORY_PI
UCDN_GENERAL_CATEGORY_PO = _mupdf.UCDN_GENERAL_CATEGORY_PO
UCDN_GENERAL_CATEGORY_PS = _mupdf.UCDN_GENERAL_CATEGORY_PS
UCDN_GENERAL_CATEGORY_SC = _mupdf.UCDN_GENERAL_CATEGORY_SC
UCDN_GENERAL_CATEGORY_SK = _mupdf.UCDN_GENERAL_CATEGORY_SK
UCDN_GENERAL_CATEGORY_SM = _mupdf.UCDN_GENERAL_CATEGORY_SM
UCDN_GENERAL_CATEGORY_SO = _mupdf.UCDN_GENERAL_CATEGORY_SO
UCDN_GENERAL_CATEGORY_ZL = _mupdf.UCDN_GENERAL_CATEGORY_ZL
UCDN_GENERAL_CATEGORY_ZP = _mupdf.UCDN_GENERAL_CATEGORY_ZP
UCDN_GENERAL_CATEGORY_ZS = _mupdf.UCDN_GENERAL_CATEGORY_ZS
UCDN_BIDI_CLASS_L = _mupdf.UCDN_BIDI_CLASS_L
UCDN_BIDI_CLASS_LRE = _mupdf.UCDN_BIDI_CLASS_LRE
UCDN_BIDI_CLASS_LRO = _mupdf.UCDN_BIDI_CLASS_LRO
UCDN_BIDI_CLASS_R = _mupdf.UCDN_BIDI_CLASS_R
UCDN_BIDI_CLASS_AL = _mupdf.UCDN_BIDI_CLASS_AL
UCDN_BIDI_CLASS_RLE = _mupdf.UCDN_BIDI_CLASS_RLE
UCDN_BIDI_CLASS_RLO = _mupdf.UCDN_BIDI_CLASS_RLO
UCDN_BIDI_CLASS_PDF = _mupdf.UCDN_BIDI_CLASS_PDF
UCDN_BIDI_CLASS_EN = _mupdf.UCDN_BIDI_CLASS_EN
UCDN_BIDI_CLASS_ES = _mupdf.UCDN_BIDI_CLASS_ES
UCDN_BIDI_CLASS_ET = _mupdf.UCDN_BIDI_CLASS_ET
UCDN_BIDI_CLASS_AN = _mupdf.UCDN_BIDI_CLASS_AN
UCDN_BIDI_CLASS_CS = _mupdf.UCDN_BIDI_CLASS_CS
UCDN_BIDI_CLASS_NSM = _mupdf.UCDN_BIDI_CLASS_NSM
UCDN_BIDI_CLASS_BN = _mupdf.UCDN_BIDI_CLASS_BN
UCDN_BIDI_CLASS_B = _mupdf.UCDN_BIDI_CLASS_B
UCDN_BIDI_CLASS_S = _mupdf.UCDN_BIDI_CLASS_S
UCDN_BIDI_CLASS_WS = _mupdf.UCDN_BIDI_CLASS_WS
UCDN_BIDI_CLASS_ON = _mupdf.UCDN_BIDI_CLASS_ON
UCDN_BIDI_CLASS_LRI = _mupdf.UCDN_BIDI_CLASS_LRI
UCDN_BIDI_CLASS_RLI = _mupdf.UCDN_BIDI_CLASS_RLI
UCDN_BIDI_CLASS_FSI = _mupdf.UCDN_BIDI_CLASS_FSI
UCDN_BIDI_CLASS_PDI = _mupdf.UCDN_BIDI_CLASS_PDI
UCDN_BIDI_PAIRED_BRACKET_TYPE_OPEN = _mupdf.UCDN_BIDI_PAIRED_BRACKET_TYPE_OPEN
UCDN_BIDI_PAIRED_BRACKET_TYPE_CLOSE = _mupdf.UCDN_BIDI_PAIRED_BRACKET_TYPE_CLOSE
UCDN_BIDI_PAIRED_BRACKET_TYPE_NONE = _mupdf.UCDN_BIDI_PAIRED_BRACKET_TYPE_NONE

def new_pint():
    return _mupdf.new_pint()

def copy_pint(value):
    return _mupdf.copy_pint(value)

def delete_pint(obj):
    return _mupdf.delete_pint(obj)

def pint_assign(obj, value):
    return _mupdf.pint_assign(obj, value)

def pint_value(obj):
    return _mupdf.pint_value(obj)


import inspect
import os
import re
import sys
import traceback

def log( text):
    print( text, file=sys.stderr)

g_mupdf_trace_director = (os.environ.get('MUPDF_trace_director') == '1')

def fz_lookup_metadata(document, key):
    """
    Like fz_lookup_metadata2() but returns None on error
    instead of raising exception.
    """
    try:
        return fz_lookup_metadata2(document, key)
    except Exception:
        return
FzDocument.fz_lookup_metadata                         = fz_lookup_metadata

def pdf_lookup_metadata(document, key):
    """
    Likepsd_lookup_metadata2() but returns None on error
    instead of raising exception.
    """
    try:
        return pdf_lookup_metadata2(document, key)
    except Exception:
        return
PdfDocument.pdf_lookup_metadata                         = pdf_lookup_metadata

import inspect
import io
import os
import sys
import traceback
import types
def exception_info(
        exception_or_traceback=None,
        limit=None,
        file=None,
        chain=True,
        outer=True,
        show_exception_type=True,
        _filelinefn=True,
        ):
    '''
    Shows an exception and/or backtrace.

    Alternative to `traceback.*` functions that print/return information about
    exceptions and backtraces, such as:

        * `traceback.format_exc()`
        * `traceback.format_exception()`
        * `traceback.print_exc()`
        * `traceback.print_exception()`

    Install as system default with:

        `sys.excepthook = lambda type_, exception, traceback: jlib.exception_info( exception)`

    Returns `None`, or the generated text if `file` is 'return'.

    Args:
        exception_or_traceback:
            `None`, a `BaseException`, a `types.TracebackType` (typically from
            an exception's `.__traceback__` member) or an `inspect.FrameInfo`.

            If `None` we use current exception from `sys.exc_info()` if set,
            otherwise the current backtrace from `inspect.stack()`.
        limit:
            As in `traceback.*` functions: `None` to show all frames, positive
            to show last `limit` frames, negative to exclude outermost `-limit`
            frames. Zero to not show any backtraces.
        file:
            As in `traceback.*` functions: file-like object to which we write
            output, or `sys.stderr` if `None`. Special value 'return' makes us
            return our output as a string.
        chain:
            As in `traceback.*` functions: if true (the default) we show
            chained exceptions as described in PEP-3134. Special value
            'because' reverses the usual ordering, showing higher-level
            exceptions first and joining with 'Because:' text.
        outer:
            If true (the default) we also show an exception's outer frames
            above the `catch` block (see next section for details). We
            use `outer=false` internally for chained exceptions to avoid
            duplication.
        show_exception_type:
            Controls whether exception text is prefixed by
            `f'{type(exception)}: '`. If callable we only include this prefix
            if `show_exception_type(exception)` is true. Otherwise if true (the
            default) we include the prefix for all exceptions (this mimcs the
            behaviour of `traceback.*` functions). Otherwise we exclude the
            prefix for all exceptions.
        _filelinefn:
            Internal only; makes us omit file:line: information to allow simple
            doctest comparison with expected output.

    Differences from `traceback.*` functions:

        Frames are displayed as one line in the form::

            <file>:<line>:<function>: <text>

        Filenames are displayed as relative to the current directory if
        applicable.

        Inclusion of outer frames:
            Unlike `traceback.*` functions, stack traces for exceptions include
            outer stack frames above the point at which an exception was caught
            - i.e. frames from the top-level <module> or thread creation to the
            catch block. [Search for 'sys.exc_info backtrace incomplete' for
            more details.]

            We separate the two parts of the backtrace using a marker line
            '^except raise:' where '^except' points upwards to the frame that
            caught the exception and 'raise:' refers downwards to the frame
            that raised the exception.

            So the backtrace for an exception looks like this::

                <file>:<line>:<fn>: <text>  [in root module.]
                ...                         [... other frames]
                <file>:<line>:<fn>: <text>  [in except: block where exception was caught.]
                ^except raise:              [marker line]
                <file>:<line>:<fn>: <text>  [in try: block.]
                ...                         [... other frames]
                <file>:<line>:<fn>: <text>  [where the exception was raised.]

    Examples:

        In these examples we use `file=sys.stdout` so we can check the output
        with `doctest`, and set `_filelinefn=0` so that the output can be
        matched easily. We also use `+ELLIPSIS` and `...` to match arbitrary
        outer frames from the doctest code itself.

        Basic handling of an exception:

            >>> def c():
            ...     raise Exception( 'c() failed')
            >>> def b():
            ...     try:
            ...         c()
            ...     except Exception as e:
            ...         exception_info( e, file=sys.stdout, _filelinefn=0)
            >>> def a():
            ...     b()

            >>> a() # doctest: +REPORT_UDIFF +ELLIPSIS
            Traceback (most recent call last):
                ...
                a(): b()
                b(): exception_info( e, file=sys.stdout, _filelinefn=0)
                ^except raise:
                b(): c()
                c(): raise Exception( 'c() failed')
            Exception: c() failed

        Handling of chained exceptions:

            >>> def e():
            ...     raise Exception( 'e(): deliberate error')
            >>> def d():
            ...     e()
            >>> def c():
            ...     try:
            ...         d()
            ...     except Exception as e:
            ...         raise Exception( 'c: d() failed') from e
            >>> def b():
            ...     try:
            ...         c()
            ...     except Exception as e:
            ...         exception_info( file=sys.stdout, chain=g_chain, _filelinefn=0)
            >>> def a():
            ...     b()

            With `chain=True` (the default), we output low-level exceptions
            first, matching the behaviour of `traceback.*` functions:

                >>> g_chain = True
                >>> a() # doctest: +REPORT_UDIFF +ELLIPSIS
                Traceback (most recent call last):
                    c(): d()
                    d(): e()
                    e(): raise Exception( 'e(): deliberate error')
                Exception: e(): deliberate error
                <BLANKLINE>
                The above exception was the direct cause of the following exception:
                Traceback (most recent call last):
                    ...
                    <module>(): a() # doctest: +REPORT_UDIFF +ELLIPSIS
                    a(): b()
                    b(): exception_info( file=sys.stdout, chain=g_chain, _filelinefn=0)
                    ^except raise:
                    b(): c()
                    c(): raise Exception( 'c: d() failed') from e
                Exception: c: d() failed

            With `chain='because'`, we output high-level exceptions first:
                >>> g_chain = 'because'
                >>> a() # doctest: +REPORT_UDIFF +ELLIPSIS
                Traceback (most recent call last):
                    ...
                    <module>(): a() # doctest: +REPORT_UDIFF +ELLIPSIS
                    a(): b()
                    b(): exception_info( file=sys.stdout, chain=g_chain, _filelinefn=0)
                    ^except raise:
                    b(): c()
                    c(): raise Exception( 'c: d() failed') from e
                Exception: c: d() failed
                <BLANKLINE>
                Because:
                Traceback (most recent call last):
                    c(): d()
                    d(): e()
                    e(): raise Exception( 'e(): deliberate error')
                Exception: e(): deliberate error

        Show current backtrace by passing `exception_or_traceback=None`:
            >>> def c():
            ...     exception_info( None, file=sys.stdout, _filelinefn=0)
            >>> def b():
            ...     return c()
            >>> def a():
            ...     return b()

            >>> a() # doctest: +REPORT_UDIFF +ELLIPSIS
            Traceback (most recent call last):
                ...
                <module>(): a() # doctest: +REPORT_UDIFF +ELLIPSIS
                a(): return b()
                b(): return c()
                c(): exception_info( None, file=sys.stdout, _filelinefn=0)

        Show an exception's `.__traceback__` backtrace:
            >>> def c():
            ...     raise Exception( 'foo') # raise
            >>> def b():
            ...     return c()  # call c
            >>> def a():
            ...     try:
            ...         b() # call b
            ...     except Exception as e:
            ...         exception_info( e.__traceback__, file=sys.stdout, _filelinefn=0)

            >>> a() # doctest: +REPORT_UDIFF +ELLIPSIS
            Traceback (most recent call last):
                ...
                a(): b() # call b
                b(): return c()  # call c
                c(): raise Exception( 'foo') # raise
    '''
# Set exactly one of <exception> and <tb>.
#
    if isinstance( exception_or_traceback, (types.TracebackType, inspect.FrameInfo)):
# Simple backtrace, no Exception information.
        exception = None
        tb = exception_or_traceback
    elif isinstance( exception_or_traceback, BaseException):
        exception = exception_or_traceback
        tb = None
    elif exception_or_traceback is None:
# Show exception if available, else backtrace.
        _, exception, tb = sys.exc_info()
        tb = None if exception else inspect.stack()[1:]
    else:
        assert 0, f'Unrecognised exception_or_traceback type: {type(exception_or_traceback)}'

    if file == 'return':
        out = io.StringIO()
    else:
        out = file if file else sys.stderr

    def do_chain( exception):
        exception_info(
                exception,
                limit,
                out,
                chain,
                outer=False,
                show_exception_type=show_exception_type,
                _filelinefn=_filelinefn,
                )

    if exception and chain and chain != 'because' and chain != 'because-compact':
# Output current exception first.
        if exception.__cause__:
            do_chain( exception.__cause__)
            out.write( '\nThe above exception was the direct cause of the following exception:\n')
        elif exception.__context__:
            do_chain( exception.__context__)
            out.write( '\nDuring handling of the above exception, another exception occurred:\n')

    cwd = os.getcwd() + os.sep

    def output_frames( frames, reverse, limit):
        if limit == 0:
            return
        if reverse:
            assert isinstance( frames, list)
            frames = reversed( frames)
        if limit is not None:
            frames = list( frames)
            frames = frames[ -limit:]
        for frame in frames:
            f, filename, line, fnname, text, index = frame
            text = text[0].strip() if text else ''
            if filename.startswith( cwd):
                filename = filename[ len(cwd):]
            if filename.startswith( f'.{os.sep}'):
                filename = filename[ 2:]
            if _filelinefn:
                out.write( f'    {filename}:{line}:{fnname}(): {text}\n')
            else:
                out.write( f'    {fnname}(): {text}\n')

    if limit != 0:
        out.write( 'Traceback (most recent call last):\n')
        if exception:
            tb = exception.__traceback__
            assert tb
            if outer:
                output_frames( inspect.getouterframes( tb.tb_frame), reverse=True, limit=limit)
                out.write( '    ^except raise:\n')
            limit2 = 0 if limit == 0 else None
            output_frames( inspect.getinnerframes( tb), reverse=False, limit=limit2)
        else:
            if not isinstance( tb, list):
                inner = inspect.getinnerframes(tb)
                outer = inspect.getouterframes(tb.tb_frame)
                tb = outer + inner
                tb.reverse()
            output_frames( tb, reverse=True, limit=limit)

    if exception:
        if callable(show_exception_type):
            show_exception_type2 = show_exception_type( exception)
        else:
            show_exception_type2 = show_exception_type
        if show_exception_type2:
            lines = traceback.format_exception_only( type(exception), exception)
            for line in lines:
                out.write( line)
        else:
            out.write( str( exception) + '\n')

    if exception and (chain == 'because' or chain == 'because-compact'):
# Output current exception afterwards.
        pre, post = ('\n', '\n') if chain == 'because' else ('', ' ')
        if exception.__cause__:
            out.write( f'{pre}Because:{post}')
            do_chain( exception.__cause__)
        elif exception.__context__:
            out.write( f'{pre}Because: error occurred handling this exception:{post}')
            do_chain( exception.__context__)

    if file == 'return':
        return out.getvalue()
def ll_fz_bidi_fragment_text(text, textlen, callback, arg, flags):
    """
    Wrapper for out-params of fz_bidi_fragment_text().
    Returns: ::fz_bidi_direction baseDir
    """
    outparams = ll_fz_bidi_fragment_text_outparams()
    ret = ll_fz_bidi_fragment_text_outparams_fn(text, textlen, callback, arg, flags, outparams)
    return outparams.baseDir

def fz_bidi_fragment_text_outparams_fn(text, textlen, callback, arg, flags):
    """
    Class-aware helper for out-params of fz_bidi_fragment_text() [fz_bidi_fragment_text()].
    """
    baseDir = ll_fz_bidi_fragment_text(text, textlen, callback, arg, flags)
    return baseDir

fz_bidi_fragment_text = fz_bidi_fragment_text_outparams_fn


def ll_fz_bitmap_details(bitmap):
    """
    Wrapper for out-params of fz_bitmap_details().
    Returns: int w, int h, int n, int stride
    """
    outparams = ll_fz_bitmap_details_outparams()
    ret = ll_fz_bitmap_details_outparams_fn(bitmap, outparams)
    return outparams.w, outparams.h, outparams.n, outparams.stride

def fz_bitmap_details_outparams_fn(bitmap):
    """
    Class-aware helper for out-params of fz_bitmap_details() [fz_bitmap_details()].
    """
    w, h, n, stride = ll_fz_bitmap_details(bitmap.m_internal)
    return w, h, n, stride

fz_bitmap_details = fz_bitmap_details_outparams_fn


def ll_fz_buffer_extract(buf):
    """
    Wrapper for out-params of fz_buffer_extract().
    Returns: size_t, unsigned char *data
    """
    outparams = ll_fz_buffer_extract_outparams()
    ret = ll_fz_buffer_extract_outparams_fn(buf, outparams)
    return ret, outparams.data

def fz_buffer_extract_outparams_fn(buf):
    """
    Class-aware helper for out-params of fz_buffer_extract() [fz_buffer_extract()].
    """
    ret, data = ll_fz_buffer_extract(buf.m_internal)
    return ret, data

fz_buffer_extract = fz_buffer_extract_outparams_fn


def ll_fz_buffer_storage(buf):
    """
    Wrapper for out-params of fz_buffer_storage().
    Returns: size_t, unsigned char *datap
    """
    outparams = ll_fz_buffer_storage_outparams()
    ret = ll_fz_buffer_storage_outparams_fn(buf, outparams)
    return ret, outparams.datap

def fz_buffer_storage_outparams_fn(buf):
    """
    Class-aware helper for out-params of fz_buffer_storage() [fz_buffer_storage()].
    """
    ret, datap = ll_fz_buffer_storage(buf.m_internal)
    return ret, datap

fz_buffer_storage = fz_buffer_storage_outparams_fn


def ll_fz_chartorune(str):
    """
    Wrapper for out-params of fz_chartorune().
    Returns: int, int rune
    """
    outparams = ll_fz_chartorune_outparams()
    ret = ll_fz_chartorune_outparams_fn(str, outparams)
    return ret, outparams.rune

def fz_chartorune_outparams_fn(str):
    """
    Class-aware helper for out-params of fz_chartorune() [fz_chartorune()].
    """
    ret, rune = ll_fz_chartorune(str)
    return ret, rune

fz_chartorune = fz_chartorune_outparams_fn


def ll_fz_clamp_color(cs, in_):
    """
    Wrapper for out-params of fz_clamp_color().
    Returns: float out
    """
    outparams = ll_fz_clamp_color_outparams()
    ret = ll_fz_clamp_color_outparams_fn(cs, in_, outparams)
    return outparams.out

def fz_clamp_color_outparams_fn(cs, in_):
    """
    Class-aware helper for out-params of fz_clamp_color() [fz_clamp_color()].
    """
    out = ll_fz_clamp_color(cs.m_internal, in_)
    return out

fz_clamp_color = fz_clamp_color_outparams_fn


def ll_fz_convert_color(ss, sv, ds, is_, params):
    """
    Wrapper for out-params of fz_convert_color().
    Returns: float dv
    """
    outparams = ll_fz_convert_color_outparams()
    ret = ll_fz_convert_color_outparams_fn(ss, sv, ds, is_, params, outparams)
    return outparams.dv

def fz_convert_color_outparams_fn(ss, sv, ds, is_, params):
    """
    Class-aware helper for out-params of fz_convert_color() [fz_convert_color()].
    """
    dv = ll_fz_convert_color(ss.m_internal, sv, ds.m_internal, is_.m_internal, params.internal())
    return dv

fz_convert_color = fz_convert_color_outparams_fn


def ll_fz_convert_error():
    """
    Wrapper for out-params of fz_convert_error().
    Returns: const char *, int code
    """
    outparams = ll_fz_convert_error_outparams()
    ret = ll_fz_convert_error_outparams_fn(outparams)
    return ret, outparams.code

def fz_convert_error_outparams_fn():
    """
    Class-aware helper for out-params of fz_convert_error() [fz_convert_error()].
    """
    ret, code = ll_fz_convert_error()
    return ret, code

fz_convert_error = fz_convert_error_outparams_fn


def ll_fz_convert_separation_colors(src_cs, src_color, dst_seps, dst_cs, color_params):
    """
    Wrapper for out-params of fz_convert_separation_colors().
    Returns: float dst_color
    """
    outparams = ll_fz_convert_separation_colors_outparams()
    ret = ll_fz_convert_separation_colors_outparams_fn(src_cs, src_color, dst_seps, dst_cs, color_params, outparams)
    return outparams.dst_color

def fz_convert_separation_colors_outparams_fn(src_cs, src_color, dst_seps, dst_cs, color_params):
    """
    Class-aware helper for out-params of fz_convert_separation_colors() [fz_convert_separation_colors()].
    """
    dst_color = ll_fz_convert_separation_colors(src_cs.m_internal, src_color, dst_seps.m_internal, dst_cs.m_internal, color_params.internal())
    return dst_color

fz_convert_separation_colors = fz_convert_separation_colors_outparams_fn


def ll_fz_decomp_image_from_stream(stm, image, subarea, indexed, l2factor):
    """
    Wrapper for out-params of fz_decomp_image_from_stream().
    Returns: fz_pixmap *, int l2extra
    """
    outparams = ll_fz_decomp_image_from_stream_outparams()
    ret = ll_fz_decomp_image_from_stream_outparams_fn(stm, image, subarea, indexed, l2factor, outparams)
    return ret, outparams.l2extra

def fz_decomp_image_from_stream_outparams_fn(stm, image, subarea, indexed, l2factor):
    """
    Class-aware helper for out-params of fz_decomp_image_from_stream() [fz_decomp_image_from_stream()].
    """
    ret, l2extra = ll_fz_decomp_image_from_stream(stm.m_internal, image.m_internal, subarea.internal(), indexed, l2factor)
    return FzPixmap(ret), l2extra

fz_decomp_image_from_stream = fz_decomp_image_from_stream_outparams_fn


def ll_fz_deflate(dest, source, source_length, level):
    """
    Wrapper for out-params of fz_deflate().
    Returns: size_t compressed_length
    """
    outparams = ll_fz_deflate_outparams()
    ret = ll_fz_deflate_outparams_fn(dest, source, source_length, level, outparams)
    return outparams.compressed_length

def fz_deflate_outparams_fn(dest, source, source_length, level):
    """
    Class-aware helper for out-params of fz_deflate() [fz_deflate()].
    """
    compressed_length = ll_fz_deflate(dest, source, source_length, level)
    return compressed_length

fz_deflate = fz_deflate_outparams_fn


def ll_fz_dom_get_attribute(elt, i):
    """
    Wrapper for out-params of fz_dom_get_attribute().
    Returns: const char *, const char *att
    """
    outparams = ll_fz_dom_get_attribute_outparams()
    ret = ll_fz_dom_get_attribute_outparams_fn(elt, i, outparams)
    return ret, outparams.att

def fz_dom_get_attribute_outparams_fn(elt, i):
    """
    Class-aware helper for out-params of fz_dom_get_attribute() [fz_dom_get_attribute()].
    """
    ret, att = ll_fz_dom_get_attribute(elt.m_internal, i)
    return ret, att

fz_dom_get_attribute = fz_dom_get_attribute_outparams_fn


def ll_fz_drop_imp(p):
    """
    Wrapper for out-params of fz_drop_imp().
    Returns: int, int refs
    """
    outparams = ll_fz_drop_imp_outparams()
    ret = ll_fz_drop_imp_outparams_fn(p, outparams)
    return ret, outparams.refs

def ll_fz_drop_imp16(p):
    """
    Wrapper for out-params of fz_drop_imp16().
    Returns: int, int16_t refs
    """
    outparams = ll_fz_drop_imp16_outparams()
    ret = ll_fz_drop_imp16_outparams_fn(p, outparams)
    return ret, outparams.refs

def ll_fz_encode_character_with_fallback(font, unicode, script, language):
    """
    Wrapper for out-params of fz_encode_character_with_fallback().
    Returns: int, ::fz_font *out_font
    """
    outparams = ll_fz_encode_character_with_fallback_outparams()
    ret = ll_fz_encode_character_with_fallback_outparams_fn(font, unicode, script, language, outparams)
    return ret, outparams.out_font

def fz_encode_character_with_fallback_outparams_fn(font, unicode, script, language):
    """
    Class-aware helper for out-params of fz_encode_character_with_fallback() [fz_encode_character_with_fallback()].
    """
    ret, out_font = ll_fz_encode_character_with_fallback(font.m_internal, unicode, script, language)
    return ret, FzFont(ll_fz_keep_font( out_font))

fz_encode_character_with_fallback = fz_encode_character_with_fallback_outparams_fn


def ll_fz_error_callback():
    """
    Wrapper for out-params of fz_error_callback().
    Returns: fz_error_cb *, void *user
    """
    outparams = ll_fz_error_callback_outparams()
    ret = ll_fz_error_callback_outparams_fn(outparams)
    return ret, outparams.user

def fz_error_callback_outparams_fn():
    """
    Class-aware helper for out-params of fz_error_callback() [fz_error_callback()].
    """
    ret, user = ll_fz_error_callback()
    return ret, user

fz_error_callback = fz_error_callback_outparams_fn


def ll_fz_eval_function(func, in_, inlen, outlen):
    """
    Wrapper for out-params of fz_eval_function().
    Returns: float out
    """
    outparams = ll_fz_eval_function_outparams()
    ret = ll_fz_eval_function_outparams_fn(func, in_, inlen, outlen, outparams)
    return outparams.out

def fz_eval_function_outparams_fn(func, in_, inlen, outlen):
    """
    Class-aware helper for out-params of fz_eval_function() [fz_eval_function()].
    """
    out = ll_fz_eval_function(func.m_internal, in_, inlen, outlen)
    return out

fz_eval_function = fz_eval_function_outparams_fn


def ll_fz_fill_pixmap_with_color(pix, colorspace, color_params):
    """
    Wrapper for out-params of fz_fill_pixmap_with_color().
    Returns: float color
    """
    outparams = ll_fz_fill_pixmap_with_color_outparams()
    ret = ll_fz_fill_pixmap_with_color_outparams_fn(pix, colorspace, color_params, outparams)
    return outparams.color

def fz_fill_pixmap_with_color_outparams_fn(pix, colorspace, color_params):
    """
    Class-aware helper for out-params of fz_fill_pixmap_with_color() [fz_fill_pixmap_with_color()].
    """
    color = ll_fz_fill_pixmap_with_color(pix.m_internal, colorspace.m_internal, color_params.internal())
    return color

fz_fill_pixmap_with_color = fz_fill_pixmap_with_color_outparams_fn


def ll_fz_get_pixmap_from_image(image, subarea, ctm):
    """
    Wrapper for out-params of fz_get_pixmap_from_image().
    Returns: fz_pixmap *, int w, int h
    """
    outparams = ll_fz_get_pixmap_from_image_outparams()
    ret = ll_fz_get_pixmap_from_image_outparams_fn(image, subarea, ctm, outparams)
    return ret, outparams.w, outparams.h

def fz_get_pixmap_from_image_outparams_fn(image, subarea, ctm):
    """
    Class-aware helper for out-params of fz_get_pixmap_from_image() [fz_get_pixmap_from_image()].
    """
    ret, w, h = ll_fz_get_pixmap_from_image(image.m_internal, subarea.internal(), ctm.internal())
    return FzPixmap(ret), w, h

fz_get_pixmap_from_image = fz_get_pixmap_from_image_outparams_fn


def ll_fz_getopt(nargc, ostr):
    """
    Wrapper for out-params of fz_getopt().
    Returns: int, char *nargv
    """
    outparams = ll_fz_getopt_outparams()
    ret = ll_fz_getopt_outparams_fn(nargc, ostr, outparams)
    return ret, outparams.nargv

def fz_getopt_outparams_fn(nargc, ostr):
    """
    Class-aware helper for out-params of fz_getopt() [fz_getopt()].
    """
    ret, nargv = ll_fz_getopt(nargc, ostr)
    return ret, nargv

fz_getopt = fz_getopt_outparams_fn


def ll_fz_getopt_long(nargc, ostr, longopts):
    """
    Wrapper for out-params of fz_getopt_long().
    Returns: int, char *nargv
    """
    outparams = ll_fz_getopt_long_outparams()
    ret = ll_fz_getopt_long_outparams_fn(nargc, ostr, longopts, outparams)
    return ret, outparams.nargv

def fz_getopt_long_outparams_fn(nargc, ostr, longopts):
    """
    Class-aware helper for out-params of fz_getopt_long() [fz_getopt_long()].
    """
    ret, nargv = ll_fz_getopt_long(nargc, ostr, longopts.m_internal)
    return ret, nargv

fz_getopt_long = fz_getopt_long_outparams_fn


def ll_fz_grisu(f, s):
    """
    Wrapper for out-params of fz_grisu().
    Returns: int, int exp
    """
    outparams = ll_fz_grisu_outparams()
    ret = ll_fz_grisu_outparams_fn(f, s, outparams)
    return ret, outparams.exp

def fz_grisu_outparams_fn(f, s):
    """
    Class-aware helper for out-params of fz_grisu() [fz_grisu()].
    """
    ret, exp = ll_fz_grisu(f, s)
    return ret, exp

fz_grisu = fz_grisu_outparams_fn


def ll_fz_has_option(opts, key):
    """
    Wrapper for out-params of fz_has_option().
    Returns: int, const char *val
    """
    outparams = ll_fz_has_option_outparams()
    ret = ll_fz_has_option_outparams_fn(opts, key, outparams)
    return ret, outparams.val

def fz_has_option_outparams_fn(opts, key):
    """
    Class-aware helper for out-params of fz_has_option() [fz_has_option()].
    """
    ret, val = ll_fz_has_option(opts, key)
    return ret, val

fz_has_option = fz_has_option_outparams_fn


def ll_fz_image_resolution(image):
    """
    Wrapper for out-params of fz_image_resolution().
    Returns: int xres, int yres
    """
    outparams = ll_fz_image_resolution_outparams()
    ret = ll_fz_image_resolution_outparams_fn(image, outparams)
    return outparams.xres, outparams.yres

def fz_image_resolution_outparams_fn(image):
    """
    Class-aware helper for out-params of fz_image_resolution() [fz_image_resolution()].
    """
    xres, yres = ll_fz_image_resolution(image.m_internal)
    return xres, yres

fz_image_resolution = fz_image_resolution_outparams_fn


def ll_fz_keep_imp(p):
    """
    Wrapper for out-params of fz_keep_imp().
    Returns: void *, int refs
    """
    outparams = ll_fz_keep_imp_outparams()
    ret = ll_fz_keep_imp_outparams_fn(p, outparams)
    return ret, outparams.refs

def ll_fz_keep_imp16(p):
    """
    Wrapper for out-params of fz_keep_imp16().
    Returns: void *, int16_t refs
    """
    outparams = ll_fz_keep_imp16_outparams()
    ret = ll_fz_keep_imp16_outparams_fn(p, outparams)
    return ret, outparams.refs

def ll_fz_keep_imp_locked(p):
    """
    Wrapper for out-params of fz_keep_imp_locked().
    Returns: void *, int refs
    """
    outparams = ll_fz_keep_imp_locked_outparams()
    ret = ll_fz_keep_imp_locked_outparams_fn(p, outparams)
    return ret, outparams.refs

def ll_fz_lookup_base14_font(name):
    """
    Wrapper for out-params of fz_lookup_base14_font().
    Returns: const unsigned char *, int len
    """
    outparams = ll_fz_lookup_base14_font_outparams()
    ret = ll_fz_lookup_base14_font_outparams_fn(name, outparams)
    return ret, outparams.len

def fz_lookup_base14_font_outparams_fn(name):
    """
    Class-aware helper for out-params of fz_lookup_base14_font() [fz_lookup_base14_font()].
    """
    ret, len = ll_fz_lookup_base14_font(name)
    return ret, len

fz_lookup_base14_font = fz_lookup_base14_font_outparams_fn


def ll_fz_lookup_builtin_font(name, bold, italic):
    """
    Wrapper for out-params of fz_lookup_builtin_font().
    Returns: const unsigned char *, int len
    """
    outparams = ll_fz_lookup_builtin_font_outparams()
    ret = ll_fz_lookup_builtin_font_outparams_fn(name, bold, italic, outparams)
    return ret, outparams.len

def fz_lookup_builtin_font_outparams_fn(name, bold, italic):
    """
    Class-aware helper for out-params of fz_lookup_builtin_font() [fz_lookup_builtin_font()].
    """
    ret, len = ll_fz_lookup_builtin_font(name, bold, italic)
    return ret, len

fz_lookup_builtin_font = fz_lookup_builtin_font_outparams_fn


def ll_fz_lookup_cjk_font(ordering):
    """
    Wrapper for out-params of fz_lookup_cjk_font().
    Returns: const unsigned char *, int len, int index
    """
    outparams = ll_fz_lookup_cjk_font_outparams()
    ret = ll_fz_lookup_cjk_font_outparams_fn(ordering, outparams)
    return ret, outparams.len, outparams.index

def fz_lookup_cjk_font_outparams_fn(ordering):
    """
    Class-aware helper for out-params of fz_lookup_cjk_font() [fz_lookup_cjk_font()].
    """
    ret, len, index = ll_fz_lookup_cjk_font(ordering)
    return ret, len, index

fz_lookup_cjk_font = fz_lookup_cjk_font_outparams_fn


def ll_fz_lookup_cjk_font_by_language(lang):
    """
    Wrapper for out-params of fz_lookup_cjk_font_by_language().
    Returns: const unsigned char *, int len, int subfont
    """
    outparams = ll_fz_lookup_cjk_font_by_language_outparams()
    ret = ll_fz_lookup_cjk_font_by_language_outparams_fn(lang, outparams)
    return ret, outparams.len, outparams.subfont

def fz_lookup_cjk_font_by_language_outparams_fn(lang):
    """
    Class-aware helper for out-params of fz_lookup_cjk_font_by_language() [fz_lookup_cjk_font_by_language()].
    """
    ret, len, subfont = ll_fz_lookup_cjk_font_by_language(lang)
    return ret, len, subfont

fz_lookup_cjk_font_by_language = fz_lookup_cjk_font_by_language_outparams_fn


def ll_fz_lookup_noto_boxes_font():
    """
    Wrapper for out-params of fz_lookup_noto_boxes_font().
    Returns: const unsigned char *, int len
    """
    outparams = ll_fz_lookup_noto_boxes_font_outparams()
    ret = ll_fz_lookup_noto_boxes_font_outparams_fn(outparams)
    return ret, outparams.len

def fz_lookup_noto_boxes_font_outparams_fn():
    """
    Class-aware helper for out-params of fz_lookup_noto_boxes_font() [fz_lookup_noto_boxes_font()].
    """
    ret, len = ll_fz_lookup_noto_boxes_font()
    return ret, len

fz_lookup_noto_boxes_font = fz_lookup_noto_boxes_font_outparams_fn


def ll_fz_lookup_noto_emoji_font():
    """
    Wrapper for out-params of fz_lookup_noto_emoji_font().
    Returns: const unsigned char *, int len
    """
    outparams = ll_fz_lookup_noto_emoji_font_outparams()
    ret = ll_fz_lookup_noto_emoji_font_outparams_fn(outparams)
    return ret, outparams.len

def fz_lookup_noto_emoji_font_outparams_fn():
    """
    Class-aware helper for out-params of fz_lookup_noto_emoji_font() [fz_lookup_noto_emoji_font()].
    """
    ret, len = ll_fz_lookup_noto_emoji_font()
    return ret, len

fz_lookup_noto_emoji_font = fz_lookup_noto_emoji_font_outparams_fn


def ll_fz_lookup_noto_font(script, lang):
    """
    Wrapper for out-params of fz_lookup_noto_font().
    Returns: const unsigned char *, int len, int subfont
    """
    outparams = ll_fz_lookup_noto_font_outparams()
    ret = ll_fz_lookup_noto_font_outparams_fn(script, lang, outparams)
    return ret, outparams.len, outparams.subfont

def fz_lookup_noto_font_outparams_fn(script, lang):
    """
    Class-aware helper for out-params of fz_lookup_noto_font() [fz_lookup_noto_font()].
    """
    ret, len, subfont = ll_fz_lookup_noto_font(script, lang)
    return ret, len, subfont

fz_lookup_noto_font = fz_lookup_noto_font_outparams_fn


def ll_fz_lookup_noto_math_font():
    """
    Wrapper for out-params of fz_lookup_noto_math_font().
    Returns: const unsigned char *, int len
    """
    outparams = ll_fz_lookup_noto_math_font_outparams()
    ret = ll_fz_lookup_noto_math_font_outparams_fn(outparams)
    return ret, outparams.len

def fz_lookup_noto_math_font_outparams_fn():
    """
    Class-aware helper for out-params of fz_lookup_noto_math_font() [fz_lookup_noto_math_font()].
    """
    ret, len = ll_fz_lookup_noto_math_font()
    return ret, len

fz_lookup_noto_math_font = fz_lookup_noto_math_font_outparams_fn


def ll_fz_lookup_noto_music_font():
    """
    Wrapper for out-params of fz_lookup_noto_music_font().
    Returns: const unsigned char *, int len
    """
    outparams = ll_fz_lookup_noto_music_font_outparams()
    ret = ll_fz_lookup_noto_music_font_outparams_fn(outparams)
    return ret, outparams.len

def fz_lookup_noto_music_font_outparams_fn():
    """
    Class-aware helper for out-params of fz_lookup_noto_music_font() [fz_lookup_noto_music_font()].
    """
    ret, len = ll_fz_lookup_noto_music_font()
    return ret, len

fz_lookup_noto_music_font = fz_lookup_noto_music_font_outparams_fn


def ll_fz_lookup_noto_symbol1_font():
    """
    Wrapper for out-params of fz_lookup_noto_symbol1_font().
    Returns: const unsigned char *, int len
    """
    outparams = ll_fz_lookup_noto_symbol1_font_outparams()
    ret = ll_fz_lookup_noto_symbol1_font_outparams_fn(outparams)
    return ret, outparams.len

def fz_lookup_noto_symbol1_font_outparams_fn():
    """
    Class-aware helper for out-params of fz_lookup_noto_symbol1_font() [fz_lookup_noto_symbol1_font()].
    """
    ret, len = ll_fz_lookup_noto_symbol1_font()
    return ret, len

fz_lookup_noto_symbol1_font = fz_lookup_noto_symbol1_font_outparams_fn


def ll_fz_lookup_noto_symbol2_font():
    """
    Wrapper for out-params of fz_lookup_noto_symbol2_font().
    Returns: const unsigned char *, int len
    """
    outparams = ll_fz_lookup_noto_symbol2_font_outparams()
    ret = ll_fz_lookup_noto_symbol2_font_outparams_fn(outparams)
    return ret, outparams.len

def fz_lookup_noto_symbol2_font_outparams_fn():
    """
    Class-aware helper for out-params of fz_lookup_noto_symbol2_font() [fz_lookup_noto_symbol2_font()].
    """
    ret, len = ll_fz_lookup_noto_symbol2_font()
    return ret, len

fz_lookup_noto_symbol2_font = fz_lookup_noto_symbol2_font_outparams_fn


def ll_fz_new_deflated_data(source, source_length, level):
    """
    Wrapper for out-params of fz_new_deflated_data().
    Returns: unsigned char *, size_t compressed_length
    """
    outparams = ll_fz_new_deflated_data_outparams()
    ret = ll_fz_new_deflated_data_outparams_fn(source, source_length, level, outparams)
    return ret, outparams.compressed_length

def fz_new_deflated_data_outparams_fn(source, source_length, level):
    """
    Class-aware helper for out-params of fz_new_deflated_data() [fz_new_deflated_data()].
    """
    ret, compressed_length = ll_fz_new_deflated_data(source, source_length, level)
    return ret, compressed_length

fz_new_deflated_data = fz_new_deflated_data_outparams_fn


def ll_fz_new_deflated_data_from_buffer(buffer, level):
    """
    Wrapper for out-params of fz_new_deflated_data_from_buffer().
    Returns: unsigned char *, size_t compressed_length
    """
    outparams = ll_fz_new_deflated_data_from_buffer_outparams()
    ret = ll_fz_new_deflated_data_from_buffer_outparams_fn(buffer, level, outparams)
    return ret, outparams.compressed_length

def fz_new_deflated_data_from_buffer_outparams_fn(buffer, level):
    """
    Class-aware helper for out-params of fz_new_deflated_data_from_buffer() [fz_new_deflated_data_from_buffer()].
    """
    ret, compressed_length = ll_fz_new_deflated_data_from_buffer(buffer.m_internal, level)
    return ret, compressed_length

fz_new_deflated_data_from_buffer = fz_new_deflated_data_from_buffer_outparams_fn


def ll_fz_new_display_list_from_svg(buf, base_uri, dir):
    """
    Wrapper for out-params of fz_new_display_list_from_svg().
    Returns: fz_display_list *, float w, float h
    """
    outparams = ll_fz_new_display_list_from_svg_outparams()
    ret = ll_fz_new_display_list_from_svg_outparams_fn(buf, base_uri, dir, outparams)
    return ret, outparams.w, outparams.h

def fz_new_display_list_from_svg_outparams_fn(buf, base_uri, dir):
    """
    Class-aware helper for out-params of fz_new_display_list_from_svg() [fz_new_display_list_from_svg()].
    """
    ret, w, h = ll_fz_new_display_list_from_svg(buf.m_internal, base_uri, dir.m_internal)
    return FzDisplayList(ret), w, h

fz_new_display_list_from_svg = fz_new_display_list_from_svg_outparams_fn


def ll_fz_new_display_list_from_svg_xml(xmldoc, xml, base_uri, dir):
    """
    Wrapper for out-params of fz_new_display_list_from_svg_xml().
    Returns: fz_display_list *, float w, float h
    """
    outparams = ll_fz_new_display_list_from_svg_xml_outparams()
    ret = ll_fz_new_display_list_from_svg_xml_outparams_fn(xmldoc, xml, base_uri, dir, outparams)
    return ret, outparams.w, outparams.h

def fz_new_display_list_from_svg_xml_outparams_fn(xmldoc, xml, base_uri, dir):
    """
    Class-aware helper for out-params of fz_new_display_list_from_svg_xml() [fz_new_display_list_from_svg_xml()].
    """
    ret, w, h = ll_fz_new_display_list_from_svg_xml(xmldoc.m_internal, xml.m_internal, base_uri, dir.m_internal)
    return FzDisplayList(ret), w, h

fz_new_display_list_from_svg_xml = fz_new_display_list_from_svg_xml_outparams_fn


def ll_fz_new_draw_device_with_options(options, mediabox):
    """
    Wrapper for out-params of fz_new_draw_device_with_options().
    Returns: fz_device *, ::fz_pixmap *pixmap
    """
    outparams = ll_fz_new_draw_device_with_options_outparams()
    ret = ll_fz_new_draw_device_with_options_outparams_fn(options, mediabox, outparams)
    return ret, outparams.pixmap

def fz_new_draw_device_with_options_outparams_fn(options, mediabox):
    """
    Class-aware helper for out-params of fz_new_draw_device_with_options() [fz_new_draw_device_with_options()].
    """
    ret, pixmap = ll_fz_new_draw_device_with_options(options.internal(), mediabox.internal())
    return FzDevice(ret), FzPixmap( pixmap)

fz_new_draw_device_with_options = fz_new_draw_device_with_options_outparams_fn


def ll_fz_new_svg_device_with_id(out, page_width, page_height, text_format, reuse_images):
    """
    Wrapper for out-params of fz_new_svg_device_with_id().
    Returns: fz_device *, int id
    """
    outparams = ll_fz_new_svg_device_with_id_outparams()
    ret = ll_fz_new_svg_device_with_id_outparams_fn(out, page_width, page_height, text_format, reuse_images, outparams)
    return ret, outparams.id

def fz_new_svg_device_with_id_outparams_fn(out, page_width, page_height, text_format, reuse_images):
    """
    Class-aware helper for out-params of fz_new_svg_device_with_id() [fz_new_svg_device_with_id()].
    """
    ret, id = ll_fz_new_svg_device_with_id(out.m_internal, page_width, page_height, text_format, reuse_images)
    return FzDevice(ret), id

fz_new_svg_device_with_id = fz_new_svg_device_with_id_outparams_fn


def ll_fz_new_test_device(threshold, options, passthrough):
    """
    Wrapper for out-params of fz_new_test_device().
    Returns: fz_device *, int is_color
    """
    outparams = ll_fz_new_test_device_outparams()
    ret = ll_fz_new_test_device_outparams_fn(threshold, options, passthrough, outparams)
    return ret, outparams.is_color

def fz_new_test_device_outparams_fn(threshold, options, passthrough):
    """
    Class-aware helper for out-params of fz_new_test_device() [fz_new_test_device()].
    """
    ret, is_color = ll_fz_new_test_device(threshold, options, passthrough.m_internal)
    return FzDevice(ret), is_color

fz_new_test_device = fz_new_test_device_outparams_fn


def ll_fz_open_image_decomp_stream(arg_0, arg_1):
    """
    Wrapper for out-params of fz_open_image_decomp_stream().
    Returns: fz_stream *, int l2factor
    """
    outparams = ll_fz_open_image_decomp_stream_outparams()
    ret = ll_fz_open_image_decomp_stream_outparams_fn(arg_0, arg_1, outparams)
    return ret, outparams.l2factor

def fz_open_image_decomp_stream_outparams_fn(arg_0, arg_1):
    """
    Class-aware helper for out-params of fz_open_image_decomp_stream() [fz_open_image_decomp_stream()].
    """
    ret, l2factor = ll_fz_open_image_decomp_stream(arg_0.m_internal, arg_1.m_internal)
    return FzStream(ret), l2factor

fz_open_image_decomp_stream = fz_open_image_decomp_stream_outparams_fn


def ll_fz_open_image_decomp_stream_from_buffer(arg_0):
    """
    Wrapper for out-params of fz_open_image_decomp_stream_from_buffer().
    Returns: fz_stream *, int l2factor
    """
    outparams = ll_fz_open_image_decomp_stream_from_buffer_outparams()
    ret = ll_fz_open_image_decomp_stream_from_buffer_outparams_fn(arg_0, outparams)
    return ret, outparams.l2factor

def fz_open_image_decomp_stream_from_buffer_outparams_fn(arg_0):
    """
    Class-aware helper for out-params of fz_open_image_decomp_stream_from_buffer() [fz_open_image_decomp_stream_from_buffer()].
    """
    ret, l2factor = ll_fz_open_image_decomp_stream_from_buffer(arg_0.m_internal)
    return FzStream(ret), l2factor

fz_open_image_decomp_stream_from_buffer = fz_open_image_decomp_stream_from_buffer_outparams_fn


def ll_fz_page_presentation(page, transition):
    """
    Wrapper for out-params of fz_page_presentation().
    Returns: fz_transition *, float duration
    """
    outparams = ll_fz_page_presentation_outparams()
    ret = ll_fz_page_presentation_outparams_fn(page, transition, outparams)
    return ret, outparams.duration

def fz_page_presentation_outparams_fn(page, transition):
    """
    Class-aware helper for out-params of fz_page_presentation() [fz_page_presentation()].
    """
    ret, duration = ll_fz_page_presentation(page.m_internal, transition.internal())
    return FzTransition(ret), duration

fz_page_presentation = fz_page_presentation_outparams_fn


def ll_fz_paint_shade(shade, override_cs, ctm, dest, color_params, bbox, eop):
    """
    Wrapper for out-params of fz_paint_shade().
    Returns: ::fz_shade_color_cache *cache
    """
    outparams = ll_fz_paint_shade_outparams()
    ret = ll_fz_paint_shade_outparams_fn(shade, override_cs, ctm, dest, color_params, bbox, eop, outparams)
    return outparams.cache

def fz_paint_shade_outparams_fn(shade, override_cs, ctm, dest, color_params, bbox, eop):
    """
    Class-aware helper for out-params of fz_paint_shade() [fz_paint_shade()].
    """
    cache = ll_fz_paint_shade(shade.m_internal, override_cs.m_internal, ctm.internal(), dest.m_internal, color_params.internal(), bbox.internal(), eop.m_internal)
    return FzShadeColorCache(ll_fz_keep_shade_color_cache( cache))

fz_paint_shade = fz_paint_shade_outparams_fn


def ll_fz_parse_page_range(s, n):
    """
    Wrapper for out-params of fz_parse_page_range().
    Returns: const char *, int a, int b
    """
    outparams = ll_fz_parse_page_range_outparams()
    ret = ll_fz_parse_page_range_outparams_fn(s, n, outparams)
    return ret, outparams.a, outparams.b

def fz_parse_page_range_outparams_fn(s, n):
    """
    Class-aware helper for out-params of fz_parse_page_range() [fz_parse_page_range()].
    """
    ret, a, b = ll_fz_parse_page_range(s, n)
    return ret, a, b

fz_parse_page_range = fz_parse_page_range_outparams_fn


def ll_fz_read_best(stm, initial, worst_case):
    """
    Wrapper for out-params of fz_read_best().
    Returns: fz_buffer *, int truncated
    """
    outparams = ll_fz_read_best_outparams()
    ret = ll_fz_read_best_outparams_fn(stm, initial, worst_case, outparams)
    return ret, outparams.truncated

def fz_read_best_outparams_fn(stm, initial, worst_case):
    """
    Class-aware helper for out-params of fz_read_best() [fz_read_best()].
    """
    ret, truncated = ll_fz_read_best(stm.m_internal, initial, worst_case)
    return FzBuffer(ret), truncated

fz_read_best = fz_read_best_outparams_fn


def ll_fz_resolve_link(doc, uri):
    """
    Wrapper for out-params of fz_resolve_link().
    Returns: fz_location, float xp, float yp
    """
    outparams = ll_fz_resolve_link_outparams()
    ret = ll_fz_resolve_link_outparams_fn(doc, uri, outparams)
    return ret, outparams.xp, outparams.yp

def fz_resolve_link_outparams_fn(doc, uri):
    """
    Class-aware helper for out-params of fz_resolve_link() [fz_resolve_link()].
    """
    ret, xp, yp = ll_fz_resolve_link(doc.m_internal, uri)
    return FzLocation(ret), xp, yp

fz_resolve_link = fz_resolve_link_outparams_fn


def ll_fz_search_chapter_page_number(doc, chapter, page, needle, hit_bbox, hit_max):
    """
    Wrapper for out-params of fz_search_chapter_page_number().
    Returns: int, int hit_mark
    """
    outparams = ll_fz_search_chapter_page_number_outparams()
    ret = ll_fz_search_chapter_page_number_outparams_fn(doc, chapter, page, needle, hit_bbox, hit_max, outparams)
    return ret, outparams.hit_mark

def fz_search_chapter_page_number_outparams_fn(doc, chapter, page, needle, hit_bbox, hit_max):
    """
    Class-aware helper for out-params of fz_search_chapter_page_number() [fz_search_chapter_page_number()].
    """
    ret, hit_mark = ll_fz_search_chapter_page_number(doc.m_internal, chapter, page, needle, hit_bbox.internal(), hit_max)
    return ret, hit_mark

fz_search_chapter_page_number = fz_search_chapter_page_number_outparams_fn


def ll_fz_search_display_list(list, needle, hit_bbox, hit_max):
    """
    Wrapper for out-params of fz_search_display_list().
    Returns: int, int hit_mark
    """
    outparams = ll_fz_search_display_list_outparams()
    ret = ll_fz_search_display_list_outparams_fn(list, needle, hit_bbox, hit_max, outparams)
    return ret, outparams.hit_mark

def fz_search_display_list_outparams_fn(list, needle, hit_bbox, hit_max):
    """
    Class-aware helper for out-params of fz_search_display_list() [fz_search_display_list()].
    """
    ret, hit_mark = ll_fz_search_display_list(list.m_internal, needle, hit_bbox.internal(), hit_max)
    return ret, hit_mark

fz_search_display_list = fz_search_display_list_outparams_fn


def ll_fz_search_page(page, needle, hit_bbox, hit_max):
    """
    Wrapper for out-params of fz_search_page().
    Returns: int, int hit_mark
    """
    outparams = ll_fz_search_page_outparams()
    ret = ll_fz_search_page_outparams_fn(page, needle, hit_bbox, hit_max, outparams)
    return ret, outparams.hit_mark

def fz_search_page_outparams_fn(page, needle, hit_bbox, hit_max):
    """
    Class-aware helper for out-params of fz_search_page() [fz_search_page()].
    """
    ret, hit_mark = ll_fz_search_page(page.m_internal, needle, hit_bbox.internal(), hit_max)
    return ret, hit_mark

fz_search_page = fz_search_page_outparams_fn


def ll_fz_search_page_number(doc, number, needle, hit_bbox, hit_max):
    """
    Wrapper for out-params of fz_search_page_number().
    Returns: int, int hit_mark
    """
    outparams = ll_fz_search_page_number_outparams()
    ret = ll_fz_search_page_number_outparams_fn(doc, number, needle, hit_bbox, hit_max, outparams)
    return ret, outparams.hit_mark

def fz_search_page_number_outparams_fn(doc, number, needle, hit_bbox, hit_max):
    """
    Class-aware helper for out-params of fz_search_page_number() [fz_search_page_number()].
    """
    ret, hit_mark = ll_fz_search_page_number(doc.m_internal, number, needle, hit_bbox.internal(), hit_max)
    return ret, hit_mark

fz_search_page_number = fz_search_page_number_outparams_fn


def ll_fz_search_stext_page(text, needle, hit_bbox, hit_max):
    """
    Wrapper for out-params of fz_search_stext_page().
    Returns: int, int hit_mark
    """
    outparams = ll_fz_search_stext_page_outparams()
    ret = ll_fz_search_stext_page_outparams_fn(text, needle, hit_bbox, hit_max, outparams)
    return ret, outparams.hit_mark

def fz_search_stext_page_outparams_fn(text, needle, hit_bbox, hit_max):
    """
    Class-aware helper for out-params of fz_search_stext_page() [fz_search_stext_page()].
    """
    ret, hit_mark = ll_fz_search_stext_page(text.m_internal, needle, hit_bbox.internal(), hit_max)
    return ret, hit_mark

fz_search_stext_page = fz_search_stext_page_outparams_fn


def ll_fz_separation_equivalent(seps, idx, dst_cs, prf, color_params):
    """
    Wrapper for out-params of fz_separation_equivalent().
    Returns: float dst_color
    """
    outparams = ll_fz_separation_equivalent_outparams()
    ret = ll_fz_separation_equivalent_outparams_fn(seps, idx, dst_cs, prf, color_params, outparams)
    return outparams.dst_color

def fz_separation_equivalent_outparams_fn(seps, idx, dst_cs, prf, color_params):
    """
    Class-aware helper for out-params of fz_separation_equivalent() [fz_separation_equivalent()].
    """
    dst_color = ll_fz_separation_equivalent(seps.m_internal, idx, dst_cs.m_internal, prf.m_internal, color_params.internal())
    return dst_color

fz_separation_equivalent = fz_separation_equivalent_outparams_fn


def ll_fz_store_scavenge(size):
    """
    Wrapper for out-params of fz_store_scavenge().
    Returns: int, int phase
    """
    outparams = ll_fz_store_scavenge_outparams()
    ret = ll_fz_store_scavenge_outparams_fn(size, outparams)
    return ret, outparams.phase

def fz_store_scavenge_outparams_fn(size):
    """
    Class-aware helper for out-params of fz_store_scavenge() [fz_store_scavenge()].
    """
    ret, phase = ll_fz_store_scavenge(size)
    return ret, phase

fz_store_scavenge = fz_store_scavenge_outparams_fn


def ll_fz_store_scavenge_external(size):
    """
    Wrapper for out-params of fz_store_scavenge_external().
    Returns: int, int phase
    """
    outparams = ll_fz_store_scavenge_external_outparams()
    ret = ll_fz_store_scavenge_external_outparams_fn(size, outparams)
    return ret, outparams.phase

def fz_store_scavenge_external_outparams_fn(size):
    """
    Class-aware helper for out-params of fz_store_scavenge_external() [fz_store_scavenge_external()].
    """
    ret, phase = ll_fz_store_scavenge_external(size)
    return ret, phase

fz_store_scavenge_external = fz_store_scavenge_external_outparams_fn


def ll_fz_strsep(delim):
    """
    Wrapper for out-params of fz_strsep().
    Returns: char *, char *stringp
    """
    outparams = ll_fz_strsep_outparams()
    ret = ll_fz_strsep_outparams_fn(delim, outparams)
    return ret, outparams.stringp

def fz_strsep_outparams_fn(delim):
    """
    Class-aware helper for out-params of fz_strsep() [fz_strsep()].
    """
    ret, stringp = ll_fz_strsep(delim)
    return ret, stringp

fz_strsep = fz_strsep_outparams_fn


def ll_fz_strtof(s):
    """
    Wrapper for out-params of fz_strtof().
    Returns: float, char *es
    """
    outparams = ll_fz_strtof_outparams()
    ret = ll_fz_strtof_outparams_fn(s, outparams)
    return ret, outparams.es

def fz_strtof_outparams_fn(s):
    """
    Class-aware helper for out-params of fz_strtof() [fz_strtof()].
    """
    ret, es = ll_fz_strtof(s)
    return ret, es

fz_strtof = fz_strtof_outparams_fn


def ll_fz_subset_cff_for_gids(orig, num_gids, symbolic, cidfont):
    """
    Wrapper for out-params of fz_subset_cff_for_gids().
    Returns: fz_buffer *, int gids
    """
    outparams = ll_fz_subset_cff_for_gids_outparams()
    ret = ll_fz_subset_cff_for_gids_outparams_fn(orig, num_gids, symbolic, cidfont, outparams)
    return ret, outparams.gids

def fz_subset_cff_for_gids_outparams_fn(orig, num_gids, symbolic, cidfont):
    """
    Class-aware helper for out-params of fz_subset_cff_for_gids() [fz_subset_cff_for_gids()].
    """
    ret, gids = ll_fz_subset_cff_for_gids(orig.m_internal, num_gids, symbolic, cidfont)
    return FzBuffer( ll_fz_keep_buffer( ret)), gids

fz_subset_cff_for_gids = fz_subset_cff_for_gids_outparams_fn


def ll_fz_subset_ttf_for_gids(orig, num_gids, symbolic, cidfont):
    """
    Wrapper for out-params of fz_subset_ttf_for_gids().
    Returns: fz_buffer *, int gids
    """
    outparams = ll_fz_subset_ttf_for_gids_outparams()
    ret = ll_fz_subset_ttf_for_gids_outparams_fn(orig, num_gids, symbolic, cidfont, outparams)
    return ret, outparams.gids

def fz_subset_ttf_for_gids_outparams_fn(orig, num_gids, symbolic, cidfont):
    """
    Class-aware helper for out-params of fz_subset_ttf_for_gids() [fz_subset_ttf_for_gids()].
    """
    ret, gids = ll_fz_subset_ttf_for_gids(orig.m_internal, num_gids, symbolic, cidfont)
    return FzBuffer( ll_fz_keep_buffer( ret)), gids

fz_subset_ttf_for_gids = fz_subset_ttf_for_gids_outparams_fn


def ll_fz_warning_callback():
    """
    Wrapper for out-params of fz_warning_callback().
    Returns: fz_warning_cb *, void *user
    """
    outparams = ll_fz_warning_callback_outparams()
    ret = ll_fz_warning_callback_outparams_fn(outparams)
    return ret, outparams.user

def fz_warning_callback_outparams_fn():
    """
    Class-aware helper for out-params of fz_warning_callback() [fz_warning_callback()].
    """
    ret, user = ll_fz_warning_callback()
    return ret, user

fz_warning_callback = fz_warning_callback_outparams_fn


def ll_pdf_annot_MK_BC(annot, color):
    """
    Wrapper for out-params of pdf_annot_MK_BC().
    Returns: int n
    """
    outparams = ll_pdf_annot_MK_BC_outparams()
    ret = ll_pdf_annot_MK_BC_outparams_fn(annot, color, outparams)
    return outparams.n

def pdf_annot_MK_BC_outparams_fn(annot, color):
    """
    Class-aware helper for out-params of pdf_annot_MK_BC() [pdf_annot_MK_BC()].
    """
    n = ll_pdf_annot_MK_BC(annot.m_internal, color)
    return n

pdf_annot_MK_BC = pdf_annot_MK_BC_outparams_fn


def ll_pdf_annot_MK_BG(annot, color):
    """
    Wrapper for out-params of pdf_annot_MK_BG().
    Returns: int n
    """
    outparams = ll_pdf_annot_MK_BG_outparams()
    ret = ll_pdf_annot_MK_BG_outparams_fn(annot, color, outparams)
    return outparams.n

def pdf_annot_MK_BG_outparams_fn(annot, color):
    """
    Class-aware helper for out-params of pdf_annot_MK_BG() [pdf_annot_MK_BG()].
    """
    n = ll_pdf_annot_MK_BG(annot.m_internal, color)
    return n

pdf_annot_MK_BG = pdf_annot_MK_BG_outparams_fn


def ll_pdf_annot_color(annot, color):
    """
    Wrapper for out-params of pdf_annot_color().
    Returns: int n
    """
    outparams = ll_pdf_annot_color_outparams()
    ret = ll_pdf_annot_color_outparams_fn(annot, color, outparams)
    return outparams.n

def pdf_annot_color_outparams_fn(annot, color):
    """
    Class-aware helper for out-params of pdf_annot_color() [pdf_annot_color()].
    """
    n = ll_pdf_annot_color(annot.m_internal, color)
    return n

pdf_annot_color = pdf_annot_color_outparams_fn


def ll_pdf_annot_default_appearance(annot, color):
    """
    Wrapper for out-params of pdf_annot_default_appearance().
    Returns: const char *font, float size, int n
    """
    outparams = ll_pdf_annot_default_appearance_outparams()
    ret = ll_pdf_annot_default_appearance_outparams_fn(annot, color, outparams)
    return outparams.font, outparams.size, outparams.n

def pdf_annot_default_appearance_outparams_fn(annot, color):
    """
    Class-aware helper for out-params of pdf_annot_default_appearance() [pdf_annot_default_appearance()].
    """
    font, size, n = ll_pdf_annot_default_appearance(annot.m_internal, color)
    return font, size, n

pdf_annot_default_appearance = pdf_annot_default_appearance_outparams_fn


def ll_pdf_annot_interior_color(annot, color):
    """
    Wrapper for out-params of pdf_annot_interior_color().
    Returns: int n
    """
    outparams = ll_pdf_annot_interior_color_outparams()
    ret = ll_pdf_annot_interior_color_outparams_fn(annot, color, outparams)
    return outparams.n

def pdf_annot_interior_color_outparams_fn(annot, color):
    """
    Class-aware helper for out-params of pdf_annot_interior_color() [pdf_annot_interior_color()].
    """
    n = ll_pdf_annot_interior_color(annot.m_internal, color)
    return n

pdf_annot_interior_color = pdf_annot_interior_color_outparams_fn


def ll_pdf_annot_line_ending_styles(annot):
    """
    Wrapper for out-params of pdf_annot_line_ending_styles().
    Returns: enum pdf_line_ending start_style, enum pdf_line_ending end_style
    """
    outparams = ll_pdf_annot_line_ending_styles_outparams()
    ret = ll_pdf_annot_line_ending_styles_outparams_fn(annot, outparams)
    return outparams.start_style, outparams.end_style

def pdf_annot_line_ending_styles_outparams_fn(annot):
    """
    Class-aware helper for out-params of pdf_annot_line_ending_styles() [pdf_annot_line_ending_styles()].
    """
    start_style, end_style = ll_pdf_annot_line_ending_styles(annot.m_internal)
    return start_style, end_style

pdf_annot_line_ending_styles = pdf_annot_line_ending_styles_outparams_fn


def ll_pdf_array_get_string(array, index):
    """
    Wrapper for out-params of pdf_array_get_string().
    Returns: const char *, size_t sizep
    """
    outparams = ll_pdf_array_get_string_outparams()
    ret = ll_pdf_array_get_string_outparams_fn(array, index, outparams)
    return ret, outparams.sizep

def pdf_array_get_string_outparams_fn(array, index):
    """
    Class-aware helper for out-params of pdf_array_get_string() [pdf_array_get_string()].
    """
    ret, sizep = ll_pdf_array_get_string(array.m_internal, index)
    return ret, sizep

pdf_array_get_string = pdf_array_get_string_outparams_fn


def ll_pdf_count_q_balance(doc, res, stm):
    """
    Wrapper for out-params of pdf_count_q_balance().
    Returns: int prepend, int append
    """
    outparams = ll_pdf_count_q_balance_outparams()
    ret = ll_pdf_count_q_balance_outparams_fn(doc, res, stm, outparams)
    return outparams.prepend, outparams.append

def pdf_count_q_balance_outparams_fn(doc, res, stm):
    """
    Class-aware helper for out-params of pdf_count_q_balance() [pdf_count_q_balance()].
    """
    prepend, append = ll_pdf_count_q_balance(doc.m_internal, res.m_internal, stm.m_internal)
    return prepend, append

pdf_count_q_balance = pdf_count_q_balance_outparams_fn


def ll_pdf_decode_cmap(cmap, s, e):
    """
    Wrapper for out-params of pdf_decode_cmap().
    Returns: int, unsigned int cpt
    """
    outparams = ll_pdf_decode_cmap_outparams()
    ret = ll_pdf_decode_cmap_outparams_fn(cmap, s, e, outparams)
    return ret, outparams.cpt

def pdf_decode_cmap_outparams_fn(cmap, s, e):
    """
    Class-aware helper for out-params of pdf_decode_cmap() [pdf_decode_cmap()].
    """
    ret, cpt = ll_pdf_decode_cmap(cmap.m_internal, s, e)
    return ret, cpt

pdf_decode_cmap = pdf_decode_cmap_outparams_fn


def ll_pdf_dict_get_inheritable_string(dict, key):
    """
    Wrapper for out-params of pdf_dict_get_inheritable_string().
    Returns: const char *, size_t sizep
    """
    outparams = ll_pdf_dict_get_inheritable_string_outparams()
    ret = ll_pdf_dict_get_inheritable_string_outparams_fn(dict, key, outparams)
    return ret, outparams.sizep

def pdf_dict_get_inheritable_string_outparams_fn(dict, key):
    """
    Class-aware helper for out-params of pdf_dict_get_inheritable_string() [pdf_dict_get_inheritable_string()].
    """
    ret, sizep = ll_pdf_dict_get_inheritable_string(dict.m_internal, key.m_internal)
    return ret, sizep

pdf_dict_get_inheritable_string = pdf_dict_get_inheritable_string_outparams_fn


def ll_pdf_dict_get_put_drop(dict, key, val):
    """
    Wrapper for out-params of pdf_dict_get_put_drop().
    Returns: ::pdf_obj *old_val
    """
    outparams = ll_pdf_dict_get_put_drop_outparams()
    ret = ll_pdf_dict_get_put_drop_outparams_fn(dict, key, val, outparams)
    return outparams.old_val

def ll_pdf_dict_get_string(dict, key):
    """
    Wrapper for out-params of pdf_dict_get_string().
    Returns: const char *, size_t sizep
    """
    outparams = ll_pdf_dict_get_string_outparams()
    ret = ll_pdf_dict_get_string_outparams_fn(dict, key, outparams)
    return ret, outparams.sizep

def pdf_dict_get_string_outparams_fn(dict, key):
    """
    Class-aware helper for out-params of pdf_dict_get_string() [pdf_dict_get_string()].
    """
    ret, sizep = ll_pdf_dict_get_string(dict.m_internal, key.m_internal)
    return ret, sizep

pdf_dict_get_string = pdf_dict_get_string_outparams_fn


def ll_pdf_edit_text_field_value(widget, value, change):
    """
    Wrapper for out-params of pdf_edit_text_field_value().
    Returns: int, int selStart, int selEnd, char *newvalue
    """
    outparams = ll_pdf_edit_text_field_value_outparams()
    ret = ll_pdf_edit_text_field_value_outparams_fn(widget, value, change, outparams)
    return ret, outparams.selStart, outparams.selEnd, outparams.newvalue

def pdf_edit_text_field_value_outparams_fn(widget, value, change):
    """
    Class-aware helper for out-params of pdf_edit_text_field_value() [pdf_edit_text_field_value()].
    """
    ret, selStart, selEnd, newvalue = ll_pdf_edit_text_field_value(widget.m_internal, value, change)
    return ret, selStart, selEnd, newvalue

pdf_edit_text_field_value = pdf_edit_text_field_value_outparams_fn


def ll_pdf_eval_function(func, in_, inlen, outlen):
    """
    Wrapper for out-params of pdf_eval_function().
    Returns: float out
    """
    outparams = ll_pdf_eval_function_outparams()
    ret = ll_pdf_eval_function_outparams_fn(func, in_, inlen, outlen, outparams)
    return outparams.out

def pdf_eval_function_outparams_fn(func, in_, inlen, outlen):
    """
    Class-aware helper for out-params of pdf_eval_function() [pdf_eval_function()].
    """
    out = ll_pdf_eval_function(func.m_internal, in_, inlen, outlen)
    return out

pdf_eval_function = pdf_eval_function_outparams_fn


def ll_pdf_field_event_validate(doc, field, value):
    """
    Wrapper for out-params of pdf_field_event_validate().
    Returns: int, char *newvalue
    """
    outparams = ll_pdf_field_event_validate_outparams()
    ret = ll_pdf_field_event_validate_outparams_fn(doc, field, value, outparams)
    return ret, outparams.newvalue

def pdf_field_event_validate_outparams_fn(doc, field, value):
    """
    Class-aware helper for out-params of pdf_field_event_validate() [pdf_field_event_validate()].
    """
    ret, newvalue = ll_pdf_field_event_validate(doc.m_internal, field.m_internal, value)
    return ret, newvalue

pdf_field_event_validate = pdf_field_event_validate_outparams_fn


def ll_pdf_js_event_result_validate(js):
    """
    Wrapper for out-params of pdf_js_event_result_validate().
    Returns: int, char *newvalue
    """
    outparams = ll_pdf_js_event_result_validate_outparams()
    ret = ll_pdf_js_event_result_validate_outparams_fn(js, outparams)
    return ret, outparams.newvalue

def pdf_js_event_result_validate_outparams_fn(js):
    """
    Class-aware helper for out-params of pdf_js_event_result_validate() [pdf_js_event_result_validate()].
    """
    ret, newvalue = ll_pdf_js_event_result_validate(js.m_internal)
    return ret, newvalue

pdf_js_event_result_validate = pdf_js_event_result_validate_outparams_fn


def ll_pdf_js_execute(js, name, code):
    """
    Wrapper for out-params of pdf_js_execute().
    Returns: char *result
    """
    outparams = ll_pdf_js_execute_outparams()
    ret = ll_pdf_js_execute_outparams_fn(js, name, code, outparams)
    return outparams.result

def pdf_js_execute_outparams_fn(js, name, code):
    """
    Class-aware helper for out-params of pdf_js_execute() [pdf_js_execute()].
    """
    result = ll_pdf_js_execute(js.m_internal, name, code)
    return result

pdf_js_execute = pdf_js_execute_outparams_fn


def ll_pdf_load_encoding(encoding):
    """
    Wrapper for out-params of pdf_load_encoding().
    Returns: const char *estrings
    """
    outparams = ll_pdf_load_encoding_outparams()
    ret = ll_pdf_load_encoding_outparams_fn(encoding, outparams)
    return outparams.estrings

def pdf_load_encoding_outparams_fn(encoding):
    """
    Class-aware helper for out-params of pdf_load_encoding() [pdf_load_encoding()].
    """
    estrings = ll_pdf_load_encoding(encoding)
    return estrings

pdf_load_encoding = pdf_load_encoding_outparams_fn


def ll_pdf_load_to_unicode(doc, font, collection, cmapstm):
    """
    Wrapper for out-params of pdf_load_to_unicode().
    Returns: const char *strings
    """
    outparams = ll_pdf_load_to_unicode_outparams()
    ret = ll_pdf_load_to_unicode_outparams_fn(doc, font, collection, cmapstm, outparams)
    return outparams.strings

def pdf_load_to_unicode_outparams_fn(doc, font, collection, cmapstm):
    """
    Class-aware helper for out-params of pdf_load_to_unicode() [pdf_load_to_unicode()].
    """
    strings = ll_pdf_load_to_unicode(doc.m_internal, font.m_internal, collection, cmapstm.m_internal)
    return strings

pdf_load_to_unicode = pdf_load_to_unicode_outparams_fn


def ll_pdf_lookup_cmap_full(cmap, cpt):
    """
    Wrapper for out-params of pdf_lookup_cmap_full().
    Returns: int, int out
    """
    outparams = ll_pdf_lookup_cmap_full_outparams()
    ret = ll_pdf_lookup_cmap_full_outparams_fn(cmap, cpt, outparams)
    return ret, outparams.out

def pdf_lookup_cmap_full_outparams_fn(cmap, cpt):
    """
    Class-aware helper for out-params of pdf_lookup_cmap_full() [pdf_lookup_cmap_full()].
    """
    ret, out = ll_pdf_lookup_cmap_full(cmap.m_internal, cpt)
    return ret, out

pdf_lookup_cmap_full = pdf_lookup_cmap_full_outparams_fn


def ll_pdf_lookup_page_loc(doc, needle):
    """
    Wrapper for out-params of pdf_lookup_page_loc().
    Returns: pdf_obj *, ::pdf_obj *parentp, int indexp
    """
    outparams = ll_pdf_lookup_page_loc_outparams()
    ret = ll_pdf_lookup_page_loc_outparams_fn(doc, needle, outparams)
    return ret, outparams.parentp, outparams.indexp

def pdf_lookup_page_loc_outparams_fn(doc, needle):
    """
    Class-aware helper for out-params of pdf_lookup_page_loc() [pdf_lookup_page_loc()].
    """
    ret, parentp, indexp = ll_pdf_lookup_page_loc(doc.m_internal, needle)
    return PdfObj( ll_pdf_keep_obj( ret)), PdfObj(ll_pdf_keep_obj( parentp)), indexp

pdf_lookup_page_loc = pdf_lookup_page_loc_outparams_fn


def ll_pdf_lookup_substitute_font(mono, serif, bold, italic):
    """
    Wrapper for out-params of pdf_lookup_substitute_font().
    Returns: const unsigned char *, int len
    """
    outparams = ll_pdf_lookup_substitute_font_outparams()
    ret = ll_pdf_lookup_substitute_font_outparams_fn(mono, serif, bold, italic, outparams)
    return ret, outparams.len

def pdf_lookup_substitute_font_outparams_fn(mono, serif, bold, italic):
    """
    Class-aware helper for out-params of pdf_lookup_substitute_font() [pdf_lookup_substitute_font()].
    """
    ret, len = ll_pdf_lookup_substitute_font(mono, serif, bold, italic)
    return ret, len

pdf_lookup_substitute_font = pdf_lookup_substitute_font_outparams_fn


def ll_pdf_map_one_to_many(cmap, one, len):
    """
    Wrapper for out-params of pdf_map_one_to_many().
    Returns: int many
    """
    outparams = ll_pdf_map_one_to_many_outparams()
    ret = ll_pdf_map_one_to_many_outparams_fn(cmap, one, len, outparams)
    return outparams.many

def pdf_map_one_to_many_outparams_fn(cmap, one, len):
    """
    Class-aware helper for out-params of pdf_map_one_to_many() [pdf_map_one_to_many()].
    """
    many = ll_pdf_map_one_to_many(cmap.m_internal, one, len)
    return many

pdf_map_one_to_many = pdf_map_one_to_many_outparams_fn


def ll_pdf_obj_memo(obj, bit):
    """
    Wrapper for out-params of pdf_obj_memo().
    Returns: int, int memo
    """
    outparams = ll_pdf_obj_memo_outparams()
    ret = ll_pdf_obj_memo_outparams_fn(obj, bit, outparams)
    return ret, outparams.memo

def pdf_obj_memo_outparams_fn(obj, bit):
    """
    Class-aware helper for out-params of pdf_obj_memo() [pdf_obj_memo()].
    """
    ret, memo = ll_pdf_obj_memo(obj.m_internal, bit)
    return ret, memo

pdf_obj_memo = pdf_obj_memo_outparams_fn


def ll_pdf_page_presentation(page, transition):
    """
    Wrapper for out-params of pdf_page_presentation().
    Returns: fz_transition *, float duration
    """
    outparams = ll_pdf_page_presentation_outparams()
    ret = ll_pdf_page_presentation_outparams_fn(page, transition, outparams)
    return ret, outparams.duration

def pdf_page_presentation_outparams_fn(page, transition):
    """
    Class-aware helper for out-params of pdf_page_presentation() [pdf_page_presentation()].
    """
    ret, duration = ll_pdf_page_presentation(page.m_internal, transition.internal())
    return FzTransition(ret), duration

pdf_page_presentation = pdf_page_presentation_outparams_fn


def ll_pdf_page_write(doc, mediabox):
    """
    Wrapper for out-params of pdf_page_write().
    Returns: fz_device *, ::pdf_obj *presources, ::fz_buffer *pcontents
    """
    outparams = ll_pdf_page_write_outparams()
    ret = ll_pdf_page_write_outparams_fn(doc, mediabox, outparams)
    return ret, outparams.presources, outparams.pcontents

def pdf_page_write_outparams_fn(doc, mediabox):
    """
    Class-aware helper for out-params of pdf_page_write() [pdf_page_write()].
    """
    ret, presources, pcontents = ll_pdf_page_write(doc.m_internal, mediabox.internal())
    return FzDevice(ret), PdfObj( presources), FzBuffer( pcontents)

pdf_page_write = pdf_page_write_outparams_fn


def ll_pdf_parse_default_appearance(da, color):
    """
    Wrapper for out-params of pdf_parse_default_appearance().
    Returns: const char *font, float size, int n
    """
    outparams = ll_pdf_parse_default_appearance_outparams()
    ret = ll_pdf_parse_default_appearance_outparams_fn(da, color, outparams)
    return outparams.font, outparams.size, outparams.n

def pdf_parse_default_appearance_outparams_fn(da, color):
    """
    Class-aware helper for out-params of pdf_parse_default_appearance() [pdf_parse_default_appearance()].
    """
    font, size, n = ll_pdf_parse_default_appearance(da, color)
    return font, size, n

pdf_parse_default_appearance = pdf_parse_default_appearance_outparams_fn


def ll_pdf_parse_ind_obj(doc, f):
    """
    Wrapper for out-params of pdf_parse_ind_obj().
    Returns: pdf_obj *, int num, int gen, int64_t stm_ofs, int try_repair
    """
    outparams = ll_pdf_parse_ind_obj_outparams()
    ret = ll_pdf_parse_ind_obj_outparams_fn(doc, f, outparams)
    return ret, outparams.num, outparams.gen, outparams.stm_ofs, outparams.try_repair

def pdf_parse_ind_obj_outparams_fn(doc, f):
    """
    Class-aware helper for out-params of pdf_parse_ind_obj() [pdf_parse_ind_obj()].
    """
    ret, num, gen, stm_ofs, try_repair = ll_pdf_parse_ind_obj(doc.m_internal, f.m_internal)
    return PdfObj(ret), num, gen, stm_ofs, try_repair

pdf_parse_ind_obj = pdf_parse_ind_obj_outparams_fn


def ll_pdf_parse_journal_obj(doc, stm):
    """
    Wrapper for out-params of pdf_parse_journal_obj().
    Returns: pdf_obj *, int onum, ::fz_buffer *ostm, int newobj
    """
    outparams = ll_pdf_parse_journal_obj_outparams()
    ret = ll_pdf_parse_journal_obj_outparams_fn(doc, stm, outparams)
    return ret, outparams.onum, outparams.ostm, outparams.newobj

def pdf_parse_journal_obj_outparams_fn(doc, stm):
    """
    Class-aware helper for out-params of pdf_parse_journal_obj() [pdf_parse_journal_obj()].
    """
    ret, onum, ostm, newobj = ll_pdf_parse_journal_obj(doc.m_internal, stm.m_internal)
    return PdfObj(ret), onum, FzBuffer( ostm), newobj

pdf_parse_journal_obj = pdf_parse_journal_obj_outparams_fn


def ll_pdf_print_encrypted_obj(out, obj, tight, ascii, crypt, num, gen):
    """
    Wrapper for out-params of pdf_print_encrypted_obj().
    Returns: int sep
    """
    outparams = ll_pdf_print_encrypted_obj_outparams()
    ret = ll_pdf_print_encrypted_obj_outparams_fn(out, obj, tight, ascii, crypt, num, gen, outparams)
    return outparams.sep

def pdf_print_encrypted_obj_outparams_fn(out, obj, tight, ascii, crypt, num, gen):
    """
    Class-aware helper for out-params of pdf_print_encrypted_obj() [pdf_print_encrypted_obj()].
    """
    sep = ll_pdf_print_encrypted_obj(out.m_internal, obj.m_internal, tight, ascii, crypt.m_internal, num, gen)
    return sep

pdf_print_encrypted_obj = pdf_print_encrypted_obj_outparams_fn


def ll_pdf_process_contents(proc, doc, res, stm, cookie):
    """
    Wrapper for out-params of pdf_process_contents().
    Returns: ::pdf_obj *out_res
    """
    outparams = ll_pdf_process_contents_outparams()
    ret = ll_pdf_process_contents_outparams_fn(proc, doc, res, stm, cookie, outparams)
    return outparams.out_res

def pdf_process_contents_outparams_fn(proc, doc, res, stm, cookie):
    """
    Class-aware helper for out-params of pdf_process_contents() [pdf_process_contents()].
    """
    out_res = ll_pdf_process_contents(proc.m_internal, doc.m_internal, res.m_internal, stm.m_internal, cookie.m_internal)
    return PdfObj(ll_pdf_keep_obj( out_res))

pdf_process_contents = pdf_process_contents_outparams_fn


def ll_pdf_repair_obj(doc, buf):
    """
    Wrapper for out-params of pdf_repair_obj().
    Returns: int, int64_t stmofsp, int64_t stmlenp, ::pdf_obj *encrypt, ::pdf_obj *id, ::pdf_obj *page, int64_t tmpofs, ::pdf_obj *root
    """
    outparams = ll_pdf_repair_obj_outparams()
    ret = ll_pdf_repair_obj_outparams_fn(doc, buf, outparams)
    return ret, outparams.stmofsp, outparams.stmlenp, outparams.encrypt, outparams.id, outparams.page, outparams.tmpofs, outparams.root

def pdf_repair_obj_outparams_fn(doc, buf):
    """
    Class-aware helper for out-params of pdf_repair_obj() [pdf_repair_obj()].
    """
    ret, stmofsp, stmlenp, encrypt, id, page, tmpofs, root = ll_pdf_repair_obj(doc.m_internal, buf.m_internal)
    return ret, stmofsp, stmlenp, PdfObj(ll_pdf_keep_obj( encrypt)), PdfObj(ll_pdf_keep_obj( id)), PdfObj(ll_pdf_keep_obj( page)), tmpofs, PdfObj(ll_pdf_keep_obj( root))

pdf_repair_obj = pdf_repair_obj_outparams_fn


def ll_pdf_resolve_link(doc, uri):
    """
    Wrapper for out-params of pdf_resolve_link().
    Returns: int, float xp, float yp
    """
    outparams = ll_pdf_resolve_link_outparams()
    ret = ll_pdf_resolve_link_outparams_fn(doc, uri, outparams)
    return ret, outparams.xp, outparams.yp

def pdf_resolve_link_outparams_fn(doc, uri):
    """
    Class-aware helper for out-params of pdf_resolve_link() [pdf_resolve_link()].
    """
    ret, xp, yp = ll_pdf_resolve_link(doc.m_internal, uri)
    return ret, xp, yp

pdf_resolve_link = pdf_resolve_link_outparams_fn


def ll_pdf_sample_shade_function(shade, n, funcs, t0, t1):
    """
    Wrapper for out-params of pdf_sample_shade_function().
    Returns: ::pdf_function *func
    """
    outparams = ll_pdf_sample_shade_function_outparams()
    ret = ll_pdf_sample_shade_function_outparams_fn(shade, n, funcs, t0, t1, outparams)
    return outparams.func

def pdf_sample_shade_function_outparams_fn(shade, n, funcs, t0, t1):
    """
    Class-aware helper for out-params of pdf_sample_shade_function() [pdf_sample_shade_function()].
    """
    func = ll_pdf_sample_shade_function(shade, n, funcs, t0, t1)
    return PdfFunction(ll_pdf_keep_function( func))

pdf_sample_shade_function = pdf_sample_shade_function_outparams_fn


def ll_pdf_signature_contents(doc, signature):
    """
    Wrapper for out-params of pdf_signature_contents().
    Returns: size_t, char *contents
    """
    outparams = ll_pdf_signature_contents_outparams()
    ret = ll_pdf_signature_contents_outparams_fn(doc, signature, outparams)
    return ret, outparams.contents

def pdf_signature_contents_outparams_fn(doc, signature):
    """
    Class-aware helper for out-params of pdf_signature_contents() [pdf_signature_contents()].
    """
    ret, contents = ll_pdf_signature_contents(doc.m_internal, signature.m_internal)
    return ret, contents

pdf_signature_contents = pdf_signature_contents_outparams_fn


def ll_pdf_sprint_obj(buf, cap, obj, tight, ascii):
    """
    Wrapper for out-params of pdf_sprint_obj().
    Returns: char *, size_t len
    """
    outparams = ll_pdf_sprint_obj_outparams()
    ret = ll_pdf_sprint_obj_outparams_fn(buf, cap, obj, tight, ascii, outparams)
    return ret, outparams.len

def pdf_sprint_obj_outparams_fn(buf, cap, obj, tight, ascii):
    """
    Class-aware helper for out-params of pdf_sprint_obj() [pdf_sprint_obj()].
    """
    ret, len = ll_pdf_sprint_obj(buf, cap, obj.m_internal, tight, ascii)
    return ret, len

pdf_sprint_obj = pdf_sprint_obj_outparams_fn


def ll_pdf_to_string(obj):
    """
    Wrapper for out-params of pdf_to_string().
    Returns: const char *, size_t sizep
    """
    outparams = ll_pdf_to_string_outparams()
    ret = ll_pdf_to_string_outparams_fn(obj, outparams)
    return ret, outparams.sizep

def pdf_to_string_outparams_fn(obj):
    """
    Class-aware helper for out-params of pdf_to_string() [pdf_to_string()].
    """
    ret, sizep = ll_pdf_to_string(obj.m_internal)
    return ret, sizep

pdf_to_string = pdf_to_string_outparams_fn


def ll_pdf_undoredo_state(doc):
    """
    Wrapper for out-params of pdf_undoredo_state().
    Returns: int, int steps
    """
    outparams = ll_pdf_undoredo_state_outparams()
    ret = ll_pdf_undoredo_state_outparams_fn(doc, outparams)
    return ret, outparams.steps

def pdf_undoredo_state_outparams_fn(doc):
    """
    Class-aware helper for out-params of pdf_undoredo_state() [pdf_undoredo_state()].
    """
    ret, steps = ll_pdf_undoredo_state(doc.m_internal)
    return ret, steps

pdf_undoredo_state = pdf_undoredo_state_outparams_fn


def ll_pdf_walk_tree(tree, kid_name, arrive, leave, arg):
    """
    Wrapper for out-params of pdf_walk_tree().
    Returns: ::pdf_obj *names, ::pdf_obj *values
    """
    outparams = ll_pdf_walk_tree_outparams()
    ret = ll_pdf_walk_tree_outparams_fn(tree, kid_name, arrive, leave, arg, outparams)
    return outparams.names, outparams.values

def pdf_walk_tree_outparams_fn(tree, kid_name, arrive, leave, arg):
    """
    Class-aware helper for out-params of pdf_walk_tree() [pdf_walk_tree()].
    """
    names, values = ll_pdf_walk_tree(tree.m_internal, kid_name.m_internal, arrive, leave, arg)
    return PdfObj(ll_pdf_keep_obj( names)), PdfObj(ll_pdf_keep_obj( values))

pdf_walk_tree = pdf_walk_tree_outparams_fn


def FzBitmap_fz_bitmap_details_outparams_fn( self):
    """
    Helper for out-params of class method fz_bitmap::ll_fz_bitmap_details() [fz_bitmap_details()].
    """
    w, h, n, stride = ll_fz_bitmap_details( self.m_internal)
    return w, h, n, stride

FzBitmap.fz_bitmap_details = FzBitmap_fz_bitmap_details_outparams_fn


def FzBuffer_fz_buffer_extract_outparams_fn( self):
    """
    Helper for out-params of class method fz_buffer::ll_fz_buffer_extract() [fz_buffer_extract()].
    """
    ret, data = ll_fz_buffer_extract( self.m_internal)
    return ret, data

FzBuffer.fz_buffer_extract = FzBuffer_fz_buffer_extract_outparams_fn


def FzBuffer_fz_buffer_storage_outparams_fn( self):
    """
    Helper for out-params of class method fz_buffer::ll_fz_buffer_storage() [fz_buffer_storage()].
    """
    ret, datap = ll_fz_buffer_storage( self.m_internal)
    return ret, datap

FzBuffer.fz_buffer_storage = FzBuffer_fz_buffer_storage_outparams_fn


def FzBuffer_fz_new_display_list_from_svg_outparams_fn( self, base_uri, dir):
    """
    Helper for out-params of class method fz_buffer::ll_fz_new_display_list_from_svg() [fz_new_display_list_from_svg()].
    """
    ret, w, h = ll_fz_new_display_list_from_svg( self.m_internal, base_uri, dir.m_internal)
    return FzDisplayList(ret), w, h

FzBuffer.fz_new_display_list_from_svg = FzBuffer_fz_new_display_list_from_svg_outparams_fn


def FzBuffer_fz_subset_cff_for_gids_outparams_fn( self, num_gids, symbolic, cidfont):
    """
    Helper for out-params of class method fz_buffer::ll_fz_subset_cff_for_gids() [fz_subset_cff_for_gids()].
    """
    ret, gids = ll_fz_subset_cff_for_gids( self.m_internal, num_gids, symbolic, cidfont)
    return FzBuffer( ll_fz_keep_buffer( ret)), gids

FzBuffer.fz_subset_cff_for_gids = FzBuffer_fz_subset_cff_for_gids_outparams_fn


def FzBuffer_fz_subset_ttf_for_gids_outparams_fn( self, num_gids, symbolic, cidfont):
    """
    Helper for out-params of class method fz_buffer::ll_fz_subset_ttf_for_gids() [fz_subset_ttf_for_gids()].
    """
    ret, gids = ll_fz_subset_ttf_for_gids( self.m_internal, num_gids, symbolic, cidfont)
    return FzBuffer( ll_fz_keep_buffer( ret)), gids

FzBuffer.fz_subset_ttf_for_gids = FzBuffer_fz_subset_ttf_for_gids_outparams_fn


def FzColorspace_fz_clamp_color_outparams_fn( self, in_):
    """
    Helper for out-params of class method fz_colorspace::ll_fz_clamp_color() [fz_clamp_color()].
    """
    out = ll_fz_clamp_color( self.m_internal, in_)
    return out

FzColorspace.fz_clamp_color = FzColorspace_fz_clamp_color_outparams_fn


def FzColorspace_fz_convert_color_outparams_fn( self, sv, params):
    """
    Helper for out-params of class method fz_colorspace::ll_fz_convert_color() [fz_convert_color()].
    """
    dv = ll_fz_convert_color( self.m_internal, sv, params.internal())
    return dv

FzColorspace.fz_convert_color = FzColorspace_fz_convert_color_outparams_fn


def FzColorspace_fz_convert_separation_colors_outparams_fn( self, src_color, dst_seps, color_params):
    """
    Helper for out-params of class method fz_colorspace::ll_fz_convert_separation_colors() [fz_convert_separation_colors()].
    """
    dst_color = ll_fz_convert_separation_colors( self.m_internal, src_color, dst_seps.m_internal, color_params.internal())
    return dst_color

FzColorspace.fz_convert_separation_colors = FzColorspace_fz_convert_separation_colors_outparams_fn


def FzCompressedBuffer_fz_open_image_decomp_stream_from_buffer_outparams_fn( self):
    """
    Helper for out-params of class method fz_compressed_buffer::ll_fz_open_image_decomp_stream_from_buffer() [fz_open_image_decomp_stream_from_buffer()].
    """
    ret, l2factor = ll_fz_open_image_decomp_stream_from_buffer( self.m_internal)
    return FzStream(ret), l2factor

FzCompressedBuffer.fz_open_image_decomp_stream_from_buffer = FzCompressedBuffer_fz_open_image_decomp_stream_from_buffer_outparams_fn


def FzDisplayList_fz_search_display_list_outparams_fn( self, needle, hit_bbox, hit_max):
    """
    Helper for out-params of class method fz_display_list::ll_fz_search_display_list() [fz_search_display_list()].
    """
    ret, hit_mark = ll_fz_search_display_list( self.m_internal, needle, hit_bbox.internal(), hit_max)
    return ret, hit_mark

FzDisplayList.fz_search_display_list = FzDisplayList_fz_search_display_list_outparams_fn


def FzDocument_fz_resolve_link_outparams_fn( self, uri):
    """
    Helper for out-params of class method fz_document::ll_fz_resolve_link() [fz_resolve_link()].
    """
    ret, xp, yp = ll_fz_resolve_link( self.m_internal, uri)
    return FzLocation(ret), xp, yp

FzDocument.fz_resolve_link = FzDocument_fz_resolve_link_outparams_fn


def FzDocument_fz_search_chapter_page_number_outparams_fn( self, chapter, page, needle, hit_bbox, hit_max):
    """
    Helper for out-params of class method fz_document::ll_fz_search_chapter_page_number() [fz_search_chapter_page_number()].
    """
    ret, hit_mark = ll_fz_search_chapter_page_number( self.m_internal, chapter, page, needle, hit_bbox.internal(), hit_max)
    return ret, hit_mark

FzDocument.fz_search_chapter_page_number = FzDocument_fz_search_chapter_page_number_outparams_fn


def FzDocument_fz_search_page_number_outparams_fn( self, number, needle, hit_bbox, hit_max):
    """
    Helper for out-params of class method fz_document::ll_fz_search_page_number() [fz_search_page_number()].
    """
    ret, hit_mark = ll_fz_search_page_number( self.m_internal, number, needle, hit_bbox.internal(), hit_max)
    return ret, hit_mark

FzDocument.fz_search_page_number = FzDocument_fz_search_page_number_outparams_fn


def FzFont_fz_encode_character_with_fallback_outparams_fn( self, unicode, script, language):
    """
    Helper for out-params of class method fz_font::ll_fz_encode_character_with_fallback() [fz_encode_character_with_fallback()].
    """
    ret, out_font = ll_fz_encode_character_with_fallback( self.m_internal, unicode, script, language)
    return ret, FzFont(ll_fz_keep_font( out_font))

FzFont.fz_encode_character_with_fallback = FzFont_fz_encode_character_with_fallback_outparams_fn


def FzFunction_fz_eval_function_outparams_fn( self, in_, inlen, outlen):
    """
    Helper for out-params of class method fz_function::ll_fz_eval_function() [fz_eval_function()].
    """
    out = ll_fz_eval_function( self.m_internal, in_, inlen, outlen)
    return out

FzFunction.fz_eval_function = FzFunction_fz_eval_function_outparams_fn


def FzImage_fz_get_pixmap_from_image_outparams_fn( self, subarea, ctm):
    """
    Helper for out-params of class method fz_image::ll_fz_get_pixmap_from_image() [fz_get_pixmap_from_image()].
    """
    ret, w, h = ll_fz_get_pixmap_from_image( self.m_internal, subarea.internal(), ctm.internal())
    return FzPixmap(ret), w, h

FzImage.fz_get_pixmap_from_image = FzImage_fz_get_pixmap_from_image_outparams_fn


def FzImage_fz_image_resolution_outparams_fn( self):
    """
    Helper for out-params of class method fz_image::ll_fz_image_resolution() [fz_image_resolution()].
    """
    xres, yres = ll_fz_image_resolution( self.m_internal)
    return xres, yres

FzImage.fz_image_resolution = FzImage_fz_image_resolution_outparams_fn


def FzOutput_fz_new_svg_device_with_id_outparams_fn( self, page_width, page_height, text_format, reuse_images):
    """
    Helper for out-params of class method fz_output::ll_fz_new_svg_device_with_id() [fz_new_svg_device_with_id()].
    """
    ret, id = ll_fz_new_svg_device_with_id( self.m_internal, page_width, page_height, text_format, reuse_images)
    return FzDevice(ret), id

FzOutput.fz_new_svg_device_with_id = FzOutput_fz_new_svg_device_with_id_outparams_fn


def FzOutput_pdf_print_encrypted_obj_outparams_fn( self, obj, tight, ascii, crypt, num, gen):
    """
    Helper for out-params of class method fz_output::ll_pdf_print_encrypted_obj() [pdf_print_encrypted_obj()].
    """
    sep = ll_pdf_print_encrypted_obj( self.m_internal, obj.m_internal, tight, ascii, crypt.m_internal, num, gen)
    return sep

FzOutput.pdf_print_encrypted_obj = FzOutput_pdf_print_encrypted_obj_outparams_fn


def FzPage_fz_page_presentation_outparams_fn( self, transition):
    """
    Helper for out-params of class method fz_page::ll_fz_page_presentation() [fz_page_presentation()].
    """
    ret, duration = ll_fz_page_presentation( self.m_internal, transition.internal())
    return FzTransition(ret), duration

FzPage.fz_page_presentation = FzPage_fz_page_presentation_outparams_fn


def FzPage_fz_search_page_outparams_fn( self, needle, hit_bbox, hit_max):
    """
    Helper for out-params of class method fz_page::ll_fz_search_page() [fz_search_page()].
    """
    ret, hit_mark = ll_fz_search_page( self.m_internal, needle, hit_bbox.internal(), hit_max)
    return ret, hit_mark

FzPage.fz_search_page = FzPage_fz_search_page_outparams_fn


def FzPixmap_fz_fill_pixmap_with_color_outparams_fn( self, colorspace, color_params):
    """
    Helper for out-params of class method fz_pixmap::ll_fz_fill_pixmap_with_color() [fz_fill_pixmap_with_color()].
    """
    color = ll_fz_fill_pixmap_with_color( self.m_internal, colorspace.m_internal, color_params.internal())
    return color

FzPixmap.fz_fill_pixmap_with_color = FzPixmap_fz_fill_pixmap_with_color_outparams_fn


def FzSeparations_fz_separation_equivalent_outparams_fn( self, idx, dst_cs, prf, color_params):
    """
    Helper for out-params of class method fz_separations::ll_fz_separation_equivalent() [fz_separation_equivalent()].
    """
    dst_color = ll_fz_separation_equivalent( self.m_internal, idx, dst_cs.m_internal, prf.m_internal, color_params.internal())
    return dst_color

FzSeparations.fz_separation_equivalent = FzSeparations_fz_separation_equivalent_outparams_fn


def FzShade_fz_paint_shade_outparams_fn( self, override_cs, ctm, dest, color_params, bbox, eop):
    """
    Helper for out-params of class method fz_shade::ll_fz_paint_shade() [fz_paint_shade()].
    """
    cache = ll_fz_paint_shade( self.m_internal, override_cs.m_internal, ctm.internal(), dest.m_internal, color_params.internal(), bbox.internal(), eop.m_internal)
    return FzShadeColorCache(ll_fz_keep_shade_color_cache( cache))

FzShade.fz_paint_shade = FzShade_fz_paint_shade_outparams_fn


def FzStextPage_fz_search_stext_page_outparams_fn( self, needle, hit_bbox, hit_max):
    """
    Helper for out-params of class method fz_stext_page::ll_fz_search_stext_page() [fz_search_stext_page()].
    """
    ret, hit_mark = ll_fz_search_stext_page( self.m_internal, needle, hit_bbox.internal(), hit_max)
    return ret, hit_mark

FzStextPage.fz_search_stext_page = FzStextPage_fz_search_stext_page_outparams_fn


def FzStream_fz_decomp_image_from_stream_outparams_fn( self, image, subarea, indexed, l2factor):
    """
    Helper for out-params of class method fz_stream::ll_fz_decomp_image_from_stream() [fz_decomp_image_from_stream()].
    """
    ret, l2extra = ll_fz_decomp_image_from_stream( self.m_internal, image.m_internal, subarea.internal(), indexed, l2factor)
    return FzPixmap(ret), l2extra

FzStream.fz_decomp_image_from_stream = FzStream_fz_decomp_image_from_stream_outparams_fn


def FzStream_fz_open_image_decomp_stream_outparams_fn( self, arg_1):
    """
    Helper for out-params of class method fz_stream::ll_fz_open_image_decomp_stream() [fz_open_image_decomp_stream()].
    """
    ret, l2factor = ll_fz_open_image_decomp_stream( self.m_internal, arg_1.m_internal)
    return FzStream(ret), l2factor

FzStream.fz_open_image_decomp_stream = FzStream_fz_open_image_decomp_stream_outparams_fn


def FzStream_fz_read_best_outparams_fn( self, initial, worst_case):
    """
    Helper for out-params of class method fz_stream::ll_fz_read_best() [fz_read_best()].
    """
    ret, truncated = ll_fz_read_best( self.m_internal, initial, worst_case)
    return FzBuffer(ret), truncated

FzStream.fz_read_best = FzStream_fz_read_best_outparams_fn


def FzXml_fz_dom_get_attribute_outparams_fn( self, i):
    """
    Helper for out-params of class method fz_xml::ll_fz_dom_get_attribute() [fz_dom_get_attribute()].
    """
    ret, att = ll_fz_dom_get_attribute( self.m_internal, i)
    return ret, att

FzXml.fz_dom_get_attribute = FzXml_fz_dom_get_attribute_outparams_fn


def FzXml_fz_new_display_list_from_svg_xml_outparams_fn( self, xmldoc, base_uri, dir):
    """
    Helper for out-params of class method fz_xml::ll_fz_new_display_list_from_svg_xml() [fz_new_display_list_from_svg_xml()].
    """
    ret, w, h = ll_fz_new_display_list_from_svg_xml( self.m_internal, xmldoc.m_internal, base_uri, dir.m_internal)
    return FzDisplayList(ret), w, h

FzXml.fz_new_display_list_from_svg_xml = FzXml_fz_new_display_list_from_svg_xml_outparams_fn


def PdfAnnot_pdf_annot_MK_BC_outparams_fn( self, color):
    """
    Helper for out-params of class method pdf_annot::ll_pdf_annot_MK_BC() [pdf_annot_MK_BC()].
    """
    n = ll_pdf_annot_MK_BC( self.m_internal, color)
    return n

PdfAnnot.pdf_annot_MK_BC = PdfAnnot_pdf_annot_MK_BC_outparams_fn


def PdfAnnot_pdf_annot_MK_BG_outparams_fn( self, color):
    """
    Helper for out-params of class method pdf_annot::ll_pdf_annot_MK_BG() [pdf_annot_MK_BG()].
    """
    n = ll_pdf_annot_MK_BG( self.m_internal, color)
    return n

PdfAnnot.pdf_annot_MK_BG = PdfAnnot_pdf_annot_MK_BG_outparams_fn


def PdfAnnot_pdf_annot_color_outparams_fn( self, color):
    """
    Helper for out-params of class method pdf_annot::ll_pdf_annot_color() [pdf_annot_color()].
    """
    n = ll_pdf_annot_color( self.m_internal, color)
    return n

PdfAnnot.pdf_annot_color = PdfAnnot_pdf_annot_color_outparams_fn


def PdfAnnot_pdf_annot_default_appearance_outparams_fn( self, color):
    """
    Helper for out-params of class method pdf_annot::ll_pdf_annot_default_appearance() [pdf_annot_default_appearance()].
    """
    font, size, n = ll_pdf_annot_default_appearance( self.m_internal, color)
    return font, size, n

PdfAnnot.pdf_annot_default_appearance = PdfAnnot_pdf_annot_default_appearance_outparams_fn


def PdfAnnot_pdf_annot_interior_color_outparams_fn( self, color):
    """
    Helper for out-params of class method pdf_annot::ll_pdf_annot_interior_color() [pdf_annot_interior_color()].
    """
    n = ll_pdf_annot_interior_color( self.m_internal, color)
    return n

PdfAnnot.pdf_annot_interior_color = PdfAnnot_pdf_annot_interior_color_outparams_fn


def PdfAnnot_pdf_annot_line_ending_styles_outparams_fn( self):
    """
    Helper for out-params of class method pdf_annot::ll_pdf_annot_line_ending_styles() [pdf_annot_line_ending_styles()].
    """
    start_style, end_style = ll_pdf_annot_line_ending_styles( self.m_internal)
    return start_style, end_style

PdfAnnot.pdf_annot_line_ending_styles = PdfAnnot_pdf_annot_line_ending_styles_outparams_fn


def PdfAnnot_pdf_edit_text_field_value_outparams_fn( self, value, change):
    """
    Helper for out-params of class method pdf_annot::ll_pdf_edit_text_field_value() [pdf_edit_text_field_value()].
    """
    ret, selStart, selEnd, newvalue = ll_pdf_edit_text_field_value( self.m_internal, value, change)
    return ret, selStart, selEnd, newvalue

PdfAnnot.pdf_edit_text_field_value = PdfAnnot_pdf_edit_text_field_value_outparams_fn


def PdfCmap_pdf_decode_cmap_outparams_fn( self, s, e):
    """
    Helper for out-params of class method pdf_cmap::ll_pdf_decode_cmap() [pdf_decode_cmap()].
    """
    ret, cpt = ll_pdf_decode_cmap( self.m_internal, s, e)
    return ret, cpt

PdfCmap.pdf_decode_cmap = PdfCmap_pdf_decode_cmap_outparams_fn


def PdfCmap_pdf_lookup_cmap_full_outparams_fn( self, cpt):
    """
    Helper for out-params of class method pdf_cmap::ll_pdf_lookup_cmap_full() [pdf_lookup_cmap_full()].
    """
    ret, out = ll_pdf_lookup_cmap_full( self.m_internal, cpt)
    return ret, out

PdfCmap.pdf_lookup_cmap_full = PdfCmap_pdf_lookup_cmap_full_outparams_fn


def PdfCmap_pdf_map_one_to_many_outparams_fn( self, one, len):
    """
    Helper for out-params of class method pdf_cmap::ll_pdf_map_one_to_many() [pdf_map_one_to_many()].
    """
    many = ll_pdf_map_one_to_many( self.m_internal, one, len)
    return many

PdfCmap.pdf_map_one_to_many = PdfCmap_pdf_map_one_to_many_outparams_fn


def PdfDocument_pdf_count_q_balance_outparams_fn( self, res, stm):
    """
    Helper for out-params of class method pdf_document::ll_pdf_count_q_balance() [pdf_count_q_balance()].
    """
    prepend, append = ll_pdf_count_q_balance( self.m_internal, res.m_internal, stm.m_internal)
    return prepend, append

PdfDocument.pdf_count_q_balance = PdfDocument_pdf_count_q_balance_outparams_fn


def PdfDocument_pdf_field_event_validate_outparams_fn( self, field, value):
    """
    Helper for out-params of class method pdf_document::ll_pdf_field_event_validate() [pdf_field_event_validate()].
    """
    ret, newvalue = ll_pdf_field_event_validate( self.m_internal, field.m_internal, value)
    return ret, newvalue

PdfDocument.pdf_field_event_validate = PdfDocument_pdf_field_event_validate_outparams_fn


def PdfDocument_pdf_load_to_unicode_outparams_fn( self, font, collection, cmapstm):
    """
    Helper for out-params of class method pdf_document::ll_pdf_load_to_unicode() [pdf_load_to_unicode()].
    """
    strings = ll_pdf_load_to_unicode( self.m_internal, font.m_internal, collection, cmapstm.m_internal)
    return strings

PdfDocument.pdf_load_to_unicode = PdfDocument_pdf_load_to_unicode_outparams_fn


def PdfDocument_pdf_lookup_page_loc_outparams_fn( self, needle):
    """
    Helper for out-params of class method pdf_document::ll_pdf_lookup_page_loc() [pdf_lookup_page_loc()].
    """
    ret, parentp, indexp = ll_pdf_lookup_page_loc( self.m_internal, needle)
    return PdfObj( ll_pdf_keep_obj( ret)), PdfObj(ll_pdf_keep_obj( parentp)), indexp

PdfDocument.pdf_lookup_page_loc = PdfDocument_pdf_lookup_page_loc_outparams_fn


def PdfDocument_pdf_page_write_outparams_fn( self, mediabox):
    """
    Helper for out-params of class method pdf_document::ll_pdf_page_write() [pdf_page_write()].
    """
    ret, presources, pcontents = ll_pdf_page_write( self.m_internal, mediabox.internal())
    return FzDevice(ret), PdfObj( presources), FzBuffer( pcontents)

PdfDocument.pdf_page_write = PdfDocument_pdf_page_write_outparams_fn


def PdfDocument_pdf_parse_ind_obj_outparams_fn( self, f):
    """
    Helper for out-params of class method pdf_document::ll_pdf_parse_ind_obj() [pdf_parse_ind_obj()].
    """
    ret, num, gen, stm_ofs, try_repair = ll_pdf_parse_ind_obj( self.m_internal, f.m_internal)
    return PdfObj(ret), num, gen, stm_ofs, try_repair

PdfDocument.pdf_parse_ind_obj = PdfDocument_pdf_parse_ind_obj_outparams_fn


def PdfDocument_pdf_parse_journal_obj_outparams_fn( self, stm):
    """
    Helper for out-params of class method pdf_document::ll_pdf_parse_journal_obj() [pdf_parse_journal_obj()].
    """
    ret, onum, ostm, newobj = ll_pdf_parse_journal_obj( self.m_internal, stm.m_internal)
    return PdfObj(ret), onum, FzBuffer( ostm), newobj

PdfDocument.pdf_parse_journal_obj = PdfDocument_pdf_parse_journal_obj_outparams_fn


def PdfDocument_pdf_repair_obj_outparams_fn( self, buf):
    """
    Helper for out-params of class method pdf_document::ll_pdf_repair_obj() [pdf_repair_obj()].
    """
    ret, stmofsp, stmlenp, encrypt, id, page, tmpofs, root = ll_pdf_repair_obj( self.m_internal, buf.m_internal)
    return ret, stmofsp, stmlenp, PdfObj(ll_pdf_keep_obj( encrypt)), PdfObj(ll_pdf_keep_obj( id)), PdfObj(ll_pdf_keep_obj( page)), tmpofs, PdfObj(ll_pdf_keep_obj( root))

PdfDocument.pdf_repair_obj = PdfDocument_pdf_repair_obj_outparams_fn


def PdfDocument_pdf_resolve_link_outparams_fn( self, uri):
    """
    Helper for out-params of class method pdf_document::ll_pdf_resolve_link() [pdf_resolve_link()].
    """
    ret, xp, yp = ll_pdf_resolve_link( self.m_internal, uri)
    return ret, xp, yp

PdfDocument.pdf_resolve_link = PdfDocument_pdf_resolve_link_outparams_fn


def PdfDocument_pdf_signature_contents_outparams_fn( self, signature):
    """
    Helper for out-params of class method pdf_document::ll_pdf_signature_contents() [pdf_signature_contents()].
    """
    ret, contents = ll_pdf_signature_contents( self.m_internal, signature.m_internal)
    return ret, contents

PdfDocument.pdf_signature_contents = PdfDocument_pdf_signature_contents_outparams_fn


def PdfDocument_pdf_undoredo_state_outparams_fn( self):
    """
    Helper for out-params of class method pdf_document::ll_pdf_undoredo_state() [pdf_undoredo_state()].
    """
    ret, steps = ll_pdf_undoredo_state( self.m_internal)
    return ret, steps

PdfDocument.pdf_undoredo_state = PdfDocument_pdf_undoredo_state_outparams_fn


def PdfFunction_pdf_eval_function_outparams_fn( self, in_, inlen, outlen):
    """
    Helper for out-params of class method pdf_function::ll_pdf_eval_function() [pdf_eval_function()].
    """
    out = ll_pdf_eval_function( self.m_internal, in_, inlen, outlen)
    return out

PdfFunction.pdf_eval_function = PdfFunction_pdf_eval_function_outparams_fn


def PdfJs_pdf_js_event_result_validate_outparams_fn( self):
    """
    Helper for out-params of class method pdf_js::ll_pdf_js_event_result_validate() [pdf_js_event_result_validate()].
    """
    ret, newvalue = ll_pdf_js_event_result_validate( self.m_internal)
    return ret, newvalue

PdfJs.pdf_js_event_result_validate = PdfJs_pdf_js_event_result_validate_outparams_fn


def PdfJs_pdf_js_execute_outparams_fn( self, name, code):
    """
    Helper for out-params of class method pdf_js::ll_pdf_js_execute() [pdf_js_execute()].
    """
    result = ll_pdf_js_execute( self.m_internal, name, code)
    return result

PdfJs.pdf_js_execute = PdfJs_pdf_js_execute_outparams_fn


def PdfObj_pdf_array_get_string_outparams_fn( self, index):
    """
    Helper for out-params of class method pdf_obj::ll_pdf_array_get_string() [pdf_array_get_string()].
    """
    ret, sizep = ll_pdf_array_get_string( self.m_internal, index)
    return ret, sizep

PdfObj.pdf_array_get_string = PdfObj_pdf_array_get_string_outparams_fn


def PdfObj_pdf_dict_get_inheritable_string_outparams_fn( self):
    """
    Helper for out-params of class method pdf_obj::ll_pdf_dict_get_inheritable_string() [pdf_dict_get_inheritable_string()].
    """
    ret, sizep = ll_pdf_dict_get_inheritable_string( self.m_internal)
    return ret, sizep

PdfObj.pdf_dict_get_inheritable_string = PdfObj_pdf_dict_get_inheritable_string_outparams_fn


def PdfObj_pdf_dict_get_string_outparams_fn( self):
    """
    Helper for out-params of class method pdf_obj::ll_pdf_dict_get_string() [pdf_dict_get_string()].
    """
    ret, sizep = ll_pdf_dict_get_string( self.m_internal)
    return ret, sizep

PdfObj.pdf_dict_get_string = PdfObj_pdf_dict_get_string_outparams_fn


def PdfObj_pdf_obj_memo_outparams_fn( self, bit):
    """
    Helper for out-params of class method pdf_obj::ll_pdf_obj_memo() [pdf_obj_memo()].
    """
    ret, memo = ll_pdf_obj_memo( self.m_internal, bit)
    return ret, memo

PdfObj.pdf_obj_memo = PdfObj_pdf_obj_memo_outparams_fn


def PdfObj_pdf_to_string_outparams_fn( self):
    """
    Helper for out-params of class method pdf_obj::ll_pdf_to_string() [pdf_to_string()].
    """
    ret, sizep = ll_pdf_to_string( self.m_internal)
    return ret, sizep

PdfObj.pdf_to_string = PdfObj_pdf_to_string_outparams_fn


def PdfObj_pdf_walk_tree_outparams_fn( self, arrive, leave, arg):
    """
    Helper for out-params of class method pdf_obj::ll_pdf_walk_tree() [pdf_walk_tree()].
    """
    names, values = ll_pdf_walk_tree( self.m_internal, arrive, leave, arg)
    return PdfObj(ll_pdf_keep_obj( names)), PdfObj(ll_pdf_keep_obj( values))

PdfObj.pdf_walk_tree = PdfObj_pdf_walk_tree_outparams_fn


def PdfPage_pdf_page_presentation_outparams_fn( self, transition):
    """
    Helper for out-params of class method pdf_page::ll_pdf_page_presentation() [pdf_page_presentation()].
    """
    ret, duration = ll_pdf_page_presentation( self.m_internal, transition.internal())
    return FzTransition(ret), duration

PdfPage.pdf_page_presentation = PdfPage_pdf_page_presentation_outparams_fn


def PdfProcessor_pdf_process_contents_outparams_fn( self, doc, res, stm, cookie):
    """
    Helper for out-params of class method pdf_processor::ll_pdf_process_contents() [pdf_process_contents()].
    """
    out_res = ll_pdf_process_contents( self.m_internal, doc.m_internal, res.m_internal, stm.m_internal, cookie.m_internal)
    return PdfObj(ll_pdf_keep_obj( out_res))

PdfProcessor.pdf_process_contents = PdfProcessor_pdf_process_contents_outparams_fn


# Define __str()__ for each error/exception class, to use self.what().
FzErrorBase.__str__ = lambda self: self.what()
FzErrorNone.__str__ = lambda self: self.what()
FzErrorGeneric.__str__ = lambda self: self.what()
FzErrorSystem.__str__ = lambda self: self.what()
FzErrorLibrary.__str__ = lambda self: self.what()
FzErrorArgument.__str__ = lambda self: self.what()
FzErrorLimit.__str__ = lambda self: self.what()
FzErrorUnsupported.__str__ = lambda self: self.what()
FzErrorFormat.__str__ = lambda self: self.what()
FzErrorSyntax.__str__ = lambda self: self.what()
FzErrorTrylater.__str__ = lambda self: self.what()
FzErrorAbort.__str__ = lambda self: self.what()
FzErrorRepaired.__str__ = lambda self: self.what()

# This must be after the declaration of mupdf::FzError*
# classes in mupdf/exceptions.h and declaration of
# `internal_set_error_classes()`, otherwise generated code is
# before the declaration of the Python class or similar. */
internal_set_error_classes([
        FzErrorNone,
        FzErrorGeneric,
        FzErrorSystem,
        FzErrorLibrary,
        FzErrorArgument,
        FzErrorLimit,
        FzErrorUnsupported,
        FzErrorFormat,
        FzErrorSyntax,
        FzErrorTrylater,
        FzErrorAbort,
        FzErrorRepaired,

FzErrorBase,
])


# Wrap fz_parse_page_range() to fix SWIG bug where a NULL return
# value seems to mess up the returned list - we end up with ret
# containing two elements rather than three, e.g. [0, 2]. This
# occurs with SWIG-3.0; maybe fixed in SWIG-4?
#
ll_fz_parse_page_range_orig = ll_fz_parse_page_range
def ll_fz_parse_page_range(s, n):
    ret = ll_fz_parse_page_range_orig(s, n)
    if len(ret) == 2:
        return None, 0, 0
    else:
        return ret[0], ret[1], ret[2]
fz_parse_page_range = ll_fz_parse_page_range

# Provide native python implementation of format_output_path() (->
# fz_format_output_path).
#
def ll_fz_format_output_path( format, page):
    m = re.search( '(%[0-9]*d)', format)
    if m:
        ret = format[ :m.start(1)] + str(page) + format[ m.end(1):]
    else:
        dot = format.rfind( '.')
        if dot < 0:
            dot = len( format)
        ret = format[:dot] + str(page) + format[dot:]
    return ret
fz_format_output_path = ll_fz_format_output_path

class IteratorWrap:
    """
    This is a Python iterator for containers that have C++-style
    begin() and end() methods that return iterators.

    Iterators must have the following methods:

        __increment__(): move to next item in the container.
        __ref__(): return reference to item in the container.

    Must also be able to compare two iterators for equality.

    """
    def __init__( self, container):
        self.container = container
        self.pos = None
        self.end = container.end()
    def __iter__( self):
        return self
    def __next__( self):    # for python2.
        if self.pos is None:
            self.pos = self.container.begin()
        else:
            self.pos.__increment__()
        if self.pos == self.end:
            raise StopIteration()
        return self.pos.__ref__()
    def next( self):    # for python3.
        return self.__next__()

# The auto-generated Python class method
# FzBuffer.fz_buffer_extract() returns (size, data).
#
# But these raw values aren't particularly useful to
# Python code so we change the method to return a Python
# bytes instance instead, using the special C function
# buffer_extract_bytes() defined above.
#
# The raw values for a buffer are available via
# fz_buffer_storage().

def ll_fz_buffer_extract(buffer):
    """
    Returns buffer data as a Python bytes instance, leaving the
    buffer empty.
    """
    assert isinstance( buffer, fz_buffer)
    return ll_fz_buffer_to_bytes_internal(buffer, clear=1)
def fz_buffer_extract(buffer):
    """
    Returns buffer data as a Python bytes instance, leaving the
    buffer empty.
    """
    assert isinstance( buffer, FzBuffer)
    return ll_fz_buffer_extract(buffer.m_internal)
FzBuffer.fz_buffer_extract = fz_buffer_extract

def ll_fz_buffer_extract_copy( buffer):
    """
    Returns buffer data as a Python bytes instance, leaving the
    buffer unchanged.
    """
    assert isinstance( buffer, fz_buffer)
    return ll_fz_buffer_to_bytes_internal(buffer, clear=0)
def fz_buffer_extract_copy( buffer):
    """
    Returns buffer data as a Python bytes instance, leaving the
    buffer unchanged.
    """
    assert isinstance( buffer, FzBuffer)
    return ll_fz_buffer_extract_copy(buffer.m_internal)
FzBuffer.fz_buffer_extract_copy = fz_buffer_extract_copy

# [ll_fz_buffer_storage_memoryview() is implemented in C.]
def fz_buffer_storage_memoryview( buffer, writable=False):
    """
    Returns a read-only or writable Python `memoryview` onto
    `fz_buffer` data. This relies on `buffer` existing and
    not changing size while the `memoryview` is used.
    """
    assert isinstance( buffer, FzBuffer)
    return ll_fz_buffer_storage_memoryview( buffer.m_internal, writable)
FzBuffer.fz_buffer_storage_memoryview = fz_buffer_storage_memoryview

# Overwrite wrappers for fz_new_buffer_from_copied_data() to
# take Python buffer.
#
ll_fz_new_buffer_from_copied_data_orig = ll_fz_new_buffer_from_copied_data
def ll_fz_new_buffer_from_copied_data(data):
    """
    Returns fz_buffer containing copy of `data`, which should
    be a `bytes` or similar Python buffer instance.
    """
    buffer_ = ll_fz_new_buffer_from_copied_data_orig(python_buffer_data(data), len(data))
    return buffer_
def fz_new_buffer_from_copied_data(data):
    """
    Returns FzBuffer containing copy of `data`, which should be
    a `bytes` or similar Python buffer instance.
    """
    return FzBuffer( ll_fz_new_buffer_from_copied_data( data))
FzBuffer.fz_new_buffer_from_copied_data = fz_new_buffer_from_copied_data

def ll_pdf_dict_getl(obj, *tail):
    """
    Python implementation of ll_pdf_dict_getl(), because SWIG
    doesn't handle variadic args. Each item in `tail` should be
    `mupdf.pdf_obj`.
    """
    for key in tail:
        if not obj:
            break
        obj = ll_pdf_dict_get(obj, key)
    assert isinstance(obj, pdf_obj)
    return obj
def pdf_dict_getl(obj, *tail):
    """
    Python implementation of pdf_dict_getl(), because SWIG
    doesn't handle variadic args. Each item in `tail` should be
    a `mupdf.PdfObj`.
    """
    for key in tail:
        if not obj.m_internal:
            break
        obj = pdf_dict_get(obj, key)
    assert isinstance(obj, PdfObj)
    return obj
PdfObj.pdf_dict_getl = pdf_dict_getl

def ll_pdf_dict_putl(obj, val, *tail):
    """
    Python implementation of ll_pdf_dict_putl() because SWIG
    doesn't handle variadic args. Each item in `tail` should
    be a SWIG wrapper for a `pdf_obj`.
    """
    if ll_pdf_is_indirect( obj):
        obj = ll_pdf_resolve_indirect_chain( obj)
    if not pdf_is_dict( obj):
        raise Exception(f'not a dict: {obj}')
    if not tail:
        return
    doc = ll_pdf_get_bound_document( obj)
    for i, key in enumerate( tail[:-1]):
        assert isinstance( key, PdfObj), f'Item {i} in `tail` should be a pdf_obj but is a {type(key)}.'
        next_obj = ll_pdf_dict_get( obj, key)
        if not next_obj:
# We have to create entries
            next_obj = ll_pdf_new_dict( doc, 1)
            ll_pdf_dict_put( obj, key, next_obj)
        obj = next_obj
    key = tail[-1]
    ll_pdf_dict_put( obj, key, val)
def pdf_dict_putl(obj, val, *tail):
    """
    Python implementation of pdf_dict_putl(fz_context *ctx,
    pdf_obj *obj, pdf_obj *val, ...) because SWIG doesn't
    handle variadic args. Each item in `tail` should
    be a SWIG wrapper for a `PdfObj`.
    """
    if pdf_is_indirect( obj):
        obj = pdf_resolve_indirect_chain( obj)
    if not pdf_is_dict( obj):
        raise Exception(f'not a dict: {obj}')
    if not tail:
        return
    doc = pdf_get_bound_document( obj)
    for i, key in enumerate( tail[:-1]):
        assert isinstance( key, PdfObj), f'item {i} in `tail` should be a PdfObj but is a {type(key)}.'
        next_obj = pdf_dict_get( obj, key)
        if not next_obj.m_internal:
# We have to create entries
            next_obj = pdf_new_dict( doc, 1)
            pdf_dict_put( obj, key, next_obj)
        obj = next_obj
    key = tail[-1]
    pdf_dict_put( obj, key, val)
PdfObj.pdf_dict_putl = pdf_dict_putl

def pdf_dict_putl_drop(obj, *tail):
    raise Exception('mupdf.pdf_dict_putl_drop() is unsupported and unnecessary in Python because reference counting is automatic. Instead use mupdf.pdf_dict_putl().')
PdfObj.pdf_dict_putl_drop = pdf_dict_putl_drop

def ll_pdf_set_annot_color(annot, color):
    """
    Low-level Python implementation of pdf_set_annot_color()
    using ll_pdf_set_annot_color2().
    """
    if isinstance(color, float):
        ll_pdf_set_annot_color2(annot, 1, color, 0, 0, 0)
    elif len(color) == 1:
        ll_pdf_set_annot_color2(annot, 1, color[0], 0, 0, 0)
    elif len(color) == 2:
        ll_pdf_set_annot_color2(annot, 2, color[0], color[1], 0, 0)
    elif len(color) == 3:
        ll_pdf_set_annot_color2(annot, 3, color[0], color[1], color[2], 0)
    elif len(color) == 4:
        ll_pdf_set_annot_color2(annot, 4, color[0], color[1], color[2], color[3])
    else:
        raise Exception( f'Unexpected color should be float or list of 1-4 floats: {color}')
def pdf_set_annot_color(self, color):
    return ll_pdf_set_annot_color(self.m_internal, color)
PdfAnnot.pdf_set_annot_color = pdf_set_annot_color

def ll_pdf_set_annot_interior_color(annot, color):
    """
    Low-level Python version of pdf_set_annot_color() using
    pdf_set_annot_color2().
    """
    if isinstance(color, float):
        ll_pdf_set_annot_interior_color2(annot, 1, color, 0, 0, 0)
    elif len(color) == 1:
        ll_pdf_set_annot_interior_color2(annot, 1, color[0], 0, 0, 0)
    elif len(color) == 2:
        ll_pdf_set_annot_interior_color2(annot, 2, color[0], color[1], 0, 0)
    elif len(color) == 3:
        ll_pdf_set_annot_interior_color2(annot, 3, color[0], color[1], color[2], 0)
    elif len(color) == 4:
        ll_pdf_set_annot_interior_color2(annot, 4, color[0], color[1], color[2], color[3])
    else:
        raise Exception( f'Unexpected color should be float or list of 1-4 floats: {color}')
def pdf_set_annot_interior_color(self, color):
    """
    Python version of pdf_set_annot_color() using
    pdf_set_annot_color2().
    """
    return ll_pdf_set_annot_interior_color(self.m_internal, color)
PdfAnnot.pdf_set_annot_interior_color = pdf_set_annot_interior_color

def ll_fz_fill_text( dev, text, ctm, colorspace, color, alpha, color_params):
    """
    Low-level Python version of fz_fill_text() taking list/tuple for `color`.
    """
    color = tuple(color) + (0,) * (4-len(color))
    assert len(color) == 4, f'color not len 4: len={len(color)}: {color}'
    return ll_fz_fill_text2(dev, text, ctm, colorspace, *color, alpha, color_params)
def fz_fill_text(dev, text, ctm, colorspace, color, alpha, color_params):
    """
    Python version of fz_fill_text() taking list/tuple for `color`.
    """
    return ll_fz_fill_text(
            dev.m_internal,
            text.m_internal,
            ctm.internal(),
            colorspace.m_internal,
            color,
            alpha,
            color_params.internal(),
            )
FzDevice.fz_fill_text = fz_fill_text

# Override mupdf_convert_color() to return (rgb0, rgb1, rgb2, rgb3).
def ll_fz_convert_color( ss, sv, ds, is_, params):
    """
    Low-level Python version of fz_convert_color().

    `sv` should be a float or list of 1-4 floats or a SWIG
    representation of a float*.

    Returns (dv0, dv1, dv2, dv3).
    """
    dv = fz_convert_color2_v()
    if isinstance( sv, float):
       ll_fz_convert_color2( ss, sv, 0.0, 0.0, 0.0, ds, dv, is_, params)
    elif isinstance( sv, (tuple, list)):
        sv2 = tuple(sv) + (0,) * (4-len(sv))
        ll_fz_convert_color2( ss, *sv2, ds, dv, is_, params)
    else:
# Assume `sv` is SWIG representation of a `float*`.
        ll_fz_convert_color2( ss, sv, ds, dv, is_, params)
    return dv.v0, dv.v1, dv.v2, dv.v3
def fz_convert_color( ss, sv, ds, is_, params):
    """
    Python version of fz_convert_color().

    `sv` should be a float or list of 1-4 floats or a SWIG
    representation of a float*.

    Returns (dv0, dv1, dv2, dv3).
    """
    return ll_fz_convert_color( ss.m_internal, sv, ds.m_internal, is_.m_internal, params.internal())
FzColorspace.fz_convert_color = fz_convert_color

# Override fz_set_warning_callback() and
# fz_set_error_callback() to use Python classes derived from
# our SWIG Director class DiagnosticCallback (defined in C), so
# that fnptrs can call Python code.
#

# We store DiagnosticCallbackPython instances in these
# globals to ensure they continue to exist after
# set_diagnostic_callback() returns.
#
set_warning_callback_s = None
set_error_callback_s = None

# Override set_error_callback().
class DiagnosticCallbackPython( DiagnosticCallback):
    """
    Overrides Director class DiagnosticCallback's virtual
    `_print()` method in Python.
    """
    def __init__( self, description, printfn):
        super().__init__( description)
        self.printfn = printfn
        if g_mupdf_trace_director:
            log( f'DiagnosticCallbackPython[{self.m_description}].__init__() self={self!r} printfn={printfn!r}')
    def __del__( self):
        if g_mupdf_trace_director:
            log( f'DiagnosticCallbackPython[{self.m_description}].__del__() destructor called.')
    def _print( self, message):
        if g_mupdf_trace_director:
            log( f'DiagnosticCallbackPython[{self.m_description}]._print(): Calling self.printfn={self.printfn!r} with message={message!r}')
        try:
            self.printfn( message)
        except Exception as e:
# This shouldn't happen, so always output a diagnostic.
            log( f'DiagnosticCallbackPython[{self.m_description}]._print(): Warning: exception from self.printfn={self.printfn!r}: e={e!r}')
# Calling `raise` here serves to test
# `DiagnosticCallback()`'s swallowing of what will
# be a C++ exception. But we could swallow the
# exception here instead.
            raise

def set_diagnostic_callback( description, printfn):
    if g_mupdf_trace_director:
        log( f'set_diagnostic_callback() description={description!r} printfn={printfn!r}')
    if printfn:
        ret = DiagnosticCallbackPython( description, printfn)
        return ret
    else:
        if g_mupdf_trace_director:
            log( f'Calling ll_fz_set_{description}_callback() with (None, None)')
        if description == 'error':
            ll_fz_set_error_callback( None, None)
        elif description == 'warning':
            ll_fz_set_warning_callback( None, None)
        else:
            assert 0, f'Unrecognised description={description!r}'
        return None

def fz_set_error_callback( printfn):
    global set_error_callback_s
    set_error_callback_s = set_diagnostic_callback( 'error', printfn)

def fz_set_warning_callback( printfn):
    global set_warning_callback_s
    set_warning_callback_s = set_diagnostic_callback( 'warning', printfn)

# Direct access to fz_pixmap samples.
def ll_fz_pixmap_samples_memoryview( pixmap):
    """
    Returns a writable Python `memoryview` for a `fz_pixmap`.
    """
    assert isinstance( pixmap, fz_pixmap)
    ret = python_memoryview_from_memory(
            ll_fz_pixmap_samples( pixmap),
            ll_fz_pixmap_stride( pixmap) * ll_fz_pixmap_height( pixmap),
            1, # writable
            )
    return ret
def fz_pixmap_samples_memoryview( pixmap):
    """
    Returns a writable Python `memoryview` for a `FzPixmap`.
    """
    return ll_fz_pixmap_samples_memoryview( pixmap.m_internal)
FzPixmap.fz_pixmap_samples_memoryview = fz_pixmap_samples_memoryview

# Avoid potential unsafe use of variadic args by forcing a
# single arg and escaping all '%' characters. (Passing ('%s',
# text) does not work - results in "(null)" being output.)
#
ll_fz_warn_original = ll_fz_warn
def ll_fz_warn( text):
    assert isinstance( text, str), f'text={text!r} str={str!r}'
    text = text.replace( '%', '%%')
    return ll_fz_warn_original( text)
fz_warn = ll_fz_warn

# Force use of pdf_load_field_name2() instead of
# pdf_load_field_name() because the latter returns a char*
# buffer that must be freed by the caller.
ll_pdf_load_field_name = ll_pdf_load_field_name2
pdf_load_field_name = pdf_load_field_name2
PdfObj.pdf_load_field_name = pdf_load_field_name

# It's important that when we create class derived
# from StoryPositionsCallback, we ensure that
# StoryPositionsCallback's constructor is called. Otherwise
# the new instance doesn't seem to be an instance of
# StoryPositionsCallback.
#
class StoryPositionsCallback_python( StoryPositionsCallback):
    def __init__( self, python_callback):
        super().__init__()
        self.python_callback = python_callback
    def call( self, position):
        self.python_callback( position)

ll_fz_story_positions_orig = ll_fz_story_positions
def ll_fz_story_positions( story, python_callback):
    """
    Custom replacement for `ll_fz_story_positions()` that takes
    a Python callable `python_callback`.
    """
#log( f'll_fz_story_positions() type(story)={type(story)!r} type(python_callback)={type(python_callback)!r}')
    python_callback_instance = StoryPositionsCallback_python( python_callback)
    ll_fz_story_positions_director( story, python_callback_instance)
def fz_story_positions( story, python_callback):
#log( f'fz_story_positions() type(story)={type(story)!r} type(python_callback)={type(python_callback)!r}')
    assert isinstance( story, FzStory)
    assert callable( python_callback)
    def python_callback2( position):
        position2 = FzStoryElementPosition( position)
        python_callback( position2)
    ll_fz_story_positions( story.m_internal, python_callback2)
FzStory.fz_story_positions = fz_story_positions

# Monkey-patch `FzDocumentWriter.__init__()` to set `self._out`
# to any `FzOutput2` arg. This ensures that the Python part of
# the derived `FzOutput2` instance is kept alive for use by the
# `FzDocumentWriter`, otherwise Python can delete it, then get
# a SEGV if C++ tries to call the derived Python methods.
#
# [We don't patch equivalent class-aware functions such
# as `fz_new_pdf_writer_with_output()` because they are
# not available to C++/Python, because FzDocumentWriter is
# non-copyable.]
#
FzDocumentWriter__init__0 = FzDocumentWriter.__init__
def FzDocumentWriter__init__1(self, *args):
    out = None
    for arg in args:
        if isinstance( arg, FzOutput2):
            assert not out, "More than one FzOutput2 passed to FzDocumentWriter.__init__()"
            out = arg
    if out:
        self._out = out
    return FzDocumentWriter__init__0(self, *args)
FzDocumentWriter.__init__ = FzDocumentWriter__init__1

# Create class derived from
# fz_install_load_system_font_funcs_args class wrapper with
# overrides of the virtual functions to allow calling of Python
# callbacks.
#
class fz_install_load_system_font_funcs_args3(FzInstallLoadSystemFontFuncsArgs2):
    """
    Class derived from Swig Director class
    fz_install_load_system_font_funcs_args2, to allow
    implementation of fz_install_load_system_font_funcs with
    Python callbacks.
    """
    def __init__(self, f=None, f_cjk=None, f_fallback=None):
        super().__init__()

        self.f3 = f
        self.f_cjk3 = f_cjk
        self.f_fallback3 = f_fallback

        self.use_virtual_f(True if f else False)
        self.use_virtual_f_cjk(True if f_cjk else False)
        self.use_virtual_f_fallback(True if f_fallback else False)

    def ret_font(self, font):
        if font is None:
            return None
        elif isinstance(font, FzFont):
            return ll_fz_keep_font(font.m_internal)
        elif isinstance(font, fz_font):
            return font
        else:
            assert 0, f'Expected FzFont or fz_font, but fz_install_load_system_font_funcs() callback returned {type(font)=}'

    def f(self, ctx, name, bold, italic, needs_exact_metrics):
        font = self.f3(name, bold, italic, needs_exact_metrics)
        return self.ret_font(font)

    def f_cjk(self, ctx, name, ordering, serif):
        font = self.f_cjk3(name, ordering, serif)
        return self.ret_font(font)

    def f_fallback(self, ctx, script, language, serif, bold, italic):
        font = self.f_fallback3(script, language, serif, bold, italic)
        return self.ret_font(font)

# We store the most recently created
# fz_install_load_system_font_funcs_args in this global so that
# it is not cleaned up by Python.
g_fz_install_load_system_font_funcs_args = None

def fz_install_load_system_font_funcs(f=None, f_cjk=None, f_fallback=None):
    """
    Python override for MuPDF
    fz_install_load_system_font_funcs() using Swig Director
    support. Python callbacks are not passed a `ctx` arg, and
    can return None, a mupdf.fz_font or a mupdf.FzFont.
    """
    global g_fz_install_load_system_font_funcs_args
    g_fz_install_load_system_font_funcs_args = fz_install_load_system_font_funcs_args3(
            f,
            f_cjk,
            f_fallback,
            )
    fz_install_load_system_font_funcs2(g_fz_install_load_system_font_funcs_args)
FzLink.__iter__ = lambda self: IteratorWrap( self)
FzStextBlock.__iter__ = lambda self: IteratorWrap( self)
FzStextLine.__iter__ = lambda self: IteratorWrap( self)
FzStextPage.__iter__ = lambda self: IteratorWrap( self)
fz_aa_context.__str__ = lambda s: to_string_fz_aa_context(s)
fz_aa_context.__repr__ = lambda s: to_string_fz_aa_context(s)
fz_color_params.__str__ = lambda s: to_string_fz_color_params(s)
fz_color_params.__repr__ = lambda s: to_string_fz_color_params(s)
fz_cookie.__str__ = lambda s: to_string_fz_cookie(s)
fz_cookie.__repr__ = lambda s: to_string_fz_cookie(s)
fz_draw_options.__str__ = lambda s: to_string_fz_draw_options(s)
fz_draw_options.__repr__ = lambda s: to_string_fz_draw_options(s)
fz_install_load_system_font_funcs_args.__str__ = lambda s: to_string_fz_install_load_system_font_funcs_args(s)
fz_install_load_system_font_funcs_args.__repr__ = lambda s: to_string_fz_install_load_system_font_funcs_args(s)
fz_irect.__str__ = lambda s: to_string_fz_irect(s)
fz_irect.__repr__ = lambda s: to_string_fz_irect(s)
fz_location.__str__ = lambda s: to_string_fz_location(s)
fz_location.__repr__ = lambda s: to_string_fz_location(s)
fz_matrix.__str__ = lambda s: to_string_fz_matrix(s)
fz_matrix.__repr__ = lambda s: to_string_fz_matrix(s)
fz_md5.__str__ = lambda s: to_string_fz_md5(s)
fz_md5.__repr__ = lambda s: to_string_fz_md5(s)
fz_pdfocr_options.__str__ = lambda s: to_string_fz_pdfocr_options(s)
fz_pdfocr_options.__repr__ = lambda s: to_string_fz_pdfocr_options(s)
fz_point.__str__ = lambda s: to_string_fz_point(s)
fz_point.__repr__ = lambda s: to_string_fz_point(s)
fz_pwg_options.__str__ = lambda s: to_string_fz_pwg_options(s)
fz_pwg_options.__repr__ = lambda s: to_string_fz_pwg_options(s)
fz_quad.__str__ = lambda s: to_string_fz_quad(s)
fz_quad.__repr__ = lambda s: to_string_fz_quad(s)
fz_rect.__str__ = lambda s: to_string_fz_rect(s)
fz_rect.__repr__ = lambda s: to_string_fz_rect(s)
fz_stext_options.__str__ = lambda s: to_string_fz_stext_options(s)
fz_stext_options.__repr__ = lambda s: to_string_fz_stext_options(s)
fz_story_element_position.__str__ = lambda s: to_string_fz_story_element_position(s)
fz_story_element_position.__repr__ = lambda s: to_string_fz_story_element_position(s)
fz_transition.__str__ = lambda s: to_string_fz_transition(s)
fz_transition.__repr__ = lambda s: to_string_fz_transition(s)
pdf_clean_options.__str__ = lambda s: to_string_pdf_clean_options(s)
pdf_clean_options.__repr__ = lambda s: to_string_pdf_clean_options(s)
pdf_filter_factory.__str__ = lambda s: to_string_pdf_filter_factory(s)
pdf_filter_factory.__repr__ = lambda s: to_string_pdf_filter_factory(s)
pdf_filter_options.__str__ = lambda s: to_string_pdf_filter_options(s)
pdf_filter_options.__repr__ = lambda s: to_string_pdf_filter_options(s)
pdf_image_rewriter_options.__str__ = lambda s: to_string_pdf_image_rewriter_options(s)
pdf_image_rewriter_options.__repr__ = lambda s: to_string_pdf_image_rewriter_options(s)
pdf_layer_config.__str__ = lambda s: to_string_pdf_layer_config(s)
pdf_layer_config.__repr__ = lambda s: to_string_pdf_layer_config(s)
pdf_layer_config_ui.__str__ = lambda s: to_string_pdf_layer_config_ui(s)
pdf_layer_config_ui.__repr__ = lambda s: to_string_pdf_layer_config_ui(s)
pdf_redact_options.__str__ = lambda s: to_string_pdf_redact_options(s)
pdf_redact_options.__repr__ = lambda s: to_string_pdf_redact_options(s)
pdf_sanitize_filter_options.__str__ = lambda s: to_string_pdf_sanitize_filter_options(s)
pdf_sanitize_filter_options.__repr__ = lambda s: to_string_pdf_sanitize_filter_options(s)
pdf_write_options.__str__ = lambda s: to_string_pdf_write_options(s)
pdf_write_options.__repr__ = lambda s: to_string_pdf_write_options(s)
FzAaContext.__str__ = lambda self: self.to_string()
FzAaContext.__repr__ = lambda self: self.to_string()
FzColorParams.__str__ = lambda self: self.to_string()
FzColorParams.__repr__ = lambda self: self.to_string()
FzCookie.__str__ = lambda self: self.to_string()
FzCookie.__repr__ = lambda self: self.to_string()
FzDrawOptions.__str__ = lambda self: self.to_string()
FzDrawOptions.__repr__ = lambda self: self.to_string()
FzInstallLoadSystemFontFuncsArgs.__str__ = lambda self: self.to_string()
FzInstallLoadSystemFontFuncsArgs.__repr__ = lambda self: self.to_string()
FzIrect.__str__ = lambda self: self.to_string()
FzIrect.__repr__ = lambda self: self.to_string()
FzLocation.__str__ = lambda self: self.to_string()
FzLocation.__repr__ = lambda self: self.to_string()
FzMatrix.__str__ = lambda self: self.to_string()
FzMatrix.__repr__ = lambda self: self.to_string()
FzMd5.__str__ = lambda self: self.to_string()
FzMd5.__repr__ = lambda self: self.to_string()
FzPdfocrOptions.__str__ = lambda self: self.to_string()
FzPdfocrOptions.__repr__ = lambda self: self.to_string()
FzPoint.__str__ = lambda self: self.to_string()
FzPoint.__repr__ = lambda self: self.to_string()
FzPwgOptions.__str__ = lambda self: self.to_string()
FzPwgOptions.__repr__ = lambda self: self.to_string()
FzQuad.__str__ = lambda self: self.to_string()
FzQuad.__repr__ = lambda self: self.to_string()
FzRect.__str__ = lambda self: self.to_string()
FzRect.__repr__ = lambda self: self.to_string()
FzStextOptions.__str__ = lambda self: self.to_string()
FzStextOptions.__repr__ = lambda self: self.to_string()
FzStoryElementPosition.__str__ = lambda self: self.to_string()
FzStoryElementPosition.__repr__ = lambda self: self.to_string()
FzTransition.__str__ = lambda self: self.to_string()
FzTransition.__repr__ = lambda self: self.to_string()
PdfCleanOptions.__str__ = lambda self: self.to_string()
PdfCleanOptions.__repr__ = lambda self: self.to_string()
PdfFilterFactory.__str__ = lambda self: self.to_string()
PdfFilterFactory.__repr__ = lambda self: self.to_string()
PdfFilterOptions.__str__ = lambda self: self.to_string()
PdfFilterOptions.__repr__ = lambda self: self.to_string()
PdfImageRewriterOptions.__str__ = lambda self: self.to_string()
PdfImageRewriterOptions.__repr__ = lambda self: self.to_string()
PdfLayerConfig.__str__ = lambda self: self.to_string()
PdfLayerConfig.__repr__ = lambda self: self.to_string()
PdfLayerConfigUi.__str__ = lambda self: self.to_string()
PdfLayerConfigUi.__repr__ = lambda self: self.to_string()
PdfRedactOptions.__str__ = lambda self: self.to_string()
PdfRedactOptions.__repr__ = lambda self: self.to_string()
PdfSanitizeFilterOptions.__str__ = lambda self: self.to_string()
PdfSanitizeFilterOptions.__repr__ = lambda self: self.to_string()
PdfWriteOptions.__str__ = lambda self: self.to_string()
PdfWriteOptions.__repr__ = lambda self: self.to_string()


PDF_ENUM_NAME_1_2 = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_1_2))
PDF_ENUM_NAME_1_5 = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_1_5))
PDF_ENUM_NAME_3D = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_3D))
PDF_ENUM_NAME_A = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_A))
PDF_ENUM_NAME_A85 = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_A85))
PDF_ENUM_NAME_AA = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_AA))
PDF_ENUM_NAME_AC = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_AC))
PDF_ENUM_NAME_AESV2 = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_AESV2))
PDF_ENUM_NAME_AESV3 = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_AESV3))
PDF_ENUM_NAME_AHx = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_AHx))
PDF_ENUM_NAME_AP = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_AP))
PDF_ENUM_NAME_AS = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_AS))
PDF_ENUM_NAME_ASCII85Decode = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_ASCII85Decode))
PDF_ENUM_NAME_ASCIIHexDecode = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_ASCIIHexDecode))
PDF_ENUM_NAME_AcroForm = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_AcroForm))
PDF_ENUM_NAME_Action = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Action))
PDF_ENUM_NAME_ActualText = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_ActualText))
PDF_ENUM_NAME_Adobe_PPKLite = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Adobe_PPKLite))
PDF_ENUM_NAME_All = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_All))
PDF_ENUM_NAME_AllOff = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_AllOff))
PDF_ENUM_NAME_AllOn = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_AllOn))
PDF_ENUM_NAME_Alpha = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Alpha))
PDF_ENUM_NAME_Alt = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Alt))
PDF_ENUM_NAME_Alternate = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Alternate))
PDF_ENUM_NAME_Annot = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Annot))
PDF_ENUM_NAME_Annots = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Annots))
PDF_ENUM_NAME_AnyOff = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_AnyOff))
PDF_ENUM_NAME_App = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_App))
PDF_ENUM_NAME_Approved = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Approved))
PDF_ENUM_NAME_Art = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Art))
PDF_ENUM_NAME_ArtBox = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_ArtBox))
PDF_ENUM_NAME_Artifact = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Artifact))
PDF_ENUM_NAME_AsIs = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_AsIs))
PDF_ENUM_NAME_Ascent = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Ascent))
PDF_ENUM_NAME_Aside = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Aside))
PDF_ENUM_NAME_AuthEvent = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_AuthEvent))
PDF_ENUM_NAME_Author = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Author))
PDF_ENUM_NAME_B = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_B))
PDF_ENUM_NAME_BBox = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_BBox))
PDF_ENUM_NAME_BC = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_BC))
PDF_ENUM_NAME_BE = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_BE))
PDF_ENUM_NAME_BG = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_BG))
PDF_ENUM_NAME_BM = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_BM))
PDF_ENUM_NAME_BPC = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_BPC))
PDF_ENUM_NAME_BS = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_BS))
PDF_ENUM_NAME_Background = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Background))
PDF_ENUM_NAME_BaseEncoding = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_BaseEncoding))
PDF_ENUM_NAME_BaseFont = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_BaseFont))
PDF_ENUM_NAME_BaseState = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_BaseState))
PDF_ENUM_NAME_BibEntry = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_BibEntry))
PDF_ENUM_NAME_BitsPerComponent = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_BitsPerComponent))
PDF_ENUM_NAME_BitsPerCoordinate = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_BitsPerCoordinate))
PDF_ENUM_NAME_BitsPerFlag = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_BitsPerFlag))
PDF_ENUM_NAME_BitsPerSample = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_BitsPerSample))
PDF_ENUM_NAME_BlackIs1 = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_BlackIs1))
PDF_ENUM_NAME_BlackPoint = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_BlackPoint))
PDF_ENUM_NAME_BleedBox = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_BleedBox))
PDF_ENUM_NAME_Blinds = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Blinds))
PDF_ENUM_NAME_BlockQuote = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_BlockQuote))
PDF_ENUM_NAME_Border = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Border))
PDF_ENUM_NAME_Bounds = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Bounds))
PDF_ENUM_NAME_Box = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Box))
PDF_ENUM_NAME_Bt = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Bt))
PDF_ENUM_NAME_Btn = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Btn))
PDF_ENUM_NAME_Butt = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Butt))
PDF_ENUM_NAME_ByteRange = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_ByteRange))
PDF_ENUM_NAME_C = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_C))
PDF_ENUM_NAME_C0 = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_C0))
PDF_ENUM_NAME_C1 = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_C1))
PDF_ENUM_NAME_CA = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_CA))
PDF_ENUM_NAME_CCF = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_CCF))
PDF_ENUM_NAME_CCITTFaxDecode = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_CCITTFaxDecode))
PDF_ENUM_NAME_CF = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_CF))
PDF_ENUM_NAME_CFM = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_CFM))
PDF_ENUM_NAME_CI = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_CI))
PDF_ENUM_NAME_CIDFontType0 = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_CIDFontType0))
PDF_ENUM_NAME_CIDFontType0C = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_CIDFontType0C))
PDF_ENUM_NAME_CIDFontType2 = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_CIDFontType2))
PDF_ENUM_NAME_CIDSystemInfo = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_CIDSystemInfo))
PDF_ENUM_NAME_CIDToGIDMap = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_CIDToGIDMap))
PDF_ENUM_NAME_CMYK = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_CMYK))
PDF_ENUM_NAME_CS = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_CS))
PDF_ENUM_NAME_CalCMYK = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_CalCMYK))
PDF_ENUM_NAME_CalGray = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_CalGray))
PDF_ENUM_NAME_CalRGB = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_CalRGB))
PDF_ENUM_NAME_CapHeight = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_CapHeight))
PDF_ENUM_NAME_Caption = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Caption))
PDF_ENUM_NAME_Caret = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Caret))
PDF_ENUM_NAME_Catalog = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Catalog))
PDF_ENUM_NAME_Cert = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Cert))
PDF_ENUM_NAME_Ch = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Ch))
PDF_ENUM_NAME_Changes = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Changes))
PDF_ENUM_NAME_CharProcs = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_CharProcs))
PDF_ENUM_NAME_CheckSum = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_CheckSum))
PDF_ENUM_NAME_Circle = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Circle))
PDF_ENUM_NAME_ClosedArrow = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_ClosedArrow))
PDF_ENUM_NAME_Code = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Code))
PDF_ENUM_NAME_Collection = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Collection))
PDF_ENUM_NAME_ColorSpace = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_ColorSpace))
PDF_ENUM_NAME_ColorTransform = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_ColorTransform))
PDF_ENUM_NAME_Colorants = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Colorants))
PDF_ENUM_NAME_Colors = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Colors))
PDF_ENUM_NAME_Columns = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Columns))
PDF_ENUM_NAME_Confidential = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Confidential))
PDF_ENUM_NAME_Configs = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Configs))
PDF_ENUM_NAME_ContactInfo = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_ContactInfo))
PDF_ENUM_NAME_Contents = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Contents))
PDF_ENUM_NAME_Coords = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Coords))
PDF_ENUM_NAME_Count = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Count))
PDF_ENUM_NAME_Cover = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Cover))
PDF_ENUM_NAME_CreationDate = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_CreationDate))
PDF_ENUM_NAME_Creator = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Creator))
PDF_ENUM_NAME_CropBox = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_CropBox))
PDF_ENUM_NAME_Crypt = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Crypt))
PDF_ENUM_NAME_D = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_D))
PDF_ENUM_NAME_DA = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_DA))
PDF_ENUM_NAME_DC = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_DC))
PDF_ENUM_NAME_DCT = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_DCT))
PDF_ENUM_NAME_DCTDecode = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_DCTDecode))
PDF_ENUM_NAME_DL = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_DL))
PDF_ENUM_NAME_DOS = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_DOS))
PDF_ENUM_NAME_DP = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_DP))
PDF_ENUM_NAME_DR = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_DR))
PDF_ENUM_NAME_DS = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_DS))
PDF_ENUM_NAME_DV = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_DV))
PDF_ENUM_NAME_DW = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_DW))
PDF_ENUM_NAME_DW2 = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_DW2))
PDF_ENUM_NAME_DamagedRowsBeforeError = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_DamagedRowsBeforeError))
PDF_ENUM_NAME_Data = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Data))
PDF_ENUM_NAME_Date = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Date))
PDF_ENUM_NAME_Decode = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Decode))
PDF_ENUM_NAME_DecodeParms = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_DecodeParms))
PDF_ENUM_NAME_Default = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Default))
PDF_ENUM_NAME_DefaultCMYK = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_DefaultCMYK))
PDF_ENUM_NAME_DefaultGray = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_DefaultGray))
PDF_ENUM_NAME_DefaultRGB = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_DefaultRGB))
PDF_ENUM_NAME_Departmental = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Departmental))
PDF_ENUM_NAME_Desc = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Desc))
PDF_ENUM_NAME_DescendantFonts = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_DescendantFonts))
PDF_ENUM_NAME_Descent = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Descent))
PDF_ENUM_NAME_Design = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Design))
PDF_ENUM_NAME_Dest = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Dest))
PDF_ENUM_NAME_DestOutputProfile = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_DestOutputProfile))
PDF_ENUM_NAME_Dests = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Dests))
PDF_ENUM_NAME_DeviceCMYK = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_DeviceCMYK))
PDF_ENUM_NAME_DeviceGray = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_DeviceGray))
PDF_ENUM_NAME_DeviceN = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_DeviceN))
PDF_ENUM_NAME_DeviceRGB = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_DeviceRGB))
PDF_ENUM_NAME_Di = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Di))
PDF_ENUM_NAME_Diamond = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Diamond))
PDF_ENUM_NAME_Differences = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Differences))
PDF_ENUM_NAME_DigestLocation = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_DigestLocation))
PDF_ENUM_NAME_DigestMethod = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_DigestMethod))
PDF_ENUM_NAME_DigestValue = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_DigestValue))
PDF_ENUM_NAME_Dissolve = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Dissolve))
PDF_ENUM_NAME_Div = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Div))
PDF_ENUM_NAME_Dm = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Dm))
PDF_ENUM_NAME_DocMDP = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_DocMDP))
PDF_ENUM_NAME_Document = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Document))
PDF_ENUM_NAME_DocumentFragment = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_DocumentFragment))
PDF_ENUM_NAME_Domain = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Domain))
PDF_ENUM_NAME_Draft = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Draft))
PDF_ENUM_NAME_Dur = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Dur))
PDF_ENUM_NAME_E = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_E))
PDF_ENUM_NAME_EF = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_EF))
PDF_ENUM_NAME_EarlyChange = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_EarlyChange))
PDF_ENUM_NAME_Em = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Em))
PDF_ENUM_NAME_EmbeddedFile = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_EmbeddedFile))
PDF_ENUM_NAME_EmbeddedFiles = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_EmbeddedFiles))
PDF_ENUM_NAME_Encode = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Encode))
PDF_ENUM_NAME_EncodedByteAlign = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_EncodedByteAlign))
PDF_ENUM_NAME_Encoding = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Encoding))
PDF_ENUM_NAME_Encrypt = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Encrypt))
PDF_ENUM_NAME_EncryptMetadata = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_EncryptMetadata))
PDF_ENUM_NAME_EndOfBlock = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_EndOfBlock))
PDF_ENUM_NAME_EndOfLine = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_EndOfLine))
PDF_ENUM_NAME_Exclude = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Exclude))
PDF_ENUM_NAME_Experimental = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Experimental))
PDF_ENUM_NAME_Expired = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Expired))
PDF_ENUM_NAME_ExtGState = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_ExtGState))
PDF_ENUM_NAME_Extend = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Extend))
PDF_ENUM_NAME_F = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_F))
PDF_ENUM_NAME_FENote = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_FENote))
PDF_ENUM_NAME_FL = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_FL))
PDF_ENUM_NAME_FRM = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_FRM))
PDF_ENUM_NAME_FS = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_FS))
PDF_ENUM_NAME_FT = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_FT))
PDF_ENUM_NAME_Fade = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Fade))
PDF_ENUM_NAME_Ff = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Ff))
PDF_ENUM_NAME_FieldMDP = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_FieldMDP))
PDF_ENUM_NAME_Fields = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Fields))
PDF_ENUM_NAME_Figure = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Figure))
PDF_ENUM_NAME_FileAttachment = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_FileAttachment))
PDF_ENUM_NAME_FileSize = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_FileSize))
PDF_ENUM_NAME_Filespec = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Filespec))
PDF_ENUM_NAME_Filter = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Filter))
PDF_ENUM_NAME_Final = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Final))
PDF_ENUM_NAME_Fingerprint = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Fingerprint))
PDF_ENUM_NAME_First = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_First))
PDF_ENUM_NAME_FirstChar = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_FirstChar))
PDF_ENUM_NAME_FirstPage = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_FirstPage))
PDF_ENUM_NAME_Fit = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Fit))
PDF_ENUM_NAME_FitB = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_FitB))
PDF_ENUM_NAME_FitBH = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_FitBH))
PDF_ENUM_NAME_FitBV = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_FitBV))
PDF_ENUM_NAME_FitH = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_FitH))
PDF_ENUM_NAME_FitR = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_FitR))
PDF_ENUM_NAME_FitV = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_FitV))
PDF_ENUM_NAME_Fl = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Fl))
PDF_ENUM_NAME_Flags = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Flags))
PDF_ENUM_NAME_FlateDecode = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_FlateDecode))
PDF_ENUM_NAME_Fly = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Fly))
PDF_ENUM_NAME_Font = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Font))
PDF_ENUM_NAME_FontBBox = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_FontBBox))
PDF_ENUM_NAME_FontDescriptor = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_FontDescriptor))
PDF_ENUM_NAME_FontFile = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_FontFile))
PDF_ENUM_NAME_FontFile2 = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_FontFile2))
PDF_ENUM_NAME_FontFile3 = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_FontFile3))
PDF_ENUM_NAME_FontMatrix = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_FontMatrix))
PDF_ENUM_NAME_FontName = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_FontName))
PDF_ENUM_NAME_ForComment = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_ForComment))
PDF_ENUM_NAME_ForPublicRelease = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_ForPublicRelease))
PDF_ENUM_NAME_Form = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Form))
PDF_ENUM_NAME_FormEx = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_FormEx))
PDF_ENUM_NAME_FormType = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_FormType))
PDF_ENUM_NAME_Formula = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Formula))
PDF_ENUM_NAME_FreeText = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_FreeText))
PDF_ENUM_NAME_Function = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Function))
PDF_ENUM_NAME_FunctionType = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_FunctionType))
PDF_ENUM_NAME_Functions = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Functions))
PDF_ENUM_NAME_G = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_G))
PDF_ENUM_NAME_GTS_PDFX = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_GTS_PDFX))
PDF_ENUM_NAME_Gamma = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Gamma))
PDF_ENUM_NAME_Glitter = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Glitter))
PDF_ENUM_NAME_GoTo = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_GoTo))
PDF_ENUM_NAME_GoToR = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_GoToR))
PDF_ENUM_NAME_Group = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Group))
PDF_ENUM_NAME_H = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_H))
PDF_ENUM_NAME_H1 = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_H1))
PDF_ENUM_NAME_H2 = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_H2))
PDF_ENUM_NAME_H3 = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_H3))
PDF_ENUM_NAME_H4 = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_H4))
PDF_ENUM_NAME_H5 = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_H5))
PDF_ENUM_NAME_H6 = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_H6))
PDF_ENUM_NAME_Height = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Height))
PDF_ENUM_NAME_Helv = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Helv))
PDF_ENUM_NAME_Highlight = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Highlight))
PDF_ENUM_NAME_HistoryPos = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_HistoryPos))
PDF_ENUM_NAME_I = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_I))
PDF_ENUM_NAME_IC = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_IC))
PDF_ENUM_NAME_ICCBased = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_ICCBased))
PDF_ENUM_NAME_ID = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_ID))
PDF_ENUM_NAME_IM = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_IM))
PDF_ENUM_NAME_IRT = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_IRT))
PDF_ENUM_NAME_Identity = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Identity))
PDF_ENUM_NAME_Identity_H = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Identity_H))
PDF_ENUM_NAME_Identity_V = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Identity_V))
PDF_ENUM_NAME_Image = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Image))
PDF_ENUM_NAME_ImageB = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_ImageB))
PDF_ENUM_NAME_ImageC = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_ImageC))
PDF_ENUM_NAME_ImageI = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_ImageI))
PDF_ENUM_NAME_ImageMask = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_ImageMask))
PDF_ENUM_NAME_Include = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Include))
PDF_ENUM_NAME_Index = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Index))
PDF_ENUM_NAME_Indexed = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Indexed))
PDF_ENUM_NAME_Info = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Info))
PDF_ENUM_NAME_Ink = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Ink))
PDF_ENUM_NAME_InkList = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_InkList))
PDF_ENUM_NAME_Intent = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Intent))
PDF_ENUM_NAME_Interpolate = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Interpolate))
PDF_ENUM_NAME_IsMap = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_IsMap))
PDF_ENUM_NAME_ItalicAngle = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_ItalicAngle))
PDF_ENUM_NAME_JBIG2Decode = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_JBIG2Decode))
PDF_ENUM_NAME_JBIG2Globals = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_JBIG2Globals))
PDF_ENUM_NAME_JPXDecode = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_JPXDecode))
PDF_ENUM_NAME_JS = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_JS))
PDF_ENUM_NAME_JavaScript = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_JavaScript))
PDF_ENUM_NAME_K = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_K))
PDF_ENUM_NAME_Keywords = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Keywords))
PDF_ENUM_NAME_Kids = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Kids))
PDF_ENUM_NAME_L = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_L))
PDF_ENUM_NAME_LBody = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_LBody))
PDF_ENUM_NAME_LC = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_LC))
PDF_ENUM_NAME_LE = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_LE))
PDF_ENUM_NAME_LI = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_LI))
PDF_ENUM_NAME_LJ = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_LJ))
PDF_ENUM_NAME_LW = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_LW))
PDF_ENUM_NAME_LZ = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_LZ))
PDF_ENUM_NAME_LZW = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_LZW))
PDF_ENUM_NAME_LZWDecode = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_LZWDecode))
PDF_ENUM_NAME_Lab = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Lab))
PDF_ENUM_NAME_Label = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Label))
PDF_ENUM_NAME_Lang = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Lang))
PDF_ENUM_NAME_Last = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Last))
PDF_ENUM_NAME_LastChar = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_LastChar))
PDF_ENUM_NAME_LastPage = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_LastPage))
PDF_ENUM_NAME_Launch = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Launch))
PDF_ENUM_NAME_Layer = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Layer))
PDF_ENUM_NAME_Lbl = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Lbl))
PDF_ENUM_NAME_Length = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Length))
PDF_ENUM_NAME_Length1 = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Length1))
PDF_ENUM_NAME_Length2 = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Length2))
PDF_ENUM_NAME_Length3 = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Length3))
PDF_ENUM_NAME_Limits = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Limits))
PDF_ENUM_NAME_Line = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Line))
PDF_ENUM_NAME_Linearized = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Linearized))
PDF_ENUM_NAME_Link = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Link))
PDF_ENUM_NAME_List = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_List))
PDF_ENUM_NAME_Location = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Location))
PDF_ENUM_NAME_Lock = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Lock))
PDF_ENUM_NAME_Locked = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Locked))
PDF_ENUM_NAME_Luminosity = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Luminosity))
PDF_ENUM_NAME_M = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_M))
PDF_ENUM_NAME_MCID = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_MCID))
PDF_ENUM_NAME_MK = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_MK))
PDF_ENUM_NAME_ML = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_ML))
PDF_ENUM_NAME_MMType1 = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_MMType1))
PDF_ENUM_NAME_Mac = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Mac))
PDF_ENUM_NAME_Mask = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Mask))
PDF_ENUM_NAME_Matrix = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Matrix))
PDF_ENUM_NAME_Matte = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Matte))
PDF_ENUM_NAME_MaxLen = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_MaxLen))
PDF_ENUM_NAME_MediaBox = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_MediaBox))
PDF_ENUM_NAME_Metadata = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Metadata))
PDF_ENUM_NAME_MissingWidth = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_MissingWidth))
PDF_ENUM_NAME_ModDate = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_ModDate))
PDF_ENUM_NAME_Movie = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Movie))
PDF_ENUM_NAME_Msg = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Msg))
PDF_ENUM_NAME_Multiply = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Multiply))
PDF_ENUM_NAME_N = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_N))
PDF_ENUM_NAME_Name = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Name))
PDF_ENUM_NAME_Named = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Named))
PDF_ENUM_NAME_Names = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Names))
PDF_ENUM_NAME_NewWindow = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_NewWindow))
PDF_ENUM_NAME_Next = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Next))
PDF_ENUM_NAME_NextPage = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_NextPage))
PDF_ENUM_NAME_NonEFontNoWarn = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_NonEFontNoWarn))
PDF_ENUM_NAME_NonStruct = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_NonStruct))
PDF_ENUM_NAME_None = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_None))
PDF_ENUM_NAME_Normal = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Normal))
PDF_ENUM_NAME_NotApproved = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_NotApproved))
PDF_ENUM_NAME_NotForPublicRelease = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_NotForPublicRelease))
PDF_ENUM_NAME_Note = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Note))
PDF_ENUM_NAME_NumSections = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_NumSections))
PDF_ENUM_NAME_Nums = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Nums))
PDF_ENUM_NAME_O = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_O))
PDF_ENUM_NAME_OC = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_OC))
PDF_ENUM_NAME_OCG = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_OCG))
PDF_ENUM_NAME_OCGs = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_OCGs))
PDF_ENUM_NAME_OCMD = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_OCMD))
PDF_ENUM_NAME_OCProperties = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_OCProperties))
PDF_ENUM_NAME_OE = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_OE))
PDF_ENUM_NAME_OFF = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_OFF))
PDF_ENUM_NAME_ON = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_ON))
PDF_ENUM_NAME_OP = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_OP))
PDF_ENUM_NAME_OPM = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_OPM))
PDF_ENUM_NAME_OS = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_OS))
PDF_ENUM_NAME_ObjStm = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_ObjStm))
PDF_ENUM_NAME_Of = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Of))
PDF_ENUM_NAME_Off = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Off))
PDF_ENUM_NAME_Open = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Open))
PDF_ENUM_NAME_OpenArrow = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_OpenArrow))
PDF_ENUM_NAME_OpenType = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_OpenType))
PDF_ENUM_NAME_Opt = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Opt))
PDF_ENUM_NAME_Order = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Order))
PDF_ENUM_NAME_Ordering = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Ordering))
PDF_ENUM_NAME_Outlines = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Outlines))
PDF_ENUM_NAME_OutputCondition = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_OutputCondition))
PDF_ENUM_NAME_OutputConditionIdentifier = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_OutputConditionIdentifier))
PDF_ENUM_NAME_OutputIntent = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_OutputIntent))
PDF_ENUM_NAME_OutputIntents = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_OutputIntents))
PDF_ENUM_NAME_P = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_P))
PDF_ENUM_NAME_PDF = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_PDF))
PDF_ENUM_NAME_PS = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_PS))
PDF_ENUM_NAME_Page = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Page))
PDF_ENUM_NAME_PageLabels = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_PageLabels))
PDF_ENUM_NAME_PageMode = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_PageMode))
PDF_ENUM_NAME_Pages = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Pages))
PDF_ENUM_NAME_PaintType = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_PaintType))
PDF_ENUM_NAME_Params = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Params))
PDF_ENUM_NAME_Parent = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Parent))
PDF_ENUM_NAME_ParentTree = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_ParentTree))
PDF_ENUM_NAME_Part = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Part))
PDF_ENUM_NAME_Pattern = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Pattern))
PDF_ENUM_NAME_PatternType = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_PatternType))
PDF_ENUM_NAME_Perms = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Perms))
PDF_ENUM_NAME_PolyLine = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_PolyLine))
PDF_ENUM_NAME_Polygon = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Polygon))
PDF_ENUM_NAME_Popup = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Popup))
PDF_ENUM_NAME_PreRelease = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_PreRelease))
PDF_ENUM_NAME_Predictor = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Predictor))
PDF_ENUM_NAME_Prev = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Prev))
PDF_ENUM_NAME_PrevPage = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_PrevPage))
PDF_ENUM_NAME_Preview = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Preview))
PDF_ENUM_NAME_Print = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Print))
PDF_ENUM_NAME_PrinterMark = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_PrinterMark))
PDF_ENUM_NAME_Private = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Private))
PDF_ENUM_NAME_ProcSet = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_ProcSet))
PDF_ENUM_NAME_Producer = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Producer))
PDF_ENUM_NAME_Prop_AuthTime = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Prop_AuthTime))
PDF_ENUM_NAME_Prop_AuthType = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Prop_AuthType))
PDF_ENUM_NAME_Prop_Build = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Prop_Build))
PDF_ENUM_NAME_Properties = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Properties))
PDF_ENUM_NAME_PubSec = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_PubSec))
PDF_ENUM_NAME_Push = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Push))
PDF_ENUM_NAME_Q = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Q))
PDF_ENUM_NAME_QuadPoints = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_QuadPoints))
PDF_ENUM_NAME_Quote = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Quote))
PDF_ENUM_NAME_R = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_R))
PDF_ENUM_NAME_RB = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_RB))
PDF_ENUM_NAME_RBGroups = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_RBGroups))
PDF_ENUM_NAME_RC = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_RC))
PDF_ENUM_NAME_RClosedArrow = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_RClosedArrow))
PDF_ENUM_NAME_RD = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_RD))
PDF_ENUM_NAME_REx = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_REx))
PDF_ENUM_NAME_RGB = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_RGB))
PDF_ENUM_NAME_RI = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_RI))
PDF_ENUM_NAME_RL = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_RL))
PDF_ENUM_NAME_ROpenArrow = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_ROpenArrow))
PDF_ENUM_NAME_RP = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_RP))
PDF_ENUM_NAME_RT = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_RT))
PDF_ENUM_NAME_Range = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Range))
PDF_ENUM_NAME_Reason = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Reason))
PDF_ENUM_NAME_Rect = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Rect))
PDF_ENUM_NAME_Redact = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Redact))
PDF_ENUM_NAME_Ref = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Ref))
PDF_ENUM_NAME_Reference = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Reference))
PDF_ENUM_NAME_Registry = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Registry))
PDF_ENUM_NAME_ResetForm = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_ResetForm))
PDF_ENUM_NAME_Resources = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Resources))
PDF_ENUM_NAME_RoleMap = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_RoleMap))
PDF_ENUM_NAME_Root = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Root))
PDF_ENUM_NAME_Rotate = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Rotate))
PDF_ENUM_NAME_Rows = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Rows))
PDF_ENUM_NAME_Ruby = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Ruby))
PDF_ENUM_NAME_RunLengthDecode = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_RunLengthDecode))
PDF_ENUM_NAME_S = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_S))
PDF_ENUM_NAME_SMask = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_SMask))
PDF_ENUM_NAME_SMaskInData = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_SMaskInData))
PDF_ENUM_NAME_Schema = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Schema))
PDF_ENUM_NAME_Screen = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Screen))
PDF_ENUM_NAME_Sect = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Sect))
PDF_ENUM_NAME_Separation = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Separation))
PDF_ENUM_NAME_Shading = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Shading))
PDF_ENUM_NAME_ShadingType = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_ShadingType))
PDF_ENUM_NAME_Si = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Si))
PDF_ENUM_NAME_Sig = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Sig))
PDF_ENUM_NAME_SigFlags = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_SigFlags))
PDF_ENUM_NAME_SigQ = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_SigQ))
PDF_ENUM_NAME_SigRef = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_SigRef))
PDF_ENUM_NAME_Size = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Size))
PDF_ENUM_NAME_Slash = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Slash))
PDF_ENUM_NAME_Sold = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Sold))
PDF_ENUM_NAME_Sound = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Sound))
PDF_ENUM_NAME_Span = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Span))
PDF_ENUM_NAME_Split = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Split))
PDF_ENUM_NAME_Square = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Square))
PDF_ENUM_NAME_Squiggly = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Squiggly))
PDF_ENUM_NAME_St = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_St))
PDF_ENUM_NAME_Stamp = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Stamp))
PDF_ENUM_NAME_Standard = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Standard))
PDF_ENUM_NAME_StdCF = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_StdCF))
PDF_ENUM_NAME_StemV = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_StemV))
PDF_ENUM_NAME_StmF = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_StmF))
PDF_ENUM_NAME_StrF = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_StrF))
PDF_ENUM_NAME_StrikeOut = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_StrikeOut))
PDF_ENUM_NAME_Strong = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Strong))
PDF_ENUM_NAME_StructParent = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_StructParent))
PDF_ENUM_NAME_StructParents = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_StructParents))
PDF_ENUM_NAME_StructTreeRoot = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_StructTreeRoot))
PDF_ENUM_NAME_Sub = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Sub))
PDF_ENUM_NAME_SubFilter = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_SubFilter))
PDF_ENUM_NAME_Subject = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Subject))
PDF_ENUM_NAME_Subtype = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Subtype))
PDF_ENUM_NAME_Subtype2 = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Subtype2))
PDF_ENUM_NAME_Supplement = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Supplement))
PDF_ENUM_NAME_Symb = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Symb))
PDF_ENUM_NAME_T = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_T))
PDF_ENUM_NAME_TBody = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_TBody))
PDF_ENUM_NAME_TD = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_TD))
PDF_ENUM_NAME_TFoot = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_TFoot))
PDF_ENUM_NAME_TH = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_TH))
PDF_ENUM_NAME_THead = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_THead))
PDF_ENUM_NAME_TI = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_TI))
PDF_ENUM_NAME_TOC = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_TOC))
PDF_ENUM_NAME_TOCI = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_TOCI))
PDF_ENUM_NAME_TR = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_TR))
PDF_ENUM_NAME_TR2 = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_TR2))
PDF_ENUM_NAME_TU = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_TU))
PDF_ENUM_NAME_Table = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Table))
PDF_ENUM_NAME_Text = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Text))
PDF_ENUM_NAME_TilingType = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_TilingType))
PDF_ENUM_NAME_Times = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Times))
PDF_ENUM_NAME_Title = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Title))
PDF_ENUM_NAME_ToUnicode = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_ToUnicode))
PDF_ENUM_NAME_TopSecret = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_TopSecret))
PDF_ENUM_NAME_Trans = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Trans))
PDF_ENUM_NAME_TransformMethod = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_TransformMethod))
PDF_ENUM_NAME_TransformParams = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_TransformParams))
PDF_ENUM_NAME_Transparency = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Transparency))
PDF_ENUM_NAME_TrapNet = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_TrapNet))
PDF_ENUM_NAME_TrimBox = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_TrimBox))
PDF_ENUM_NAME_TrueType = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_TrueType))
PDF_ENUM_NAME_TrustedMode = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_TrustedMode))
PDF_ENUM_NAME_Tx = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Tx))
PDF_ENUM_NAME_Type = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Type))
PDF_ENUM_NAME_Type0 = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Type0))
PDF_ENUM_NAME_Type1 = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Type1))
PDF_ENUM_NAME_Type1C = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Type1C))
PDF_ENUM_NAME_Type3 = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Type3))
PDF_ENUM_NAME_U = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_U))
PDF_ENUM_NAME_UE = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_UE))
PDF_ENUM_NAME_UF = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_UF))
PDF_ENUM_NAME_URI = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_URI))
PDF_ENUM_NAME_URL = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_URL))
PDF_ENUM_NAME_Unchanged = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Unchanged))
PDF_ENUM_NAME_Uncover = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Uncover))
PDF_ENUM_NAME_Underline = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Underline))
PDF_ENUM_NAME_Unix = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Unix))
PDF_ENUM_NAME_Usage = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Usage))
PDF_ENUM_NAME_UseBlackPtComp = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_UseBlackPtComp))
PDF_ENUM_NAME_UseCMap = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_UseCMap))
PDF_ENUM_NAME_UseOutlines = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_UseOutlines))
PDF_ENUM_NAME_UserUnit = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_UserUnit))
PDF_ENUM_NAME_V = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_V))
PDF_ENUM_NAME_V2 = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_V2))
PDF_ENUM_NAME_VE = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_VE))
PDF_ENUM_NAME_Version = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Version))
PDF_ENUM_NAME_Vertices = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Vertices))
PDF_ENUM_NAME_VerticesPerRow = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_VerticesPerRow))
PDF_ENUM_NAME_View = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_View))
PDF_ENUM_NAME_W = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_W))
PDF_ENUM_NAME_W2 = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_W2))
PDF_ENUM_NAME_WMode = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_WMode))
PDF_ENUM_NAME_WP = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_WP))
PDF_ENUM_NAME_WT = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_WT))
PDF_ENUM_NAME_Warichu = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Warichu))
PDF_ENUM_NAME_Watermark = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Watermark))
PDF_ENUM_NAME_WhitePoint = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_WhitePoint))
PDF_ENUM_NAME_Widget = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Widget))
PDF_ENUM_NAME_Width = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Width))
PDF_ENUM_NAME_Widths = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Widths))
PDF_ENUM_NAME_WinAnsiEncoding = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_WinAnsiEncoding))
PDF_ENUM_NAME_Wipe = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Wipe))
PDF_ENUM_NAME_XFA = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_XFA))
PDF_ENUM_NAME_XHeight = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_XHeight))
PDF_ENUM_NAME_XML = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_XML))
PDF_ENUM_NAME_XObject = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_XObject))
PDF_ENUM_NAME_XRef = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_XRef))
PDF_ENUM_NAME_XRefStm = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_XRefStm))
PDF_ENUM_NAME_XStep = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_XStep))
PDF_ENUM_NAME_XYZ = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_XYZ))
PDF_ENUM_NAME_YStep = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_YStep))
PDF_ENUM_NAME_Yes = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_Yes))
PDF_ENUM_NAME_ZaDb = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_ZaDb))
PDF_ENUM_NAME_a = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_a))
PDF_ENUM_NAME_adbe_pkcs7_detached = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_adbe_pkcs7_detached))
PDF_ENUM_NAME_ca = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_ca))
PDF_ENUM_NAME_n0 = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_n0))
PDF_ENUM_NAME_n1 = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_n1))
PDF_ENUM_NAME_n2 = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_n2))
PDF_ENUM_NAME_op = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_op))
PDF_ENUM_NAME_r = PdfObj( obj_enum_to_obj( PDF_ENUM_NAME_r))
